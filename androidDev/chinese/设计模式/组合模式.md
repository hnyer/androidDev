# 组合模式 Composite Pattern 、 整体-部分模式

组合模式将一批有共同特征的对象组合成 “树形结构”。<br>
关键点是定义了一个抽象构件类，它既可以代表叶子，又可以代表容器，而客户端针对该抽象构件类进行编程，无须知道它到底表示的是叶子还是容器，可以对其进行统一处理。


#### 透明组合模式 （推荐使用）
强调透明性一致性。 <br>
 因为叶子节点不存在子节点，所以一些方法是无效的。可以用过 “提供异常处理或相关提示”来解决 。 <br>
![](https://gitee.com/hnyer/filesOfGitbook/raw/master/files/201804091146_osChina_透明组合模式.png)

<br>
#### 安全组合模式

![](https://gitee.com/hnyer/filesOfGitbook/raw/master/files/201804091147_osChina_安全组合模式.png)


```java
/**抽象节点  */
abstract class AbstractFile
{  
    public abstract void add(AbstractFile file);  
    public abstract AbstractFile getChild(int i);  
    public abstract void killVirus();  
}

/**叶子节点*/
class ImageFile extends AbstractFile
{  
    private String name;  

    public ImageFile(String name) { ...}  

    public void add(AbstractFile file)
    {  
       // 子节点 不支持 当前方法 的相关提示
    }  

    public AbstractFile getChild(int i)
    {  
        // 子节点 不支持 当前方法 的相关提示
        return null;  
    }  

    public void killVirus()
    {  
        //模拟杀毒  
        ...
    }  
}  


/**容器节点*/
class Folder extends AbstractFile
{  

    private ArrayList<AbstractFile> fileList=new ArrayList<>();  
    private String name;  

    public Folder(String name) {...}  

    public void add(AbstractFile file) {  
       fileList.add(file);    
    }  

    public AbstractFile getChild(int i) {  
        return (AbstractFile)fileList.get(i);  
    }  

    public void killVirus()
    {  
        //递归调用
        for(AbstractFile obj : fileList)
        {  
            obj .killVirus();  
        }  
    }  
}


//使用 。针对抽象构件编程
// 子节点
AbstractFile folder2 = new Folder("图像文件夹");  
folder2.add(new ImageFile("xxx.jpg"));  
folder2.add(new ImageFile("xxxx.gif"));  

// 容器节点
AbstractFile file1 = new Folder();
folder1.add(folder2);  
folder1.killVirus();
```

#### 优点
1、将对象们进行树形分层，方便对整个某个层次的所有对象进行处理。<br>
2、使用透明组合模式时， 新增节点(容器节点、子节点) 符合 “开闭原则” 。
