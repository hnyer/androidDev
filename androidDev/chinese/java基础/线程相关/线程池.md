# 线程池

为什么要用线程池:

1.减少了创建和销毁线程的次数，每个工作线程都可以被重复利用，可执行多个任务。

2.可以根据系统的承受能力，调整线程池中工作线线程的数目，防止因为消耗过多的内存

![](https://gitee.com/hnyer/filesOfGitbook/raw/master/files/201801261639_osChina_线程池架构.png)

```java
//创建一个单线程的线程池。如果这个唯一的线程异常结束，会有一个新的线程来替代它。
//此线程池保证所有任务的执行顺序按照任务的提交顺序执行。
ExecutorService pool1 = Executors.newSingleThreadExecutor();
pool1.execute(command);
```

```java
//每次提交一个任务就创建一个线程，直到线程达到线程池的最大大小。
ExecutorService pool2 =Executors.newFixedThreadPool(10);
pool2.execute(command);
```

```java
//如果有线程超过一定时间(60秒)，就会被回收。
//当线程不够时，又会新建线程。
//线程池大小完全依赖于当前JVM能够创建的最大线程大小。
ExecutorService pool3=Executors.newCachedThreadPool();
pool3.execute(command);
```

```java
//支持定时及周期性任务执行
ScheduledExecutorService pool4 =Executors.newScheduledThreadPool(10);
pool4.scheduleAtFixedRate(command, initialDelay, period, unit);
```

```java
//跟Executors出来的差不多
ScheduledThreadPoolExecutor pool5 =new ScheduledThreadPoolExecutor(10);
pool5.scheduleAtFixedRate(command, initialDelay, period, unit);
pool5.execute(command);
```

&nbsp;&nbsp;
&nbsp;&nbsp;

#### 线程池demo
```java
public class MyThreadPoolTools
{
    private   ExecutorService singleThreadPool = null ;
    private   ExecutorService getThreadPoolsIncetance()
    {
        //guava-17.0.jar
        ThreadFactory threadFactory = new ThreadFactoryBuilder().setNameFormat("wk-pool-%d").build();
        RejectedExecutionHandler handler =new ThreadPoolExecutor.AbortPolicy();
        /*核心线程数量newSingleThreadExecutor
        最大线程数量ScheduledThreadPoolExecutor
        当线程池数量超过核心线程数量以后，空闲时间超过这个值的线程会被终止
        KeepAlive时间单位
        任务队列
        创建线程的工厂对象
        任务被拒绝后调用的handler*/
        ExecutorService   threadPool = new ThreadPoolExecutor(
                    5 ,  10 , 3 ,  TimeUnit.MICROSECONDS ,
                    new LinkedBlockingQueue<Runnable>(Integer.MAX_VALUE) ,
                    threadFactory ,
                    handler  ) ;
        return  threadPool ;
    }
    /**提交任务并执行*/
    public   void addTask(Runnable runnable)
    {
        if (singleThreadPool == null)
        {
            singleThreadPool= getThreadPoolsIncetance();
        }
        //运行线程池中的任务
        singleThreadPool.submit(runnable) ;
    }
    /**关闭线程池*/
    public   void shutdownThreadPool()
    {
        if (singleThreadPool != null)
        {
            if(!singleThreadPool.isShutdown())
            {
                singleThreadPool.shutdownNow() ;
            }
        }
    }
}

//使用
MyThreadPoolTools myThreadPoolTools= new MyThreadPoolTools();
Runnable task = new Runnable()
{
    @Override
    public void run()
    {
       //耗时操作
    }
};
myThreadPoolTools.addTask(task);
myThreadPoolTools.shutdownThreadPool();
```
