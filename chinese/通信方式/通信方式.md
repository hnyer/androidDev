# 通信方式
## http 、https 方式
```xml
1、http是基于 TCP/IP 的应用层协议 。
2、 采用 “一问一答” 模式 ，并不会保持长连接。
3、HTTP允许传输任意类型的数据对象。传输的类型由Content-Type加以标记。
```

### Content-type
[HTTP Content-type 手册](http://tool.oschina.net/commons)

文件扩展名	| Content-Type
-|-
.*（ 二进制流，不知道下载文件类型）|	application/octet-stream
.txt	|text/plain
.xml	|text/xml
.css	|text/css
.html	|text/html
.js	|application/x-javascript


以下是RFC1867协议为HTTP协议的基础上|-为INPUT标签增加了file属性

文件扩展名	| Content-Type
-|-
无文件的表单提交|application/x-www-form-urlencoded
有文件的表单提交|multipart/form-data

没查到何人何时 添加支持“json提交格式 ”的。

文件扩展名	| Content-Type
---|---
json格式的请求|application/json


### 建立、断开 http连接
http建立连接，底层是通过 Tcp协议 经过了3次握手、断开经过4次挥手。具体请查看tcp的相关知识。

###  TCP/IP协议族
![](https://gitee.com/hnyer/filesOfGitbook/raw/master/files/201802071433_osChina_tcp_ip协议族.png)


## https请求
即使采用了 HTTPS，也可以实现中间人攻击，或者进行数据解密等，但是，目前 HTTPS 目前使用的加密算法需要巨大的计算量才能破解
```xml
HTTPS 的目的主要有三个，
一个是数据的保密性，你给别人送个邮包，但邮包是打了封印的，快递员不知道包里装的是啥。
第二是数据的完整性，快递员不知道邮包是啥，但可以掉包啊，HTTPS 发现了掉包的数据，可以拒收。
第三就是身份验证，HTTPS 可以保证邮包被正确的送到指定的接收方，而不是第三方。
```

### https相关术语
专业名词 | 解释 |其他
-|-
SSL（Secure Sockets Layer）|  |网景公司设计的
单向证书认证|任何客户端都可以访问服务器|
双向证书认证|被允许的客户端才能访问服务器|
对称加密|加密和解密时使用的是同一个秘钥|
非对称加密|用公钥加密，私钥解密|
公钥|负责加密|在网络上传输
私钥|负责解密| 本地保管，别人无法获取



<br>

# ftp
## 第三方工具[ftp4j](http://www.sauronsoftware.it/projects/ftp4j/download.php)
### ftp登录
```java
@Override
public void run(){
     //标记是否登录成功
    boolean loginError = false ;
    try {
        mFTPClient.setType(FTPClient.TYPE_BINARY);
        //中文文件名 乱码处理
        mFTPClient.setCharset("GBK");
        //登录成功后FTP服务器返回的欢迎语句
        String[] welcome = mFTPClient.connect(FTP.HOST_IP, FTP.HOST_PORT);
        mFTPClient.login(FTP.HOST_USER, FTP.HOST_PASSWORD);
        mHandler.sendEmptyMessage(FTP.MSG_CMD_CONNECT_OK);
    }catch (Exception e) {
        loginError = true ;
    }
    if(loginError && FTP.mDameonRunning){
        mHandler.sendEmptyMessageDelayed(FTP.MSG_CMD_CONNECT_FAILED, 2000);
    }
}
```


### ftp删除文件（夹）
```java
@Override
public void run(){
    try {
        if (isDirectory)  {
            //删除文件夹
            mFTPClient.deleteDirectory(realivePath);
        } else {
            //删除文件
            mFTPClient.deleteFile(realivePath);
        }
        mHandler.sendEmptyMessage(FTP.MSG_CMD_DELE_OK);
    } catch (Exception ex) {
        mHandler.sendEmptyMessage(FTP.MSG_CMD_DELE_FAILED);
    }
}
```


### ftp断开连接
```java
if (mFTPClient != null){
    try {
        mFTPClient.disconnect(true);
    } catch (Exception ex) {
        ex.printStackTrace();
    }
}
```


### ftp文件下载
```java
if(! localFile.exists()){
    long fileSize = ftpFile.getSize() ;
    if(fileSize > 0){
        mFTPClient.download( ftpFile.getName(), new File(localFilePath),  
                             new DownloadFTPDataTransferListener(ftpFile.getSize()));
    }else{
        //文件异常的情况  下载发生异常the size of file muset be larger than zero.
    }
}
```

### ftp 获取文件列表
```java
@Override
public void run(){
    try {
        mFTPClient.changeDirectory(FTP.FTPSMAllPICDIR);
        FTPFile[] ftpFiles = mFTPClient.list();
        synchronized (mLock){
            mFileList.clear();
            //数组拷贝到list中去
            mFileList.addAll(Arrays.asList(ftpFiles));
        }
        mHandler.sendEmptyMessage(FTP.MSG_CMD_LIST_OK);
    } catch (Exception ex) {
        mHandler.sendEmptyMessage(FTP.MSG_CMD_LIST_FAILED);
    }
}//
```



### ftp 文件上传（进度条）
```java
try {
    File file = new File(path);
    mFTPClient.upload(file, new DownloadFTPDataTransferListener( file.length()));
} catch (Exception ex) {
    return false;
}
```

### ftp 连接守护进程
```java
//在子线程中定时判断
if (mFTPClient != null && !mFTPClient.isConnected()){
    try {
        //解决中文件名乱码问题
        mFTPClient.setType(FTPClient.TYPE_BINARY);
        mFTPClient.setCharset("GBK");
        mFTPClient.connect(FTP.HOST_IP, FTP.HOST_PORT);
        mFTPClient.login(FTP.HOST_USER, FTP.HOST_PASSWORD);
        Thread.sleep(FTP.MAX_DAMEON_TIME_WAIT);
    } catch (Exception ex) {
    }
}
```


### FTP 传输进度 回调
```java
public class DownloadFTPDataTransferListener implements  FTPDataTransferListener{
    /**已经传送量*/
    private int totolTransferred = 0;
    /**数据总量*/
    private long fileSize = -1;

    public DownloadFTPDataTransferListener(long fileSize){
        if (fileSize <= 0) {
            throw new RuntimeException( "the size of file muset be larger than zero.");
        }
        this.fileSize = fileSize;
    }

    @Override
    public void aborted()  {}

    @Override
    public void completed(){  }

    @Override
    public void failed()  {  }

    @Override
    public void started()  {  }

    @Override
    public void transferred(int length){
        totolTransferred += length;
        float percent = (float) totolTransferred / this.fileSize;
    }
}
```

### 使用场景
```java
FtpManager ftpManager = new FtpManager();
//然后 ftp 的相关操作 要放到子线程中去执行。 建议使用线程池。
```




<br>

# sockt  tcp_udp
进行tcp通信时，需要注意处理 粘包的问题。然后控制好休眠时间 和 接收的 buffer[] 大小。

##  TCP标志位 (位码)

标记 | 含义
---|---
SYN|synchronous 建立联机
ACK|acknowledgement 确认
PSH|push传送
FIN|finish结束
RST|reset重置
URG|urgent紧急

## 术语
### Sequence number
顺序号码
### Acknowledge number
确认号码
### MSL
Maximum Segment Lifetime ，报文最长存活时间

## tcp相关问题
### 为什么连接的时候是三次握手，2次不行吗?
为了让服务器、客户端端彼此知道 自己+对方的 接收、发送功能正常。 自己模拟一下就知道至少需要三次。

![](https://gitee.com/hnyer/filesOfGitbook/raw/master/files/201802071556_osChina_TCP三次握手.png)

### 为什么连接的时候是三次握手，关闭的时候却是四次挥手？
```xml
关闭连接时，当Server端收到FIN报文时，很可能并不会立即关闭SOCKET，
所以只能先回复一个ACK报文，告诉Client端，"你发的FIN报文我收到了"。
只有等到我Server端所有的报文都发送完了，我才能发送FIN报文，因此不能一起发送。
故需要四步挥手。 （为了争取一段缓冲时间，完成正在进行的数据传输）
```

![](https://gitee.com/hnyer/filesOfGitbook/raw/master/files/201802071556_osChina_tcp四次挥手.png)

### 为什么客户端在TIME-WAIT状态必须等待2MSL的时间？
```xml
为了保证客户端发送的最后一个ACK报文段能够到达服务器。
因为这个ACK报文段有可能丢失，因而使处在LAST-ACK状态的服务器收不到对已发送的FIN+ACK报文段的确认。
服务器会超时重传这个FIN+ACK报文段。而客户端就能在2MSL时间内收到这个重传的FIN+ACK报文段。
接着客户端重传一次确认，重新启动2MSL计时器。
最后客户端和服务器都正常进入到CLOSED状态。
```


##  粘包处理
目前不是最优方法，速度有点慢。想到高效的方法再补充。
```java
public class AirUnPackTools{
    /**帧头*/
    private static final byte packHead1= (byte) 0xDD;
    /**是否在有效数据之内*/
    private static boolean isContinue = false ;
    private static byte mlastByte =(byte) 0x00 ;
    /**byte索引 ， 用来指示 关键字 和 长度 */
    private static  int mByteIndex = 0;
    /**当前帧的长度*/
    private static  int mFrameLengh =0 ;
    /**临时list*/
    private static List<Byte>  lastBytesList = new ArrayList<>() ;
    /**数据段 数据长度 */
    private static  int mbyteCount = 0;
    /**遥控器返回的消息类型 = 0x55 ,5a ,5b ， 00为默认状态，无意义*/
    private static byte msgType =0x00 ;

    /**
     * 对来自 遥控端的 bytes数据解包
     */
    public static DronePacket320 unPackageofGround(byte mByte){
        DronePacket320 packetGround  = null ;
        //判断是否是帧开头
        switch (mByte)  {
            case packHead1:
                // 连续出现2个DD ，说明这是帧头
                if(mlastByte == packHead1 )  {
                    lastBytesList.clear();
                    lastBytesList.add(packHead1) ;
                    mByteIndex = 0;
                    isContinue = true ;
                }
                break;
        }

        if(isContinue) {
           boolean reslut =  getUnpackagedFrame(mByte);
            if(reslut)  {
                packetGround = new DronePacket320() ;
                packetGround.msgType = msgType ;
                packetGround.bytes =  listToBytesArray(lastBytesList) ;
            }else{
                packetGround = null ;
            }
        }else{
            packetGround = null ;
        }
        mlastByte =  mByte ;
        return  packetGround ;
    }

    public static byte [] listToBytesArray(List<Byte> list)  {
        byte[] bytes = new byte[list.size()] ;
        for(int i= 0; i<list.size() ;i++)  {
            bytes[i] = list.get(i) ;
        }
        return  bytes;
    }

    private static boolean getUnpackagedFrame( byte mBytes ){
        mByteIndex ++ ;

        if(mByteIndex == 2)   {  // 帧类型
            lastBytesList.add(mBytes) ;
            msgType  =mBytes;
            return  false ;
        }else  if(mByteIndex == 3)  {  //长度
            lastBytesList.add(mBytes) ;
            mbyteCount = 0;
            mFrameLengh = MyStringUtils.byte1ToInt(mBytes) ;
            return  false ;
        } else{
            mbyteCount ++ ;
            lastBytesList.add(mBytes) ;
            if(mbyteCount == mFrameLengh +1 )  {
                //数据段+校验位读取完毕 ，返回组装标记true
                isContinue =false ;
                return  true ;
            }else {
                return  false ;
            }
        } //end  else
    }//
}

```


```java
public class DronePacket320{
    public short msgType;
    public byte[] bytes;
}
```


```java
//使用
for (int i = 0; i < bytesGet.length; i++){
    DronePacket320 packetAir = AirUnPackTools.unPackageofGround(tcpResultBean.reslut[i]);
    if (packetAir != null){
        //处理格式化后的数据...
    }
}
```


## 第三方库 netty
用来连接tcp、接收 和发送数据的

```Java
public interface MyNettyCallBack{
    /**tcp成功建立连接*/
    public static final int Key_State_connect=1 ;
    /**tcp断开*/
    public static final int Key_State_disConnect=2 ;
    /**tcp正在重连*/
    public static final int Key_State_isReConnect=3 ;
    /**连接发生异常*/
    public static final int Key_State_error=4;
    /**连接手动关闭*/
    public static final int Key_State_close=5;
    /**连接正常-正在接收数据*/
    public static final int Key_State_recevieData=6;
    /**服务器返回信息给客户端*/
    public void sendMsgToUser(byte[] reslut , int state ,String stateMsg) ;
}
```


```java
public class NettyTcpTools{
    private int port;
    private String host;
    private SocketChannel socketChannel;
    private Bootstrap bootstrap;
    private boolean isConnect = false;
    /**是否需要重连*/
    private boolean isRepeate = false;
    /**用来区分是用户主动断开还是异常导致断开<br>用户主动断开的话就不用去重连*/
    private  boolean isStopByUser =false ;
    /**通信管道*/
    private ChannelFuture future = null;
    /**状态回调*/
    private MyNettyCallBack myNettyCallBack ;
    /**线程池工具*/
    private MyThreadPoolTools myThreadPoolTools ;

    public NettyTcpTools(String host , int port){
        this.port = port;
        this.host = host;
        bootstrap = new Bootstrap();
        bootstrap.channel(NioSocketChannel.class);
        //保持长连接
        bootstrap.option(ChannelOption.SO_KEEPALIVE, true);
        //自动调整下一次缓冲区建立时分配的空间大小，避免内存的浪费
        bootstrap.option(ChannelOption.RCVBUF_ALLOCATOR, new AdaptiveRecvByteBufAllocator(1024, 1024 * 32, 1024 * 64));
        bootstrap.group( new NioEventLoopGroup());
        bootstrap.remoteAddress(host, port);
        bootstrap.handler(new ChannelInitializer<SocketChannel>() {
            @Override
            protected void initChannel(SocketChannel socketChannel) throws Exception {
                //超时处理
                socketChannel.pipeline().addLast(new IdleStateHandler(3, 3, 3 ,TimeUnit.SECONDS));
                //接收服务器信息
                socketChannel.pipeline().addLast(  new NettyClientHandler());
            }
        });
    }


    private void gotoConnectTcp(){
        closeThreadPool();
        myThreadPoolTools= new MyThreadPoolTools();

        Runnable task = new Runnable() {
            @Override
            public void run() {
                isStopByUser = false ;
                try {
                    if (future != null)  {
                        boolean isActive = future.channel().isActive() ;
                        boolean isOpen = future.channel().isOpen() ;
                        MyLogUtils.mLog_iNormal("连接测试：isActive=" + isActive +"  isOpen="+ isOpen);
                       /* 这个地方注意了： 如果 没有关闭，会导致多个tcp连接
                        使用 网络调试助手.exe 进行调试查看*/
                        future.channel().close();
                    }

                    future = bootstrap.connect(new InetSocketAddress(host, port)).sync();
                    if (future.isSuccess())  {
                        socketChannel = (SocketChannel) future.channel();
                        sendMsgToUser(null ,MyNettyCallBack.Key_State_connect ,"connect server  Success");
                        isConnect = true;
                        return;
                    }
                } catch (Exception cause) {
                    sendMsgToUser(null ,MyNettyCallBack.Key_State_error ,"error2:"+cause.toString());
                }
                //连接状态在此处处理
                repeateTcp();
            }
        };
        if (myThreadPoolTools == null) {
            myThreadPoolTools= new MyThreadPoolTools();
        }
        myThreadPoolTools.addTask(task);
    }


    public  void startTcpTools(){
      gotoConnectTcp();
    }

    private void closeThreadPool(){
        if(myThreadPoolTools!=null)  {
            myThreadPoolTools.shutdownThreadPool();
            myThreadPoolTools=null ;
        }
    }


    public void nettySendBytes(final  byte[] bytesSend)  {
        Runnable runnable = new Runnable() {
            @Override
            public void run() {
                if (isConnect)  {
                    ByteBuf buf = Unpooled.buffer(bytesSend.length);
                    buf.writerIndex();
                    buf.writeBytes(bytesSend);
                    socketChannel.writeAndFlush(buf);
                }
            }
        } ;
        if (myThreadPoolTools == null) {
            myThreadPoolTools= new MyThreadPoolTools();
        }
        myThreadPoolTools.addTask(runnable);
    }


    public class NettyClientHandler extends SimpleChannelInboundHandler<ByteBuf>{
        @Override
        protected void channelRead0(ChannelHandlerContext channelHandlerContext,ByteBuf byteBuf) throws Exception
        {
            //这里是接受服务端发送过来的消息
            byte[] result  = new byte[byteBuf.readableBytes()];
            byteBuf.readBytes(result);
            /*这种方式会定长读取，后面有很多00 00 00
            byte[] bytes = byteBuf.array();*/
            sendMsgToUser(result ,MyNettyCallBack.Key_State_recevieData ,"channelRead0");
        }


        /**这里是断线要进行的操作*/
        @Override
        public void channelInactive(ChannelHandlerContext ctx) throws Exception  {
            super.channelInactive(ctx);
            ctx.close() ;
            if(!isStopByUser)  {
                sendMsgToUser(null ,MyNettyCallBack.Key_State_disConnect ,"channelInactive");
                repeateTcp();
            }
        }

        /**这里是出现异常的话要进行的操作*/
        @Override
        public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception {
            //ctx.close() ;
            sendMsgToUser(null ,MyNettyCallBack.Key_State_error ,"error1:"+cause.toString());
            repeateTcp();
        }

        /**用来处理读写超时的 自定义操作*/
        @Override
        public void userEventTriggered(ChannelHandlerContext ctx, Object evt) throws Exception  {
            super.userEventTriggered(ctx, evt);
            if (evt instanceof IdleStateEvent) {
                IdleStateEvent event = (IdleStateEvent) evt;

                if (event.state().equals(IdleState.READER_IDLE)) {
                    // 在指定的时间内没有收到服务器的反馈信息
                } else if (event.state().equals(IdleState.WRITER_IDLE)) {
                    //在指定的时间内没有像服务器发送过信息
                } else if (event.state().equals(IdleState.ALL_IDLE)) {
                    //在指定的时间内 既没有收到过信息 也没有发送过信息
                }

            }
        }
    }


    /**
     * 设置消息回调接口，用来获取从服务器返回的消息。
     */
    public void setMyNettyCallBack(MyNettyCallBack myNettyCallBack)  {
        this.myNettyCallBack =  myNettyCallBack ;
    }

    private void sendMsgToUser(byte[] result , int state ,String sendMsgToUser)  {
        if (myNettyCallBack != null) {
            myNettyCallBack.sendMsgToUser(result ,state ,sendMsgToUser);
        }
    }

    /**
     * tcp重连
     */
    private void repeateTcp()  {
        if(isStopByUser)    {
           return;
        }
        if (!isRepeate) {
            if (isConnect)  {
                isConnect = false;
                //断线监听在此处处理
            }
            isRepeate = true;
            sendMsgToUser(null ,MyNettyCallBack.Key_State_isReConnect ,"repeateTcp");
            try {
                TimeUnit.SECONDS.sleep(5);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            isRepeate = false;
            startTcpTools();
        }
    }

    /***
     * 关闭 tcp连接
     */
    public void nettyToolsClose()  {

        resetState();
        closeThreadPool();
        if (future != null && future.channel() != null)  {
            if (future.channel().isOpen())
            {
                sendMsgToUser(null ,MyNettyCallBack.Key_State_close ,"close");
                future.channel().close();

            }
        }
    }

    private void resetState()  {
        isConnect = false;
        isRepeate=false;
        isStopByUser = true ;
    }
}
```




<br>

# usb 通信
## [AOA](https://developer.android.com/adk/index.html )协议
```xml
Google推出的 Android开放配件协议AOA（Android Open Accessory Protocol）及配件开发工具包ADK（Accessory Development Kit）
提供了Android设备与Android配件通过USB或蓝牙进行通信的API，
为基于Android系统的智能设备控制外设提供了条件。
利用Android，系统可以连接从家用电器到重型机械、机器人等多种设备。
```

当前项目用到的是 android 的[AOA协议](http://www.hackermi.com/2015-04/aoa-analyse/)。遥控器作为主机供电，移动设备（手机、平板）作为从机。
使用方法请自行查阅相关文档。

## 使用场景一 ：android设备作为从机
[参考资料](http://www.hackermi.com/2015-04/aoa-analyse/)

![](https://gitee.com/hnyer/filesOfGitbook/raw/master/files/201801231626_osChina_usb配件模式.png)

这种模式是Android定义的一种新的通讯模式，它将usb配件作为协议交互的主要角色，配件内置USB Embedded Host端，可以为Android手机供电，并且识别Android手机，建立数据通道。使得配件成为一个简化版的PC Host端。


## usb通信demo
### MusbAccessoryManager.java
```java
/**
 * usb 操作管理类
 */
public class MusbAccessoryManager
{
	private Context mCtx;
	/**文件操作符*/
	private ParcelFileDescriptor fileDescriptor;
	/**输入流*/
	private FileInputStream inputStream;
	/**输出流*/
	private FileOutputStream outputStream;
	/**读线程*/
	private AccessoryReadThread readThread;
	/**写线程*/
	private AccessoryWriteThread writeThread;
	/**解析线程*/
	private BytesDataRepackThread repackThread ;
	/**usb 通信是否在进行*/
	private boolean enableThread;
	/**发送队列*/
	private BlockingQueue<MyBytesTransfer> outQueue;
	/**读取队列*/
	private BlockingQueue<byte[]> readQuene;
	/**回调接口 - 状态标记*/
	private IOperateResultCallBack iUsbResultCallBack ;
	/**回调接口 - byte[] 传输*/
	//private IBytesTransferInterface iGetBytesInterface ;
	/**解析后的数据对象 回调-*/
    private IUsbPackageTransferInterface iusbpackageTransInterface ;
	/**读入流 时的休眠间隔  微秒*/
	private final long READ_STRING_SLEEPTIME= 20L;
	/**写入流 时的休眠间隔*/
	private final long WRITE_STRING_SLEEPTIME= 60L;
	/**解析 byte[] 时的休眠间隔*/
	private final long REPACKAGE_SLEEPTIME= 0L;
	/** 调整读取大小*/
	private byte[] buffer= new byte[2048 * 3] ;

	public MusbAccessoryManager(Context context  , IOperateResultCallBack iUsbResultCallBack ,
								IUsbPackageTransferInterface iusbpackageTransInterface)	{
		this.mCtx = context;
		fileDescriptor = null;
		inputStream = null;
		outputStream = null;
		readThread = null;
		writeThread = null;
		repackThread =null ;
		enableThread = false;
		this.iUsbResultCallBack= iUsbResultCallBack;
		this.iusbpackageTransInterface = iusbpackageTransInterface;
		outQueue = new LinkedBlockingQueue< >(Integer.MAX_VALUE);
		readQuene = new LinkedBlockingQueue<>(Integer.MAX_VALUE) ;
	}

	/**
	 * 添加数据 到发送队列
	 */
	public void addMessage(MyBytesTransfer msg)	{
		try	{
			outQueue.put(msg);
		}catch (Exception e)	{
			MyLogUtils.mLog_iNormal("usb设备== 发送异常1 ="+e.getMessage());
		}
	}

	/**
	 * 打开USB通信
	 */
	public void OpenAccessory(UsbAccessory accessory)  {
		if (!enableThread)		{
	    	fileDescriptor = ((UsbManager) mCtx.getSystemService(Context.USB_SERVICE)).openAccessory(accessory);
	    	if (fileDescriptor != null)	{
	    		FileDescriptor fd = fileDescriptor.getFileDescriptor();
	    		inputStream = new FileInputStream(fd);
	    		outputStream = new FileOutputStream(fd);

	    		if (inputStream == null || outputStream == null)	{
					// 读取流异常
					iUsbResultCallBack.onResultCallBack(MyStateConfig.STATE_2);
					return;
				}
				//连接成功
				iUsbResultCallBack.onResultCallBack(MyStateConfig.STATE_14);
    			enableThread = true;
    			readThread = new AccessoryReadThread(inputStream);
    			readThread.start();
    			writeThread = new AccessoryWriteThread(outputStream);
    			writeThread.start();
				repackThread = new BytesDataRepackThread() ;
				repackThread.start();
	    	}else{
				toastMsg("fileDescriptor==null "   ) ;
			}
		}
    }//


	/**
	 * 关闭连接、清空队列、停止线程
	 */
    public void CloseAccessory()  {
    	try	{
			if (fileDescriptor != null)		{
				fileDescriptor.close();
			}
			if (outputStream != null)		{
				outputStream.close();
			}
			if (inputStream != null)	{
				inputStream.close();
			}
		}catch (Exception ie)	{
			ie.printStackTrace();
		}
		outQueue.clear();
		readQuene.clear();
		enableThread = false;
    	fileDescriptor = null;
    	outputStream = null;
    	inputStream = null;
    }

    /**
     读取子线程
     */
	private class AccessoryReadThread extends Thread  {
    	private FileInputStream inStream;

    	public AccessoryReadThread(FileInputStream stream) 	{
			  this.inStream = stream;
	   	}
    	@Override
    	public void run() 	{
			while (enableThread) 	{
				try {
					int realReaded = inStream.read(buffer);
					// 将Buffer中有效的数据拷贝出来
					if(realReaded>0) 	{
						byte [] realBytes = MyStringUtils.subBytes(buffer, 0 , realReaded) ;
						readQuene.put(realBytes);
					}
				} catch (Exception e) {
					com.walkera.base.utils.MyLogUtils.mLog_iNormal("usb设备== 接收异常="+e.getMessage());
					MyApplication.usbReadStreamState=  MyStateConfig.STATE_8;
					//发生异常，继续执行
					continue;
				}
				MyApplication.usbReadStreamState=  MyStateConfig.STATE_9;
				try {
					TimeUnit.MICROSECONDS.sleep(READ_STRING_SLEEPTIME);
				} catch (InterruptedException e) {
					e.printStackTrace();
				}
			} // end while

    	} // end run
    }//

	/**
     *发送子线程
	 */
	private class AccessoryWriteThread extends Thread 	{
		private FileOutputStream outStream;
		public AccessoryWriteThread(FileOutputStream outputStream) 	{
			this.outStream = outputStream;
		}

		@Override
		public void run()  {
			MyBytesTransfer msg;
			while (enableThread){
				try{
					if (outStream != null)	{
						msg = outQueue.poll();
						if (msg != null)	{
							sendByteDataToServer(msg.bytes );
							msg = null;
						}else{
						}
					} else{
						MyApplication.usbWriteStreamState=  MyStateConfig.STATE_11;
						outQueue.clear();
					}
					MyApplication.usbWriteStreamState=  MyStateConfig.STATE_10;
					try {
						Thread.sleep(WRITE_STRING_SLEEPTIME);
					} catch (InterruptedException e) {
						e.printStackTrace();
					}
				}catch (Exception ex)
				{
					com.walkera.base.utils.MyLogUtils.mLog_iNormal("发送测试3=  msg="+ex.getMessage());
					MyApplication.usbWriteStreamState=  MyStateConfig.STATE_11;
				}
			}
		}

		/**
		 * 将数据发送给服务器
    */
		private void sendByteDataToServer(byte[] buffer) {
	    	try	{
	    		if (outStream != null)	{
					iUsbResultCallBack.onResultCallBack(MyStateConfig.STATE_13);
					outStream.write(buffer, 0, buffer.length);
					outStream.flush();
		    	}
	    	}catch (IOException ex)	{
				iUsbResultCallBack.onResultCallBack(MyStateConfig.STATE_12);
	    	}
	    }//
	}

	/**
	 * 解析 重组包 子线程
	 */
	private class BytesDataRepackThread extends Thread{
		@Override
		public void run()	{
			while (enableThread)	{
				if(readQuene!=null)		{
					byte[] realBytes =	readQuene.poll() ;
					if(realBytes!=null)	{
						rePackageForBytes(realBytes) ;
					}
				}
				try	{
					Thread.sleep(REPACKAGE_SLEEPTIME);
				} catch (InterruptedException e){
					e.printStackTrace();
				}

			} //  while
		}//end run
	}

	/***
	 * 重组包 ， 将遥控器 、 飞控、视屏数据分开 .
   */
	private void rePackageForBytes(byte[] bytes)	{
		if(bytes!=null)	{
			int size =bytes.length ;
			for(int i=0 ; i< size ;i++)	{
				MyBytesTransfer myBytesTransfer = MyUsbUnPackTools.unPackageofUsb(bytes[i]) ;
				if(myBytesTransfer!=null)	{
					iusbpackageTransInterface.transferUsbPackageBean(myBytesTransfer);
				}
			}
		} // end if
	} //

	private void toastMsg(String msg){
		Toast.makeText(mCtx, msg ,Toast.LENGTH_SHORT) .show();
	}
}
```

### UsbMsgClient.java
```java
/**
 * 功能描述：  负责 用usb方式的通信方式 给其他部件提供发送和接收数据的功能 <br>
 */
public class UsbMsgClient{
    private Context mCtx ;
    /**usb管理类*/
    private UsbManager usbmanager ;
    /**usb 操作管理类*/
    private MusbAccessoryManager mubAccessoryManager;
    /**对外暴露的接口 ，以便其他模块获取 对应的数据*/
    private IUsbMsgBackInterface iUsbMsgBackInterface ;

    /**
     * @param iUsbMsgBackInterface   对外暴露的接口 ，以便其他模块获取 对应的数据
     * @param iUsbResultCallBack  usb 返回状态码
     */
    public UsbMsgClient (Context mCtx ,IUsbMsgBackInterface iUsbMsgBackInterface ,IOperateResultCallBack iUsbResultCallBack)  {
        this.mCtx = mCtx;
        this.iUsbMsgBackInterface= iUsbMsgBackInterface ;
        usbmanager=((UsbManager) mCtx.getSystemService(Context.USB_SERVICE)) ;
        mubAccessoryManager = new MusbAccessoryManager(mCtx , iUsbResultCallBack   ,iusbpackageTransInterface);
        discoverAccessories();
    }//

    /**回调 来自usb的数据*/
    private IUsbPackageTransferInterface iusbpackageTransInterface = new IUsbPackageTransferInterface()  {
        @Override
        public void transferUsbPackageBean(MyBytesTransfer myBytesTransfer)  {
            if(myBytesTransfer != null)    {
                // 4759图传  -  3678飞控    - 5869 遥控器
                if( Arrays.equals(myBytesTransfer.msgType, MyStateConfig.VEDEO_DATA_RECEIVE))  {  //视屏数据
                    iUsbMsgBackInterface.getUsbVedioByte(myBytesTransfer);
                }else if(Arrays.equals(myBytesTransfer.msgType, MyStateConfig.FC_DATA_RECEIVE))  {
                    //飞控数据
                    iUsbMsgBackInterface.getUsbFcByte(myBytesTransfer);
                }else if(Arrays.equals(myBytesTransfer.msgType, MyStateConfig.RC_DATA_RECEIVE))  {
                    //遥控器数据
                    iUsbMsgBackInterface.getUsbRcByte(myBytesTransfer);

                }
            }
        }
    } ;

    /**
     * 扫描usb设备 发现从设备
     */
    private void discoverAccessories()  {
        UsbAccessory[] list = usbmanager.getAccessoryList();
        if (list != null && list.length!=0)  {
            openTheAccessory(list[0]);
        }else  {
            //MyToastTools.toastWarning(mCtx ,mCtx.getString( R.string.v5_str_1));
        }
    }//

    /**
     * 连接 指定设备
     */
    private void openAccessory(UsbAccessory accessory)  {
        mubAccessoryManager.OpenAccessory(accessory);
        // 延时 n秒 发送打开session命令
        new Handler().postDelayed(new Runnable()  {
            @Override
            public void run()  {
                byte[] openSession = { (byte)0xDD , (byte)0xDF  ,(byte)0x06 ,(byte)0x00 } ;
                sendBytesToDevices(openSession);
            }
        } , 2000) ;
    }

    /**
     * 连接USB设备
     */
    private void openTheAccessory(UsbAccessory accessory)  {
        if (accessory == null)  {
            MyToastTools.toastWarning(mCtx ,mCtx.getString( R.string.v5_str_2));
        }else {
            if (usbmanager.hasPermission(accessory))  {
                openAccessory(accessory);
            }else  {
                com.walkera.base.utils.MyLogUtils.mLog_iNormal("usb设备== 无权限1");
            }
        }
    }

    /**
     * 通知遥控器关闭
     */
    private void closeSession()  {
        byte[] closeSession = { (byte)0xDD , (byte)0xDF  ,(byte)0x07 ,(byte)0x00 } ;
        sendBytesToDevices(closeSession);
    }

    /**
     * 关闭usb收发工具
     */
    public void closeUsbMsgClinet()  {
        closeSession();
        new Handler().postDelayed(new Runnable()  {
            @Override
            public void run()  {
                closeAccessory();
            }
        }, 500);
    }

    /**
     * 断开设备
     */
    private void closeAccessory(){
        if (mubAccessoryManager != null)  {
            mubAccessoryManager.CloseAccessory();
        }
    }

    /**
     * 发送数据
     */
    public void sendBytesToDevices( byte[] data )  {
        if (mubAccessoryManager != null)  {
            mubAccessoryManager.addMessage(new MyBytesTransfer(data , MyStateConfig.STATE_6,null));
        }
    }
}
```



### MyStateConfig.java
```java
public class MyStateConfig{
    /**请求usb访问的自定义权限*/
    public static final String ACTION_USB_ACCESSORY_PERMISSION = "com.wk.USB_ACCESSORY_PERMISSION";
    /**当前参数无意义 */
    public final  static int STATE_NULL = -100 ;
    /**所有的状态的初始化状态 */
    public final  static int STATE_0 = 0 ;
    /** usb退出 */
    public final  static int STATE_1 =1 ;
    /** usb连接异常 , 读取流异常 */
    public final static int STATE_2 =2 ;
    /** usb 权限被拒绝了 */
    public final static int STATE_3 =3;
    /**接收usb byte 正式*/
    public final static int STATE_4 =4;
    /**接收usb byte 测试*/
    public final static int STATE_5 =5;
    /**发送的bytes[]*/
    public final static int STATE_6 =6;
    /**接收到的byte[]*/
    public final static int STATE_7 =7;
    /**usb输入流异常*/
    public final static int STATE_8 =8;
    /**usb输入流正常*/
    public final static int STATE_9 =9;
    /**usb输出流正常*/
    public final static int STATE_10 =10;
    /**usb输出流异常*/
    public final static int STATE_11 =11;
    /**发送失败*/
    public final static int STATE_12 =12;
    /**发送成功*/
    public final static int STATE_13 =13;
    /**Usb连接成功*/
    public final static int STATE_14 =14;
    /**属于相机数据 */
    public final  static int STATE_15 = 15 ;
}
```

### xml中的一些配置、usb插入、拔出监听
请参考官网

### 使用
```java
/**usb收发工具*/
private UsbMsgClient usbMsgClient ;
//初始化usb数据接收器
usbMsgClient = new UsbMsgClient( mContext ,iUsbMsgBackInterface ,iUsbResultCallBack) ;
//发送byte[]数据
usbMsgClient.sendBytesToDevices(code);
//关闭连接
usbMsgClient.closeUsbMsgClinet();

/**
 * 接收 usb 返回数据
 */
private IUsbMsgBackInterface iUsbMsgBackInterface = new IUsbMsgBackInterface(){
    /**视屏数据*/
    @Override
    public void getUsbVedioByte(MyBytesTransfer vedioData)  {
        //解码...
    }

    /**飞控数据*/
    @Override
    public void getUsbFcByte(MyBytesTransfer fcData)  {
        //解析飞控数据
    }

    /**遥控器数据*/
    @Override
    public void getUsbRcByte(MyBytesTransfer rcData)  {
        //解析遥控器数据
    }
} ;

/**
 * 接收 usb 操作、状态码
 */
private IOperateResultCallBack iUsbResultCallBack = new IOperateResultCallBack(){
    @Override
    public void onResultCallBack(int state ){
        //状态码
    }
};
```




<br>

# 私有协议
## 参数类型对应的字节数

类型 | 对应字节数 | 备注
-|-|-
bit | 1/8 |
byte | 1 |  
char | 1 |  
boolean | 1 |  
uint8  | 1 |
uint8_t  | 1  |
uint16  | 2  |
int16  | 2  |
short | 2 |
int | 4 |
float | 4 |  
int32   | 4  |
uint32_t  | 4  |
double | 8 |  
long | 8 |


## 常用的方法
### 获得byte[] 校验值
```java
/**
 * 获得校验位。
 * 计算规则：
 * SUM等于从该数据帧第一字节开始，也就是帧头开始，至该帧数据的最后一字节所有字节的和，
 * 只保留低八位，高位舍去。
 *   P1=s/256; //整除高8位s
     P0=s%256; //取余是低八
 */
public static  byte[] getVerifyValue(byte [] lastBytes){
    byte checksum =  0;

    for (int i = 0; i <= lastBytes.length-2; i++) {
        checksum += lastBytes[i];
    }

    checksum = (byte) (checksum % 256) ;
    lastBytes[lastBytes.length-1] = checksum;
    return  lastBytes ;
}
```


### 数组动态扩充容量
```java
/**
 * 数组动态扩充容量 <br>
 * 代码并没有真正增加原数组a的容量，只是将a内容复制到新的大数组，<br>
 * 然后让a重新引用大数组。由于Java数组存贮在堆中，原a数组无需释放，会被自动回收。<br>
 */
public static String [] getNewArrayWithMoreSpaceString( String [] oldArray , String [] increceData){
    //新数组
    String [] lastArray=new String[oldArray.length+increceData.length];
    //将a数组内容复制新数组b
    System.arraycopy(oldArray, 0, lastArray, 0, oldArray.length);

    for(int i=0 ;i<increceData.length ;i++)  {
        lastArray[ oldArray.length + i] = increceData[i] ;
    }
    //改变引用
    oldArray=lastArray;
    return   oldArray ;
}
```



### 指定数组中复制内容到新的数组
```java
/***
 * 指定数组中复制内容到新的数组
 src:源数组
 srcPos:源数组要复制的起始位置
 dest:目的数组
 destPos:目的数组放置的起始位置
 length:要复制的长度
 */
public static void  copyDataToNewByteteArray(byte[] src, int srcPos , byte[] dest,
 int destPos , int length){
    System.arraycopy(src, srcPos , dest, destPos, length);
}
```


### 数组截取
```java
/**
 * 数组截取
 * @param srcByte 源数组
 * @param begin   源数组要复制的起始位置
 * @param count   要复制的长度
 * @return
 */
public static byte[] subBytes(byte[] srcByte, int begin, int count){
    byte[] result = new byte[count];
    System.arraycopy(srcByte, begin, result, 0, count);
    return result;
}
```

### 将byte转换为一个长度为8的byte数组
```java
/**
 * 将byte转换为一个长度为8的byte数组，数组每个值代表bit
 */
public byte[] get8bitsOfOneByte(byte mByte)  {
    byte[] array = new byte[8];
    byte h01= (byte)0x01;

    for (int i = 7; i >= 0; i--)  {
        //与1与运算- >  0000 0001
        array[i] = (byte)(mByte & h01);
        mByte = (byte) (mByte >> 1);
    }
    return array;
}
```


### 获取byte的高四位
```java
public byte gethe4BitOfByte(byte mByte)  {
    //0xF0换成二进制 -> 1111 0000（0xF0相当于高四位保留，低四位置为0）
    return (byte)((mByte & 0xF0) >> 4);
}
```

### 获取byte的低四位
```java
public byte getLow4BitOfByte(byte mByte)  {
    //0x0F换成二进制 -> 0000 1111  （0xF0相当于低四位保留，高四位置为0）
    return (byte) (mByte & 0x0F);
}
```

### bytes转换成十六进制字符串
```java
/**
 * bytes转换成十六进制字符串
 * @param b byte数组
 * @return String 每个Byte值之间空格分隔
 */
public static String byte2HexStr(byte[] b)  {
    String stmp ;
    StringBuilder sb = new StringBuilder("");
    for (int n = 0; n < b.length; n++) {
        stmp = Integer.toHexString(b[n] & 0xFF);
        sb.append((stmp.length() == 1) ? "0" + stmp : stmp);
        sb.append(" ");
    }
    return sb.toString().toUpperCase().trim();
}
```


### 将一个byte 转为十六进制
```java
public static String byteOne2HexStr(byte  b)  {
    String  stmp = Integer.toHexString( b & 0xFF);
    return  (stmp.length() == 1) ? "0" + stmp : stmp ;
}

public static String byte1ToHexStr(byte mByte)  {
    String stmp   = Integer.toHexString(mByte & 0xFF);
    return stmp.toUpperCase().trim();
}
```



###  int 类型 转为 1个字节长度的 byte
```java
/***
 * int 类型 转为 1个字节长度的 byte
 */
public static byte intTo1ByteHex(int intVaue )  {
    return new Integer(intVaue & 0xff).byteValue();
}
```

###  int 类型 转为 1个字节长度的 byte数组
```java/***
 * int 类型 转为 1个字节长度的 byte数组、
 * ？？
 */
public static byte[] intTo1ByteHexArray(int intVaue )  {
    byte[] array = new byte[1] ;
    array[0] = new  Integer(intVaue & 0xff).byteValue();
    return array ;

}
```


###  int 类型 转为 4个字节长度的 byte数组。
```java
/***
 * int 类型 转为 4个字节长度的 byte数组。
 * 大端小端翻转 。
 */
public static void intTo4ByteArrayHex(int intVaue, byte[] byteVauesHex)  {
    for (int i = 0; i < byteVauesHex.length; i++) {
        byteVauesHex[i] = new Integer(intVaue & 0xff).byteValue();
        intVaue = intVaue >> 8;
    }
}
```



### int 类型 转为 4个字节长度的 byte数组。
```java
/***
 * int 类型 转为 4个字节长度的 byte数组。
 * 正常顺序 。不考虑大端小端翻转 。
 */
public static void intTo4ByteArrayHexNormal(int intVaue, byte[] byteVauesHex){
    for (int i = byteVauesHex.length - 1; i >= 0; i--) {
        byteVauesHex[i] = new Integer(intVaue & 0xff).byteValue();
        intVaue = intVaue >> 8;
    }
}
```



### 将一个short转为2个字节的数组
```java
/**
 * 将一个short转为2个字节的数组
 * 算法来源 网络
 * http://blog.csdn.net/thanklife/article/details/17002641
 * 如: pitch = 1900 = 0x076c => 发送顺序：先发0x07，再发0x6c
 * 高位在前，低位在后
 */
public static byte[] shortTobytes2HeightLow(short number)  {
    int temp = number;
    byte[] b = new byte[2];
    for (int i = b.length - 1; i >= 0; i--) {
        b[i] = new Integer(temp & 0xff).byteValue();
        temp = temp >> 8;
    }
    return b;
}

public static byte[] shortTobytes2_low_height(short number){
    int temp = number;
    byte[] b = new byte[2];
    for (int i = 0; i < b.length; i++) {
        b[i] = new Integer(temp & 0xff).byteValue();
        temp = temp >> 8;
    }
    return b;
}
```





### intTo4ByteArray
```java
public static  byte[]  intTo4ByteArrayHex_height_low (int intVaue)  {
    byte[] byteVauesHex = new byte[4] ;
    for (int i = byteVauesHex.length -1; i >=0  ; i--) {
        byteVauesHex[i] = new Integer(intVaue & 0xff).byteValue();
        intVaue = intVaue >> 8;
    }
    return  byteVauesHex ;
}

public static  byte[]  intTo4ByteArrayHex_low_height(int intVaue){
    byte[] byteVauesHex = new byte[4] ;
    for (int i = 0; i < byteVauesHex.length; i++) {
        byteVauesHex[i] = new Integer(intVaue & 0xff).byteValue();
        intVaue = intVaue >> 8;
    }
    return  byteVauesHex ;
}
```





### floatTo4ByteArrayHex
```java
public static  byte[]  floatTo4ByteArrayHex_height_low (float intVaue){
    byte[] byteVauesHex = new byte[4] ;
    int fbit = Float.floatToIntBits(intVaue);
    for (int pos = 3; pos >= 0 ; pos -- ) {
        byteVauesHex[pos] = new Integer(fbit).byteValue();
        fbit = fbit >> 8;
    }
    return  byteVauesHex ;
}

public static  byte[]  floatTo4ByteArrayHex_low_height(float intVaue)  {
    byte[] byteVauesHex = new byte[4] ;
    int fbit = Float.floatToIntBits(intVaue);
    for (int pos = 0; pos <  4; pos++) {
        byteVauesHex[pos] = new Integer(fbit).byteValue();
        fbit = fbit >> 8;
    }
    return  byteVauesHex ;
}
```



### 将2个字节的 16进制数组 转化为 一个short
```java
/***
 * 将2个字节的 16进制数组 转化为 一个short
 * 高位在前，低位在后  的bytes数组
 */
public static short bytes2ToShort(byte[] srcBytes){
    short result;
    short v1 = (short) (srcBytes[0] & 0xFF);
    short v2 = (short) (srcBytes[1] & 0xFF);
    result = (short) (v1 * 256 + v2);
    return result;
}

/***
 * 将2个字节的 16进制数组 转化为 一个short <br>
 * 低位在前，高位在后  的bytes数组
 */
public static int bytes2ToShort_low_hight(byte[] src)  {
    return ((src[0] & 0xFF)
            | ((src[ 1] & 0xFF) << 8)  );
}
```


### 将2个字节的 16进制数组 转化为 一个 double
```java
/***
 * 将2个字节的 16进制数组 转化为 一个 double
 * 高位在前，低位在后  的bytes数组
 */
public static double bytes2ToDouble(byte[] srcBytes){
    double result;
    short v1 = (short) (srcBytes[0] & 0xFF);
    short v2 = (short) (srcBytes[1] & 0xFF);
    result = (double) (v1 * 256 + v2);
    return result;
}
```

### 两个byte转 int
```java
/**
 * 两个byte转整形，add zc
 */
public static int byte2int(byte[] res)  {
    // 一个byte数据左移24位变成0x??000000，再右移8位变成0x00??0000
    return  (res[0] & 0xff) | ((res[1] << 8) & 0xff00);
}
```


### int 类型 转为 2个字节长度的 byte数组
```java
/***
 * int 类型 转为 2个字节长度的 byte数组。
 * 大端小端翻转 。
 * @param intVaue  int
 * @param byteVauesHex byte[]
 */
public static void intTo2ByteArrayHex(int intVaue, byte[] byteVauesHex){
    for (int i = 0; i < byteVauesHex.length; i++) {
        byteVauesHex[i] = new Integer(intVaue & 0xff).byteValue();
        intVaue = intVaue >> 8;
    }
}

/***
 * int 类型 转为 2个字节长度的 byte数组。
 * 正常顺序。
 */
public static byte[]  intTo2ByteArrayHexNormal(int intVaue )  {
    byte[] byteVauesHex = new byte[2] ;
    for (int i = byteVauesHex.length - 1; i >= 0; i--) {
        byteVauesHex[i] = new Integer(intVaue & 0xff).byteValue();
        intVaue = intVaue >> 8;
    }
    return byteVauesHex;
}
```


### 将4个字节长度的 byte数组转为int
```java
/**
 * 将4个字节长度的 byte数组转为int。
 * 本方法适用于(低位在后，高位在前)的顺序
 */
public static int bytes4HeightAndLowToInt(byte[] src, int offset){
    return (((src[offset] & 0xFF) << 24)
            | ((src[offset + 1] & 0xFF) << 16)
            | ((src[offset + 2] & 0xFF) << 8)
            | (src[offset + 3] & 0xFF));
}

/**
 * 将4个字节长度的 byte数组转为int。<br>
 * 本方法适用于(低位在前，高位在后)的顺序<br>
 * 320项目中用到
 */
public static int bytes4LowAndHeightToInt(byte[] src, int offset)  {

    return ((src[offset] & 0xFF)
            | ((src[offset + 1] & 0xFF) << 8)
            | ((src[offset + 2] & 0xFF) << 16)
            | ((src[offset + 3] & 0xFF) << 24));
    }
```



### 将1个字节长度的 byte数组转为int
```java
/**
 * 将1个字节长度的 byte数组转为int。
 */
public static int bytes1ToInt(byte[] src){
    return src[0] & 0xFF;
}

/**
 * 将一个字节长度的byte 转为 int
 */
public static int byte1ToInt(byte src)  {
    return src & 0xFF;
}
```




### getStrByByte
```java
public  static  String getStrByByte(StringBuilder sb , byte byte0){
    sb.replace(0, sb.length(), "") ;
    sb.append(Integer.toHexString( byte0 & 0xFF).toUpperCase()) ;

    if(sb.length()==1)  {
        sb.insert(0, "0") ;
    }
    return sb.toString() ;
}
```
