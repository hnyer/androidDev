# 线程阻塞
阻塞指的是暂停一个线程的执行以等待某个条件发生（如某资源就绪）。


### 阻塞机制：

##### 1、sleep()
sleep() 允许线程在指定的时间内进入阻塞状态，不能得到CPU 时间，指定的时间一过，线程重新进入可执行状态。
只是不参与cpu时间的竞争， 已经拿到手的锁资源并不释放 （此时不一定占有锁）。

sleep 方法时间到了会自动醒过来， 时间没到可以用interrupt方法强行唤醒。


```java
@Override
public void run()
{
    while (!isStoped)
     {
        try {
            Thread.sleep(50);
            //todo...
        } catch (Exception e) {   }
    }
}
```

##### 2、 suspend() 和 resume()
两方法配套使用，调用suspend()进入阻塞状态（不会立即的停止，而是执行到一个安全点后挂起 。不会自动恢复）。调用resume()进入唤醒状态。
在多线程场景中很容易造成死锁，目前这2个方法已经被废弃。
 ~~~suspend()  、 resume() 、 stop()~~~   

##### 3、yield()

线程礼让、让步。

yield()方法让当前正在执行的线程放弃当前分得的CPU时间（并不是阻塞该线程），它只是将该线程从运行状态转入就绪状态。

只是礼让当前的cpu使用权，让系统的线程调度器重新调度一次。很有可能，当这个线程调用了yield()方法后它又马上抢占了CPU的执行权，继续执行。


```java
Thread t = new Thread;
t.sleep();
t.yield();
```

##### 4、 wait() 、 notify() 、notify

```html
两个方法配套使用 。
都是Object的方法。并不是Thread独有的。

这里要明确 线程等待的就是一个对象发出的信号，所以要基于对象而存在。
```

```html
wait() 、 notify() 必须在 synchronized 同步方法或块中调用 。
否则运行时会抛出 IllegalMonitorStateException 异常 。
```

```html
调用wait进入阻塞后，会释放占用的锁。
obj.wait( time ) ， 超时自动唤醒或者由notify( )、notifyAll()唤醒 进入就绪状态。
obj.wait( ) ，由notify( )、notifyAll( )唤醒 进入就绪状态。

调用wait会让当前线程释放这个对象的锁。 （线程此时不一定持有锁，如果没有锁就忽略，如果占有锁就会释放）
```

```html
如果多个线程调用了某个对象的 wait() ， 对象的notify()被调用时 是随机选择一个线程唤醒 。
如果多个线程调用了某个对象的 wait() ， notifyAll()被调用时 将这些线程全部唤醒，抢到锁的那个线程 进入就绪状态 。

线程竞争对象的锁。
```


```java
class NumberPrint implements Runnable
{
	public static void main(String args[])
	{
		// 以该对象为共享资源
		final byte a[] = { 0 };
		new Thread(new NumberPrint((1), a), "1").start();
		new Thread(new NumberPrint((2), a), "2").start();
	}

	private int number;
	public byte res[];
	public static int count = 5;

	public NumberPrint(int number, byte a[])
	{
		this.number = number;
		res = a;
	}

	@Override
	public void run()
	{
		synchronized (res)
		{
			while (count-- > 0) {
				try {
					res.notify();
					System.out.println(" " + number);
					res.wait();
					System.out.println("------线程"
							+ Thread.currentThread().getName()
							+ "获得锁，wait()后的代码继续运行：" + number);
				} catch (InterruptedException e) { }
			}// end of while
			return;
		}// synchronized

	}
}
```

##### 为什么java规定 wait()，notify()和notifyAll()必须在同步块或同步方法中调用。而suspend()、 resume()可以在任何地方都调用？


![](https://gitee.com/hnyer/filesOfGitbook/raw/master/files/201801251657_osChina_不解.png)

以下是个人感觉比较靠谱一点的网络[解释](http://blog.csdn.net/suyue466300750/article/details/52963541)。
```html
1、首先suspend()、 resume()是基于线程存在的。 wait()、notify()基于对象存在的。

2、既然是基于对象的，此时在这个对象上可能同时有多个线程调用wait()/notify()方法，
   依然存在并发的问题，理论上也需要一个锁来控制。

```


&nbsp;&nbsp;

##### join()方法的作用

线程A 里面 调用了 线程B.join() 。 此时线程A进入阻塞状态 ，线程B执行。

直到线程B执行完毕或者被打断，线程A才能恢复继续执行 。

主要用于线程之间的交互。












·
