# 线程进程中的相关概念



#### 公平锁（Fair）
加锁前检查是否有排队等待的线程，优先排队等待的线程，先来先得。

#### 非公平锁（Nonfair）
加锁时不考虑排队等待问题，直接尝试获取锁，获取不到自动到队尾等待

#### 独享锁/共享锁

独享锁(例如synchronized )是指该锁一次只能被一个线程所持有。

共享锁是指该锁可被多个线程所持有。
```java
ReadWriteLock rtLock = new ReentrantReadWriteLock();
//共享锁
rtLock.readLock();
//互斥锁
rtLock.writeLock();
```
ReadWriteLock rtLock = new ReentrantReadWriteLock();

#### 死锁
多个线程同时被阻塞，它们中的一个或者全部都在等待某个资源被释放。由于线程被无限期地阻塞。


```html
//java 死锁产生的四个必要条件：
1、互斥使用，即当资源被一个线程使用(占有)时，别的线程不能使用.
2、不可抢占，资源请求者不能强制从资源占有者手中夺取资源，资源只能由资源占有者主动释放。
3、请求和保持，即当资源请求者在请求其他的资源的同时保持对原有资源的占有。
4、循环等待，即存在一个等待队列：P1占有P2的资源，P2占有P3的资源，P3占有P1的资源。
这样就形成了一个等待环路。

当上述四个条件都成立的时候，便形成死锁。当然，死锁的情况下如果打破上述任何一个条件，便可让死锁消失。

```


#### 线程中断
中断本质是一种特殊的电信号。处理器接受到中断后，会马上向操作系统反映此信号的到来，然后就由os负责处理这些新到来的数据。 要中断一个Java线程，可调用线程类对象的实例方法：interrupte()。其本质只是设置该线程的中断标志，将中断标志设置为true，并根据线程当前的状态决定做出不同的响应。


#### CAS / 非阻塞同步
CAS(Compare-and-Swap) 。基于冲突检测的乐观并发策略 ，先将内存的值进行保存，当操作完成时再判断保存的值和当前内存的值是否相同，如果不同则说明其他线程操作了该数据，所以需要重试或者放弃。这种乐观的并发策略不需要把线程挂起，因此这种同步措施称为非阻塞同步。


#### ABA问题
是指在CAS操作中带来的一个潜在问题。例如，线程1将初始值为A的变量 先修改成B，再修改回成A。线程B的CAS操作无法分辨当前V值是否发生过变化。

### 原子操作
是指不会被线程调度机制打断的操作机制。这种操作一旦开始，就一直运行到结束，中间不会有任何 context switch （切换到另一个线程）。根据java 定义，原子操作是不会被打断地的操作，因此被认为是线程安全的。java中可以通过锁和循环CAS的方式来实现原子操作。
