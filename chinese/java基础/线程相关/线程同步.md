# 线程同步

同步是一种计算机术语，一般指的是在多个数据库、文件、模块、线程之间用来保持数据内容一致性的机制。


程同步的真实意思和字面意思恰好相反，其实是“线程排队”：几个线程之间要排队，一个一个对共享资源进行操作，而不是同时进行操作。


### 核心点

1、java的每个对象都有一个内置锁 .

2、同步高开销，尽量减少同步的内容。一般同步关键代码（代码块）即可。


---
### 线程同步的实现方式

1、同步方法
```java

public synchronized void funcA()
{
  //锁住 当前方法
}

public static synchronized void funcB()
{
  //锁住 当前类
}
```

2、同步代码块
```java
public synchronized void funcC()
{
  //其他操作...
  synchronized (this)
  {
    //同步 操作共享资源...
  }

  //其他操作...
}
```


3、关键字volatile

个人感觉跟同步没啥关系。！！ 没实际用过

![黑人问号脸](https://gitee.com/hnyer/filesOfGitbook/raw/master/files/201801251031_osChina_黑人问号脸.png)
```java

1、对于volatile修饰的变量，只保证从主内存加载到线程工作内存的值是最新的。保证不了线程安全 。

2、volatile关键字所在的代码块 禁止指令重排。


```
![](https://gitee.com/hnyer/filesOfGitbook/raw/master/files/201801241435_osChina_线程内存和主内存.jpg)


4、使用重入锁 ReentrantLock 实现线程同步
```java
//fair为true表示是公平锁 。默认非公平。
boolean fair= false ;
ReentrantLock  reentrantLock  = new ReentrantLock(fair) ;

private void func1(ReentrantLock lock)
{
  //如果已经被锁定了 就会忽略。不会等待。
  if(lock.tryLock())
  {
    try{
      //执行相关操作
    }finally{
      //释放锁
      lock.unlock();
    }
  }
}

private void func2(ReentrantLock lock) throws InterruptedException
{
  //如果被锁定了，就会尝试等待指定时长。如果还没有就放弃
  if(lock.tryLock(5 , TimeUnit.SECONDS))
  {
    try{
      //执行相关操作
    }finally{
      //释放锁
      lock.unlock();
    }
  }
}

private void func3(ReentrantLock lock)
{
  //如果已经被锁定了 ,会在此等待
  try{
    lock.lock();
    //执行相关操作
  }finally{
    //释放锁
    lock.unlock();
  }
}


/***
 * 如果指定时间内没有完成操作。就中断当前线程，释放锁
 * @param lock
 */
private void func4(ReentrantLock lock)
{
  //tryLock和lockInterruptibly方法在申请锁的过程中是可以被中断的 .
  //如果线程被中断，抛出一个InterruptedException异常
  try {
    lock.lockInterruptibly();
    //
  } catch (InterruptedException e) {
    //执行相关操作

  }finally{
    //释放锁
    lock.unlock();
  }
}
```

5、使用 ThreadLocal线程局部变量 实现线程同步。

Aivin感觉跟线程同步有毛关系！！

![](https://gitee.com/hnyer/filesOfGitbook/raw/master/files/201801251031_osChina_黑人问号脸.png)

以下来自网络解释  ~~~“作为Thread的一个局部变量 。为解决多线程程序的并发问题提供了一种新的思路。ThreadLocal会为每一个线程维护一个和该线程绑定的变量的副本，从而隔离了多个线程的数据，每一个线程都拥有自己的变量副本，从而也就没有必要对该变量进行同步了。  ”~~~

~~~通俗的解释，threadlocal就跟自助餐的餐盘一样，外面一堆人排队，进去的一人一个餐盘，装一堆，再慢慢消化，有这个场景的应该都可以用~~~


```html
//使用场景：
暂时没有这方面的需求，没用过。
```

6、使用 阻塞队列 LinkedBlockingQueue  实现线程同步

使用java封装的帮助类，实现多线程安全。 每次只允许 一个线程去队列里面存放对象 。
```java
BlockingQueue<byte[]> outQueue = new LinkedBlockingQueue<>(Integer.MAX_VALUE);
outQueue.put(msg);
msg = outQueue.poll();

```

7、使用 Atomic 原子变量实现线程同步

根据java 定义，原子操作是不会被打断地的操作，因此被认为是线程安全的。

java.util.concurrent.atomic包提供 Atomic 用CAS方式实现 原子操作。
```java
/**原子更新基本类型类 （没有 double 和float的封装类型） */
AtomicInteger atomicInt = new AtomicInteger(100);
AtomicBoolean atomicBoolean  = new AtomicBoolean(false);
AtomicLong atomicLong = new AtomicLong(1000000);

private void func1( )
{
   //原子更新数组类
  int[]arrayInt ={1,30};
  AtomicIntegerArray atomicIntArray = new AtomicIntegerArray(arrayInt);
  atomicIntArray.getAndSet(i, newValue);
  atomicIntArray.addAndGet(i, delta);

  //AtomicReferenceFieldUpdater 一个基于反射的工具类，它能对指定类的指定的volatile引用字段进行原子更新。(这个字段不能是private的)
  AtomicReferenceFieldUpdater  updater=AtomicReferenceFieldUpdater.newUpdater(Dog.class,String.class,"name");  
  updater.compareAndSet(dog1,dog1.name,"test") ;  

  //AtomicMarkableReference ,为解决CAS操作中潜在的ABA问题 设计的解决方案。
  AtomicMarkableReference atomicMarkRef= new AtomicMarkableReference<String> ("StrMsg", false) ;
  if(!atomicMarkRef.isMarked())
  {
    atomicMarkRef.set("bbb", true);
  };
  //AtomicStampedReference 用法与 AtomicMarkableReference 类似
}
```
