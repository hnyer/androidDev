# ArrayMap
ArrayMap是Android api提供的 .

Android里的Bundle内部就是ArrayMap 。

ArrayMap并不适用于数据量比较大的场景，它是一种以时间换空间的优化。

通常比HashMap要慢，因为在查找时需要进行二分查找，增加或删除时，需要在数组中插入或者删除键。而这种操作比较耗时。


ArrayMap有两个数组 。第一个数组存放存放item的hash值，第二数组是把key，value连续的存放在数组里，通过先算hash在第一个数组里找到它的hash index，根据这个index在去第二个数组里找到这个key-value。

![img](https://gitee.com/hnyer/filesOfGitbook/raw/master/files/201801171626_osChina_arrayMap.png)



<br>

#  HashMap
Hashtable和HashMap的内部数据结构相似.

![imgs](https://gitee.com/hnyer/filesOfGitbook/raw/master/files/201801171540_osChina_哈希表_hashmap结构.png)

 HashMap由数组+链表组成的，数组是HashMap的主体，链表则是主要为了解决哈希冲突而存在的。

 HashMap中的链表出现越少，性能才会越好。

 ```html
加载因子(DEFAULT_LOAD_FACTOR)越大，对空间的利用更充分，后果是查找效率的降低；
加载因子太小，那么散列表的数据将过于稀疏，对空间造成严重浪费。
默认加载因子为0.75，一般情况下我们是无需修改。

当哈希表中的条目数超出了加载因子与当前容量的乘积时，则要对该哈希表进行重建内部数据结构.
 ```


##  HashMap存储的步骤put（K,V）
传入key和value，计算key的hash值，根据hash值搜索在哈希表table中的索引位置，若当前索引位置不为null，则对该位置的Entry链表进行遍历，如果链中存在该key，则用传入的value覆盖掉旧的value，同时把旧的value返回。
否则调用addEntry，用key-value创建一个新的节点，并把该节点插入到该索引对应的链表的头部

##  HashMap的读取实现get（key，value）
 读取的步骤比较简单，调用hash（key）求得key的hash值，然后调用indexFor（hash）求得hash值对应的table的索引位置，然后遍历索引位置的链表，如果存在key，则把key对应的Entry返回，否则返回null

##  HashMap键的遍历，keySet()
 HashMap遍历时，按哈希表的每一个索引的链表从上往下遍历，




<br>

# 哈希表
Hashtable 和HashMap 的内部数据结构相似.

![imgs](https://gitee.com/hnyer/filesOfGitbook/raw/master/files/201801171540_osChina_哈希表_hashmap结构.png)

## Hash
是一种信息摘要算法，一般用于验证完整性，它还叫做哈希、散列。我们平时使用的MD5,SHA1,SSL中的公私钥验证都属于Hash算法。

## Hash碰撞
好的Hash算法可以出计算几乎出独一无二的HashCode，如果出现了重复的hashCode，就称作碰撞; 不过就算是MD5这样优秀的算法也会发生碰撞，即两个不同的key也有可能生成相同的MD5。


## hashmap和hashtable的区别
HashTable已经被淘汰了！！ 不用关注太多细节 。

知道以下几个区别就好了。

1、 一: HashMap可以允许key为null，value为null，HashTable都不允许为null

2 、HashMap没有提供同步机制，是线程不安全的，需要自己在外面写同步代码，HashTable 部分方法上有自己的 synchronize 同步，是线程安全的。

3、父类不一样 ， 各自拥有的方法不完全一样 ， 扩充机制（规则）不一样 。




<br>

# 栈
![](https://gitee.com/hnyer/filesOfGitbook/raw/master/files/201802081030_osChina_栈示意图.png)

## 手写代码实现一个栈。
1、用数组实现

通过移动下标来模拟。


2、使用系统的 LinkedList 来实现。
```java
Deque< Object > queue = new LinkedList<Object>();  
queue.addFirst(e);
queue.removeFirst();
```

3、自己模拟单链表 实现栈

sample没有考虑线程安全等细节，只是简洁地展示关键思想

Node.java   
```java
/**
 * 栈节点
 */
public class Node
{
	/**数据*/
	public Object data;
	/**下一个节点*/
	public Node next ;

	public Node(Object data ,Node next)
	{
		this.data=data ;
		this.next =next;
	}
}
```

MyStack.java
```java
public class MyStack
{
	/**栈顶节点*/
	private Node topNode ;
	/**栈大小*/
	public int stackSize;

	/**
	 * 入栈
	 */
	public void push(Object data)
	{
		//新节点
		Node newNode = new Node(data, topNode);
		//对外公布 新栈顶元素
		topNode= newNode ;
		stackSize++ ;
	}

	/**
	 * 出栈
	 */
	public void pop()
	{
		//需要出栈的节点
		Node temp= topNode ;
		//对外公布  新的栈顶元素
		topNode = temp.next ;
		stackSize-- ;

	}

	/**打印该栈所有元素*/
	public void showStackInfo()
	{
		Node temp =topNode ;
		if(temp==null)
		{
			System.out.println("空栈");
			return ;
		}

		while(temp !=null )
		{
			System.out.println("栈节点值="+ temp.data);
			temp = temp.next;
		}
		System.out.println("---------end-------");
	}
}
```

测试
```java
public static void main(String[] args)
{
  MyStack myStack = new MyStack();
  myStack.showStackInfo();  
  myStack.push(1) ;
  myStack.push(2) ;
  myStack.showStackInfo();
  myStack.pop();
  myStack.showStackInfo();
}
```




<br>

# 队列
队列的特点是“先进先出”。

## 阻塞队列
与普通队列的区别在于：当阻塞队列为空时，从队列中获取元素的操作将会被阻塞，或者当队列是满时，往队列里添加元素会被阻塞。


## 阻塞双端队列
指允许两端都可以进行入队和出队操作的阻塞队列。

常用队列 | 特点 | 常用方法 | 安全性
-|- |-|-
LinkedBlockingQueue|基于链表的单向队列||线程安全
LinkedBlockingDeque|基于链表的双端队列||



```java  
interface BlockingQueue  extends Queue  ...

interface BlockingDeque   extends BlockingQueue , Deque  {...

class LinkedBlockingDeque ...  implements BlockingDeque {...

class LinkedBlockingQueue implements BlockingQueue...
```
