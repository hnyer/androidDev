# 建造者模式 Builder Pattern
适用于 构建流程非常复杂的 对象。
#### 定义
将一个复杂对象的构造与它的表示分离，使同样的构建过程可以创建不同的表示。<br>
```xml
1、对象的构建：对象的组装生成过程。
2、对象的表示：产品本身。产品的特性。
3、同样的创建过程：指挥者中定义的创建的相同流程。
4、创建不同的表示：不同的创建细节区分在构建者当中，调用不同的构建者会有不同的结果。
```

### 具有指挥者的建造者模式 （完整模式）
```java
// 具体的构建者 只负责 最后的构建细节。
// 不负责这些细节如何组装
class DevilBuilder extends ActorBuilder{
   public  void buildType() { ...}
   public  void buildSex()  { ... }
   public  void buildFace() { ... }
   public  void buildCostume() {...}
   public  void buildHairstyle() {...}
}

// 指挥者 只负责构建顺序
class ActorController{
   public  Product getProduct(ActorBuilder ab)
   {
          ab.buildType();
          ...
          ab.buildCostume();
          // Product在ActorBuilder的构造函数中创建好
          return ab.createAProduct();
   }
}

//测试
// 构建顺序定义在 ActorController 中
ActorController controller = ...;
// 产品不同部位的构建能力 定义在 builer 中
ActorBuilder  builer=...;
//根据构建者不同返回产品不同
Product product = controller.getProduct(builer);
```

### 没有指挥者的建造者模式（简略模式）
构建顺序 和构建能力 全部定义在 ActorBuilder 中
```java
class DevilBuilder extends ActorBuilder{
   public  void buildType() { ...}
   public  void buildSex()  { ... }
   public  void buildFace() { ... }
   public  void buildCostume() {...}
   public  void buildHairstyle() {...}

   public  Product getProduct()
   {
        buildType();
        ...
        buildCostume();
        return createAProduct();
   }
}
```


#### 建造者模式 和 工厂模式 的区别
工厂模式与 建造者模式的完整模式相比，就多了一个 指挥者。 不同的构建者的 构建流程 抽象出来放在一起了。  与简略模式相比，我感觉没啥区别。

#### 建造者模式 和 策略模式 的区别
个人感觉只是定义的出发点不同。 从形式上看，都是根据传入不同的策略，获得不同的结果。（一种构建者可以看做一种策略）
