
# Android中 常用的设计模式
```text
单例模式 // 
建造者模式 Builder //   AlertDialog.Builder
观察者模式  // Rxjava ，
适配器模式 // 解决接口不兼容的问题 ，两个系统的接口不一样，我继承旧接口,然后...
代理模式  // 源码中 有大量用到 ActivityManagerProxy , AMS  

// AsyncTask 应用 模板方法   
@MainThread
public final AsyncTask<Params, Progress, Result> execute(Params... params){
    return executeOnExecutor(sDefaultExecutor, params);
}
@MainThread
public final AsyncTask<Params, Progress, Result> executeOnExecutor(
Executor exec, Params... params){
    ...
    onPreExecute();
    ...
    exec.execute(mFuture);
    return this;
}
```
 

# 回调机制
```text
回调的简单理解：
A需要做一件事情(不需要立刻知道结果)，给B设置一个回调对象，然后B在条件合适的时候执行得到一个结果， 
然后通过A传过来的回调对象告诉A。
 
// 1、回调普通使用
public interface IH264StoreFinishCallBack{
    public void onStoreAndParseFinished( boolean result, String msgStr) ;
}
private IH264StoreFinishCallBack ih264StoreFinishCallBack = new IH264StoreFinishCallBack(){
    @Override
    public void onStoreAndParseFinished(boolean result, String msgStr)  {
        if(result) {
            disMissIosLoading();
        }
    }
} ;
H264FileSotrPresenter h264FileSotrPresenter = new H264FileSotrPresenter(ih264StoreFinishCallBack);
if(ih264StoreFinishCallBack!=null){
 ih264StoreFinishCallBack.onStoreAndParseFinished(true ,"切换到照片时自动触发结束录像命令");
}

//  2、全局回调的使用方法(结合单例模式)
这种模式可以实现在不同的activity之间传递参数。
1、定义回调函数管理类：
/**
 * Created by Aivin on 2017/5/8.
 * 单例模式 管理一个回调对象，
 * 实现两个不同的activity实时通讯
 *用户手动改变计量单位后，通知另外一个activity做出相应的改变
 */

public class UnitsChangeCallBackManager{
  private IUnitsModeChangeCallBack iUnitsModeChangeCallBack ;
   // 接受传入的回调实例
    public void setiUnitsModeChangeCallBack(IUnitsModeChangeCallBack iUnitsModeChangeCallBack) {
        this.iUnitsModeChangeCallBack = iUnitsModeChangeCallBack;
    }
    public void sendUnitsChangedByUser(int type , int value , String msgStr) {
       if(iUnitsModeChangeCallBack !=null) {
           iUnitsModeChangeCallBack.onUnitsModeChange(type , value , msgStr);
       }
    }//

    /**私有化构造函数，防止被其他类实例化*/
    private UnitsChangeCallBackManager()  {
        //初始化操作
    }//

    /**使用一个内部类来维护单例
     *单例模式使用内部类来维护单例的实现。
     *利用jvm提供的机制，加载类的线程互斥的，用来解决多线程访问的时候可能会遇到null的问题。
     **/
    private static class SingletonFactory   {
        private static UnitsChangeCallBackManager instance = new UnitsChangeCallBackManager();
    }

    /**获取实例,对外提供的接口 */
    public static UnitsChangeCallBackManager getInstance()  {
        return SingletonFactory.instance;
    }

    /**为了能在序列化过程仍能保持单例的特性，需要添加一个readResolve()方法 */
    private Object readResolve()  {
        return getInstance();
    }
}
 
UnitsChangeCallBackManager.getInstance().setiUnitsModeChangeCallBack(this); // 设置回调：
public void onUnitsModeChange(int type, int value, String msgStr){
    switch (type) {
        case 1:  
          break;
             
    }
}
UnitsChangeCallBackManager.getInstance().sendUnitsChangedByUser(1,1 ,"英尺"); // 触发回调
```


# 面向对象设计原则

## 单一职责
```text
一个类只负责一个功能领域中的相应职责。
在软件系统中，一个类承担的职责越多，它被复用的可能性就越小。
一个类承担的职责过多，就相当于将这些职责耦合在一起，当其中一个职责变化时，可能会影响其他职责的运作。
因此，要将这些职责进行分离，将不同的职责封装在不同的类中。
单一职责原则是实现高内聚、低耦合的指导方针，它是最简单但又最难运用的原则。
```

### 高内聚、低耦合
```text
高内聚 是指一个模块是由相关性很强的代码组成，只负责一项任务。
低耦合 是指模块与模块之间，尽可能的使其独立存在。
```

 

## 开闭原则
```text
一个 软件实体 应当对扩展开放，对修改关闭。应尽量在不修改原有代码的情况下进行扩展。
//软件实体：
可以指一个软件模块、一个由多个类组成的局部结构或一个独立的类。

当软件系统需要面对新的需求时，我们应该尽量保证系统的设计框架是稳定的。
如果一个软件设计符合开闭原则，那么可以非常方便地对系统进行扩展，而且在扩展时无须修改现有代码，
使得软件系统在拥有适应性和灵活性的同时具备较好的稳定性和延续性。

在Java中，可以为系统定义一个相对稳定的抽象层(抽象类或者接口)，而将不同的实现行为移至具体的实现层中完成。
增加新的具体类来实现新的业务功能，在不修改已有代码的基础上扩展系统的功能。

//注意：
因为xml和properties等格式的配置文件是纯文本文件，编辑后无须编译，
因此在软件开发中，一般不把对配置文件的修改认为是对系统源代码的修改。
如果一个系统在扩展时只涉及到修改配置文件，而原有的Java代码没有做任何修改，
则可认为该系统是一个符合开闭原则的系统。
```

 
 
##   接口隔离原则
(Interface  Segregation Principle, ISP)
```text
使用多个专门的接口，而不使用单一的总接口。
因为在面向对象编程语言中，实现一个接口就需要实现该接口中定义的所有方法，所以大的总接口使用起来不一定很方便。

//注意：
在使用接口隔离原则时，我们需要注意控制接口的粒度。
1、接口不能太小。接口太小会导致系统中接口泛滥，不利于维护；
2、接口也不能太大。太大的接口将违背接口隔离原则，灵活性较差，使用起来很不方便。
一般而言，接口中仅包含为某一类用户定制的方法即可。

//“接口”往往有两种不同的含义：
对于不同的含义，ISP的表达方式以及含义都有所不同。

1、把接口理解成角色，一个接口只能代表一个角色，每个角色都有它特定的一个接口，
此时，这个原也可以叫做“角色隔离原则”。
2、如果把“接口”理解成狭义的特定语言的接口，
那么ISP表达的意思是指接口仅仅提供客户端需要的行为。
```


  

## 依赖倒转原则
Dependency Inversion  Principle, DIP

```text
抽象不应该依赖于细节，细节应当依赖于抽象。换言之，要针对接口编程，而不是针对实现编程。
DIP要求传递参数时或在关联关系中，尽量引用层次高的抽象层类，而不要用具体类。
我们需要针对抽象层编程。将具体类的对象通过依赖注入的方式注入到其他对象中。

依赖注入(DependencyInjection, DI):
当一个对象要与其他对象发生依赖关系时，通过抽象来注入所依赖的对象。
常用的注入方式有三种：
1、构造注入。通过构造函数来传入具体类的对象；
2、设值注入。通过Setter方法来传入具体类的对象；
3、接口注入。通过在接口中声明的业务方法来传入具体类的对象。
```

### 依赖倒置和里氏替换的区别
```text
在大多数情况下，这三个设计原则会同时出现，开闭原则是目标，里氏代换原则是基础，依赖倒转原则是手段，
它们相辅相成，相互补充，目标一致，只是分析问题时所站角度不同而已。
1、定义的角度不同。里氏替换原则是关于子类和父类的原则;依赖倒置原则是关于抽象与细节的原则。
2、应用范围不同。依赖倒置原则使用范围更广。
在大多数情况下，OCP、LSP、DIP会同时出现。开闭原则是目标，里氏代换原则是基础，
依赖倒转原则是手段，它们相辅相成，相互补充，目标一致，只是分析问题时所站角度不同而已。
```
 

## 里氏代换原则
Liskov Substitution Principle, LSP
```text
**LSP** 是由麻省理工学院计算机科学实验室的**Liskov**女士提出来的。所以以她的名字命名。
里氏代换原则要求，在软件中将一个基类对象替换成它的子类对象，程序将不会产生任何错误和异常，反过来则不成立。

例如：我喜欢动物，那我一定喜欢狗，因为狗是动物的子类；但是我喜欢狗，不能据此断定我喜欢所有动物。
里氏代换原则是实现开闭原则的重要方式之一，因此在程序中尽量使用基类类型来对对象进行定义，
而在运行时再确定其子类类型，用子类对象来替换父类对象。

//在使用LSP时需要注意如下问题：
1、子类的所有方法必须在父类中声明，或子类必须实现父类中声明的所有方法。
因为如果一个方法只存在子类中，在父类中不提供相应的声明，则无法在以父类定义的对象中使用该方法。
2、在运用LSP时，尽量把父类设计为抽象类或者接口，让子类继承父类或实现父接口，并实现在父类中声明的方法，
运行时，子类实例替换父类实例，我们可以很方便地扩展系统的功能，同时无须修改原有子类的代码。

附： 类似 List tempList= new ArrayList() ;  ?
//申明时用基类List ， 具体实现时用子类ArrayList 。
```
 

##  迪米特法则 、得墨忒耳法则
(Law of  Demeter, LoD) ,有些书也译作 “得墨忒耳法则” 。

```text
一个软件实体应当尽可能少地与其他实体发生相互作用。
迪米特法则可降低系统的耦合度，当其中某一个模块发生修改时，就会尽量少地影响其他模块。

//所以在类的结构设计上：
1、每一个类都应当尽量降低其成员变量和成员函数的访问权限；
2、在类的设计上，只要有可能，一个类型应当设计成不变类；
3、在对其他类的引用上，一个对象对其他对象的引用应当降到最低。

迪米特法则还有几种定义形式，包括：不要和“陌生人”说话、只与你的直接朋友通信等
其朋友包括以下几类：
1、当前对象本身(this)；
2、以参数形式传入到当前对象方法中的对象；
3、当前对象的成员对象；
4、 如果当前对象的成员对象是一个集合，那么集合中的元素也都是朋友；
5、当前对象所创建的对象。

任何一个对象，如果满足上面的条件之一，就是当前对象的“朋友”，否则就是“陌生人”。
迪米特法则要求我们在设计系统时，应该尽量减少对象之间的交互，
如果两个对象之间不必彼此直接通信，那么这两个对象就不应当发生任何直接的相互作用，
如果其中的一个对象需要调用另一个对象的某一个方法的话，可以通过第三者转发这个调用。
简言之，就是通过引入一个合理的第三者来降低现有对象之间的耦合度。
```



 

##  合成复用原则
(Composite Reuse Principle, CRP),
有一些书上没有列上CRP，只说“六大设计原则” 。
```text
组合复用原则、聚合复用原则
尽量使用对象组合，而不是继承来达到复用的目的。

在面向对象设计中，可以通过两种方法在不同的环境中复用已有的设计和实现:
1、通过 组合/聚合 实现 
组合/聚合可以使系统更加灵活，降低类与类之间的耦合度。请优先考虑。

2、通过 继承 实现
继承复用会破坏系统的封装性，因为继承会将基类的实现细节暴露给子类。
由于基类的内部细节通常对子类来说是可见的，所以这种复用又称“白箱”复用。
一般而言，如果两个类之间是“Has-A”的关系应使用组合或聚合；
如果是“Is-A”关系可使用继承。
```
 




  




# 中介者模式 
```text
Mediator Pattern ,“中介者模式” 是 “迪米特法则” 的一个典型应用。（不要与陌生人说话）。 
同事类之间没有直接显示交流 ，而是通过中介类（定义了行为接口）进行通信。 
```
![](https://gitee.com/hnyer/filesOfGitbook/raw/master/files/201803261940_osChina_网状结构_星形结构.png)


## 应用场景
```text
1、在有些软件中，某些类/对象之间的相互调用关系错综复杂，类似QQ用户之间的关系，
此时，我们特别需要一个类似“QQ群”一样的中间类来协调这些类/对象之间的复杂关系 。
2、 请结合现实生活中的 “中介”进行理解。 房产中介...
```

## 优缺点
```text
// 优点
1、 简化了对象之间的交互，将原本难以理解的网状结构转换成相对简单的星型结构。
2、 增加新的中介者和新的同事类都比较方便，更好地符合“开闭原则”。

// 缺点
1、 中介者类中包含了大量同事类之间的交互细节，可能会导致中介者类非常复杂 
```



# 享元模式  
```text
Flyweight Pattern
当系统中存在大量相似或相同的对象时，将会导致运行代价过高、OOM 等问题，享元模式正为解决之一类问题而诞生。
1、享元模式在使用时存在线程安全问题，需要考虑线程安全。
2、通常用一个 工厂类 类维护享元对象。

// 内部状态 Internal State
存储在享元对象内部并且不会随环境改变而改变的状态，内部状态可以共享。

// 外部状态 External State
随环境改变而改变的、不可以共享的状态。外部状态由客户端保存。
外部状态不可以影响享元对象的内部状态，它们是相互独立的。
```

## 缺点
```text
1、对象 需要分离出 内部状态 和 外部状态，这使得程序的逻辑复杂化。
2、读取外部状态使得运行时间变长。
```

## 示例
![](https://gitee.com/hnyer/filesOfGitbook/raw/master/files/201803271357_osChina_享元模式.png)

围棋棋盘中包含大量的黑子和白子，它们的形状、大小都一模一样，只是出现的位置不同而已。
如果将每一个棋子都作为一个独立的对象存储在内存中，将导致该围棋软件在运行时所需内存空间较大。

```text
class Chessman   {
  private String color; // 内部状态
  private Point location;// 外部状态
  public Chessman(String color)
  { ...}
  public String getColor()
  { ... }
  public String getLocation()
  { ...}
  /**更新外部状态 需要主要线程安全*/
  public synchronized void updateLocation( Point loation)
  { ...  }
}
public class ChessmanFactory {
    /**享元池*/
    private static Map<String,Chessman> map=new HashMap<>();
    public static ChessFlyWeight getChess(String color)  {
        if(map.get(color)!=null){
            return map.get(color);
        }else{
            Chessman chessman=new Chessman(color);
            map.put(color, chessman);
            return chessman;
        }
    }
}
//多次调用 也只创建了一个 Chessman 对象
Chessman chessman=ChessmanFactory.getChess("黑色");
```





# 代理模式
Proxy Pattern,
```text
当无法直接访问某个对象或访问某个对象存在困难时可以通过一个代理对象来间接访问。
关键点：代理对象控制对原对象的引用 。
```

## 静态代理

```text
代理类与委托类有同样的接口。通过代理对象访问目标对象。
1、可以在目标对象实现的基础上,增强额外的功能操作 。(这一点跟装饰者模式一样)
实现自定义的控制策略。
 
// 委托类 实现的接口
public interface IUser{
	public String getUserInfo();
}
 
// 委托类。对外提供 查询用户信息的功能。
public class UserTools implements IUser{
	public String getUserInfo(){
	  return "he is tom";
	}
}

/**
 * 代理类。 实现的接口与委托类一模一样。
 * 用户通过代理作为中间人去使用原对象拥有的功能。
 * 但是真正执行的还是原来的对象。
 */
public class UserToolsProxy implements IUser{
  private UserTools  userTools ;
	public String getUserInfo() {
      //做授权判断
  	boolean isTheRightTime = true of false...;
  	if(isTheRightTime){
  		return userTools.getUserInfo();
  	}else{
  		return "wrong time";
  	}
}
```

## 动态代理
```text
因为静态代理的方案是需要编写好代码的，
代理类与委托类有同样的接口，如果 委托类 方法数量较多，采用静态代理方案，
代理类的代码就比较冗余，工作量比较大。

动态代理 可以在不改变源码的情况下，直接在方法中插入自定义逻辑。
这种编程模型有一个专业名称叫 AOP (Aspect Oriented Programming 面向切面编程) 。

JDK的动态代理机制只能代理实现了接口的类。
JDK 动态代理是基于接口设计实现的，如果 委托类没有实现接口，会抛异常。
Exception in thread "main" java.lang.ClassCastException

//  功能接口
public interface UserService {
    public void select();
    public void update();
}

// 委托类
public class UserServiceImpl implements UserService {
    @Override
    public void select() {
        System.out.println("委托类原始选择功能");
    }

    @Override
    public void update() {
        System.out.println("委托类原始更新功能");
    }
}

// 动态代理 新功能处理类
public class LogHandler implements InvocationHandler {
    private Object target;
    // target 是委托类
    LogHandler(Object target){
        this.target = target;
    }

    @Override
    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
        System.out.print("--- "+ method.getName()); // 方法名
        before();
        Object result = method.invoke(target, args);
        after();
        return result;
    }

    private void before() {
        System.out.println("\r\n");
        System.out.println(String.format("动态代理添加的日志记录功能 ，日志开始记录于 [%s] ", new Date()));
    }
    private void after() {
        System.out.println(String.format("动态代理添加的日志记录功能 ，日志记录结束于 [%s] ", new Date()));
    }
}

// 测试
UserServiceImpl userServiceImpl = new UserServiceImpl();
// 委托类的 类加载器
ClassLoader classLoader = userServiceImpl.getClass().getClassLoader();
// 委托类实现的接口
Class[] interfaces = userServiceImpl.getClass().getInterfaces();
// 需要 切入添加的 事件处理器
InvocationHandler logHandler = new LogHandler(userServiceImpl);
// JDK 生成动态代理
UserService proxy = (UserService) Proxy.newProxyInstance(classLoader, interfaces, logHandler);
// 动态代理的 方法
proxy.select();
proxy.update();
```

## cglib 动态代理
```text
JDK的动态代理用起来非常简单，但是它有一个限制，
就是使用动态代理的对象必须实现一个或多个接口。
如果想代理没有实现接口的继承类，我们可以使用 CGLIB 包。

CGLIB 包使用字节码处理框架 ASM (Java字节码操控框架),
通过字节码技术为一个类创建子类，并在子类中采用方法拦截的技术拦截所有父类方法的调用，
顺势织入横切逻辑，来完成动态代理的实现。
```

## 代理模式和接口回调的区别
跟做iOS的同事曾经讨论过，对方说代理模式和接口回调理解起来差不多。
( 可能是iOS的代理的定义不一样?) 我个人认为这两者相差还是比较大的，出发点和定义都不一样。




#单例模式  Singleton Pattern
```text
通过单例模式可以保证系统中，应用该模式的一个类只有一个实例 。
1、单例类只能有一个实例

2、单例类必须自己自己创建自己的唯一实例。
(不考虑反射机制)外部只能通过 getInstance() 访问。

4、构造方法限定为 private ，防止外部实例化该类的对象
```

## 使用场景
```text
1、某些大型的类创建频繁时会导致很大的系统开销。
2、软件系统中有些地方只能有一个实例，否则会出现各种问题。
例如打印机为了避免状态不一致而采用单例模式。
```

## 缺点
```text
单例实例的生命周期和软件的生命周期一样长。
如果它持有某些对象的引用 ，会导致该对象无法释放。
```

## 饿汉式 单例模式 (不推荐，有并发问题)

```text
实例在类加载的时候即被实例化(jvm的机制，加载类的线程互斥)，因此线程安全。
没有延迟加载，如果长时间没用到这个实例，则会造成内存的浪费。
如果实例初始化时间长而需要延迟初始化 就要考虑用懒汉模式了。

public class SingletonBean {
    private  SingletonBean(){  }
    // 在类加载的时候即被实例化
    private static final SingletonBean singleton=new SingletonBean();
    public SingletonBean getIncetance(){
        return singleton;
    }
}
```


##  简单 懒汉式单例模式 (不推荐 ，效率不高)
```text
单线程下没有安全问题，
多线程下，可能会有多个线程同时拿到 if (null == instance) ，
所以可能会产生多个实例。
可以加 synchronized 解决安全问题，让线程串行执行。
绝大部分的耗时都用在synchronized修饰符的同步准备上，因此从性能上来说很不划算。

public class SingletonBean {
    private  SingletonBean(){  }
    private static SingletonBean singleton = null;
    public synchronized static SingletonBean getIncetance() {
        if (singleton == null) {
            singleton = new SingletonBean();
        }
        return singleton;
    }
}
```

##  DCL  + Volatile  懒汉模式 (推荐)
DCL (Double-Check-Locking  ) 双重检查锁定 。

```text
public class SingletonBean{
    private static volatile SingletonBean instance = null;
    public  static SingletonBean getInstance() {
        if(null == instance) { // 第一次检查
            synchronized (SingletonBean.class) {
                if(null == instance) { // 第二次检查 + volatile 配合避免了创建多个实例
                    instance = new SingletonBean();
                }
            }
        }
        return instance;
    }
}

这种方式的关键点：
1、必须要有 volatile ，否则可能出现Java中的另一个线程看到个初始化了一半的 instance 的情况。
2、第一次检查不上锁，为了防止每次访问时都要去竞争锁，减少等待时间，
第二次检查 是 volatile + synchronized 确保生成唯一的实例。

instance = new SingletonBean() 这句代码被编译成多条指令，大致做了下面三件事
1、给instance实例分配内存
2、初始化instance的构造器 (真正初始化)
3、将instance对象指向分配的内存空间（到这步时instance就非null了）

volatile 禁止指令重排，确保 步骤3在步骤2之后执行 。
```
 

## Holder 懒汉模式 (推荐)
注意，这种方式的单例模式不太适合将单例对象销毁后再次新建。
如果有这种需求可以使用 “双重检查锁定”这种创建方式。
```text
将懒加载和线程安全(无锁)完美结合的一种方式 。
public class SingletonBean{
    private static SingletonBean  instance = null ;
    private SingletonBean() {  }

    public static SingletonBean getInstance() {
        return SingletonFactory.instance;
    }

    /**
     * 静态的成员式内部类，该内部类的实例与外部类的实例没有绑定关系，
     * 而且只有被调用到才会装载，从而实现了延迟加载
     */
    private static class SingletonFactory  {
        // 由 JVM 来保证线程安全
        private static SingletonBean instance = new SingletonBean();
    }
}
```

## 枚举 懒汉模式
```text
Java规范中规定，每一个枚举类型极其定义的枚举变量在JVM中都是唯一的 。
利用枚举的特性，让JVM来帮我们保证线程安全和单一实例的问题。

public class SingletonBean {
    private SingletonBean() { }

    public static SingletonBean getInstance() {
        return EnumHolder.INSTANCE.getInstance();
    }

    private enum EnumHolder {
        INSTANCE;
        private SingletonBean instance = null;

        private EnumHolder() {
            // JVM保证这个方法只调用一次
            instance = new SingletonBean();
        }

        private SingletonBean getInstance() {
            return instance;
        }
    }
}
```


## 类的静态方法也可以实现单例模式的效果，有什么区别
```text
单例模式可以延迟初始化，有助于优化性能 。
```

 


## 单例模式 反序列化 的问题
```text
一般来说，一个类实现了Serializable接口，我们就可以将它写入内存然后再从内存中读取组装成一个跟原来一样的对象。
此时，内存中存在N（N>=2）个相同的对象。 
而单例模式要求JVM中只能有一个类的对象。如果不做特殊处理反序列就会违反单例模式的规则。
 
/**
 * 实现readResolve方法，一个class可以直接控制反序化返回的类型和对象引用。
 * ObjectInputStream 会检查对象的class是否定义了readResolve方法。
 * Method readResolveMethod = getInheritableMethod( cl, "readResolve", null, Object.class);
 */
 private Object readResolve() throws ObjectStreamException {  
			return INSTANCE; //直接返回已经存在单例对象，不再组装新的对象。确保唯一性。
	 }
```




# 原型模式  
```text
Prototype Pattern ,原型模式特点 在于通过 克隆 一个已经存在的实例来返回新的实例，而不是新建实例。
被复制的实例就是我们所称的“原型”。
模型需要对外暴露自己实现的克隆接口。
当创建新的对象实例较为复杂、成本较大时，使用原型模式可以简化对象的创建过程、节约资源。
 
// 创建原型对象
WeeklyLog log_previous = new WeeklyLog();  
log_previous.setDate("第12周");
//调用克隆方法创建克隆对象
WeeklyLog  log_new = log_previous.clone();
log_new.setDate("第13周");
```


## 缺点
```text
1、需要为每一个类配备一个克隆方法 ，当对已有的类进行改造时，需要修改源代码，违背了“开闭原则”。
2、如果对象复杂，实现深克隆的时候较麻烦。（每一层对象对应的类都必须支持深克隆）
```




# 命令模式 Command Pattern  
类型 | 特点
-|-
命令 Command| 有N种。包含具体的接收者。
接收者 Receiver|有N种 。执行具体逻辑的地方 。
请求者 Invoker| 1种 。 只负责 接收命令并调用命令的执行方法。

## 示例
```text
/**调用者 */
public class Invoker{
    /**接收具体命令 并执行*/
    public void executeCmd(Command command){
        command.execute();
    }
}

/**具体的命令,例如打开连接 */
public class CommandOpenConnection implements Command{
　　private Receiver receiver;
    /**命令 和 接收者 绑定*/
　　public CommandOpenConnection(Receiver receiver) { ...}
    /**执行命令*/
　　public void execute() {
　　   receiver.doSomeThing(...);
　　}
}

/**具体的接收者*/
public class ReceiverOpenConnection implements Receiver{
     public void doSomeThing(...)  {
       具体的逻辑....  
     }
}

//使用场景
Receiver receiver=... ;
Invoker invoker = ...;
Command cmd1 = ... ;
//Command cmd2 = ... ;
// 调用者 更新命令 并发起执行
invoker.executeCmd(cmd1);
```
 

## 优缺点
```text
//优点
1、请求者（Invoker） 和执行者（Receiver） 完全解耦。
2、添加新的命令 符合 “开闭原则” 。
// 缺点
1、一种命令 对应 一个命令类(xxx.java)。导致 类个数过多 。
```
 

## 命令模式 和 策略模式 的区别
```text
1、命令模式 只是强调解耦合，调用者只是负责发起调用。不同的命令得到不同的处理结果 。
2、策略模式 强调 一个问题可以用多种策略方法来 获得相同的处理结果 。
```


# 备忘录模式  Memento Pattern  、快照模式
```text
在不破坏封闭的前提下，保存对象当前状态，并且在需要的时候可以再次恢复到此状态。
数据库的 回滚操作、编辑器的 Ctrl+Z恢复 都有用到 备忘录模式。

// 如何理解“不破坏封闭的前提”
发起者只提供有限的接口（保存、恢复数据）。不暴露其他不该暴露的信息。
// 缺点
消耗资源
 
/**发起者*/
public class Game{
    private int time; //游戏开始时间
    private int killPeople; //游戏人头数

    /** 将信息保存到备忘录*/
    public GameInfo saveGameInfo() {
      GameInfo gameInfo= new GameInfo(time, killPeople);
      return gameInfo;
    }

   // 根据备忘录 恢复 信息 。
    public void loadGame(GameInfo gameInfo) {
        time = gameInfo.getTime();
        killPeople = gameInfo.getKillPeople();
    }
}

/**备忘录角色 ,保存指定的状态信息*/
public class GameInfo{
    private int time;
    private int killPeople;
    public GameInfo(int time, int killPeople)
    { ...  }
}
//使用
Game dota = new Game();
// 将状态保存到备忘录中
GameInfo info = dota.saveGameInfo();
// 根据备忘录 恢复数据
dota.loadGame(info);
```


# 外观模式  Facade Pattern 、门面模式
```text
有一个系统 很大、很复杂，以至于一般的人不会用。即使会用也很麻烦。
这时，我们可以对这个系统做封装 ，让大家通过封装后的接口很方便地使用原来的系统 。

开启电脑 需要经过多个步骤，接通电源、启动BIOS、加载系统等等。
显然，用户不需要去操作这么繁琐复杂的流程 。 
所以我们给用户暴露了一个简单的接口，只要一按开机键 就可以启动电脑了 。
大大减小了系统使用的复杂度。
```

![](https://gitee.com/hnyer/filesOfGitbook/raw/master/files/201804031414_osChina_外观模式.png)

 

## 缺点
```text
1、如果子系统做了修改 ， 外观类可能需要做相应修改。违背了开闭原则。
```

## 代理模式 、外观模式 的区别
```text
1、侧重点不同， 代理强调 不直接访问原系统（因为权限等） 。 外观模式 强调 复杂系统的简化。
```







# 建造者模式 Builder Pattern
```text
适用于 构建流程非常复杂的 对象。
 
将一个复杂对象的构造与它的表示分离，使同样的构建过程可以创建不同的表示。
1、对象的构建：对象的组装生成过程。
2、对象的表示：产品本身。产品的特性。
3、同样的创建过程：指挥者中定义的创建的相同流程。
4、创建不同的表示：不同的创建细节区分在构建者当中，调用不同的构建者会有不同的结果。
```

## 具有指挥者的建造者模式 （完整模式）
```text
// 具体的构建者 只负责 最后的构建细节。
// 不负责这些细节如何组装
class DevilBuilder extends ActorBuilder{
   public  void buildType() { ...}
   public  void buildSex()  { ... }
   public  void buildFace() { ... }
   public  void buildCostume() {...}
   public  void buildHairstyle() {...}
}

// 指挥者 只负责构建顺序
class ActorController{
   public  Product getProduct(ActorBuilder ab)  {
          ab.buildType();
          ...
          ab.buildCostume();
          // Product在ActorBuilder的构造函数中创建好
          return ab.createAProduct();
   }
}

//测试
// 构建顺序定义在 ActorController 中
ActorController controller = ...;
// 产品不同部位的构建能力 定义在 builer 中
ActorBuilder  builer=...;
//根据构建者不同返回产品不同
Product product = controller.getProduct(builer);
```

## 没有指挥者的建造者模式（简略模式）
构建顺序 和构建能力 全部定义在 ActorBuilder 中
```text
class DevilBuilder extends ActorBuilder{
   public  void buildType() { ...}
   public  void buildSex()  { ... }
   public  void buildFace() { ... }
   public  void buildCostume() {...}
   public  void buildHairstyle() {...}

   public  Product getProduct()  {
        buildType();
        ...
        buildCostume();
        return createAProduct();
   }
}
```


## 建造者模式 和 工厂模式 的区别
```text
工厂模式与 建造者模式的完整模式相比，就多了一个 指挥者。 
不同的构建者的 构建流程 抽象出来放在一起了。  与简略模式相比，我感觉没啥区别。
```

## 建造者模式 和 策略模式 的区别
```text
个人感觉只是定义的出发点不同。 
从形式上看，都是根据传入不同的策略，获得不同的结果。（一种构建者可以看做一种策略）
```





# 桥接模式 Bridge Pattern
```text
如果一个类有多个变化维度。此时可以使用继承的方法进行组合 ，但是这样会产生大量的派生类 才能满足要求。
此时我们的桥接模式，采用聚合而非继承的方式 也可以实现同样的效果。但是需要的派生类就大大减少了。
```
##  抽象部分 、实现部分
概念参考自[刘伟](https://blog.csdn.net/lovelion/article/details/7464195) 。
```text
假如一个类有两个独立的纬度，我们将与这个类关系最密切、最本质的那个纬度 称之为 “抽象部分”。
而另外的一个纬度称之为“实现部分” 。
例如 一支毛笔，有“大小型号” 和"能绘制的颜色" 两个纬度 。
因为毛笔一旦生产它的大小型号就已经被固定了，而能绘制的颜色可以根据沾染的涂料不同而变化。 
所以， “型号”这个纬度划分为 “抽象部分” ，“颜色”划分为 “实现部分” 。
```

## 示意图
采用继承的方式去实现效果。需要较多的派生类。 
![](https://gitee.com/hnyer/filesOfGitbook/raw/master/files/201804111503_osChina_继承模式.png)


采用桥接的方式去实现效果。型号和颜色互相组合即可实现。
![](https://gitee.com/hnyer/filesOfGitbook/raw/master/files/201804111504_osChina_桥接模式.png)


## demo
```text
//实现部分
public class Color{
	String color="";
	public Color(String color) {...}
}
// 抽象部分
public class Size {
	Color color;
	String size ="大号" ;
	public Size(Color color){...}
	public void disPlay() {
		System.out.println(size+" "+ color.color+ "  笔");
	}
}
//组合
Color white =new Color("白色 ");
Size size = new Size(white);
size.disPlay();
//获得 大号白色笔
```


# 模板模式 、模板方法模式 、Template Method Pattern
```text
模板方法使得子类可以在不改变算法结构的情况下，重新定义算法中的某些步骤。
为防止恶意操作，一般模板方法都加上 final 防篡改。
```

##  demo
```text
/**抽象类*/
public abstract class AbstractComputer{
    /**开机*/
    protected void powerOn()
     { ...  }
    /**常规硬件检查*/
    protected void checkHardware()
    { ...}
    /**加载 操作系统*/
    protected void loadOS()
    { ...}
    /**默认无密码验证，直接进入系统*/
    protected void login()
     { ... }
    // 模板方法，用 final修饰，防止被篡改 算法流程。
    public final void startUp() {
        //公共方法
        powerOn();
        //有差异性的方法
        checkHardware();
        //公共方法
        loadOS();
        //有差异性的方法
        login();
    }
}
 
// 程序员的电脑  
CoderComputer extends AbstractComputer...
@Override
 protected void login() {
   // 验证用户名和密码
 }
 //军用计算机
 class MilitaryComputer extends AbstractComputer...
 @Override
protected void checkHardware(){
  //进行 硬件防火墙 等安全设备是否正常
  ...
}
@Override
protected void login(){
  //验证 指纹 、 用户名、密码等
}
```



# 状态模式 State Pattern
```text
某种业务情况下，确实可以用 if  else 来完成 ，
但是由于 不同状态下的处理方法不一样。会导致大量的 if  else 代码。 
会造成代码复杂，不易维护等问题。 此时可以考虑用 状态模式 解决。
```
## demo
一个订单的状态： 未支付、正在支付、已支付、申请退款，退款中，退款完成
```text
//直接采用简单的 if else 方式
public void 支付（）{
  if(未支付){
    //处理 支付操作
  }
  else if(正在支付){
    //提示 不符合操作条件。
  }
  else if(退款完成){
  //提示 不符合操作条件。
  }
}

public void 退款（）{
  if(未支付){
   //提示 不符合操作条件。
  }else if(正在支付){
   //提示 不符合操作条件。
  } else if(退款完成){
   //提示 不符合操作条件。
  }else if(已支付){
    // 处理退款操作..
  }
}
//如果要新增 一个 "退款审核"状态 。
//此时需要去修改以上所有的 if else ,严重破坏 开闭原则 。
 
//采用状态模式
/**未支付状态*/
public class NoPayStatus  {
    public NoPayStatus(Order order,String name){
        //初始化订单信息
    }

    public OrderStatus processOrder(Order order) {
        //处理当前状态下的订单，
        ...
        //根据处理结果，设置订单新的状态
        OrderStatus state=new PayStatus(order,"已支付");
        order.setStatus(state);
        return state;
    }
}

/**申请退款*/
public class ApplyDrawbackStatus  {
  private Order order;
  private String name;
    public ApplyDrawbackStatus(Order order, String name)   {
       //初始化订单信息
    }

    @Override
    public OrderStatus processOrder(Order order)  {
        //处理当前状态下的订单，
        ...
       //根据处理结果，设置订单新的状态
        return new DrawbackStatus(order, "订单回款中");
    }
}
//使用场景
//某个时刻根据情况根据具体情况给订单设置状态
Order order=new Order();
order.setStatus( 某个状态);
....
//在另一个时刻，处理订单。
OrderStatus status=order.getStatus();
status.processOrder(order);
```

## 缺点
并没有完全符合 开闭原则
```text
@Override
public OrderStatus processOrder(Order order){
  //如果要新增 一个 "退款审核"状态 。
  //也需要修改相关代码
  //return new DrawbackStatus(order, "订单回款中");
  return new CheckDrawbackStatus(order, "退款审核中");
}
```
 

## 策略模式 和 状态模式 的区别
```text
1、策略模式只是一个解决方案的封装 。重在外部对策略的选择或动态的切换。策略模式每个算法是相对独立的。
2、状态模式是初始化一个状态，之后的每个状态的变化都会指定下一个状态。状态模式中每个状态是存在相互转化的，
```



#  策略模式  Strategy Pattern
## demo
```text
/**抽象接口，定义共同操作*/
public interface Strategy{
	public double getValue(double paramA, double paramB);
}
// 加法策略
public class AddStrategy implements Strategy{
	@Override
	public double getValue(double paramA, double paramB){
		return paramA + paramB;
	}
}//
// 减法策略
public class SubStrategy implements Strategy{
	@Override
	public double getValue(double paramA, double paramB){
		return paramA - paramB;
	}
}//
 
// 辅助类。根据传入的策略类型返回计算结果。 
public class CalcClient{
	private Strategy strategy;
	public void setStrategy(Strategy strategy){
		this.strategy = strategy;
	}
	public double calc(double paramA, double paramB){
		return this.strategy.getValue(paramA, paramB);
	}
}

public static void main(String[] args){
    double paramA = 5;
    double paramB = 21;
    //用if-else实现 （ 普通形式）   
    System.out.println("普通方法-加法结果是：" + calc("+", paramA, paramB));
    System.out.println("普通方法-减法结果是：" + calc("-", paramA, paramB));
    //System.out.println("乘法结果是：" + calc("*", paramA, paramB));
    //System.out.println("除法结果是：" + calc("/", paramA, paramB));
    //策略模式
    System.out.println("策略模式-加法结果是：" + calc(new AddStrategy(), paramA, paramB));
    System.out.println("策略模式-减法结果是：" + calc(new SubStrategy(), paramA, paramB));
    //System.out.println("乘法结果是：" + calc(new MultiStrategy(), paramA, paramB));
    //System.out.println("除法结果是：" + calc(new DivStrategy(), paramA, paramB));
}

// 用if-else实现 （ 普通形式）   
 public static double calc(String op, double paramA, double paramB){
    if ("+".equals(op)) {
      return paramA + paramB;
    } else if ("-".equals(op)) {
      return paramA - paramB;
    } else if ("*".equals(op)) {
      return paramA * paramB;
    } else if ("/".equals(op)) {
      return paramA / paramB;
    } else {
      throw new IllegalArgumentException("未找到计算方法!");
    }
  }

//  策略模式  实现
  public static double calc(Strategy strategy, double paramA, double paramB) {
    CalcClient calc = new CalcClient();
    calc.setStrategy(strategy);
    return calc.calc(paramA, paramB);
  }
  
前者通过简单的if-else来解决问题，在解决简单问题事会更简单、方便;
后者则是通过给予不同的具体策略来获取不同的结果，对于较为复杂的业务逻辑显得更为直观，扩展也更为方便。
```




## 优缺点
```text
// 优点
1、结构清晰明了、使用简单直观。
2、耦合度相对而言较低，扩展方便。
3、操作封装也更为彻底，数据更为安全。
// 缺点
1、随着策略的增加，子类也会变得繁多。
```


#  简单工厂模式（Simple Factory Pattern）
```text
又叫做静态工厂方法（StaticFactory Method）模式。
注：简单工厂模式实际上不属于23个GOF模式。
工厂类根据传入的参量,动态的决定应该创建出哪一个产品类的实例的设计模式。一个工厂可以生产多种产品。
```

## 优缺点
```text
//优点
使用者不需要去负责具体的创建过程，只需要向工厂传递参数信息就可以获得自己想要的产品。
// 缺点
因为工厂类集中了所有实例的创建逻辑， 如果需要增加新的产品，就需要修改工厂类，不利于代码的维护。违背了“开闭原则” 。所以**不推荐**使用这种设计模式。
客户很爽，工厂很被动。
```

## demo
```text
// 产品抽象类，定义产品共同的特效 
public interface Product{
	public void getProductInfo() ;
}
// 具体的产品
public class Car implements Product{
	@Override
	public void getProductInfo(){
		System.out.println("汽车产品");
	}//
}//

public class Bicycle implements Product{
	@Override
	public void getProductInfo(){
		System.out.println("自行车产品");
	}//
}//

// 简单工厂
public class SimpleFactory{
    /**
     * 根据不同的参数进行判断，返回不同的结果。
     * 如果增加了产品类，需要修改判断代码。
     * 静态工厂方法 的“静态”体现在这个 static方法上
     */
	public static Product getProductInfo(String productType ){
		Product product = null ;
		if("car".equals(productType)){
			product = new Car() ;
		}else{
			product = new Bicycle() ;
		}
		return product;
	}//
}
 // 测试
public static void main(String[] args){
  //直接调用工厂类的 静态方法或的产品。
  Product product =SimpleFactory.getProductInfo("car") ;
  product.getProductInfo() ;
}//
```


# 抽象工厂模式（Abstract Factory Pattern）
```text
工厂方法模式是一个具体工厂生产一种具体产品，抽象工厂模式是一个具体工厂生产一个品牌下的多种产品。
工厂方法模式解决了简单工厂模式中工厂类职责太重的问题。
但由于工厂方法模式中的每个工厂只生产一类产品，可能会导致系统中存在大量的工厂类，势必会增加系统的开销。
此时，我们可以考虑将一些相关的产品组成一个“产品族”，由同一个工厂来统一生产，这就是抽象工厂模式的基本思想。
```
##  产品等级结构 、产品族
```text
// 产品等级结构
类似手机与androdi手机、mac手机的关系。手机和Android手机、mac手机具体手机产品之间构成了一个产品等级结构。
// 产品族
同一个品牌下的各种产品，比如android手机和Android电视属于同一个产品族。
```

## 优缺点
```text
// 优点
- 1、隔离了具体类的生成，更换一个具体工厂就变得相对容易。
- 2、增加新的产品族很方便，无须修改已有系统，符合“开闭原则”。
//缺点
- 1、增加新的产品等级结构麻烦，违背了“开闭原则”。
增加新的产品族很方便，但是增加新的产品等级结构很麻烦，抽象工厂模式的这种性质称为“开闭原则”的倾斜性。
```

## demo
```text
// 抽象产品
public interface Iphone{
	public void getInfo();
}
// 抽象产品
public interface TV{
	public void getInfo();
}
// 具体产品
public class AndroidIphone implements Iphone{
	@Override
	public void getInfo(){
		System.out.println("mac 手机");
	}
}
public class MacIphone implements Iphone{
	@Override
	public void getInfo(){
		System.out.println("android 手机");
	}
}
public class AndroidTv implements TV{
	@Override
	public void getInfo(){
		System.out.println(" Android 电视");
	}
}
public class MACTv implements TV{
	@Override
	public void getInfo() {
		System.out.println(" MAC 电视");
	}
}

// 抽象工厂
public interface IFactory{
  public Iphone createPhone() ;
  public TV createTV() ;
}
// 具体工厂。
public class AndroidFactory implements IFactory{
	@Override
	public Iphone createPhone(){
		return new MacIphone();
	}

	@Override
	public TV createTV(){
		return new MACTv();
	}
}
// 具体工厂
public class MacFactory implements IFactory{
	@Override
	public Iphone createPhone(){
		return new AndroidIphone();
	}
	@Override
	public TV createTV(){
		return new AndroidTv();
	}
}

// 测试场景 
public static void main(String[] args){
  IFactory factory = new AndroidFactory() ;
  //根据配置文件或者网络参数，动态决定采用哪一个工厂。
  //IFactory factory = new MacFactory() ;
  //批量得到属于同一品牌下的产品。
  Iphone phone = factory.createPhone() ;
  TV tv = factory.createTV() ;
  tv.getInfo();
}//
```


# 工厂方法模式（Factory Method Pattern）
```text
又被称为多态工厂模式。
通常我们所说的工厂模式是指工厂方法模式。
工厂方法是针对每一种产品提供一个工厂类。通过不同的工厂实例来创建不同的产品实例。
反射生成对象只能适用一些最简单的情况，简单的创建一个对象。
如果对象的创建过程比较复杂，例如要调用有参构造函数、创建之前要配置环境等等，需要将这些代码封装到工厂中。
 
// 定义工厂的公共行为。 可以用接口或抽象类。
public interface  Factory{
	public Product produceProduct() ;
}
// 具体的产品 car
public class Car implements Product{
	@Override
	public void getProductInfo(){
		System.out.println("汽车产品");
	}
}
// 具体的产品  bicycle
public class Bicycle implements Product{
	@Override
	public void getProductInfo(){
		System.out.println("自行车产品");
	}
}

// 定义工厂的公共行为。可以用接口或抽象类。
public interface  Factory{
	public Product produceProduct() ;
}
 
// 具体的工厂类。BicycleFactory
public class BicycleFactory implements Factory{
	@Override
	public Product produceProduct(){
		//做一些复杂的操作。比如连接数据库等
		//调用有参构造等
		Bicycle bicycle = new Bicycle();
		return bicycle;
	}
}//
 
// 具体的工厂类。CarFactory
public class CarFactory implements Factory{
	@Override
	public Product produceProduct(){
		//做一些复杂的操作。比如连接数据库等
		// ...
		//调用有参构造等
		Car car = new Car();
		return car;
	}
}//

 /**使用场景*/
 public static void main(String[] args){
   //根据相关参数 生成具体的工厂对象。例如根据配置文件或者网络参数来决定
    Factory factory ;
    factory= new CarFactory() ;
    //factory= new BicycleFactory() ;

    Product product = factory.produceProduct() ;
    product.getProductInfo();
 }//
```

## 优缺点
```text
// 优点
1、它能够让工厂可以自主确定创建何种产品对象，而如何创建这个对象的细节则完全封装在不同的具体工厂内部。
2、加入新产品时，无须修改抽象工厂和抽象产品提供的接口，也无须修改其他的具体工厂和具体产品，
而只要添加一个具体工厂和具体产品就可以了。

// 缺点
1、在添加新产品时，需要新加新的具体产品类和与之对应的具体工厂类，在一定程度上增加了系统的复杂度，
有更多的类需要编译和运行，会给系统带来一些额外的开销。
```



## 策略模式和工厂模式有什么区别
```text
1、侧重点不一样 。 工厂模式侧重构建过程，使用者拿到最终的“生产物”即可。 
策略模式侧重 事件的行为，使用可互换的规则创建成功业务。  
策略模式是开放的，大多数事情要你自己亲力亲为。
而工厂模式作是封闭的，很多事情都帮组你做好了，你直接“点”就可以了。 
工厂相当于黑盒子，策略相当于白盒子?  [参考资料](http://blog.csdn.net/tengzhaorong/article/details/6827093)
```



# 组合模式 Composite Pattern 、 整体-部分模式
```text
组合模式将一批有共同特征的对象组合成 “树形结构”。
关键点是定义了一个抽象构件类，它既可以代表叶子，又可以代表容器，
而客户端针对该抽象构件类进行编程，无须知道它到底表示的是叶子还是容器，可以对其进行统一处理。
```

## 透明组合模式 （推荐使用）
```text
强调透明性一致性。 
因为叶子节点不存在子节点，所以一些方法是无效的。可以用过 “提供异常处理或相关提示”来解决 。 
```
![](https://gitee.com/hnyer/filesOfGitbook/raw/master/files/201804091146_osChina_透明组合模式.png)


## 安全组合模式

![](https://gitee.com/hnyer/filesOfGitbook/raw/master/files/201804091147_osChina_安全组合模式.png)

## 优点
```text
1、将对象们进行树形分层，方便对整个某个层次的所有对象进行处理。
2、使用透明组合模式时， 新增节点(容器节点、子节点) 符合 “开闭原则” 。
```

## demo
```text
/**抽象节点  */
abstract class AbstractFile{  
    public abstract void add(AbstractFile file);  
    public abstract AbstractFile getChild(int i);  
    public abstract void killVirus();  
}

/**叶子节点*/
class ImageFile extends AbstractFile{  
    private String name;  
    public ImageFile(String name) { ...}  
    public void add(AbstractFile file) {  
       // 子节点 不支持 当前方法 的相关提示
    }  
    public AbstractFile getChild(int i)  {  
        // 子节点 不支持 当前方法 的相关提示
        return null;  
    }  
    public void killVirus()  {  
        //模拟杀毒  
        ...
    }  
}  

/**容器节点*/
class Folder extends AbstractFile {  
    private ArrayList<AbstractFile> fileList=new ArrayList<>();  
    private String name;  
    public Folder(String name) {...}  
    public void add(AbstractFile file) {  
       fileList.add(file);    
    }  
    public AbstractFile getChild(int i) {  
        return (AbstractFile)fileList.get(i);  
    }  
    public void killVirus()  {  
        //递归调用
        for(AbstractFile obj : fileList)  {  
            obj .killVirus();  
        }  
    }  
}

//使用 。针对抽象构件编程
// 子节点
AbstractFile folder2 = new Folder("图像文件夹");  
folder2.add(new ImageFile("xxx.jpg"));  
folder2.add(new ImageFile("xxxx.gif"));  
// 容器节点
AbstractFile file1 = new Folder();
folder1.add(folder2);  
folder1.killVirus();
```


# 装饰者模式 、Decorator Pattern 、包装模式  、Wrapper Pattern
```text
装饰模式是一种用于替代继承的技术。
在不改变一个对象原有结构和功能的前提下，给它新加一些额外的功能。 

public class ConcreteComponent extends MyComponent{
    /**原有功能*/
    @Override
    public void operation() { ...  }
}
```
## 透明装饰模式 (尽量使用这种方式)
```text
要求完全针对抽象编程。可以透明地使用装饰之前的对象和装饰之后的对象。
为了达到这种效果， 必须在构件对象的方法中调用 增强方法。
但是缺点是用户不能单独地调用那些增强的方法 。
 
/**具体装饰器*/
public class ConcreteDecoratorA  extends MyComponent{
    MyComponent component ;
    /**持有被装饰的对象*/
    public ConcreteDecoratorA(MyComponent component) { ...  }
    public int operationA(){ ... 增强方法 ...  }

    @Override
    public void operation() {
        // 区别点！！里面调用了 operationA（）
        operationA();
        component.operation();
    }
}
 
MyComponent myComponet1= new ConcreteComponent(...);
// 针对MyComponent抽象编程
MyComponent myComponet2 = new ConcreteDecoratorA(myComponet1);
myComponet1.operation();
//不能在外面调用额外功能 。- 编译 出错
myComponet2.operationA();
myComponet2.operation();
```

## 半透明装饰模式
```text
/**具体装饰器*/
public class ConcreteDecoratorA  extends MyComponent {
    MyComponent component ;
    /**持有被装饰的对象*/
    public ConcreteDecoratorA(MyComponent component) { ...  }
    public int operationA(){ ... 增强方法 ...  }

    @Override
    public void operation()  {
        // 区别点！！ 在里面并没有调用 operationA()
        component.operation();
    }
}
 
MyComponent myComponet1= new ConcreteComponent(...);
ConcreteDecoratorA myComponet2 = new ConcreteDecoratorA(myComponet1);
//透明装饰者模式
myComponet1.operation();
// 可以在外 调用增强方法 - 编译ok
myComponet2.operationA();
myComponet2.operation();
```


##  如何理解 “半透明装饰模式不能实现对同一个对象的多次装饰”
```text
首先明确一点：半透明装饰模式 是将 增强方法 和原有方法 独立开来的。在装饰器中 原有方法并没有调用过增强方法。    
因为装饰类持有的是 MyComponent 类型的引用，而 MyComponent 并不能调用增强方法。
所以导致如下结果： 多次装饰的情况下，无法使用那些增强方法。
```


## 代理模式 与 装饰者模式 区别
```text
代理模式 强调对 委托对象的访问 ( 例如情况下 委托类不能或者不想对外暴露)。
装饰模式 强调 给原对象增加额外功能。

二者看起来类似，但是解决问题的出发点不一样。
```


#  观察者模式  Observer Pattern
```text
1、Observer Pattern用于建立一种对象与对象之间的依赖关系。
一个对象发生改变时将自动通知其他对象，其他对象将相应作出反应。

2、Observer Pattern包含1个观察目标和n(n>=1)观察者两类对象。一旦观察目标的状态发生改变，所有的观察者都将得到通知。

3、这种交互也称为发布-订阅(Publish-Subscribe)。
发布者发出通知时并不需要知道谁是它的观察者，可以有任意数目的观察者订阅它并接收通知。
- 4、凡是涉及到一对一或者一对多的对象交互场景都可以使用观察者模式。

// 举例
1、交通信号灯是汽车（驾驶员）的观察目标，而汽车是观察者。
随着交通信号灯的变化，汽车的行为也将随之而变化，一盏交通信号灯可以指挥多辆汽车。

2、在当前流行的MVC架构中也应用了观察者模式，它包含三个角色：模型(Model)，视图(View)和控制器(Controller)。
其中模型可对应于观察者模式中的观察目标，而视图对应于观察者，控制器可充当两者之间的中介者。
当模型层的数据发生改变时，视图层将自动改变其显示内容。

3、邮件订阅和RSS订阅，当我们浏览一些博客或wiki时，当你订阅了该文章，如果后续有更新，会及时通知你。

```
 

## 观察目标
Observer Pattern中，发生改变的对象称为观察目标。

## 观察者
```text
而被通知的对象称为观察者。
1、一个观察目标可以对应多个观察者。
2、这些观察者之间可以没有任何相互联系。
3、可以根据需要增加和删除观察者，使得系统更易于扩展。
```


## 优缺点
```text
// 优点
1、观察者模式可以实现表示层和数据逻辑层的分离，定义了稳定的消息更新传递机制，并抽象了更新接口，
使得可以有各种各样不同的表示层充当具体观察者角色。

2、观察者模式在观察目标和观察者之间建立一个抽象的耦合。
观察目标只需要维持一个抽象观察者的集合，无须了解其具体观察者。

3、观察者模式支持广播通信，观察目标会向所有已注册的观察者对象发送通知，简化了一对多系统设计的难度。

4、观察者模式满足“开闭原则”的要求，增加新的具体观察者无须修改原有系统代码，
而且观察目标和观察者没有紧密地耦合在一起，因此它们可以属于不同的抽象化层次。
在具体观察者与观察目标之间不存在关联关系的情况下，增加新的观察目标也很方便。

// 缺点
1、若一个观察目标对象有很多直接和间接观察者，将所有的观察者都通知到会耗时过多。
2、若观察者和观察目标之间存在循环依赖，观察目标会触发它们之间进行循环调用，可能导致系统崩溃。
3、Observer Pattern没有相应的机制让观察者知道所观察的目标对象是怎么发生变化的，而仅仅只是知道观察目标发生了变化。
```
 
## demo:
```text
// 观察者抽象类，定义共同的行为
public interface Observer{
  public void update();
}
// 具体的观察者 1
public class Observer1 implements  Observer{
	@Override
	public void update(){
		System.out.println("观察者 1收到通知");
	}
}//
// 具体的观察者 2
public class Observer2 implements  Observer{
	@Override
	public void update(){
		System.out.println("观察者 2收到通知");
	}
}//

// 被观察者接口。定义一些 方法用来管理 观察者集合。
public interface Subject{
	/**添加观察者*/
	public void addObserver(Observer observer) ;
	/**删除观察者*/
	public void delObserver(Observer observer) ;
	/**通知观察者*/
	public void notifyAllObservers();
}//
 
//  具体的 被观察者 
public class MySubject implements Subject{
	/**线程安全的集合*/
	private Vector<Observer> myObservers ;
	/**构造函数*/
	public MySubject () {
		myObservers = new Vector<Observer>();
	}
	@Override
	public void addObserver(Observer observer) {
		myObservers.add(observer) ;
	}
	@Override
	public void delObserver(Observer observer) {
		myObservers.remove(observer) ;
	}
	@Override
	public void notifyAllObservers() {
		//使用迭代器获取所有观察者 并通知
		Iterator<Observer> iterator = myObservers.iterator() ;
		while (iterator.hasNext()) 	{
			Observer observer =  iterator.next();
			observer.update();
		}//
	}//
}
 
/**实际场景应用*/
public static void main(String[] args) {
  Observer1 ob1 = new Observer1() ;
  Observer2 ob2 = new Observer2() ;
  MySubject mySubject = new MySubject() ;
  mySubject.addObserver(ob1);
  mySubject.addObserver(ob2);
  mySubject.notifyAllObservers() ;
}//
```



# 解释器模式 Interpreter Pattern
还未完全理解。 等过段时间再来更新....

~~解释器模式为自定义语言的设计和实现提供了一种解决方案，它用于定义一组文法规则并通过这组文法规则来解释自定义语言中的句子。~~


~~#### 应用场景
1、正则表达式解释器
2、SQL语法的解释器~~


相关概念 | 特点 | 举例
-|-|-
终结符（表达式）|不可拆分的最小元素。 一个语法的规则不能改变终结符。|x -> xa  a是终结符
非终结符（表达式）| 可拆分元素。 非终结符是可以被取代的元素。运算符也是非终结符|x -> xa  x 是非终结符
语言的文法规则| 即语法规则。拥有自己的表达式和结构。|
抽象语法树(Abstract Syntax Tree, AST)|用来直观地表示语言的构成。  每一棵抽象语法树对应一个语言实例。 终结符表达式类的实例作为树的叶子节点，非终结符表达式类的实例作为非叶子节点。  通过对抽象语法树的分析，可以识别出语言中的终结符类和非终结符类。|
环境角色|存放文法中各个终结符所对应的具体值|


~~#### 示例
Java无法直接解释类似“1+ 2 + 3 – 4 + 1”这样的字符串。 我们可以自己定义 一个解释器来解释这个语句 。~~


~~一些重复发生的问题，比如加减乘除四则运算，但是公式每次都不同，有时是a+b-c*d，有时是a*b+c-d，等等等等个，公式千变万化，但是都是由加减乘除四个非终结符来连接的，这时我们就可以使用解释器模式。~~
 

~~#### 缺点
1、 执行效率低。
2、 维护困难。~~






# 访问者模式  Visitor Pattern
```text
访问者模式把  数据结构 和 作用于结构上的操作 解耦合 。
适用于数据结构相对稳定算法又易变化的场景。
```

##  demo
以公司员工和部门的关系为场景。
```text
/**全职员工*/
public class FulltimeEmployee implements Employee  {
    public FulltimeEmployee(String name, int workTime) {...}
    /**每个对象都会实现这个方法*/
    @Override
    public void accept(Department handler) {
        //每个访问者都会有这个方法
        handler.visit(this);
    }
}

/**人力资源部类：具体访问者类*/
public class HRDepartment implements Department {
    /**所有访问者都会重载 所有 visit方法*/
    @Override
    public void visit(FulltimeEmployee employee) {  ... }
    /***所有访问者都会重载 所有 visit方法 */
    @Override
    public void visit(ParttimeEmployee employee) { ...  }
}

//使用。访问者不同，会做出不同的处理结果
Employee  employee = new FulltimeEmployee(...);
Department dep = new HRDepartment(....) ;
//Department dep = new FADepartment (....) ;
employee.accept(dep);
```

## 优缺点

```text
// 优点
1、方便定义 新的访问者，实现新的数据操作。
//Department dep = new HRDepartment(....) ;
//定义新的访问者
Department dep = new FADepartment (....) ;

// 缺点
1、违背了"依赖倒置原则" 。访问者依赖的是具体元素，而不是抽象元素。
public void visit(FulltimeEmployee employee) {  ... }

2、增加新的元素类比较困难。
每增加一个元素类 , 访问者就要多加一个visit()。
// 有 n个元素类 就有 n 个visit 方法
@Override
public void visit(FulltimeEmployee employee) {  ... }
....
@Override
public void visit(ParttimeEmployee employee) { ...  }
```
 

## 访问者模式 和 策略模式 的区别
```text
我个人感觉这两个模式差不多。 个人体会到的区别：  
1、策略模式是通过构造方法将策略传进去的 。 访问者模式 是通过普通的方法 accept() 将访问者（策略）传进的。
2、 体现在定义架构上
public class HRDepartment implements Department {
    @Override
    public void visit(FulltimeEmployee employee) {  ... }
    ...
    @Override
    public void visit(ParttimeEmployee employee) { ...  }
}
```


# 责任链模式 
Chain of Responsibility Pattern
```text
其实 ，swith 、if-else 体现了最简单的责任链思想 。只是这种写法 比较臃肿、耦合度高。
```

## 优缺点
```text
// 优点
1、一个请求沿着一条“链”传递，申请者不需要知道是谁来批准这个请求。 
批阅者也不需要这个请求来自谁。 这样将 申请者和批阅者优雅地解耦了。
2、容易拓展责任链
// 缺点
1、需要对链中责任人的遍历，如果责任人太多那么遍历必定会影响性能。
2、请求不一定会被处理掉。
```
 


##  demo
```text
/**责任人的处理方法*/
public void handleRequest(ProgramApe ape){
	if ( 有处理权限) {
		// 自己处理掉...
	} else {
		if (null != mSuperiorLeader) {
		   //如果自己没有权限处理， 就交给上级处理
		} else {
		  //如果自己没有权限处理， 也没有其他领导。就抛出错误，提示该
      //请求没有被处理掉
		}
	}
}
 
//应用场景
//先来一个程序猿 这里给他一个三万以内的随机值表示需要申请的差旅费
ProgramApe ape = new ProgramApe((int) (Math.random() * 30000));
//再来四个领导
Leader leader = new GroupLeader();
Leader director = new Director();
Leader manager = new Manager();
Leader boss = new Boss();
//事先设置好 责任链之间的连接关系
leader.setLeader(director);
director.setLeader(manager);
manager.setLeader(boss);
// 提交申请（不用写 if else 繁琐代码）
leader.handleRequest(ape);
```

 

# 迭代器模式 Iterator Pattern 、游标模式
```text
迭代器模式 提供一种机制 遍历一个聚合对象中的各个元素，而又不暴露其他细节。 

由于java已经为我们对容器对象（Collection，List、Set、Map等）做了很好的封装，
我们平时其实很少会自己实现迭代器模式。
```

## demo 
```text
// 具体迭代器    
class ConcreteIterator implements MyIterator{  
    private List  list = new ArrayList ();  
    private int cursor =0;  
    public ConcreteIterator(List list){  
        this.list = list;  
    }  
	public boolean hasNext(){
		return !(cursor == list.size());
	}
    public Object next(){  
        if(hasNext()){  
           return list.get(cursor++);  
        }  
        return null;  
    }  
}

/**具体的聚合类*/
class ConcreteAggregate {  
    private List  list = new ArrayList();  
    public MyIterator iterator(){  
        return new ConcreteIterator(list);  
    }  
   //  聚合类中的其他方法 ，处理其他逻辑 fun1 、saveObj 、removeObj
    public void saveObj(Object obj)
    { ...  }
     ... 其他逻辑...
}

//使用
// 聚合类
ConcreteAggregate ag = new ConcreteAggregate();  
ag.saveObj("obj1");  
ag.saveObj("obj2");  

// 获取迭代器
MyIterator it = ag.iterator();  
//根据迭代器 遍历
while(it.hasNext()){ ...  }
```


## 优缺点
```text
// 优点
1、将聚合类 的 “数据存储” 和 "数据遍历" 分离 。
2、自定义的迭代器可以实现一些自己想要的遍历效果（逆序遍历、只遍历符合自己指定条件的对象等）。
// 缺点
1、一个具体的聚合类 对应一个 迭代器 ，略显繁琐。
```
 
 

# 适配器模式  Adapter Pattern   
```text
解决接口不兼容的问题。
A 需要 C接口， 但是系统只提供了B接口。
同时, A 和B 都不想改或者不能改。
如果，我们将B封装一下，改成C接口的规范。就解决了问题。

被适配者 ：即源接口 。
```


## 一、类适配器 （不推荐）
采用继承方案。
```text
// 旧接口 提供220V电压
public class Voltage220 {
    public int output220V() {
        return 220;
    }
}
// 用户需要 5V的电压
public interface Voltage5{
    int output5V();
}

//新建适配器
public class VoltageAdapter extends Voltage220 implements Voltage5 {
    @Override
    public int output5V() {
      //获得旧接口的数据， 转换成用户需要的数据
        int src = output220V();
        return src / 44;
    }
}
```

## 二、对象适配器 （推荐）
采用持有方案。
```text
// 新建适配器
public class VoltageAdapter2 implements Voltage5 {
    private Voltage220 mVoltage220;
    public VoltageAdapter2(Voltage220 voltage220) {...}
    @Override
    public int output5V() {
        int src = mVoltage220.output220V();
        return src / 44;
    }
}
```

## 三、缺省适配器 、接口适配器模式（推荐）
原接口是 interface 。
```text
// 原接口
public  interface AnimatorPauseListener{
  void onAnimationStart(Animator animation);
  void onAnimationEnd(Animator animation);  
   ...
  void onAnimationResume(Animator animation) ;
}

// 新建适配器
public abstract class AnimatorListenerAdapter implements  
AnimatorListener  {
    @Override
    public void onAnimationEnd(Animator animation){...}
    @Override
    public void onAnimationStart(Animator animation){...}
    @Override
    public void onAnimationResume(Animator animation) {...}
}
// 使用
XXX.addListener(new AnimatorListenerAdapter() {
           @Override
           public void onAnimationStart(Animator animation) {
               // 重新 需要的那个方法就行。
               // 而不必 要实现 interface 中所有的方法，从而简化代码
           }
       });
```


## 四、双向适配器 （不推荐）
同时持有原接口和旧接口的对象。 
```text
class Adapter implements DesInterface,SrcInterface {  
    private Des des;  
    private Src src;  
    public Adapter(Des des) {... }  
    public Adapter(Src src) {...}  
    public void() func1(){
      src.xxx();
    };
    public void() func2(){
      des.xxx();
    };
}
```

