##### 观察者模式  Observer Pattern


#### 观察者模式
- 1、Observer Pattern用于建立一种对象与对象之间的依赖关系。
一个对象发生改变时将自动通知其他对象，其他对象将相应作出反应。
- 2、Observer Pattern包含1个观察目标和n(n>=1)观察者两类对象。一旦观察目标的状态发生改变，所有的观察者都将得到通知。
- 3、这种交互也称为发布-订阅(Publish-Subscribe)。
发布者发出通知时并不需要知道谁是它的观察者，可以有任意数目的观察者订阅它并接收通知。
- 4、凡是涉及到一对一或者一对多的对象交互场景都可以使用观察者模式。


##### 观察者模式的应用
- 1、交通信号灯是汽车（驾驶员）的观察目标，而汽车是观察者。
随着交通信号灯的变化，汽车的行为也将随之而变化，一盏交通信号灯可以指挥多辆汽车。
- 2、在当前流行的MVC架构中也应用了观察者模式，它包含三个角色：模型(Model)，视图(View)和控制器(Controller)。
其中模型可对应于观察者模式中的观察目标，而视图对应于观察者，控制器可充当两者之间的中介者。
当模型层的数据发生改变时，视图层将自动改变其显示内容。

##### 观察目标
Observer Pattern中，发生改变的对象称为观察目标。
##### 观察者
而被通知的对象称为观察者。
1、一个观察目标可以对应多个观察者。
2、这些观察者之间可以没有任何相互联系。
3、可以根据需要增加和删除观察者，使得系统更易于扩展。


##### Observer Pattern优点
- 1、观察者模式可以实现表示层和数据逻辑层的分离，定义了稳定的消息更新传递机制，并抽象了更新接口，使得可以有各种各样不同的表示层充当具体观察者角色。
- 2、观察者模式在观察目标和观察者之间建立一个抽象的耦合。观察目标只需要维持一个抽象观察者的集合，无须了解其具体观察者。
- 3、观察者模式支持广播通信，观察目标会向所有已注册的观察者对象发送通知，简化了一对多系统设计的难度。
- 4、观察者模式满足“开闭原则”的要求，增加新的具体观察者无须修改原有系统代码，而且观察目标和观察者没有紧密地耦合在一起，因此它们可以属于不同的抽象化层次。在具体观察者与观察目标之间不存在关联关系的情况下，增加新的观察目标也很方便。

##### Observer Pattern缺点：
- 1、若一个观察目标对象有很多直接和间接观察者，将所有的观察者都通知到会耗时过多。
- 2、若观察者和观察目标之间存在循环依赖，观察目标会触发它们之间进行循环调用，可能导致系统崩溃。
- 3、Observer Pattern没有相应的机制让观察者知道所观察的目标对象是怎么发生变化的，而仅仅只是知道观察目标发生了变化。


##### Observer Pattern应用场景
- 1、邮件订阅和RSS订阅，当我们浏览一些博客或wiki时，当你订阅了该文章，如果后续有更新，会及时通知你。

##### demo:


```
/**
 * 观察者抽象类，定义共同的行为
 */
public interface Observer
{
  public void update();
}
```

```
/***
 * 具体的观察者 1
 */
public class Observer1 implements  Observer
{
	@Override
	public void update()
	{
		System.out.println("观察者 1收到通知");
	}
}//
```


```
/***
 * 具体的观察者 2
 */
public class Observer2 implements  Observer
{
	@Override
	public void update()
	{
		System.out.println("观察者 2收到通知");
	}
}//
```


```
/**
 * 被观察者接口。
 * 定义一些 方法用来管理 观察者集合。
 */
public interface Subject
{
	/**添加观察者*/
	public void addObserver(Observer observer) ;
	/**删除观察者*/
	public void delObserver(Observer observer) ;
	/**通知观察者*/
	public void notifyAllObservers();
}//
```



```
/***
 * 具体的 被观察者 （观察目标）。
 */
public class MySubject implements Subject
{
	/**线程安全的集合*/
	private Vector<Observer> myObservers ;

	/**构造函数*/
	public MySubject ()
	{
		myObservers = new Vector<Observer>();
	}

	@Override
	public void addObserver(Observer observer)
	{
		myObservers.add(observer) ;
	}

	@Override
	public void delObserver(Observer observer)
	{
		myObservers.remove(observer) ;
	}

	@Override
	public void notifyAllObservers()
	{
		//使用迭代器获取所有观察者 并通知
		Iterator<Observer> iterator = myObservers.iterator() ;
		while (iterator.hasNext())
		{
			Observer observer =  iterator.next();
			observer.update();
		}//
	}//
}
```


```
/**实际场景应用*/
public static void main(String[] args)
{
  Observer1 ob1 = new Observer1() ;
  Observer2 ob2 = new Observer2() ;
  MySubject mySubject = new MySubject() ;
  mySubject.addObserver(ob1);
  mySubject.addObserver(ob2);
  mySubject.notifyAllObservers() ;
}//
```
