{"./":{"url":"./","title":"首页","keywords":"","body":"﻿本博客不保证完整性和正确性,请自行甄别。 左上角的 搜索功能 进行关键字搜索。 托管地址 https://gitee.com/hnyer/androidDev 博客链接 http://hnyer.gitee.io/androidDev http://hnyer.gitee.io/nativeDev //cpp jni https://blog.csdn.net/dengpanwen //CSDN https://hnyer.gitee.io //红尘之声 因为博客页数太多会导致编译时间较长，我不太喜欢。所以采用面试技术点的方式展示，善用左上角的搜索功能即可。 Java基础 [x] Java 内存模型、内存结构、Java的内存分区 [ ] jvm 结构 [ ] jvm 垃圾回收机制、老年代有什么算法？ [ ] 方法区有什么东西 [ ] JVM 类加载机制了解吗，类什么时候会被加载？类加载的过程具体生命周期是怎样的？ [ ] 拉圾回收的 GCRoot 是什么？ [ ] 讲下 equals 和 hashcode ，他们为何必须一起重写 [ ] 成员变量和局部变量的区别。为何成员变量需要jvm在对象初始话过程中赋默认值？ [ ] GCRoot，举例说明。比如说Activity和它的匿名内部类Handler，分析下引用链，对应的gcroot是哪个？ [ ] class文件的组成？常量池里面有什么内容？ [ ] 编译期注解处理的是字节码还是java文件 [ ] 字节码注入 [ ] java和 字节码 有什么区别？ [ ] 自动装箱发生在什么时候？编译期还是运行期 [ ] 内部类访问外部类 [ ] java有什么特性，继承有什么用处，多态有什么用处 [ ] 对象加载的过程，属性先加载还是方法先加载 [x] 讲下Java的 双亲委派 [ ] 说说你对类加载机制的了解？ DexClassLoader与PathClassLoader的区别 [x] java 里带$的函数 是什么意思 [x] 硬件加速 是什么原理 [x] 进程优先级 [ ] 反射 是什么，在哪里用到，怎么利用反射创建一个对象 [ ] 反射可以反射final修饰的字段吗？ [ ] 静态方法，静态对象为什么不能继承 [ ] 单例的DCL方式下，那个单例的私有变量要不要加volatile关键字，这个关键字有什么用 [x] JMM 可见性 、原子性 、有序性 、synchronized 可以保证什么 [x] 重入锁 ReentrantLock 、synchronized 和 读写锁 ReadWriteLock 的区别 [x] Lock 接口 的实现，以及与 synchronized 的区别 [ ] 平常有用到什么锁，锁之间的区别 ,synchronized 底层原理是什么 [x] synchronized 是公平锁还是非公平锁 , ReteranLock 是公平锁吗？ 是怎么实现的 [x] synchronized 跟 ReentranLock 有什么区别？ 发生异常的场景 [ ] 双锁单例，为什么要价 volatile [ ] synchronized 和 volatile 的区别？为何不用 volatile 替代 synchronized？ [ ] 说说你对 volatile 字段有什么用途？ [ ] Synchronize 关键字后面跟类或者对象有什么不同 [x] 类锁和对象锁互斥么 [x] CAS 原理 [ ] AQS 了解吗 [ ] gcroot 的类型 [x] 泛型是什么、泛型有什么优点 [x] 泛型通配符 [x] 泛型擦除 是什么，为何会有擦除 、擦除的时机 [ ] 泛型是怎么解析的，比如在 retrofit 中的泛型是怎么解析的 [x] 泛型 为何会有 协变 和 逆变，PECS 规则 [x] string 比较 equals 和 == 有什么区别 [x] 函数式编程 如何理解 [ ] 说说你对 注解 的了解，是怎么解析的 [ ] 编译时注解与运行时注解，为什么retrofit要使用运行时注解？什么时候用运行时注解？ android 基础 [ ] Activity与AppCompactActivity区别，Activity会打包到包里面去吗？ [x] Android APP的 入口函数 在哪里 [x] activity 启动模式 [x] Activity 生命周期有哪些，知道 onRestart 么； A启动B ，A的 onStop 一定会执行吗；按 Home 按键后的生命周期 [x] activity 启动另外一个activity的时候横屏切换再点击返回，过程中发生的生命周期 [x] Fragment#onHiddenChanged 是生命周期方法么？如何触发？ [ ] Fragment hide show生命周期变化 [ ] Fragment replace生命周期变化 [ ] ViewPager切换Fragment什么最耗时？ [ ] Fragment hide show生命周期 [ ] Activity和Fragment的通信方式；系统为何会设计Fragment#setArgument方法。 [x] Service的生命周期，两种启动方法，有什么区别 [x] 有什么工具可以看到 Activity栈信息么？多个栈话，有方法分别得到各个栈的Activity列表么 [x] ANR 是怎么回事？怎么查？Service会引起 ANR 么 [x] 为什么 Activity.finish() 之后 10s 才 onDestroy [x] SQLite 的数据库升级 [ ] AMS交互调用生命周期是顺序的吗 [x] SharedPreference 原理 ，读取xml是在哪个线程 [x] SharedPreferences 的 apply 和 commit 有什么区别 [ ] ContentProvider具体实现。 [ ] binderService方法中的回调具体运行在哪个线程？binder线程池最大线程数是多少？自定义的Callback远程调用，运行在哪个线程？为何不是主线程，如果运行在主线程会有哪些问题？ [ ] jetpack组件库使用过么？讲下具体组件 [ ] t1、t2、t3三个线程，如何让三个线程按照顺序依次打印1-100。 [ ] 悬浮窗如何实现 [ ] 通知的类别 [ ] ANR的log中关键字是什么 [ ] Activity的onSaveInstance方法何时调用？它跟onPause、onStop的调用顺序如何？ [ ] 讲下 leakCanary 原理，为什么不用虚引用？引用队列里面存的是什么？ [ ] 方法内部的匿名内部类，比如说给View设置的OnClickListener，它里面相关调用外部方法的形参，必须使用final修饰这个形参，为何？ [ ] Android里面进程间通信方式，ContentProvider可以用file实现么？ [ ] Activity启动模式，以及各启动模式生命周期问题 [x] Activity怎么启动 Service 、Activity 与 Service 交互，Service 与 Thread 的区别 [x] ANR 了解过吗？有没有实际的ANR定位问题的经历 [ ] mainfest中配置LargeHeap，真的能分配到大内存吗？ [ ] 生命周期都是通过什么调用的？有用过AIDL吗？ [ ] AIDL in out oneWay 代表什么意思 [ ] put post有什么区别 [ ] 本地广播为何效率高？ [ ] 广播与RxBus的区别，全局广播与局部广播区别 [ ] Rxjava是怎么实现线程切换的 [ ] Rxjava自定义操作符 [ ] RXJava 怎么切换线程 [ ] ARouter的原理 [ ] ARouter怎么实现接口调用 [ ] ARouter怎么实现页面拦截 [ ] 同步屏障 [ ] 有用DSL,anko写过布局吗？ [ ] 如何封装一个字符串转数字的工具类 [ ] 多进程 怎么实现？如果启动一个多进程APP，会有几个进程运行？ [ ] 怎么中止一个线程，Thread.Interupt一定有效吗？ [ ] bugly日志收集的原理是什么？ [ ] 做过一些SDK的操作吗？ [ ] 为什么会有R文件这个映射表？直接使用资源的路径不好么？ [ ] dex文件结构了解过么？为何会有65535的限制？mutildex技术了解么？这项技术的目的是什么？ [ ] ThreadLocal，LocalBroadcastReceiver实现 [ ] Android 中Activity、Window、ViewRoot、DecorView之间的联系 [ ] Seriazable与Parceable的区别 [ ] Bundle是什么数据结构?利用什么传递数据 [ ] 两个getDrawable取得的对象，有什么区别？ [ ] savedInstanceState知道么，干什么用的，什么时候有值，什么时候为空，平时是怎么用的 [ ] ragment的replace和end？？的区别 [ ] Scroller有什么方法，怎么使用的 [ ] 想改变listview的高度，怎么做 [ ] canvas lock的缓冲区是怎么回事 Android 动画 [x] 介绍一下 Android 动画 [ ] 补间动画与属性动画的区别，哪个效率更高 [ ] 动画里面用到了什么设计模式 [ ] 属性动画更新时会回调 onDraw 吗 [ ] 动画连续调用 的原理是什么 网络相关 [x] TCP和UDP区别，TCP为何是三次握手，为何是四次挥手 [x] MediaPlayer 能同时播放多个音频么？ 如果需要播放多个提示音，如何实现 [ ] SharedPreferences 可以跨进程通信吗？如何改造成可以跨进程通信的.commit和apply的区别. [ ] 如何在网络框架里直接避免内存泄漏，不需要在presenter中释放订阅 [ ] hdpi和xxhdpi的手机，分别加载xhdpi下的图片，会缩放图片么？如果会缩放，是如何缩放的，像素点是如何补全或者减少的？图片在内存中的大小会如何变化？ [ ] http 与 https 有什么区别 。https 多了tls层。对称加密和非对称加密。 [ ] http1.0 、http1.1 、http1.2 、 HTTP3.0 有什么区别 [ ] OkHttp 里面用到了什么设计模式？ [ ] OkHttp连接池是怎么实现的？里面怎么处理SSL？ [ ] OkHttp网络拦截器，应用拦截器 ? OKHttp有哪些拦截器，分别起什么作用 [ ] OkHttp怎么实现连接池 [ ] 网络封装怎么实现？ [ ] 如何上传数据？请求头关键字段和请求体格式 [ ] 实现一个下载功能的接口 [x] 平常抓包用什么工具 [x] 在项目中有直接使用tcp 、socket 来发送消息吗 线程 、进程 、跨平台 [x] 多线程如何实现 ,有哪些方式 、四种线程池原理 ,线程池的类型 [x] 线程池如何配置，核心线程数你一般给多少 、线程池的参数 ,最大线程数和核心线程数的关系 [x] 线程池 task 的优先级如何实现？（优先级队列） [x] 线程池 拒绝策略有几种 [x] 如何禁止 手动创建线程 。使用 自定义 lint [x] 阿里编程规范 不建议使用 Executors 来创建线程池，为什么 [ ] IdleHandler 调用时机 [ ] IdleHandler用过吗 ？IdleHandler 应用场景 [ ] Handler休眠是怎样的？epoll的原理是什么？如何实现延时消息，如果移除一个延时消息会解除休眠吗？ [ ] Handler内存泄漏 的GCRoot是什么？ [ ] 说说你对Handler机制的了解，同步消息，异步消息等 [ ] Handler机制了解吗？一个线程有几个Looper？为什么？ [ ] 简单描述下Handler,Handler是怎么切换线程的,Handler同步屏障 [ ] Launcher启动App的流程，中间有几种跨进程通信(socket) [ ] 描述一次跨进程通讯 [ ] 跨进程通信了解多少？管道了解吗？ [ ] 线程间同步的方法 [ ] 你们用的什么消息通信机制 [ ] 说说 binder 机制的原理 [ ] binder 的 mmap [ ] android跨进程通信了解吗？共享内存用过吗？binder怎么验证pid?binder驱动了解吗？ [ ] binder进程间通信可以调用原进程方法吗？ [ ] Handler 通信，Binder通信 html5 [ ] .h5 与 native 交互做过什么工作 [ ] 项目中的 Webview 与 native 通信 [ ] h5 与 native 交互，webView.loadUrl 与 webView.evaluateUrl 区别 [ ] 项目中对 WebView 的功能进行了怎样的增强 [ ] native 如何对 h5 进行鉴权，让某些页面可以调，某些页面不能调 [ ] @JavaScriptInterface为什么不通过多个方法来实现 [ ] 为什么不利用同步方法来做 jsBridge交互？ 同步可以做异步，异步不能做同步 [ ] jsBridge 实现方式 [ ] PathClassLoader与DexClassLoader有什么区别 [ ] CoordinatorLayout自定义behavior,可以拦截什么？ [ ] 视频播放,一个player怎么实现预加载，避免loading [ ] webView加载本地图片，如何从安全方面考虑 [ ] webwiew了解？怎么实现和javascript的通信？相互双方的通信。@JavascriptInterface在？版本有bug，除了这个还有其他调用android方法的方案吗 [ ] retrofit怎么做post请求 启动流程 、加载流程 [ ] 从桌面点击icon图标开始，整个启动activity的启动过程 [ ] ContentProvider启动流程 [ ] Application 启动流程 [ ] Application 中持有 静态的信息，有何缺点 ？如何改进 [x] Application 中可以显示Dialog么 ？为什么？ [x] 使用 ActivityLifecycleCallbacks 做了哪些事情？ [ ] etPack组件用过哪些？lifeCycle 的原理是什么？如果在onStart里面订阅，会回调onCreate吗？ [ ] LifeCycle的原理是怎样的？ [ ] Parcelable和Serializable本质区别，不要说用法，说原理。 [ ] ViewRootImpl 创建的时机？ [ ] PhoneWindow 是在哪里初始化的 [ ] DecorView 的布局是什么样的 [ ] DecorView 的创建时机？ [ ] setContentView 的流程 [ ] LayoutInflate 的流程 [ ] Activity、PhoneWindow、DecorView、ViewRootImpl 的关系？ [ ] activity，Window，view 的关系 [ ] activity 有几个 Window [ ] Activity#setContentView中的xml文件是如何转化成View并显示到Activity中的。 [ ] Window 和 Activity 的对应关系。除了Activity还有别的方式显示 Window 出来么？ [ ] LayoutInflater是如何把xml布局文件转换成View对象的（反射）？View树如何生成的？怎么优化？ [ ] RecyclerView的缓存结构是怎样的？缓存的是什么？cachedView会执行onBindView吗? [ ] RecyclerView嵌套RecyclerView，NestScrollView嵌套ScrollView滑动冲突 [ ] 讲一下 RecyclerView 的缓存机制,滑动10个，再滑回去，会有几个执行onBindView [ ] 如何实现RecyclerView的局部更新，用过payload吗,notifyItemChange方法中的参数？ [ ] RecyclerView 防止内存OOM的一道题，充分利用自身的缓存机制 [ ] RecyclerView 和 ListView 区别、特点、缓存 、懒加载、局部刷新 ,多种type场景下怎么避免滑动卡顿 ,怎么优化滑动 [ ] RecyclerView 缓存结构，RecyclerView预取，RecyclerView局部刷新 [ ] Launcher启动图标，有几个进程？ [ ] 源码中有哪里用到了AtomicInt [ ] 有看过哪些框架的源码吗？ [ ] Activity内LinearLayout红色wrap_content,包含View绿色wrap_content,求界面颜色 [ ] viewpager切换掉帧有什么处理经验？ [ ] ViewPager2原理 [ ] 说说App的启动过程,在ActivityThread的main方法里面做了什么事，什么时候启动第一个Activity？ [ ] 如何求当前Activity View的深度 [ ] setFactory和setFactory2有什么区别？ [ ] 如何自定义实现一个FlexLayout [ ] A Activity打开B Activity的生命周期变化，会有什么方法打断吗？ [ ] 登陆功能，登陆成功然后跳转到一个新Activity，中间涉及什么？从事件传递，网络请求,AMS交互角度分析 事件分发 UI绘制 [x] View 绘制流程 [x] onMeasure 、onLayout 、onDraw关系 [x] 自定义 View 的几种方式。onMeasure、onLayout、onDraw 方法都何时需要重写 [x] MeasureSpec 讲一下 [x] 讲下 onMeasure方法 , 如何测量 ，测量模式 ，入参为什么是int类型 [x] 怎么获取view的宽高，如何确定值是准确的 ,有遇到是0的情况吗 [x] 为什么 view.post 可以获得宽高，有看过view.post的源码吗 [x] 自定义 LinearLayout ，怎么测量子 View宽高 [x] onCreate 、onResume 、onStart里面，什么地方可以获得宽高 [x] 如何触发重新绘制 [ ] 首次 View 的绘制流程是在什么时候触发的 [x] invalidate 每次都会触发 onDraw 么？invalidate 每次会触发 View#onLayout 么？ [ ] 为什么会多次调用 onMeasure 和 onLayout 方法 [ ] ACTION_CANCEL 什么时候触发，触摸button然后滑动到外部抬起会触发点击事件吗，在+ + 滑动回去抬起会么 [ ] 获取TextView的行数时，StaticLayout原理 [ ] MotionEvent#offsetLocation事件转发。 [ ] 绘制的数据是如何提交到远端的SurfaceFlinger [ ] requestLayout 和 invalidate 的流程 [ ] requestLayout 和 invalidate 的区别 [ ] requestLayout调用后，都会调用哪些方法？ [ ] 滑动冲突如何解决？有几种方式？具体从哪个事件开始拦截？在哪里拦截？比如双层ViewPager嵌套的滑动冲突如何解决。 [ ] 讲下事件传递 ，总体流程，DOWN事件拦截后，后续事件如何处理？，dispatchTouchEvent方法返回true后事件如何处理？ [ ] setOnTouchListener,onClickeListener 和 onTouchEvent 的关系 [ ] dispatchTouchEvent , onInterceptEvent , onTouchEvent 顺序，关系 [ ] 说说 事件分发机制，怎么写一个不能滑动的ViewPager [ ] RecyclerView是怎么处理内部ViewClick冲突的 [ ] 手势操作 ActionCancel 后怎么取消 [ ] 伪代码实现一个长按事件 [ ] 说说你对屏幕刷新机制的了解，双重缓冲，三重缓冲，黄油模型 [ ] attachToWindow什么时候调用？ [ ] ViewGroup在Action_Move时onIntercept返回true，事件怎么传递 [ ] ViewPager中嵌套ViewPager怎么处理滑动冲突 [ ] 怎么处理嵌套View的滑动冲突问题 [ ] View的分发机制，滑动冲突 [ ] 如果onInterceptTouchEvent返回true，但是onTouchEvent返回了false，是什么效果？如果还想让其他View接收事件，该怎么做？ 自定义控件 [ ]自定义圆角图片 [ ] 自定义实现一个九宫格如何实现 插件化 热修复 组件化 [ ] 说说插件化的原理，资源的插件化id重复如何解决？ [ ] 插件化 的原理是怎样的？ [ ] 插件化的原理是什么？有没有什么非运行时插件化的解决方案？ [ ] 插件化换肤方案 [ ] 插件化的原理，startActivity hook了哪个方法 [ ] 插件化的主要优点和缺点是什么？ [ ] 插件化的原理，以及hook点，大概有两个 [ ] 组件化有详细了解过吗？ARouter详细原理 [ ] 说说热修复的原理？ [ ] 热修复的原理，资源的热修复的原理,会不会有资源冲突的问题 [ ] tinker的原理是什么,还用过什么热修复框架，robust的原理是什么？ [ ] 热修复，主要说了ClassLoader的方式和Rubost的插装方式，重点介绍了Rubost的原理。 [ ] 组件化的实现方案 [x] 多模块开发，不同的人可能会引入重复资源。相同的字符串，相同的icon等但是文件名并不一样，怎样去重 [ ] ARouter 路由原理？注解处理器是处理java还是字节码 [ ] ARouter的原理是怎样的？ [ ] ARouter的原理是什么？如果不用ARouter，你会怎么去解藕。接口？设计接口有什么需要注意的？ [ ] Drawable与View有什么区别,Drawable有哪些子类 kotlin [ ] kotlin空安全的原理是什么？ [ ] kotlinc与javac编译字节码有什么区别？ [ ] kotlin lazy使用,lazy viewmodel [ ] kotlin 与Java互相调用有什么问题？ [ ] kotlin ?的原理 [x] 说说你对 协程 的理解， 可以完全取代 rxjava 吗 , 协程 可以在Java项目中使用吗 [x] 协程 怎么取消 [ ] 讲一个 协程 的 scope 与 context，协程的+号 代表什么 算法 [ ] 了解哪些算法 [ ] 删除数组中的重复元素 [ ] 反转数组 [ ] 一个大致有序的数组如何排序，最快时间复杂度 [ ] 手写双检查单例模式，各个步骤有什么区别 [ ] 斐波那契台阶 [ ] 手写生产者消息者模型 [ ] 如何让两个线程循环交替打印 [ ] 不同面值的几个硬币，怎么求满足条件的最小值 [ ] K个一组反转链表 [ ] 二叉树最长结点集合 [ ] 二叉树的最大深度 [ ] 二叉树的每一层最左边节点 [ ] 链表求和 [ ] 有用过什么加密算法？AES,RAS什么原理？ [x] 非对称加密 、对称加密 [ ] token放在本地如何保存？ 如何加密比较好 [ ] HashMap 讲一下，数据结构、hash过程、扩容、加载因子为何是0.75等。 [ ] hashmap。hash冲突时给链表插入数据，1.7头插法，1.8尾插法。 [ ] SparseArray 和 ArrayMap 各自的数据结构，前者的查找是怎么实现的，与HashMap的区别 [ ] 说说HashMap的原理 HashMap查找的时间复杂度是多少？ [ ] 讲下arraylist、hashmap、linkedlist、linkedhashmap的实现。linkedhashmap为何会有这样的特性(lru)?它有个参数，表示命中率和使用次数。 [ ] lru是通过linkedhashmap实现的么？ [ ] 讲讲LinkedHashMap的数据结构 [ ] ArrayMap和SparseArray的区别，实现。 优化 、稳定性 、技术选型 [ ] 图片加载优化有什么经验吗 [ ] WebView 性能优化做过什么工作 [ ] 使用 Application#onTrimMemory 优化 [ ] 启动优化做过什么工作？ 如果首页就要用到的初始化 [ ] 有没有做过什么 WebView 秒开的一些优化 [ ] 界面优化的一些方法，ConstraintLayout实现三等分,ConstraintLayout动画 [ ] 包体积的极致优化 [ ] 你做过什么 性能优化 的工作 [ ] 性能优化做过什么工作? 有用过什么工具？有没有精确测量的工具？ [ ] 有什么实际解决UI卡顿优化的经历 [ ] 有做过什么Bitmap优化的实际经验 [ ] Apk的大小如何压缩 [ ] 看视频的时候网络请求很慢怎么优化？ [x] 如何提高线上代码质量 [ ] 自定义 lint [x] App上线后 用户使用时卡顿 ，怎么查看是什么原因 [x] 界面卡顿怎么排查和优化 ，何监测应用的 FPS [ ] 网络优化 ，数据库优化 [ ] view的优化，减少层级，异步加载，x2c框架引入，优缺点，textview的优化。 [ ] 怎么优化xml inflate的时间，涉及IO与反射。了解compose吗？ [ ] 讲下你做过的 首页优化 [ ] 你们项目的稳定性如何？有做过什么稳定性优化的工作？ [x] 如何进行单元测试，如何保证App稳定 [x] 代码质量如何控制 [x] 技术选型是如何做 ，为什么这么考虑？从开发效率，产品性能，产品质量，产品体验等方面考虑 [ ] 你们网络框架用的什么？为什么？ [ ] 如果 Android 和 iOS 调一个接口，一个通了一个没通(或者响应速度一个块一个慢)，你会如何解决 [ ] 说一说Android中如何查看一个对象的回收情况 ？ [x] 冷启动、热启动 优化方案 [ ] 有什么提高编译速度的方法 内存泄漏 、图片 、图片加载 [ ] drawable下所以的格式都能转成 webp么 ？哪些不能转 [ ] 图片内存的计算 [ ] Bitmap高效加载 、Bitmap内存复用 [ ] 大图加载优化，原理。 [ ] 你碰到过什么 内存泄漏 ，怎么处理 [ ] AsyncTask内存泄露 [ ] 图片的三级缓存中,图片加载到内存中,如果内存快爆了,会发生什么 ？怎么处理 [ ] xhdpi的图片放到xxhdp的手机上，内存会如何变化； [ ] 在不影响图片质量的前提下，如何减少内存 [ ] 图片显示不全、变形怎么处理 [ ] glide 默认 Bitmap 的 Config 配置是 ARGB_8888 么 [ ] Glide的缓存，有用过Glide的什么深入的API，自定义model是在Glide的什么阶段 [ ] 一个 wrap_content 的 ImageView ，加载远程图片，传什么参数裁剪比较好? 打包发布 [ ] 项目搭建过程中有什么经验,有用到什么gradle脚本，分包有做什么操作 [x] 如何通过 Gradle 配置多渠道包 [ ] 了解APK打包的过程吗？ 适配 [x] 屏幕适配方案；头条适配方案核心原理。 [x] 屏幕适配做过什么工作 [ ] Android11 有没有适配 设计能力 [ ] 如果让你来实现一个网络框架，你会考虑什么 [ ] 设计一个上传日志的大小，涉及到，性能、文件大小、怎样压缩、时机、TopK问题等 [ ] 如果产品要求你开发一个音频播放功能，你会怎么着手？预计会有什么坑？ [ ] 你觉得 XX 目前的APP有什么问题？ [ ] 如果叫你实现，你会怎样实现一个多主题的效果 [ ] 你如何自己实现一个LRUCache？Android里面的LRUCache是如何实现的 设计模式 [ ] 你在项目中有用到什么设计模式吗 [ ] 单例模式有什么缺点 [ ] 动态代理 的实现 ， 动态代理有什么作用 [ ] 代理模式与装饰模式的区别，手写一个静态代理，一个动态代理 [ ] 单例的几种实现方式：DCL、enum，静态内部类。还有饿汉式。懒汉式的使用场景：占用内存大、延迟初始化 [x] Android中常用的设计模式，说三个比较高级的 [ ] android源码中有哪些设计模式 [x] MVC 、MVP 、MVVM 理解 [ ] 讲讲 MVC 、MVP ，presenter 内存泄漏的问题 [ ] MVP 怎么处理内存泄漏 [x] MVVM 双向数据绑定的原理是怎样的 [x] MVVM 怎么更新UI, databinding 用得多吗, databinding的原理 [ ] viewModel的原理，为什么可以在Activity销毁后保存数据 [ ] viewModel 是怎么实现双向数据绑定的 [ ] viewModel 怎么实现自动处理生命周期 [ ] ViewModel 为什么在旋转屏幕后不会丢失状态 [ ] ViewModel 的使用中有什么坑 [ ] 有没有看一下Google官方的 ViewModel demo [ ] ViewModel 在 Activity 初始化与在 Fragment中初始化，有什么区别 [x] 如果用了一些解耦的策略，怎么管理生命周期的 其他问题 [ ] 介绍一下你们项目的架构 [ ] 介绍一下你自已和项目 ，项目有什么难点 [ ] 你们的项目中做过什么比较难的工作 [ ] 这些年有做一些什么比较难的工作 [ ] 说说为什么考虑离职 ,为什么考虑换工作 ，说说对你们原来公司的印象 [ ] 为什么考虑换一份工作 ，在你们公司这几年感觉怎么样 [ ] 你在团队中是怎样一个角色 ，有没有做什么推进项目的工作 [ ] 你们的产品为什么被砍掉，从哪方面考虑 [ ] 在这几年里，你有做过什么觉得最有价值的工作 [ ] 平常是怎么了解一些新知识与业界动态的，最近有什么印象深刻的文章 [ ] 你还有什么要问我的吗？目前有几个offer，倾向性是怎样的 无版权 可以无限制使用！ all right reserved，powered by Gitbook该文件更新时间： 2021-01-12 09:41:42 "},"chinese/doc/常用网站.html":{"url":"chinese/doc/常用网站.html","title":"常用网站","keywords":"","body":"android 相关 android官方英文版 android官方中文版 民间组织-安卓中文组 android developer Java8 官方文档 谷歌开发者社区 lantern 蓝灯 翻墙 maven 仓库 maven、central、gradle-plugin 阿里云镜像 在线工具 bmob 后端云 fir app 托管 UEditor 百度 UEditor 富文本 githubd github 代下载 git标签生成工具 shields.io 在线流程图工具 ProcessOn 代码高亮工具 tool oschina GLSL在线编辑 json格式化工具 正则表达式测试 Rar暴力破解 文本差异比较 在线图片压缩 音频、视频、图片测试文件下载 文字对比 抖音视屏去水印 二维码在线解析 草料二维码 汉字手写输入 小白 网盘搜索 数学公式 \\frac{ h_{x} } { H_{当前设备高度} } = \\frac{600} {1920_{设计稿高度}} 查询相关 国家企业信用信息公示系统 中国版权保护中心 行政区划分 磁力搜索 诗词文学地图 鸠摩搜书 阿里云盘 网盘 window 软件 福昕pdf 在阿里云盘 Everything 电脑全局搜索 Snipaste 截图、贴图 ConEmu 比cmd好用的命令行工具 cports 端口查看工具 EVCapture录屏工具 AdvancedRenamer文件名批量相关 Koodo pc epub 阅读器 博客、网站 可可英语 v2ex wanandroid 干货集中营 王垠的博客 wanandroid 代码家的博客 掘金网 伯乐在线 猎云网 太平洋手机 人人都是产品经理 pmcaff python3基础语法 廖雪峰python3基础教程 崔庆才-静觅python博客 大鱼python博客 文档模板 mydocuments 项目代码 在线简历 代码块Share 无人车APP WalkeraDrone1100 WK420_6K Version2017All-ReadOnly 农服App AppsUrl 航线规划Demo 微信点赞助手 史海沉钩阅读器 天气APP 俄罗斯方块 android_ftp_server android_http_server SmartHomeApp 智能家居APP万物互联 简易博客前端 简易博客后台 基于 springBoot 的 api服务器 服务器demo BusinessExternal xiaoyi DataShareDev hexo 红尘之声 第一个小程序 无版权 可以无限制使用！ all right reserved，powered by Gitbook该文件更新时间： 2021-01-08 14:04:51 "},"chinese/常用软件/常用软件和框架.html":{"url":"chinese/常用软件/常用软件和框架.html","title":"常用软件和框架","keywords":"","body":"androidstudio androidstudio官网 Androidstudio 模板 ctrl + J 快速查看Live Templates 打开 *设置 -> Editor -> Live Templates* ，可以看到默认已经有很多 *Live Templates* 了 ，可以自己自定义。 导入原有的模板： 将文件替换即可 （C:\\Users\\kaifa4k\\.AndroidStudio2.2 是你自己的安装路径） C:\\Users\\kaifa4k\\.AndroidStudio2.2\\config\\templates 我用的模板 androidstudio 插件 安装或更新后插件后都需要重启Androidstudio 。 CodeGlance 代码快速定位 插件 Android-Resource-Usage-Count 显示 Android 资源使用的次数。 翻译插件ECTranslation 原理是调用了有道词典的API 。可以自定义 快捷方式，我目前设置的是 alt + m 快捷键设置 Preferences -> Keymap -> 搜索Translate - > 右键 add Keyboard Shortcut. 输入你想要的快捷键。 Android Parcelable code generator 自动生成 Parcelable接口相关的代码。 public class FtpThumDownListInfo implements Parcelable{ /**当前这个指针 指向的文件需要下载*/ private int gotoDownFileIndex = 0; /**需要下载的文件列表- 这个列表会分批次增加 */ private List ftpNeddLoadList =null ; /**下载好的文件的byte[]*/ private List ftpDowndBytesList =null ; //以下代码是 用插件自动生成的 start protected FtpThumDownListInfo(Parcel in){ this.gotoDownFileIndex = in.readInt(); this.ftpNeddLoadList = new ArrayList(); in.readList(this.ftpNeddLoadList, FTPFile.class.getClassLoader()); this.ftpDowndBytesList = new ArrayList(); in.readList(this.ftpDowndBytesList, FTPFile.class.getClassLoader()); } /** * 内容接口描述，默认返回0就可以了 */ @Override public int describeContents(){ return 0; } @Override public void writeToParcel(Parcel dest, int flags){ dest.writeInt(this.gotoDownFileIndex); dest.writeList(this.ftpNeddLoadList); dest.writeList(this.ftpDowndBytesList); } /** 实例化静态内部对象 * 接口对象名必须为CREATOR. * 必须按成员变量声明的顺序读取数据 */ public static final Parcelable.Creator CREATOR = new Parcelable.Creator() { @Override public FtpThumDownListInfo createFromParcel(Parcel source) { return new FtpThumDownListInfo(source); } @Override public FtpThumDownListInfo[] newArray(int size) { return new FtpThumDownListInfo[size]; } }; // 以下代码是 用插件自动生成的 end } //赋值 Bundle mBundle = new Bundle(); mBundle.putParcelable(\"picBean\",picBean); intentToMatch.putExtras(mBundle); //获取： RecommendPicBean picBean = (RecommendPicBean)getIntent().getParcelableExtra(\"picBean\"); 无线调试 ADB WIFI 华为M2 ，无Root 1、 确保电脑和手机在同一个局域网 2、插上USB线 连上adb 3、adb tcpip 5555 ( 5555为端口号，可自由指定） 4、adb connect 192.168.x.x:5555 // 如果是想同时连接多个设备 > adb devices // 找到设备号 adb -s 设备号 指令 // 使用 -s 参数指定设备号 EventBus、 缺点： 不容易跟踪调试代码。逻辑不是很连贯。 https://github.com/greenrobot/EventBus compile 'org.greenrobot:eventbus:3.1.1' // 绑定 @Override public void onStart() { super.onStart(); EventBus.getDefault().register(this); } // 解绑 @Override public void onStop() { super.onStop(); EventBus.getDefault().unregister(this); } // 发送 EventBus.getDefault().post(new MessageEvent()); // 接收 @Subscribe(threadMode = ThreadMode.MAIN) public void onEventBusMsgCome(WkEventBean bean) { switch (bean.getCode()){ case WkEventBean.CODE_1: String msg = (String) bean.getData() ; WkLog.d(\"UI received = \"+msg); break; default: break; } public class WkEventBean { public static final int CODE_1 = 1; public static final int CODE_2 = 2; public WkEventBean(int code , Object data){ this.code = code ; this.data =data ; } private int code ; private Object data ; public int getCode() { return code; } } git操作 配置全局信息 git config --global user.name \"aivin666@qq.com\" git config --global user.email \"aivin666@qq.com\" git config --list //查看当前用户信息 添加个人私钥到网站 这种情况下无需配置密码 - window10下测试 1、生成对应的文件 ssh-keygen -t rsa -C 'aivin666@qq.com' 2、将 id_rsa.pub 里面的内容填写到网站上。 3、测试是否成功 。 ssh -T git@gitee.com 配置密码方式 Ubuntu下测试 https模式，每次提交都需要输入密码。 1、在一个新目录 初始化 git init 2、将远程代码拉倒本地 git pull https://gitee.com/hnyer/java_android.git 3、关联远程端仓库 master 是远程端的一个支路。 git remote add master https://gitee.com/hnyer/java_android.git // git remote rm master , 删除关联 4、 将本地指定的版本推送到远程端指定的版本 的一个maser是远程的 ，第二个是本地的 git push -u master master 5、以后不用每次都用参数 u ,直接 git push 即可 Ubuntu下 SSH 配置 码云 1、进入 /home/用户名/.ssh 目录下 生成公钥 ssh-keygen -t rsa -C \"your_email@example.com\" 2、将 id_rsa.pub 文件中的内容填入码云网站中 。 3、即可正常拉取 、提交 gitbook windows 安装gitbook 安装gitbook过程中请优先连接VPN，如果没有请考虑更换淘宝源等方式。 安装过程 可以参考 https://segmentfault.com/a/1190000005859901 npm install gitbook -g npm install -g gitbook-cli gitbook -V gitbook常用的使用命令 gitbook install // 安装依赖包 gitbook init //新建定义好的文件 gitbook serve // 本地服务器测试 gitbook build // 编译成html格式 安装错误 如果遇到 “ Error: ENOENT: no such file or directory ... ” 这个错误 ， 把.gitbook\\versions\\3.2.2\\lib\\output\\website\\copyPluginAssets.js 修改成 confirm：false ！！！ gitbook 热更新 (Windows) https://github.com/GitbookIO/gitbook-cli/issues/67 暂时没找到优雅的办法。给出粗暴的方案，检测到奔溃后又重启。 将下面的命令做成一个 xx.bat ，通过这个文件启动即可。 @echo off :start call gitbook serve @goto start ps 常用快捷键： 移动工具 V 裁剪工具 C shift+ctrl+alt+s 保存切片 放大视图 Ctrl+【+】 缩小视图 【Ctrl】+【-】 切图： ctrl + alt + shift + a 制作圆角矩形图片 参考资料 图片渐变、透明度渐变 参考资料 PS里怎么样将白色背景去掉，变成透明的背景？ 参考资料 要先解压图层锁定 打开图片，单纯白色背景的话则只需使用工具栏中的魔棒工具在白色部位点一下，跟着delete键删除，此时就是透明的背景图片了，但关键的是要选择合适的保存方式。点文件-存储为web和设备所用格式，在弹窗选择附图红框处的PNG格式就可以了。 方法一:用擦除工具组中的魔棒擦除,点选白色 方法二: 1、用选择工具中的魔棒工具选白色(勾选连续的). 2、然后反选,复制 3、再粘贴成新层 4、册掉背景层 5、完 xUtils https://github.com/wyouflf/xUtils3 compile 'org.xutils:xutils:3.5.0' // 1、在Application 初始化 // import org.xutils.x; x.Ext.init(this); x.Ext.setDebug(false); // get请求 private void loadData( ) { String API = Ipconfig.KEY_WORKNEWS_DetailItem; API = API.replace(\"{pageSize}\" ,\"10\") ; RequestParams params = new RequestParams(API); Callback.Cancelable cancelable = x.http().get(params, new Callback.CommonCallback() { @Override public void onSuccess(String result) { } @Override public void onError(Throwable ex, boolean isOnCallback) { } @Override public void onCancelled(CancelledException cex) { } @Override public void onFinished() { } }); } // post 请求 private void requestHost(String name, String pwd1 ) { String API = Ipconfig.KEY_userRegister; RequestParams params = new RequestParams(API); params.addBodyParameter(\"userName\",name); params.addParameter(\"password\",pwd1); x.http().post(params, new Callback.CommonCallback() { public void onSuccess(String result) { } }); // 文件上传 String api =\"http://xxx\" ; RequestParams params = new RequestParams(api) ; params.setMultipart(true); params.addBodyParameter(\"userId\", MyApplication.getUserId(activity)); params.addBodyParameter(\"file\", new File( filePath)); Callback.Cancelable cancelable = x.http().post(params, new Callback.CommonCallback() { @Override public void onSuccess(String result) { } }); // 文件下载 RequestParams requestParams = new RequestParams(); requestParams.setSaveFilePath(filePath); requestParams.setUri(url);// 文件url x.http().get( requestParams, new Callback.ProgressCallback() { @Override public void onSuccess(File result) { } @Override public void onLoading(long total, long current, boolean isDownloading) { float percent = 100f* current / total ; } 虚拟机 VMware Workstation 12序列号 5A02H-AU243-TZJ49-GTC7K-3C61N RxJava 2.x 要在Android中使用RxJava2, 需要依赖 Rxjava2.x 、 RxAndroid 异步事件处理框架。 continued support for Java 6+ & Android 2.3+ 基于观察者设计模式。 RxJava1.x 跟 RxJava2.x 不能共存 ，会冲突。 RxJava组成元素 RxJava基本组成元素 说明 被观察者 数据源 发送数据 观察者 接收到（处理后的数据） 建立订阅关系 操作符 可以对数据进行过滤、转换等处理 线程切换 指定发送和接收的线程 RxJava 常用类 常用类 作用 Observable 被观察者 ObservableEmitter 用来发出事件的，它可以发出三种类型的事件 x.onNext() x.onComplete() x.onError() 发射规则如下： 1、上游可以发送无限个onNext ，下游也可以接收无限个onNext 2、当上游发送了一个onComplete后（只能发一次）, 上游onComplete之后的事件将会继续发送, 而下游收到onComplete事件之后将不再继续接收事件 3、当上游发送了一个onError后（只能发一次）, 上游onError之后的事件将继续发送, 而下游收到onError事件之后将不再继续接收事件 4、上游可以不发送onComplete或onError. 5、onComplete 和 onError 只能发送一个 , 不能都发送 ObservableOnSubscribe Observer 观察者 Disposable x.dispose() 切断订阅关系。 调用dispose()后 ，观察者接收不到数据，但是数据源还可以继续发送 CompositeDisposable Disposable 容器 x.add(...) x.clear() Flowable Rxjava2 新增的 。数据发送 。我们可以用Flowable + Subscriber 来解决 收发速度不一致问题 Subscriber 与Flowable搭配， 数据接收。 Subscription 切断订阅关系 Subscription.cancel() 观察者请求数据源发送多少个数据 subscription.request(Long.MAX_VALUE) FlowableEmitter 返回 观察者 能处理多少个数据 flowableEmitter.requested() Action BiConsumer BiFunction Predicate BiPredicate BooleanSupplier Cancellable Consumer Function Function3 Function4 Function5 Function6 Function7 Function8 Function9 IntFunction LongConsumer Schedulers 调度器。 当数据源和观察者在同一个线程时，这是一个同步的订阅关系 。 数据源每发送一个事件后必须等到观察者接收处理完了以后才能接着发送下一个。 当处于不同线程时 ,就是异步的订阅关系, 这个时候数据源可以自由发送数据。 //CPU计算密集型线程 默认线程数等于处理器的数量 Schedulers.computation() // 使用指定的Executor作为调度器 Schedulers.from() // io操作的线程 Schedulers.io() // 常规新线程 Schedulers.newThread() // Android主线程 AndroidSchedulers.mainThread() // 在当前线程执行 ，不过需要等队列中的其他任务完成后才执行 Schedulers.trampoline() BackpressureStrategy 背压策略 抗压力策略 背压是指在异步场景中，数据源发送事件速度远快于观察者的处理速度的情况下， 一种告诉 数据源 需要降低发送速度的策略 。 // 缓存区大小128，超过大小继续发就会报错 BackpressureStrategy.ERROR // 默认128，超过大小继续发就会 提示缓冲满了 BackpressureStrategy.MISSING // 默认大小128 ，大于128时就会修改为无限大。直到OOM BackpressureStrategy.BUFFER // 默认128 ，超过128后来的数据会被丢掉 BackpressureStrategy.DROP // 默认128 ，超过128就会只会保留最后的一个数据。 最后总个数 是 129 BackpressureStrategy.LATEST SingleEmitter 用来发射一条单一的数据，且一次订阅只能调用一次 singleEmitter.onSuccess() // onSuccess与onError只可调用一个 ，否则会报异常 singleEmitter.onError() Subject 主题 , 不支持背压控制 一种特殊的存在 ，同时是 数据接收者 和 发送者 AsyncSubject 无论输入多少参数，永远只输出最后一个参数 , 如果因为发生了错误而终止，AsyncSubject将不会发射任何数据 BehaviorSubject 会发送离订阅最近的上一个值，没有上一个值的时候会发送默认值。 如果遇到错误会直接中断 PublishSubject 一旦一个观察者订阅了该Subject，它会发送所有数据给订阅者。 如果接收者只关系自己订阅的信息 ，可以用ofType来过滤 订阅者只会接受订阅之后的来自PublishSubject发射的数据。 ReplaySubject 无论何时订阅，都会将所有历史订阅内容全部发出 Processor rxjava2.x新增的 ，作用与Subject一样 。 支持背压控制 AsyncProcessor BehaviorProcessor PublishProcessor ReplayProcessor Transformer 转换器 ， 实际上就是Func1， 换句话说就是提供给他一个Observable它会返回给你另一个Observable ObservableTransformer SingleTransformer CompletableTransformer FlowableTransformer MaybeTransformer RxJava2.0中的观察者模式 RxJava2.0中的观察者模式 说明 Observable / Observer 不支持背压，及无法处理发送数据速度不协调的问题。 Flowable/ Subscriber Single/ SingleObserver 只发射一条单一的数据，或者一条异常通知， 不能发射完成通知，其中数据与通知只能发射一个。 // 可以指定Schedulers实现异步处理 ，如果不被订阅是不会被调用的 Single.create // 接收传入的参数 ，是一种特殊的create() ，只会在当前线程里执行 , 不管是否被 订阅均会被调用 Single.just // 仅仅用来连接Single顺序执行的，比如顺序执行检查网络，检查内存 ，注意：如果某个Single调用了onError()会导致被中断 Single.concat // 将多个Single整合为一个 Single.zip // Observable.just().zipWith() //创建一个自定义的操作符，用来处理数据发送者 。 就是对当前Observable进行操作，然后再返回它 Single.compose // Single.subscribe // 返回一个错误， 一般用于调试 Single.error // 用于一对0~多的返回 Single.just( ... ).flatMap() // 一般map()是用于一对一的返回 Single.just( ).map() // 它支持将Single转化为Observable对象，可以返回多个值 Single.just( ).flatMapObservable() // 类似于concat ，如果有中断 ，后面都会中断 Single.merge() // Single.just().mergeWith() // 用于指定异步任务的线程 Single.just().subscribeOn() // 相当于try catch中的return，具体意思就是当函数抛出错误的时候给出一个返回值 Single.just().onErrorReturn() // 指定回调所在线程 Single.just().observeOn() // 超时设置 Single.just().timeout() // Single.just( ).toString() Completable/ CompletableObserver 只发射一条完成通知，或者一条异常通知， 不能发射数据，其中完成通知与异常通知只能发射一个 Maybe/ MaybeObserver 可发射一条单一的数据，以及发射一条完成通知， 或者一条异常通知，其中完成通知和异常通知只能发射一个， 发射数据只能在发射完成通知或者异常通知之前，否则发射数据无效。 RXjava2操作符 所谓的操作符就是一些被Rxjava封装好的方法或API ，使用这些操作符就可以完成线程调度，数据过滤等功能 。 操作符类型 说明 create() 创建被观察者对象 just() 快速的创建被观察者对象 fromArray() 将数组中的数据转换为Observable对象 fromIterable() 将List中的数据转换为Observable对象 empty() 用于测试 ，仅发送Complete事件 error() 用于测试 ，仅发送Error事件 never() 不发射数据，也永远不会结束 defer() 直到有观察者订阅时，才创建被观察者对象&发送事件 每次订阅后，都会得到一个刚创建的最新的Observable对象 timer() 延迟指定时间后，发送1个数值0 interval() 每隔指定时间就加n并发送出去 range() 连续发送一个事件序列，可指定范围 rangeLong() 跟 range()类似，支持数据类型为Long intervalRange() 每隔指定时间 就发送 事件，可指定发送的数据的数量 map() 将传入数据处理后返回 。 输入和输出是一对一 flatMap() 输入和输出可以是 一对多 不能保证 输出的顺序和输入的顺序一致 concatMap 输入和输出可以是一对对 输出和输入顺序 严格一致 buffer() 每次取n个事件放到缓存区中，n可配置 filter() 将符合自定义条件的事件过滤出来 ofType() 过滤 特定数据类型的数据 skip() 跳过正序的前 n 项 skipLast() 跳过正序的后 n 项 distinct() 去掉序列中重复的事件 distinctUntilChanged() 去掉序列中连续重复的事件 take() 指定观察者最多能接收到的事件数量 takeLast() 指定观察者只能接收到被观察者发送的最后几个事件 throttleFirst() 在某段时间内，只发送该段时间内第1次事件 throttleLast() 在某段时间内，只发送该段时间内 最后1次事件 sample() 指定时间内 取一次数据 ，其他的数据就会被丢掉 throttleWithTimeout() 在输出了一个数据后的一段时间内，没有再次输出新的数据， 则把这个数据真正的发送出去； 假如在这段时间内有新的数据输出，则以这个数据作为将要发送的数据项， 并且重置这个时间段，重新计时 debounce () 跟 throttleWithTimeout() 一样 firstElement() 仅选取第1个元素 lastElement() 仅选取最后一个元素 elementAt() 接收指定索引的某个元素 ， 索引越界也不会报异常 elementAtOrError() 接收指定索引的某个元素 ， 索引越界 会报异常 all() 判断发送的所有数据是否都满足自定义的条件 , true false takeWhile() 判断发送的每项数据是否满足 自定义条件 若满足条件则发送 ,不满足不发送 skipWhile() 一直跳过，直到满足自定义条件 skipUntil() - takeUntil() 一直发送 ，直到某个条件 sequenceEqual() 两个数据源的数据是否相同 isEmpty() 数据源的数据是否为空 contains() 数据源中是否包含指定数据 defaultIfEmpty( obj) 在不发送任何有效事件（ Next事件）、仅发送了 Complete 事件的前提下，发送个默认值obj amb() 当有多个数据源需要发送数据时 ， 只发送 先发送数据的Observable的数据，而其余 Observable被丢弃。 concat() 组合多个被观察者一起发送数据，合并后 按发送顺序串行执行 concatArray() 跟concat()类似 merge() 组合多个被观察者一起发送数据，合并后 按时间线并行执行 被观察者数量≤4 mergeArray() 被观察者数量 > 4 mergeWith() delay() 使被观察者延迟一段时间再发送事件 concatDelayError() 使用concat()，一旦某个被观察者发出onError事件，其他被观察者就会终止发送。 为了让其他被观察者继续发送，可以使用这个操作符 concatArrayDelayError() mergeDelayError() combineLatestDelayError() reduce() 把被观察者需要发送的事件聚合成1个事件、发送 collect() 将被观察者发送的数据事件收集到一个数据结构里 startWith() 在被观察者发送事件前，追加发送一些数据 startWithArray() count() 统计被观察者发送事件的数量 subscribe() 订阅， 连接观察者 和 被观察者 zip() 多个数据源Observable 发送数据，经过自定义组合处理后，观察者再收到 。 1、组合数据时严格按照顺序从多个数据源中拿数据。 2、最后观察者收到的数据个数 跟发送最少数据的数据源的数据个数相同。 x.zipWith() combineLatest() 如果子流1在等待其他流发射数据期间又发射了新数据， 则使用子流最新发射的数据进行合并 x.concatMap() x.scan() x.window() subscribeOn() 指定发送事件的线程 只有第一次指定有效，其余的指定线程无效 unsubscribeOn() 取消订阅 observeOn() 指定接收事件的线程 每次指定均有效 doOnEach() 每发送一次就会调用一次 doOnNext () 执行 next之前调用 doAfterNext() 执行 next之后调用 doOnError() doOnComplete() doOnTerminate() doFinally() doOnSubscribe() 观察者订阅时调用 onErrorReturn() 遇到错误时，发送1个特殊事件 & 正常终止 onErrorResumeNext() 拦截的错误 是Throwable 类型 onExceptionResumeNext() 拦截的错误 是 Exception类型 retry() 当捕捉到错误时，被观察者会重新发射数据 retryUntil() 遇到错误，重新发射，直到... retryWhen() repeat() 无条件地、重复发送事件 repeatWhen() repeatUntil() publish() share() connect() 补充知识点 链式调用 MsgInfo msgInfo = new MsgInfo(); // 链式调用 msgInfo.setOwnerId(\"100011002\") .setStatus(MsgInfo.Status.SENDING) .setTime(System.currentTimeMillis()); // 普通调用 msgInfo.setOwnerId(\"100011002\"); msgInfo .setStatus(MsgInfo.Status.SENDING) ; msgInfo .setTime(System.currentTimeMillis()); // 链式调用的关键在于方法的返回值！ public MsgInfo setStatus(int status) { this.status = status; // 注意返回的是 this return this; } Retrofit 2.x 一个支持 RxJava方式调用的网络请求框架 A type-safe HTTP client for Android and Java by Square, Inc. requires at minimum Java 7 or Android 2.3. Retrofit 提供2种风格的网络请求方式： 1、传统风格 (略过不看) 采用Callback 接口 2、RxJava 风格 (流行) 采用Observable接口 Retrofit2 + Rxjava2 依赖 // rxjava核心库 compile 'io.reactivex.rxjava2:rxjava:2.0.1' // Android 支持 Rxjava compile 'io.reactivex.rxjava2:rxandroid:2.0.1' // Android 支持 Retrofit compile 'com.squareup.retrofit2:retrofit:2.1.0' // 衔接 Retrofit & RxJava compile 'com.jakewharton.retrofit:retrofit2-rxjava2-adapter:1.0.0' // 支持Gson解析 compile 'com.squareup.retrofit2:converter-gson:2.1.0' 注解 作用 @GET get请求 @POST post请求 @DELETE delete请求 @HEAD head请求 @OPTIONS options请求 @PATCH patch请求 @Headers 添加请求头 @Path get请求 ，user/{password} 格式 @Query get请求 ， user/password?password=xxx 格式 @FormUrlEncoded 用表单数据提交 @Field post需要 post请求需要 ， 替换参数 //定义请求接口 public interface BlogService { // get 方式 @GET(\"getAllMusicInfoGson\") Call getBlogByGet(@Query(\"pageNum\") int pageNum); // post 方式 @FormUrlEncoded @POST(\"getAllMusicInfoGson\") Call getBlogByPost(@Field(\"pageNum\") int pageNum); } //简单使用 Retrofit retrofit = new Retrofit.Builder() .baseUrl(\"https://www.aivin666.cn/AivinInfo/\")// url根目录 .build(); BlogService service = retrofit.create(BlogService.class); //Call call = service.getBlogByGet(2);//get方式 Call call = service.getBlogByPost(2);//post方式 call.enqueue(new Callback() { @Override public void onResponse(Call call, Response response) { try { String reslut = response.body().string(); tvHttpResult.setText(reslut); Log.i(TAG , reslut) ; } catch (Exception e) { } } @Override public void onFailure(Call call, Throwable t) { } }); Retrofit_RxJava_OkHttp Retrofit + RxJava + OkHttp Retrofit 负责请求的数据和请求的结果 RxJava 负责异步，各种线程之间的切换 OkHttp 负责请求的过程 // rxjava 核心库 compile 'io.reactivex.rxjava2:rxjava:2.1.14' // Android 支持 Rxjava compile 'io.reactivex.rxjava2:rxandroid:2.0.1' // retrofit 核心库 compile 'com.squareup.retrofit2:retrofit:2.4.0' // retrofit json 转换器 compile 'com.squareup.retrofit2:converter-gson:2.3.0' // 衔接 Retrofit & RxJava compile 'com.squareup.retrofit2:adapter-rxjava2:2.3.0' // okhttp 核心库 compile 'com.squareup.okhttp3:okhttp:3.10.0' // okhttp log 拦截器 compile 'com.squareup.okhttp3:logging-interceptor:3.8.1' RxJava 订阅者 public class HttpSubscriber implements Observer { private PicInfoSubscriberListener subscriberOnListener; private Context context; private Disposable disposable; public HttpSubscriber( PicInfoSubscriberListener subscriberOnListener, Context context) { this.subscriberOnListener = subscriberOnListener; this.context = context; } @Override public void onSubscribe(@NonNull Disposable d) { disposable = d; } @Override public void onComplete() { if( (subscriberOnListener == null) || (context == null)) { if(disposable != null && !disposable.isDisposed()){ //切断订阅关系 disposable.dispose(); } } } @Override public void onError(Throwable e) { if(subscriberOnListener != null && context != null) { if (e instanceof SocketTimeoutException) { subscriberOnListener.onError(-1001, \"网络超时，请检查您的网络状态\"); } else if (e instanceof ConnectException) { subscriberOnListener.onError(-1002, \"网络链接中断，请检查您的网络状态\"); } else if(e instanceof MyException){ subscriberOnListener.onError(((MyException)e).getCode(), ((MyException)e).getMsg()); } else { subscriberOnListener.onError(-1003, \"未知错误:\" + e.getMessage()); } } else { if(disposable != null && !disposable.isDisposed()){ disposable.dispose(); } } } @SuppressWarnings(\"unchecked\") @Override public void onNext(T t) { if(subscriberOnListener != null && context != null) { // 收到想要的订阅信息 ，然后通过回到接口 发送到需要数据的地方 subscriberOnListener.onSucceed((List) t); } else { if(disposable != null && !disposable.isDisposed()){ disposable.dispose(); } } } } 定义 发布者 的能力接口 /** * 最终的访问地址是 主地址 + 尾地址 http://xxx/getAllPicInfoGson?pageNum=6 * 此处填写 尾地址 */ @GET(\"getAllPicInfoGson\") Observable> getPicListByGet(@Query(\"pageNum\") int pageNum ); @FormUrlEncoded @POST(\"getAllPicInfoGson\") Observable> getPicListByPost( @Field(\"pageNum\") int pageNum ); 封装发布者 /** * 封装 图片模块的http接口 */ public class PicInfoApi { private final String TAG=\"PicInfoApi\" ; private static PicInfoApi picInfoApi; private PicInfoService picInfoService; private PicInfoApi() { final String BASE_URL_PANDA = \"https://www.aivin666.cn/AivinInfo/\"; picInfoService = HttpClient.getInstance(BASE_URL_PANDA).createApi(PicInfoService.class); } public static PicInfoApi getInstance() { if(picInfoApi == null) { picInfoApi = new PicInfoApi(); } return picInfoApi; } public void getPicListByGet (Observer >subscriber , int pageNum) { // 通过操作符 map(...) 将接收的数据经过处理后再返回 Observable observable = picInfoService.getPicListByGet(pageNum) .flatMap( function ); toSubscribe(observable, subscriber); } public void getPicListByPost (Observer> subscriber , int pageNum) { // 通过操作符 map(...) 将接收的数据经过处理后再返回 Observable observable = picInfoService.getPicListByPost(pageNum) .flatMap( function ); toSubscribe(observable, subscriber); // 将观察者 和订阅者 关联起来 } private void toSubscribe( Observable> o, Observer> s){ o.subscribeOn(Schedulers.io()) // 运行在 io 线程中 .unsubscribeOn(Schedulers.io())// 取消订阅 .observeOn(AndroidSchedulers.mainThread())// 指定接收事件的线程 .subscribe(s);// 订阅 } /*** * 配合 操作符 map 使用 * Function, List> 第一个参数是输入数据类型 ， 第二个参数是输出类型 * List apply(List list) * 第一个 List 是返回数据类型 ， 第二个 List 是输入的数据类型 * */ private Function function = new Function, Observable > >() { @Override public Observable > apply(List list) throws Exception { // 可以在这个函数里面进行数据过滤等处理 if(list != null && list.size() > 0) { Log.i(TAG , \" 数据处理=\"+ list.size()) ; }else{ Log.i(TAG , \" 数据处理 没有获取到数据\") ; } return Observable.fromArray(list) ; } }; 进行http访问的相关配置 public class HttpClient { private static String token = \"\"; private static Retrofit retrofit; private static HashMap clients = new HashMap<>(); private HttpClient(String url) { retrofit = new Retrofit.Builder() .baseUrl(url) // 设置接口主地址 .client(getHttpRequestClient())// 配置 HTTP 请求客户端 .addConverterFactory(GsonConverterFactory.create())// 配置json 转换器 // 添加支持 - 返回值定义为Observable对象 .addCallAdapterFactory(RxJava2CallAdapterFactory.create()) .build(); } public T createApi(Class clazz) { return retrofit.create(clazz);// 获取接口实例 } public static HttpClient getInstance(String url){ if(!clients.containsKey(url)) { HttpClient httpClient = new HttpClient(url); clients.put(url, httpClient); } return clients.get(url); // 一个主地址 对应一个client } /** * 定制 http 访问访问器 */ private OkHttpClient getHttpRequestClient() { HttpLoggingInterceptor logging = new HttpLoggingInterceptor( new OkHttpLogTool()); // 打印获取到的信息。 （不设置不打印） logging.setLevel(HttpLoggingInterceptor.Level.BODY); //设置缓存路径 String cacheDir = MyApplication.getInstance().getExternalCacheDir().getAbsolutePath() ; File httpCacheDirectory = new File(cacheDir , \"OKHttpResponses\"); //设置缓存 大小 Cache cache = new Cache(httpCacheDirectory, 50 * 1024 * 1024); // 自定义拦截器 Interceptor interceptor = new Interceptor() { @Override public Response intercept(Chain chain) throws IOException { Request request = chain.request() .newBuilder() .addHeader(\"token\", token) .build(); // 无网络时 ，使用缓存 if (!NetUtil.isNetworkConnected(MyApplication.getInstance())) { request = request.newBuilder() .cacheControl(CacheControl.FORCE_CACHE) .build(); } Response response = chain.proceed(request); if (NetUtil.isNetworkConnected(MyApplication.getInstance())) { // 有网络时 设置缓存超时时间0个小时 int maxAge = 0 * 60; response.newBuilder() .addHeader(\"Cache-Control\", \"public, max-age=\" + maxAge) // 清除头信息，因为服务器如果不支持，会返回一些干扰信息，不清除下面无法生效 .removeHeader(\"Pragma\") .build(); } else { // 无网络时，设置超时为1周 int maxStale = 60 * 60 * 24 * 7; response.newBuilder() .addHeader(\"Cache-Control\", \"public, only-if-cached, max-stale=\" + maxStale) .removeHeader(\"Pragma\") .build(); } return response; } }; OkHttpClient httpClient = new OkHttpClient.Builder() .addInterceptor(logging) .cache(cache) .addInterceptor(interceptor) .build(); return httpClient; } } 如何使用 private int pageNum = 6 ; private void testUrlGet() { PicInfoApi.getInstance().getPicListByGet( new HttpSubscriber>(new PicInfoSubscriberListener () { @Override public void onSucceed(List data) { // 获取到数据 } @Override public void onError(int code, String msg) { } }, this) , pageNum); } private void testUrlPost( ){ PicInfoApi.getInstance().getPicListByPost( new HttpSubscriber>(new PicInfoSubscriberListener () { @Override public void onSucceed(List data) { } @Override public void onError(int code, String msg) { } }, this) , pageNum); } Hierarchyviewer 借助ViewServer 这个工具可以在任何手机上使用 hierarchyviewer。 注：在 android device monitor 可以找到 hierarchyviewer。 检验手机是否开启了View Server： adb shell service call window 3 //View Server处于关闭状态 返回：Result: Parcel(00000000 00000000 '........')\" //View Server处于开启状态 返回值：Result: Parcel(00000000 00000001 '........')\" 反编译 keystore 、 // apktool http://ibotpeaches.github.io/Apktool/install/ 解压apk文件，获取其中的图片、布局文件 ，必须用apktool打开。 apktool.bat d -f test.apk test 直接用解压软件打开的会显示乱码。 // dex2jar https://sourceforge.net/projects/dex2jar/files/ 直接用解压软件解开,获得dex。 用 dex2jar 将classes.dex转变成jar包。 dex2jar.bat classes.dex //在当前文件夹里生成classes_dex2jar.jar // jd-gui http://java-decompiler.github.io/ 用 jd-gui打开jar包，查看class 文件。 react-native 将 reate-native 的相关笔记删除。体验不如 Flutter ，跨平台请使用 flutter。 抓包工具 对于一般的公司和个人来说，抓包难度越来越大。 暂时没有深入研究。 1、高版本的Android系统，例如7.0以上会抓包更难。 2、APP做了证书合法性检验。例如检测到非法证书无法启动APP。 3、https 传输 并对传输内容进行了加密。抓到后并不是明文。 常用工具有 小茶壶 charles https://www.charlesproxy.com/download/ HttpCanary https://github.com/MegatronKing/HttpCanary Fiddler Mac 系统 复制粘贴 command +c v xcode 全局查找 command + shift + f commit+shift+J 快速定位文件 // xcode shift+ option + 全屏按钮 --》 最大化 command + 🔼箭头 // 返回上一个目录 command + F3 //回到桌面 command + tab //程序切换 贴图工具 // 安装 snap 软件 图片浏览软件，用 kantu 看图 。 // Xcode打包 应用 https://www.yisu.com/zixun/80031.html 首先我们打开要打包的工程文件，comm＋shift＋K清空，再comm＋B编译一下， 1、product --> scheme --> editor scheme 把debaug改成release，点击close。 2、product --> archive 无版权 可以无限制使用！ all right reserved，powered by Gitbook该文件更新时间： 2021-01-08 16:39:38 "},"chinese/doc/开发规范.html":{"url":"chinese/doc/开发规范.html","title":"开发规范","keywords":"","body":"开发规范 Android开发规范 阿里巴巴Android开发规范 1.0.0 类型 规范 示例 资源文件 需带模块前缀 layout文件 - Activity 的 layout以 module_activity开头Fragment 的 layout 以 module_fragment 开头Dialog 的 layout 以 module_dialog 开头include 的 layout 以 module_include 开头ListView 的 item layout 以 module_list_item 开头GridView 的 item layout 以 module_grid_item 开头RecyclerView 的 item layout 以 module_recycle_item 开头 drawable 资源 小写单词+下划线 module_tabs_icon_home_normal module_login_btn_pressed anim 资源 - module_fade_out module_push_down_in color 资源 module_colors.xml 《color name=\"module_btn_bg_color\">#33b5e5e5 dimen 资源 module_dimens.xml 《dimen name=\"module_horizontal_line_height\">1dp style 资源 module_styles.xml 《style name=\"ParentTheme.ThisActivityTheme\"》 string 资源 module_strings.xml moudule_login_tips module_homepage_notice_desc 控件Id 资源 驼峰法命名 View 的缩写作为前缀 LinearLayout  ll RelativeLayoutnbsp   rlConstraintLayout   clListView   lvScollView   svTextView   tvButton   btnImageView   ivCheckBox   cbRadioButton   rbEditText   et //其它控件ProgressBar    progress_bar DatePicker    date_picker Java 开发规范 阿里巴巴编码规范Java 1.3.1 类型 规范 示例 资源文件 需带模块前缀 不能以下划线或美元符号开始、结束 _name Object$ 严禁拼音与英文混合严禁直接使用中文 类名 使用UpperCamelCase风格 TcpUdpDeal DO 、 DTO 、VO 、 DAO等例外 方法名参数名成员变量局部变量 使用lowerCamelCase风格 getHttpMessage() 常量 全部大写、用下划线隔开、语义表达完整 不允许任何魔法值 按模块分开放在不同文件中 MAX_STOCK_COUNT CacheConsts.java ConfigConsts.java 抽象类命名 Abstract 或 Base 开头 异常类命名 用Exception结尾 测试类命名 以它要测试的类名开始，以Test结尾 包名 统小写、统一使用单数形式 com.alibaba.ai.util √ com.alibaba.ai.utils × 接口类 方法和属性不要加任何修饰符号（包括public） void f(); √ void f(); × 枚举 类名带Enum后缀、成员名全大写、用下划线隔开 若变量值仅在一个固定范围内变化，请用枚举 UNKNOWN_REASON 大括号 若大括号内为空，则写成{} 若非空，则左大括号前不换行(不要学c代码的风格) 小括号 小括号和字符之间不出现空格 if (空格a == b空格) × equals方法 \"test\".equals(object); √ object.equals(\"test\"); × 构造方法 禁止写任何业务逻辑 POJO类(没有业务逻辑的类) 必须写toString方法，为了方便排除异常 字符串拼接 使用 StringBuilder final 不允许被继承的类 不允许修改的方法、变量 并不会影响内存的回收 单例对象、工具类 需要保证线程安全 if else for while 必须使用大括号 if (condition) statements × if()...else 请勿超过3层 终止、退出 高并发场景，禁止使用 “==”作为终止条件 并发处理错误会导致数量瞬间变成负数 而无法终止 条件判断 禁止执行复杂语句 if ((...) != null) && (...) &&(...)) × TODO FIXME 代表 “错误，不能工作” 亚信 xx系统编写规范 long或者Long初始赋值时，必须使用大写的L， 不能是小写的l，小写容易跟数字1混淆，造成误解。 不能使用过时的类或方法。 例如 java.net.URLDecoder 中的方法 decode(String encodeStr) 这个方法已经过时， 应该使用双参数 decode(String source, String encode)。 接口提供方既然明确是过时接口，那么有义务同时提供新的接口； 作为调用方来说，有义务去考证过时方法的新实现是什么。 异常不要用来做流程控制，条件控制，因为异常的处理效率比条件分支低。 对大段代码进行 try-catch，这是不负责任的表现。 捕获异常是为了处理它，不要捕获了却什么都不处理而抛弃之，如果不想处理它，请将该异常抛给它的调用者。 异常信息应该包括两类信息：案发现场信息和异常堆栈信息。 如果不处理，那么往上抛。 代码质量 控制 导致 代码质量问题 的原因 1、新手 ，经验和能力不足 2、人员的调动和更换，导致对业务的理解有偏差 3、没有一个约定的 代码规范 ，导致沟通和维护困难 如何保证代码质量 1、架构师搭建、设置 合理优秀的基础框架。 2、要求 开发者 单元测试、代码自测。bug率跟绩效挂钩。 3、代码 评审、复查、 review 代码提交后，由其他人 一般是水平更高的人来评审代码， 评审点可以放在 代码是否符合约定的代码规范、 设计思路和逻辑、性能 ， 必要时要进行重构，实行老人带动新人成长 一般而言， 采用 以小组为单位，组长责任制的代码复查形式。 小组长不要分配太多的开发任务，而是以指导设计、评审代码为主。 4、定期开总结大会，做分享，团队成员能力共同提高 技术选型 首先要确保一点：技术选型是稳定压倒一切、先验证后使用。 不稳定的技术或框架，在后期会带来很多的麻烦， 此项技术是否要被采纳，可以考虑以下因素 1、该技术是否成熟，是否已经被广泛应用和验证过。 一些技术随着开发版本的推进，API会大幅改变，甚至不再维护旧版本，导致旧版本中的BUG无人修复，逼迫你升级。 新技术可能会有很多未知的BUG，如果你深度使用后遇到一个Bug，你自己无法解决 也没人解决过，你会非常难受。 还有一些新技术可能会影响你的APP上架。 2、该技术是谁发起和主持的，权威性如何，后续更新如何，是否有版权风险。 可能会有一些技术精英会开源一个框架，但是并没有形成一个好的社区来维护，后期可能导致项目更新缓慢，甚至停更。 有些可能会慢慢地演化成开源版和收费版，你想要的功能只在收费版中提供。影响你的预算。 3、该技术的复杂性如何、学习成本 、以后替换的成本如何。 在一些工期比较紧的项目中，如果采用新技术，因为团队成员需要学习成本，可能无法把控开发进度。 4、使用该技术是否带来过多的冗余模块，对程序的健壮性是否有影响。 例如一些工具类想做得大且全，但是你引入它只是为了使用它的一个小模块，此时要好好考虑和验证下。 如果出现 依赖冲突、安装包增大等问题，你又对该技术不太熟悉，无法进行优化和排查， 会给项目带来很多不稳定因素。 5、对技术进行考虑时不仅仅要看到它的优点，更要看到它的不足点，改技术在宣传时，它一般是对缺点避而不谈的， 所以你要留心并验证。 如何 提高 线上代码 质量 1、上线前先做好本地测试，加入 bugly等获取异常信息，以便排查修复 2、支持热更新 ，无感知修复小bug 3、全局异常捕捉，防止APP崩溃。 模块化 、组件化 资源去重 // 防止同名资源 1、从源头控制，配置 resourcePrefix 指定前缀， xml资源会红色提示(但是不影响运行)你要加前缀。 图片资源没有提示，需要有意识地添加。 android { resourcePrefix \"app_\" } 2、图片相同，名字不一样。文件去重 方法。 这里写了一个 Md5文件去重 示例。 https://gitee.com/Aivin_CodeShare/android_tool_code/raw/master/md5%E6%96%87%E4%BB%B6%E5%8E%BB%E9%87%8D/CalcMD5.java 无版权 可以无限制使用！ all right reserved，powered by Gitbook该文件更新时间： 2020-12-25 16:27:37 "},"chinese/源码阅读/源码阅读配置.html":{"url":"chinese/源码阅读/源码阅读配置.html","title":"源码阅读","keywords":"","body":"系统源码阅读 androidstudio 查看自带的sdk中的源码 1、在 Androidstudio中点击自己的代码想往下查看源码时， throw new RuntimeException(\"Stub!\" 这是因为没有匹配到对应版本的源码，此时按提示下载源码即可。 2、有一些源码被加了 @hide标签，从 Androidstudio中看不到， 可以从 https://github.com/anggrayudi/android-hidden-api 下载对应版本的 android.jar 替换掉。 3、替换掉 android.jar 后，Androidstudio 报错 ERROR: Execution failed for MockableJarTransform 这是 com.android.tools.build:gradle:x.x.x 版本的问题, 高版本的 gradle中加了一些校验机制， https://github.com/anggrayudi/android-hidden-api/issues/46 4、最终配置 compileSdkVersion 27 targetSdkVersion 27 classpath 'com.android.tools.build:gradle:3.1.4' Androidstudio查看整个Android系统的源码 只能阅读，不能编译。 这里给出 android-8.1.0_r1 版本的源码。 源码地址 https://gitee.com/hnyer/android-8.1.0_r1_learning 1、下载好源码解压，此时导入Androidstudio 只能查看，不能点击跳转。 2、将 android.iml 、android.ipr 两个文件放到根目录。此时可能仍然不能跳转。 3、进入 project Structure --> Modules ，将所有文件都设置成 sources 选项。 4、如果查看源码的时候展示的是 xxx.class ，连接的是 android.jar ， 你将连接指向 F:\\sdk2\\sources\\android-29 即可(举例)。 其他 throw new RuntimeException(\"Stub!\"); 代表没找到对应的android。下载对应版本的源码就可查看。 android 内部API 有些类可以在源码中调用，但是在 Androidstudio 中找不到，是因为这是 内部API 不允许用户调用。 例如 com.android.internal.policy; 注意关键字“internal” 。 其中 PhoneWindow 就是一个私有API 。 RecyclerView implementation 'com.android.support:appcompat-v7:24.2.1' implementation 'androidx.recyclerview:recyclerview:1.0.0' 在添加依赖的时候，要用小写字母去搜索。 RecyclerView 与 listview 的区别 RecyclerView 是 listview 的升级版，具有更高灵活、扩展 。 1、RecyclerView 默认实现了 线性布局、网格布局、流式布局。 2、RecyclerView 取消了 setEmptyView() 、 addHeaderView() 、 addFooterView() 对应的 UI效果需要自己去实现。 3、RecyclerView 提供了 局部刷新的 接口 notifyItemChanged(position) 4、RecyclerView 提供了部分 动画效果。listview 完全靠自定义 。 5、RecyclerView 实现嵌套滚动机制 。 RecyclerView ItemDecoration 间隔线 recyclerView.addItemDecoration(xx); https://gitee.com/Aivin_CodeShare/android_tool_code/raw/master/RecyclerView/RecyclerViewMarginDecoration.java RecyclerView 添加动画 默认实现一些基础动画。 RecyclerView 局部刷新 原理 RecyclerView 缓存 机制 默认已经实现了 View的复用，不需要类似 if(convertView == null) 的实现 RecyclerView 复用 机制 默认已经实现了 View的复用，不需要类似 if(convertView == null) 的实现 RecyclerView 回收机制 RecyclerView 嵌套滑动 机制 Android 5.0推出了嵌套滑动机制，在之前，一旦子View处理了触摸事件， 父View就没有机会再处理这次的触摸事件，而嵌套滑动机制解决了这个问题 RecyclerView 多种 type场景下怎么避免滑动卡顿 RecyclerView 万能适配器 以上是讲解 recyclerview 的原理，实际使用中 可以使用 一些封装过的 第三方 适配器，提高开发速度。 https://github.com/CymChad/BaseRecyclerViewAdapterHelper 无版权 可以无限制使用！ all right reserved，powered by Gitbook该文件更新时间： 2020-12-31 11:46:10 "},"chinese/产品经理/常用概念.html":{"url":"chinese/产品经理/常用概念.html","title":"产品经理","keywords":"","body":"工具 Axure 软件安装 Axure 原型制作工具 1、安装包 测试版本为8.1.0.3377 安装包在我百度盘有备份 2、汉化 汉化包也在百度盘 将汉化包解压，将其中的 lang文件夹, 复制到Axure 安装目录下即可。 3、破解 于20180907测试可用，以后可能会失效。 zdfans.com gP5uuK2gH+iIVO3YFZwoKyxAdHpXRGNnZWN8Obntqv7++FF3pAz7dTu8B61ySxli 类型 保真度 用途 特点 费用 线框图 低 文档、快速交流、表达设计思路和大纲 手绘草图，不能交互 低 原型 中 模拟成品的交互流程 可以交互 高 视觉稿 高 给非专业人看的，视觉感受 静态视觉设计，不能交互 中 类图(Class Diagram) 对象图(Object Diagram) 包图(Package Diagram) 组件图(Component Diagram) 部署图(Deployment Diagram) 用例图(User Case Diagram) 顺序图/序列图/时序图(Sequence Diagram) ---> 交互图 状态机图、状态图(State Machine Diagram) 协作图、通信图(Communlcation Diagram) 活动图(Activity Diagram) PERT图 项目评估与评审技术 Project Evaluation and Review Technique 可以使用亿图图示绘制 pert图示例 UML流程图 绘制软件 推荐使用 Visio 、processon 流程图符号 类型 作用 图形 开始 / 结束 代表“开始”、“结束” 过程 一个步骤或操作 判断 if else 数据 输入/ 输出 输入、输出的数据 箭头、连接线 工作流方向 文档 输入、输出的文件 多文档 外部数据 表示数据来自外部 数据库 表示从数据库中获取数据信息 内部存储 指数据提交之后，需要写入数据库 队列数据 表示数据处理的一种方式 直接数据 人工输入 用户通过键盘等手动输入的数据 人工操作 表示需要用户手动操作调整的内容 比如修改、搜索、删除、提交等 手动操作 卡片 穿孔卡是早期计算机的信息输入设备 纸带、条带 参考卡片 展示内容 在设备上展示信息 循环限值 是指循环开始或结束的条件 子流程 并行模式 表示同时进行 （在并行模式的框内可以添加其它的部件） 预定义流程 人员 注释 批注 页面内引用 相当于一个页面内的跳转 跨页引用 相当于一个跨页的连接器 预备 进入流程前的准备状态 推迟、延期 UML状态图 State Machine Diagram 用于描述一个特定的对象的所有可能状态以及由于各种事件的发生而引起的状态之间的转换。 概念 意义 图示 状态 开始 、其他状态、结束 转移 两个状态之间的一种关系 表示对象将在第一个状态中执行一定的动作， 并在某个特定事件发生而某个特定的条件满足时进入第二个状态 UML用例图 User Case Diagram 用例图从用户角度描述系统的静态使用情况 类型 作用 图示 角色、参与者 在系统外部与系统直接交互的人或事物 用例 系统外部可见的一个系统功能单元 系统边界、容器 用来展示系统的一部分功能，这部分功能联系紧密 关系 有4种：关联、泛化、包含、扩展 关系 意义 图示 备注 关联 箭头指向消息接收方 泛化 继承关系 箭头指向父类 包含 用来体现一个用例功能的多个子功能 拓展 是指用例功能的延伸，相当于为基础用例提供一个附加功能 UML类图 Unified Modeling Language 统一建模语言 绘制UML类图的软件推荐 Enterprise Architect 或 processon 作用域类型 符号 public + private - protected # 元素类型 图示 包 类 接口 元素之间的关系 定义 举例 备注 泛化（Generalization） 继承 箭头指向父类 实现（Realization） 类实现接口 箭头指向接口 关联（Association) 拥有关系 箭头指向被拥有者 聚合（Aggregation） 整体与部分的关系。部分可以单独存在。 菱形指向整体 组合(Composition) 整体与部分的关系 部分不能单独存在。 图标有2种菱形指向整体 依赖(Dependency) A需要B的协助才能完成某项功能 箭头指向被使用者 甘特图 甘特图最早由Henry L.Gantt在1917年提出。 甘特图是一个二维平面图， 横纬度 显示了每项工作的开始时间和结束时间，横道线的长度表示了该项工作的持续时间。 纵维表示工作内容 绘制工具可以使用 雁阵 其他 五大过程组 、十大知识领域 项目管理常用缩写 缩写 解释 AC 实际成本 。 Actual Cost : 在一个给定的时间段内，为完成进度活动或工作分解结构组成部分的工作，而实际发生并记录在案的总成本。实际成本有时仅为直接工时或直接成本，有时也为包括间接成本在内的所有成本。实际成本也称“已完工作实际成本（ACWP）”。参见“挣值管理”和“挣值技术”。 ACWP 已完成工作实际成本- Actual Cost of Work Performed : 见“实际成本”。AC BAC 完工预算- Budget At Completion：项目工作、工作分解结构组成部分或进度活动的所有预算之和，即项目的总计划价值。即PV之和 BCWP 已完成工作预算成本- Budgeted Cost of Work Performed：见“挣值”。EV BCWS 计划工作预算成本- Budgeted Cost of Work Scheduled：见“计划价值”。PV CCB 变更控制委员会-Change Control Board：由干系人正式组成的团体，负责审议、评价、批准、推迟或否决项目变更，所有决定和建议均应记录在案。 COQ 质量成本-Cost Of Quality：确定为保证质量而付出的成本的一种方法。预防和评估成本（一致性成本）包括为确保符合要求而进行质量规划、质量控制和质量保证的成本（即培训、质量控制体系等）。缺陷成本（非一致性成本）包括对不合格产品、部件或过程的返工成本，保修工作和废品的成本，以及名誉的损失。 CPF 成本加费用-Cost Plus Fee: CPFF 成本加固定费用- Cost Plus Fixed Fee [Contract]：成本补偿合同的一种类型，买方为卖方报销可列支成本（可列支成本由合同确定），再加上一笔固定数额的利润（费用）。 CPAF 成本加奖励费用- Cost Plus Award Fee [Contract]：为卖方报销履行合同工作所发生的一切合法成本，但是只有在满足了合同中规定的某些笼统、主观的绩效标准的情况下，才能向卖方支付大部分费用。完全由买方根据自己对卖方绩效的主观判断来决定奖励费用，并且卖方通常无权申诉。 CPIF 成本加激励费用- Cost Plus Incentive Fee [Contract]：成本补偿合同的一种类型，买方为卖方报销可列支成本（可列支成本由合同确定），并且卖方在达到规定绩效标准时赚取利润。 CPI 成本绩效指数-Cost Performance Index：项目成本效率的一种指标，是挣值（EV）与实际成本（AC）之比。CPI=EV／AC。 CPM 关键路径法-Critical Path Methodology：一种进度网络分析技术，用来确定项目进度网络中各条逻辑路径的灵活性大小（浮动时间大小），进而确定整个项目的最短工期。从规定的开始日期开始，利用顺推计算法计算最早开始和完成日期。从规定的完成日期（可能是顺推计算所得到的项目最早完成日期）开始，利用逆推计算法计算最晚开始和完成日期。 CV 成本偏差-Cost Variance：项目成本绩效的一种指标，是挣值（EV）与实际成本（AC）之差。CV=EV−AC。 DU or DUR Duration (DU or DUR) 持续时间：完成某进度活动或工作分解结构组成部分所需的工作时段总数（不包括节假日或其他非工作时段）。通常用工作日或工作周表示。有时被错误地等同于“自然流逝时间”。与“人力投入”比较。 EAC 完工估算[输出／输入] -Estimate at Completion [Output/Input] ：为完成某进度活动、工作分解结构组成部分或整个项目所需的预期总成本。EAC 既可以根据迄今为止的实际绩效进行计算，也可以由项目团队根据其他因素做出估算，后者也常称“最新修订估算”。参见“挣值技术”和“完工尚需估算”。 ETC 完工尚需估算[输出／输入] -Estimate to Completion[Output/Input ]：为完成某进度活动、工作分解结构组成部分或整个项目的所有剩余工作而预计需要的成本。参见“挣值技术”和“完工估算”。 EV 挣值-Earned Value Management ：进度活动或工作分解结构组成部分的已完成工作的价 值，用分配给该工作的预算数来表示。也称“已完工作预算成本（BCWP）”。 ES 最早开始时间-Earliest Start Date：在关键路径法中，基于进度网络逻辑、数据日期和所有进度制约因素，某进度活动（或项目）的未完部分可能开始的最早时点。最早开始日期可随项目的进展和项目管理计划的变更而改变。 EF 最早结束时间-Earliest Finish Date：在关键路径法中，基于进度网络逻辑、数据日期和所有进度制约因素，某进度活动（或项目）的未完部分可能完成的最早时点。最早完成日期可随项目的进展和项目管理计划的变更而改变。 EMV 预期货币价值分析- Expected Monetary Value Analysis：当某些情况在未来可能发生、也可能不发生时，计算平均结果的一种统计技术。这种技术经常在决策树分析中使用。 FF 完成到完成- Finish to Finish：只有当紧前活动完成，紧后活动才能完成的逻辑关系。参见“逻辑关系”。 FFP 固定总价[合同]- Firm Fixed Price [Contract]：不考虑卖方实际成本，由买方向卖方支付事先确定的金额（由合同规定）的一种总价合同。 FPIF 总价加激励费用- Fixed Price Incentive Fee FP-EPA 总价加经济价格调整- Fixed Price with Economic Price Adjustment FMEA 失效模式与影响分析[技术]：-Failure Mode and Effect Analysis [Technique]：一种分析程序用来分析产品的每个部件的每种可能失效模式及其对该部件的可靠性的影响，并确定每种失效模式本身或与其他失效模式联合将对产品或系统的可靠性的影响，或对该部件的必备功能的影响；或者，用来检查产品（在整个系统和／或较低层次上）的所有可能失效模式。对于每一种可能的失效，都要估计对整个系统的影响。此外，还应该审查为降低失效的概率和影响而计划采取的行动。 FS 完成到开始- Finish to Start：紧后活动的开始依赖于紧前活动的完成的逻辑关系。参见“逻辑关系”。 IFB 投标邀请书- Invitation For Bid：通常本术语等同于建议邀请书。但在某些应用领域，其含义可能更狭窄或更具体。 LS 最晚开始日期-Late Start Date：在关键路径法中，基于进度网络逻辑、项目完成日期和任何施加于进度活动的制约因素，在不违反进度制约因素或延误项目完成日期的条件下，允许某进度活动最晚开始的时点。最晚开始日期在项目进度网络的逆推计算中确定。 LF 最晚完成日期- Late Finish Date：在关键路径法中，基于进度网络逻辑、项目完成日期和任何施加于进度活动的制约因素，在不违反进度制约因素或延误项目完成日期的条件下，允许某进度活动最晚完成的时点。最晚完成日期在项目进度网络的逆推计算中确定。 LOE 人力投入量- Level of Effort OBS 组织分解结构[工具]- Organizational Breakdown Structure [Tool]：对项目组织的一种层级描述，以便把工作包与相应的执行部门联系起来。 PDM 紧前关系绘图法-Precedence Diagramming Method: 一种用方框（或节点）表示计划活动的进度网络图绘制技术。进度活动在图形中按一种或多种逻辑关系连接起来，以显示活动的实施顺序。 PMBOK 项目管理知识体系-Project Management Body of Knowledge：说明项目管理专业范围内的知识总和的概括性术语。与法律、医学、会计等其他专业一样，该知识体系掌握在应用和推进它的实践者和学者手中。完整的项目管理知识体系既包括已被验证并广泛应用的传统做法，也包括本专业新近涌现的创新做法。该知识体系包括已发表和未发表的材料。该知识体系正处于不断演进中。PMI的PMBOK® 指南识别了作为项目管理知识体系一部分的、被普遍公认的良好做法。 PMIS 项目管理信息系统-Project Management Information System：由收集、整合和传播项目管理过程成果的工具和技术所组成的信息系统。它为项目从启动到收尾的所有方面提供支持，可以包括人工和自动系统。 PV 计划价值-Planned Value：为某进度活动或工作分解结构组成部分的预定工作进度而分配且经批准的预算。也称“计划工作预算成本”。 QA 质量保证-Quality Assurance: 审计质量要求和质量控制测量结果，确保采用合理的质量标准和操作性定义的过程 QC 质量控制-Quality Control: 监测并记录执行质量活动的结果，从而评估绩效并建议必要变更的过程。 RACI 执行、负责、咨询、知情-Responsible、Accountable、Consult、Inform RAM 责任分配矩阵- Responsibility Assignment Matrix：一种将项目组织分解结构与工作分解结构联系起来的结构，有助于确保项目工作范围的每个组成部分都被分配给了某个人或某个团队。 RBS 风险分解结构- Risk Breakdown Structure：按风险类别和子类别来排列已识别的项目风险的一种层级结构图，用来显示潜在风险的所属领域和产生原因。风险分解结构通常依具体项目类型定制。 RFI 信息邀请书-Request For Information：采购文件的一种，买方借此邀请潜在卖方就某种产品、服务或卖方能力提供相关信息。 RFP 建议邀请书- Request For Proposal：采购文件的一种，用来向潜在卖方征求对产品或服务的建议书。在某些应用领域，其含义可能更狭窄或更具体。 RFQ 报价邀请书- Request For Quotation：采购文件的一种，用来向潜在卖方征求对普通或标准产品或服务的报价。有时可用来代替建议邀请书。在某些应用领域，其含义可能更狭窄或更具体。 SF 开始到完成- Start to Finish：紧后进度活动的完成取决于紧前进度活动的启 动的逻辑关系。参见“逻辑关系”。 SS 开始到开始- Start to Start：紧后进度活动的启动取决于紧前进度活动的启动的逻辑关系。参见“逻辑关系”。 SV 进度偏差-Schedule Variance：项目进度绩效的一种指标，是挣值（EV）与计划价值（PV）之差。SV=EV-PV。 SPI 进度绩效指数-Schedule Performance Index：项目进度效率的一种指标，是挣值（EV）与计划价值（PV）之比。SPI=EV/PV。 SOW 工作说明书-Statement of Work：对需提供的产品、服务或成果的叙述性说明。 SWOT 优势、劣势、机会、威胁-Strength、Weaknesses、Opportunities、Threats：这种信息收集技术从项目的每一个优势、劣势、机会和威胁的出发，对项目进行考察，以便更全面地考虑风险。 T&M 工料合同-Time & Material Contract：兼具成本补偿和总价合同特征的一种混合合同安排。与成本补偿合同相似，工料合同没有封顶价，因为签订合同时并没有确定合同总价。工料合同的合同价可以像成本补偿合同那样增长。另外，工料合同又与总价合同相似。例如，当买卖双方就某类高级工程师的单价达成一致意见时，该单价就被事先确定了。 TQM 全面质量管理-Total Quality Management WBS 工作分解机构-Work Breakdown Structure：以可交付成果为导向的工作层级分解。其分解的对象是项目团队为实现项目目标、提交所需可交付成果而实施的工作。工作分解结构组织并定义了项目的全部范围。 PERT （Program/Project Evaluation and Review Technique）即计划评审技术 ITTO 是一种输入输出工具法，类似于思维导图。用于项目管理中各种工作内容的计划的过程梳理，能够帮助人们在工作中理清工作思路，做好项目中的优先级排序。 NPV ROI IRR EVM 挣值计算 AT 实际时间 PMB 绩效测量基准 VAC 完工偏差 TCPI 完工尚需绩效指数 141个工具和技术 序号 名称 定义 1 专家判断 对某方面擅长的人就是专家，找专家协助就是专家判断，专家可能是顾问、干系人、团队成员 2 引导技术 用来协调干系人之间的矛盾，以及项目其他要素之间的矛盾。头脑风暴，冲突处理，问题解决和会议管理等，都是引导者可以用来帮助团队和个人完成项目活动的关键技术 3 项目管理信息系统 作为事业环境因素的一部分，项目管理信息系统提供下列工具：进度计划工具，工作授权系统，配置管理系统，信息收集与发布系统，或进入其他在线自动化系统的网络界面。也可用于自动收集和报告关键绩效指标KPI 4 会议 通过会议来讨论和解决项目的相关问题。参会者可包括项目经理，项目团队成员，以及与所讨论问题相关或会受该问题影响的干系人。按照会议目的分为三类：交换信息，头脑风暴或方案评估，制定决策。注意不要把各种会议类型混合在一起。 5 变更控制工具 为了便于开展配置和变更管理，可用一些手工或自动化的工具。工具的选择应基于项目干系人的需要，并考虑组织和环境情况或制约因素。可使用工具来管理变更请求和后续决策，还要关注沟通，以帮助CCB成员履行职责，以及向相关干系人传达决定。例如，变更管理软件，版本控制软件都是软件开发项目常用的变更控制工具 6 变更控制会 CCB开的会，重要干系人组成负责评审、批准变更请求，但不是所有变更都要由CCB来批准。是另一个工具“会议”的一种形式 7 分析技术 用来研究变量之间的复杂关系的各种技术的总称。可用的项目分析技术包括：回归分析，分组方法，因果分析，根本原因分析，预测方法，FMEA，FTA，储备分析，趋势分析，挣值管理，差异分析 8 配置管理系统 整个项目管理系统的一个子系统。它由一系列正式的书面程序组成，用于对以下工作提供技术和管理方面的指导与监督：识别并记录产品、成果、服务或部件的功能特征和物理特征；控制对上述特征的任何变更；记录并报告每一项变更及其实施情况；支持对产品、成果或部件的审查，以确保其符合要求。该系统包括文件和跟踪系统，并明确了为核准和控制变更所需的批准层次，包括变更控制系统 9 工作授权系统 整个项目管理系统的一个子系统。它是一系列正式书面程序的集合，规定如何授权（委托）项目工作，以保证该工作由正确的组织、在正确的时间、以正确的顺序执行。工作授权系统包括发布工作授权所需的步骤、文件、跟踪系统以及审批层次 10 访谈 与干系人直接交流，通常是一对一 11 焦点小组会议 有主持人，分主题、分小组讨论 12 引导式讨论会 跨职能人员讨论：IT行业JAD（联合应用开发）；制造业QFD（质量功能部署,倾听客户的声音） 13 头脑风暴法 面对面，快，容易受别人影响；属于群体创新技术 14 名义小组法 头脑风暴后，对创意进行排序；属于群体创新技术 15 德尔斐法 背靠背，匿名，客观，慢；属于群体创新技术 16 思维导图 圆圈、创意、线连起来；属于群体创新技术 17 亲和图 大量创意，然后找关系，同类的放在一起；属于群体创新技术 18 多标准决策分析 做决策时需要考虑多重相互矛盾的标准，可以建立矩阵表格，基于多重标准作出决策；属于群体创新技术 19 群体决策技术 为达成某种期望结果而对多个未来行动方案进行评估 20 问卷调查 通过设计书面问题，向为数众多的受访者快速收集信息 21 观察 直接观察个人在各自的环境中如何开展工作和实施流程 22 原型法 先造出该产品的实用模型 23 系统交互图 把某个系统置于大背景中，用图形直观地展示该系统与其他系统之间的接口关系。例如，该系统从哪里获得输入，又会向哪里输出什么，该系统与周围环境是什么关系等等 24 文件分析 从各种文件中识别并收集干系人的需求。可供分析的文件包括：商业计划，营销文献，协议，建议邀请书，现行流程，逻辑数据模型，业务规则库，应用软件文档，业务流程或接口文档，其他需求文档，问题日志，政策程序和法规文件 25 产品分析 产品分解、系统分析、需求分析、系统工程、价值工程和价值分析 26 备选方案识别 头脑风暴、横向思维和配对比较，条条大路通罗马 27 分解 把项目可交付成果划分为更小的、更便于管理的组成部分 28 检查 开展测量、审查与核实等活动，来判断工作和可交付成果是否符合要求及产品验收标准 29 滚动式规划 近期详细、远期粗略，计划反复进行 30 模板 过去的经验总结 31 PDM紧前关系图 节点法AON，方框代表活动，箭线代表逻辑关系，ADM，CDM 32 确定依赖关系 硬逻辑（客观，无法改变）、软逻辑（考验项目经理创造力，最佳实践）、外部逻辑（依赖其他项目的活动，隐含着风险，可以包含硬逻辑或软逻辑） 33 提前&滞后 提前或推迟（如水泥抹平晾干）某个活动的开始日期，不改变本来的逻辑关系 34 网络模板 标准化网络，某部分可以称为子网络，适合项目中存在重复性的成果时 35 出版的估算数据 外部公司发布的生产率和资源单价 36 自下而上估算 对活动估算，然后汇总到工作包，再汇总到项目总资源，比较准，比较慢 37 项目管理软件 不等于项目管理信息系统 38 类比估算 以过去项目信息做基础来估算未来项目信息（历时、资源、成本） 39 参数估算 利用历史数据与其它变量的关系，生产率、成果数量，铺电缆200ft/小时 40 三点估算以及标准差 用最悲观、最乐观、最可能三个来估算 41 储备分析 考虑应急储备（如缓冲时间或储备金）和/或管理储备 42 进度网络分析 包括CPM、关键链、资源平衡、假设情景分析等 43 关键路径法 不考虑资源限制的情况下，找出完成项目的最短时间 44 关键链：帕金森定律 关键路径-时差概念+时间缓冲+资源缓冲，越早越好 45 资源平衡 确保资源使用量稳定均衡，往往会造成关键路径的变化 46 资源平滑 对进度模型中的活动进行调整，从而使项目资源需求不超过预定的资源限制的一种技术，相对于资源平衡，资源平滑不会改变关键路径，完工日期也不会延迟 47 资源优化技术 包括了资源平衡和资源平滑，通常先做资源平滑，再做资源平衡 48 假设情景分析 考虑各种可能的情形，预测对项目目标的影响，属于建模技术 49 模拟 基于多种不同的活动假设（通常使用三点估算的概率分布）计算出多种可能的项目工期，以应对不确定性，最常用的模拟技术为蒙特卡洛分析；属于建模技术 50 建模技术 包括假设情景分析和模拟 51 进度压缩 不改变范围情况下，缩短项目历时：赶工（那资源换时间，但逻辑关系不变）与快速跟进（调整逻辑关系，会增大风险） 52 进度计划编制工具 和项目管理软件一起使用，应该也是自动化的工具 53 绩效审查 测量与对比分析进度绩效，可使用各种技术包括趋势分析，关键路径法，关键链法，挣值管理，偏差分析 54 质量成本（COQ） 一致、非一致成本（失败或缺陷成本）；一致中又分预防（培训）和评估（过程控制） 55 卖方投标分析 让卖方先报价，预估项目大概花费成本 56 成本汇总 以WBS中工作包为单位汇总，得出总成本 57 历史关系 感觉就是参数估算或类比估算的基础 58 资金限制平衡 平衡资金支出，不要有很大起伏，财务部很喜欢 59 挣值管理（EVM） PV、EV、AC、CV、SV、CPI、SPI、EAC、ETC、TCPI，属于偏差分析的一种 60 绩效审查 包括偏差分析（看节点）、趋势分析（一个区间段）、挣值绩效分析 61 成本效益分析 对质量活动进行分析评估是否合适 62 控制图 看过程是否稳定，7点规则、失控 63 标杆对照（基准对照） 将项目与其它项目对比找差距、制定改进措施 64 实验设计（DOE） 统计学方法，分析每个因素对开发的流程和产品的特定变量的影响 65 统计抽样 从目标总体中选样本进行检查，在规划确定次数规模，在控制实施 66 流程图 显示某个过程中各步骤之间的关系 67 其它质量规划工具 头脑风暴、力场分析、名义小组、质量管理和控制工具 68 质量管理和控制工具 亲和图，过程决策程序图（PDPC），关联图，树形图，优先矩阵，活动网络图，矩阵图 69 质量审计 独立的结构化审查，由内外部审计师进行 70 过程改进（过程分析） 识别所需要改进的过程，包括根本原因分析 71 因果图 石川图、鱼骨图 72 直方图 显示特定情况的发生次数 73 帕累托图 特殊的直方图，按每个情况发生次数排序，28原理，如银行存款28法则 74 核查表（计数表） 用于收集数据的查对清单，合理排列各种事项，以便有效地收集关于潜在质量问题的有用数据 75 散点图 显示两个变量（因变量、自变量）的关系 76 组织机构图（OBS） 按组织部门排列下面列出工作包 77 责任分配矩阵图（RAM） 显示工作包（活动）和成员（资源）之间的关系，RACI 78 人际交往 正式、非正式的行业、职业环境下的人际互动，有助于认识人才 79 组织理论 个人、团队、组织的行为方式 80 多标准决策分析 在组建团队过程中，经常需要使用团队成员选择标准。通过多标准决策分析，制定出选择标准，并据此对候选团队成员进行定级或打分。根据各种因素对团队的不同重要性赋予不同的权重。包括可用性，成本，经验，能力，知识，技能，态度，国际因素等等 81 预分派 事先选定的，三种情况：竞标过程承诺、取决于特定技能、项目章程承诺 82 谈判 就某个事情双方达成共识的过程 83 招募 从外部招聘人员 84 虚拟团队 为共同目标而努力可几乎大家不见面，凝聚力低，沟通麻烦 85 人际关系技能 软技能：领导力，团队建设，激励，沟通，影响力，决策，政治和文化意识，谈判，建立信任，冲突管理，教练技术 86 培训 能够提高团队成员能力的活动 87 团队建设活动 有专门和非专门之分，非正式沟通非常重要，需要持续进行 88 基础规则 对成员可接受行为进行明确规定 89 集中办公 “紧密矩阵”，把许多或全部最活跃的项目团队成员安排在同一个物理地点（作战室）工作，以增强团队工作能力。 90 认可与奖励 对优秀成员的行为给予认可和奖励，要根据对方需求进行奖励 91 人事测评工具 能帮助项目经理和项目团队洞察成员的优劣势，了解成员的偏好和愿望，如何与人交际等。如态度调查，细节评估，结构化面谈，能力测试及焦点小组讨论等 92 观察与交谈 了解团队的工作表现和态度动态 93 项目绩效评估 对成员表现进行评估 94 冲突管理 解决项目冲突，合作/解决问题（综合考虑不同意见引导各方达成共识）、强制/命令（问题解决了，人际关系破坏了，通常在紧急情况下）、撤退/回避、缓和/包容（求同存异），妥协/调解（各让一步） 95 问题日志 书面的记录下来项目出现的问题 96 干系人分析 系统收集和分析各种信息了解干系人的利益、影响、期望 97 沟通需求分析 确定项目干系人的信息需求 98 沟通技术 要不要使用自动化工具，网络系统、视频会议等等 99 沟通模型 显示发送者和接受者 100 沟通方法 推式（发email)、拉式(在线课堂、网站）、交互式（开会） 101 信息管理系统 用来管理和分发项目信息的工具，包括电子的、纸的、项目管理电子工具（门户网站） 102 报告绩效 收集和发布绩效信息，包括状况报告，进展测量结果及预测结果，可以是简单的状态报告，也可以是详尽的报告 103 管理技能 指导与控制一群人协调他们行动实现目标 104 规划会议和分析 项目干系人、项目经理、团队成员、组织内负责风险的人一起开会 105 文档审查 对项目文档（合同、计划、项目档案等）进行评估审查 106 信息收集技术 头脑风暴、德尔斐、访谈、根本原因分析 107 核对表分析 根据编制的风险识别清单来进行风险识别，优点快，缺点不够全面 108 假设分析 检验之前的假设是否还成立，如果不成立就是风险 109 图解技术 因果图、流程图、影响图 110 SWOT分析 从内部优势、劣势；外部机会和威胁不同角度进行分析 111 概率与影响评估 分析风险发生可能性和后果 112 概率影响矩阵 用来对比把某个风险放入，深灰色代表严重；中度灰色代表较轻 113 风险数据质量评估 对风险识别分析所依据的数据进行评估开是否可信 114 风险分类 根据WBS、根据阶段、根据干系人、根据RBS（类别）对风险分类 115 风险紧迫性评估 评估哪些风险现在需要应对，哪些需要过一段时间应对 116 数据收集与表现 包括访谈、概率分布（贝塔分布、三角分布） 117 敏感性分析 确定哪些风险对项目具有最大影响，用龙卷风图来表现 118 预期货币价值（EMV） 把各种可能的后果和概率相乘，常和决策树一起使用 119 消极风险和威胁应对 回避、转移、减轻、主动或被动接受 120 积极风险和机会应对 开拓、提高、分享、接受 121 应急应对策略 制定应急计划，当风险发生时再执行 122 风险再评估 对现有评估、识别新风险、删除过去的风险，团队成员作的，内部人做的 123 风险审计 评估风险管理过程的有效性，通常外部人来做 124 技术绩效衡量 对技术成果和项目计划进行比较 125 状态审查会 定义开会，顺便看风险状况 126 自制外购分析 确定某个工作是团队自己完成还是外部采购 127 市场调研 包括考察行业情况和供应商能力 128 合同类型 固定价（范围明确时使用，买方风险小，卖方风险大，可以加激励、加经济调整考虑利率）、成本补偿类（买方参与最多，卖方风险小，有加成、有激励、有奖励-主观的·虚的）、时间材料合同（二者混合，谈判速度快） 129 投标人会议 买方向所有潜在卖方召开，要公平，让每个卖方对项目有清楚认识 130 建议书评价技术 就是评标的方法 131 独立估算 买方或找第三方编写，用作标杆来和投标人的报价进行对比 132 广告 在报纸或网站宣传招标活动 133 采购谈判 作为买方和卖方谈判，谈判技巧很重要，黑脸白脸，最终期限，有限授权，继承事实 134 合同变更控制系统 文书工作、跟踪系统、争议解决程序、审批层次 135 采购绩效审查 根据合同对卖方审查业绩，结构化审查 136 检查和审计 买方开展的，卖方需要支持 137 绩效报告 用来向高层汇报说明卖方合同执行情况 138 支付系统 说明如何给卖方付款，需要先确定卖方工作完成了 139 索赔管理 就是针对争议性的变更如何进行管理，先按合同谈判，然后考虑仲裁，最后上法院 140 记录管理系统 属于项目管理信息系统的一部分用来记录合同执行过程的文档 141 采购审计 对项目采购过程进行审查，找出经验和教训 PMP相关文档 https://hnyer.gitee.io/2020/06/08/pmp-xiang-guan-wen-dang/ 技术选型的 考虑纬度 //需求的满足度 是否满足当前的业务需求 // 成熟度、使用人数、社区活跃度、替换成本 更新速度稳定、社区气氛活跃的框架优先考虑。 // 学习成本 学习使用、引入当前技术框架带来的学习和改造成本。 // 开发速度、代码可维护性、可阅读性 、易调试性 当前技术是否会降低开发速度，和维护难度。 // 执行效率 、性能 是否对产品的性能有影响。 //安全性 数据安全性，是否容易被攻击； 开源协议约束，是否对自己的商业产品有版权威胁。 无版权 可以无限制使用！ all right reserved，powered by Gitbook该文件更新时间： 2020-10-19 11:53:20 "},"chinese/设计模式/设计模式.html":{"url":"chinese/设计模式/设计模式.html","title":"设计模式","keywords":"","body":"设计模式 参考资料教材 目前设计模式： 23个GoF设计模式 + 简单工厂模式 学习设计模式的意义 过多地使用 if else 会造成代码臃肿 ，维护困难（容易产生bug ，需要大量修改代码）。此时你应该要考虑用某种设计模式来解决这个问题。 简单的设计意味着缺少灵活性，我们将其称之为“一次性代码”，不能方便地被应用在其他项目。 而合适的设计模式，可以让你的代码可以被反复使用。 设计模式分类 创建模型 创建型模式用来处理对象的创建过程 模式类型 学习进度 工厂方法模式（Factory Method Pattern） 抽象工厂模式（Abstract Factory Pattern） 建造者模式（Builder Pattern） 原型模式（Prototype Pattern） 单例模式（Singleton Pattern） 附：简单工厂模式：又叫做静态工厂方法（StaticFactory Method）模式，是属于创建型模式，但不属于23种GOF设计模式之一。 结构型模式 用来处理类或者对象的组合 模式类型 学习进度 适配器模式（Adapter Pattern） 桥接模式（Bridge Pattern） 组合模式（Composite Pattern） 装饰者模式（Decorator Pattern） 外观模式（Facade Pattern） 享元模式（Flyweight Pattern） 代理模式（Proxy Pattern） 行为型模式 用来对类或对象怎样交互和怎样分配职责进行描述 模式类型 学习进度 责任链模式（Chain of Responsibility Pattern） 命令模式（Command Pattern） 解释器模式（Interpreter Pattern） 迭代器模式（Iterator Pattern） 中介者模式（Mediator Pattern） 备忘录模式（Memento Pattern） 观察者模式（Observer Pattern） 状态模式（State Pattern） 策略模式（Strategy Pattern） 模板方法模式（Template Method Pattern） 访问者模式（Visitor Pattern） 面向对象设计原则 面向对象设计原则蕴含在很多设计模式中，它们是从许多设计方案中总结出的指导性原则。是我们用于评价一个设计模式的使用效果的重要指标之一。 [x] 1、单一职责原则(Single Responsibility Principle, SRP) [x] 2、开闭原则(Open-Closed Principle, OCP) [x] 3、接口隔离原则(Interface Segregation Principle, ISP) [x] 4、依赖倒转原则(Dependency Inversion Principle, DIP) [x] 5、里氏代换原则(Liskov Substitution Principle, LSP) [x] 6、迪米特法则(Law of Demeter, LoD) [x] 7、合成复用原则(Composite Reuse Principle, CRP) 无版权 可以无限制使用！ all right reserved，powered by Gitbook该文件更新时间： 2020-08-19 17:20:00 "},"chinese/设计模式/模式详解.html":{"url":"chinese/设计模式/模式详解.html","title":"模式详解","keywords":"","body":"依赖倒转原则(Dependency Inversion Principle, DIP) 抽象不应该依赖于细节，细节应当依赖于抽象。换言之，要针对接口编程，而不是针对实现编程。 DIP要求传递参数时或在关联关系中，尽量引用层次高的抽象层类，而不要用具体类。 我们需要针对抽象层编程。将具体类的对象通过依赖注入的方式注入到其他对象中。 依赖注入(DependencyInjection, DI) : 当一个对象要与其他对象发生依赖关系时，通过抽象来注入所依赖的对象。 常用的注入方式有三种： 1、构造注入。通过构造函数来传入具体类的对象； 2、设值注入。通过Setter方法来传入具体类的对象； 3、接口注入。通过在接口中声明的业务方法来传入具体类的对象。 依赖倒置和里氏替换的区别 在大多数情况下，这三个设计原则会同时出现，开闭原则是目标，里氏代换原则是基础，依赖倒转原则是手段，它们相辅相成，相互补充，目标一致，只是分析问题时所站角度不同而已。 1、定义的角度不同。里氏替换原则是关于子类和父类的原则;依赖倒置原则是关于抽象与细节的原则。 2、应用范围不同。依赖倒置原则使用范围更广。 在大多数情况下，OCP、LSP、DIP会同时出现。开闭原则是目标，里氏代换原则是基础，依赖倒转原则是手段，它们相辅相成，相互补充，目标一致，只是分析问题时所站角度不同而已。 单一职责 一个类只负责一个功能领域中的相应职责。 在软件系统中，一个类承担的职责越多，它被复用的可能性就越小。一个类承担的职责过多，就相当于将这些职责耦合在一起，当其中一个职责变化时，可能会影响其他职责的运作。 因此，要将这些职责进行分离，将不同的职责封装在不同的类中。 单一职责原则是实现高内聚、低耦合的指导方针，它是最简单但又最难运用的原则。 高内聚 是指一个模块是由相关性很强的代码组成，只负责一项任务。 低耦合 模块与模块之间，尽可能的使其独立存在。 里氏代换原则(Liskov Substitution Principle, LSP) LSP 是由麻省理工学院计算机科学实验室的Liskov女士提出来的。所以以她的名字命名。 里氏代换原则要求，在软件中将一个基类对象替换成它的子类对象，程序将不会产生任何错误和异常，反过来则不成立。 例如：我喜欢动物，那我一定喜欢狗，因为狗是动物的子类；但是我喜欢狗，不能据此断定我喜欢所有动物。 里氏代换原则是实现开闭原则的重要方式之一，因此在程序中尽量使用基类类型来对对象进行定义，而在运行时再确定其子类类型，用子类对象来替换父类对象。 //在使用LSP时需要注意如下问题： 1、子类的所有方法必须在父类中声明，或子类必须实现父类中声明的所有方法。 因为如果一个方法只存在子类中，在父类中不提供相应的声明，则无法在以父类定义的对象中使用该方法。 2、在运用LSP时，尽量把父类设计为抽象类或者接口，让子类继承父类或实现父接口，并实现在父类中声明的方法， 运行时，子类实例替换父类实例，我们可以很方便地扩展系统的功能，同时无须修改原有子类的代码。 附： 类似 List tempList= new ArrayList() ; ? //申明时用基类List ， 具体实现时用子类ArrayList 。 迪米特法则(Law of Demeter, LoD) 一个软件实体应当尽可能少地与其他实体发生相互作用。 迪米特法则可降低系统的耦合度，当其中某一个模块发生修改时，就会尽量少地影响其他模块。 //所以在类的结构设计上： 1、每一个类都应当尽量降低其成员变量和成员函数的访问权限； 2、在类的设计上，只要有可能，一个类型应当设计成不变类； 3、在对其他类的引用上，一个对象对其他对象的引用应当降到最低。 迪米特法则还有几种定义形式，包括：不要和“陌生人”说话、只与你的直接朋友通信等 其朋友包括以下几类： 1、当前对象本身(this)； 2、以参数形式传入到当前对象方法中的对象； 3、当前对象的成员对象； 4、 如果当前对象的成员对象是一个集合，那么集合中的元素也都是朋友； 5、当前对象所创建的对象。 任何一个对象，如果满足上面的条件之一，就是当前对象的“朋友”，否则就是“陌生人”。 迪米特法则要求我们在设计系统时，应该尽量减少对象之间的交互， 如果两个对象之间不必彼此直接通信，那么这两个对象就不应当发生任何直接的相互作用， 如果其中的一个对象需要调用另一个对象的某一个方法的话，可以通过第三者转发这个调用。 简言之，就是通过引入一个合理的第三者来降低现有对象之间的耦合度。 附： law of Demeter 有些书也译作 “得墨忒耳法则” 。 为什么叫做这个名字，我的猜测是根据\"德墨忒尔\"的故事进行命名的。纯粹猜测 ，读者如果知道正确的原因请留言告知我。谢谢。 开闭原则 一个软件实体应当对扩展开放，对修改关闭。应尽量在不修改原有代码的情况下进行扩展。 //软件实体：可以指一个软件模块、一个由多个类组成的局部结构或一个独立的类。 当软件系统需要面对新的需求时，我们应该尽量保证系统的设计框架是稳定的。如果一个软件设计符合开闭原则，那么可以非常方便地对系统进行扩展，而且在扩展时无须修改现有代码，使得软件系统在拥有适应性和灵活性的同时具备较好的稳定性和延续性。 在Java中，可以为系统定义一个相对稳定的抽象层(抽象类或者接口)，而将不同的实现行为移至具体的实现层中完成。 增加新的具体类来实现新的业务功能，在不修改已有代码的基础上扩展系统的功能。 //注意： 因为xml和properties等格式的配置文件是纯文本文件，编辑后无须编译，因此在软件开发中，一般不把对配置文件的修改认为是对系统源代码的修改。 如果一个系统在扩展时只涉及到修改配置文件，而原有的Java代码没有做任何修改，则可认为该系统是一个符合开闭原则的系统。 合成复用原则(Composite Reuse Principle, CRP) 组合复用原则、聚合复用原则 尽量使用对象组合，而不是继承来达到复用的目的。 在面向对象设计中，可以通过两种方法在不同的环境中复用已有的设计和实现: 1、通过组合/聚合实现 组合/聚合可以使系统更加灵活，降低类与类之间的耦合度。请优先考虑。 2、通过继承实现 继承复用会破坏系统的封装性，因为继承会将基类的实现细节暴露给子类。 由于基类的内部细节通常对子类来说是可见的，所以这种复用又称“白箱”复用。 一般而言，如果两个类之间是“Has-A”的关系应使用组合或聚合； 如果是“Is-A”关系可使用继承。 附： 有一些书上没有列上CRP， 只说“六大设计原则” 。 接口隔离原则(Interface Segregation Principle, ISP) 使用多个专门的接口，而不使用单一的总接口。因为在面向对象编程语言中，实现一个接口就需要实现该接口中定义的所有方法，所以大的总接口使用起来不一定很方便。 //注意： 在使用接口隔离原则时，我们需要注意控制接口的粒度。 1、接口不能太小。接口太小会导致系统中接口泛滥，不利于维护； 2、接口也不能太大。太大的接口将违背接口隔离原则，灵活性较差，使用起来很不方便。 一般而言，接口中仅包含为某一类用户定制的方法即可。 //“接口”往往有两种不同的含义： 对于不同的含义，ISP的表达方式以及含义都有所不同。 1、把接口理解成角色，一个接口只能代表一个角色，每个角色都有它特定的一个接口，此时，这个原也可以叫做“角色隔离原则”。 2、如果把“接口”理解成狭义的特定语言的接口，那么ISP表达的意思是指接口仅仅提供客户端需要的行为。 回调机制 回调的简单理解： A需要做一件事情(不需要立刻知道结果)，给B设置一个回调对象，然后B在条件合适的时候执行得到一个结果， 然后通过A传过来的回调对象告诉A。 1、回调普通使用 1、定义回调接口： public interface IH264StoreFinishCallBack { public void onStoreAndParseFinished( boolean result, String msgStr) ; } 2、设置接口： private IH264StoreFinishCallBack ih264StoreFinishCallBack = new IH264StoreFinishCallBack() { @Override public void onStoreAndParseFinished(boolean result, String msgStr) { if(result) { disMissIosLoading(); } } } ; H264FileSotrPresenter h264FileSotrPresenter = new H264FileSotrPresenter(ih264StoreFinishCallBack); 3、触发回调： if(ih264StoreFinishCallBack!=null) { ih264StoreFinishCallBack.onStoreAndParseFinished(true ,\"切换到照片时自动触发结束录像命令\"); } 2、全局回调的使用方法(结合单例模式) 这种模式可以实现在不同的activity之间传递参数。 1、定义回调函数管理类： /** * Created by Aivin on 2017/5/8. * 单例模式 管理一个回调对象， * 实现两个不同的activity实时通讯 *用户手动改变计量单位后，通知另外一个activity做出相应的改变 */ public class UnitsChangeCallBackManager { private IUnitsModeChangeCallBack iUnitsModeChangeCallBack ; /** *接受传入的回调实例 */ public void setiUnitsModeChangeCallBack(IUnitsModeChangeCallBack iUnitsModeChangeCallBack) { this.iUnitsModeChangeCallBack = iUnitsModeChangeCallBack; } /** * 用户手动改变电池的警报值 * @param type 标记是 哪一个电池被修改 * @param value 具体的修改值 * @param msgStr 拓展字段，备用。 */ public void sendUnitsChangedByUser(int type , int value , String msgStr) { if(iUnitsModeChangeCallBack !=null) { iUnitsModeChangeCallBack.onUnitsModeChange(type , value , msgStr); } }// /**私有化构造函数，防止被其他类实例化*/ private UnitsChangeCallBackManager() { //初始化操作 }// /**使用一个内部类来维护单例 *单例模式使用内部类来维护单例的实现。 *利用jvm提供的机制，加载类的线程互斥的，用来解决多线程访问的时候可能会遇到null的问题。 **/ private static class SingletonFactory { private static UnitsChangeCallBackManager instance = new UnitsChangeCallBackManager(); } /**获取实例,对外提供的接口 */ public static UnitsChangeCallBackManager getInstance() { return SingletonFactory.instance; } /**为了能在序列化过程仍能保持单例的特性，需要添加一个readResolve()方法 */ private Object readResolve() { return getInstance(); } } 2、设置回调： UnitsChangeCallBackManager.getInstance().setiUnitsModeChangeCallBack(this); public void onUnitsModeChange(int type, int value, String msgStr) { switch (type) { case 1: break; case 2: break; } } 3、触发回调： UnitsChangeCallBackManager.getInstance().sendUnitsChangedByUser(1,1 ,\"英尺\"); 中介者模式 Mediator Pattern “中介者模式” 是 “迪米特法则” 的一个典型应用。（不要与陌生人说话）。 同事类之间没有直接显示交流 ，而是通过中介类（定义了行为接口）进行通信。 应用场景： 1、在有些软件中，某些类/对象之间的相互调用关系错综复杂，类似QQ用户之间的关系， 此时，我们特别需要一个类似“QQ群”一样的中间类来协调这些类/对象之间的复杂关系 。 2、 请结合现实生活中的 “中介”进行理解。 房产中介... 优点 1、 简化了对象之间的交互，将原本难以理解的网状结构转换成相对简单的星型结构。 2、 增加新的中介者和新的同事类都比较方便，更好地符合“开闭原则”。 缺点 1、 中介者类中包含了大量同事类之间的交互细节，可能会导致中介者类非常复杂 。 享元模式 Flyweight Pattern 当系统中存在大量相似或相同的对象时，将会导致运行代价过高、OOM 等问题，享元模式正为解决之一类问题而诞生。 注意 1、享元模式在使用时存在线程安全问题，需要考虑线程安全。 2、通常用一个 工厂类 类维护享元对象。 内部状态 Internal State 存储在享元对象内部并且不会随环境改变而改变的状态，内部状态可以共享。 外部状态 External State 随环境改变而改变的、不可以共享的状态。外部状态由客户端保存。 外部状态不可以影响享元对象的内部状态，它们是相互独立的。 缺点 1、对象 需要分离出 内部状态 和 外部状态，这使得程序的逻辑复杂化。 2、读取外部状态使得运行时间变长。 示例 围棋棋盘中包含大量的黑子和白子，它们的形状、大小都一模一样，只是出现的位置不同而已。如果将每一个棋子都作为一个独立的对象存储在内存中，将导致该围棋软件在运行时所需内存空间较大。 class Chessman { /**内部状态*/ private String color; /**外部状态*/ private Point location; public Chessman(String color) { ...} public String getColor() { ... } public String getLocation() { ...} /**更新外部状态 需要主要线程安全*/ public synchronized void updateLocation( Point loation) { ... } } public class ChessmanFactory { /**享元池*/ private static Map map=new HashMap<>(); public static ChessFlyWeight getChess(String color) { if(map.get(color)!=null){ return map.get(color); }else{ Chessman chessman=new Chessman(color); map.put(color, chessman); return chessman; } } } //多次调用 也只创建了一个 Chessman 对象 Chessman chessman=ChessmanFactory.getChess(\"黑色\"); 代理模式（Proxy Pattern） 当无法直接访问某个对象或访问某个对象存在困难时可以通过一个代理对象来间接访问。 关键点：代理对象控制对原对象的引用 。 静态代理 代理类与委托类有同样的接口　。通过代理对象访问目标对象。 1、可以在目标对象实现的基础上,增强额外的功能操作 。(这一点跟装饰者模式一样) 实现自定义的控制策略。 /** * 委托类 实现的接口 */ public interface IUser { /**获取用户信息*/ public String getUserInfo(); } /** * 委托类。对外提供 查询用户信息的功能。 */ public class UserTools implements IUser { public String getUserInfo(){ return \"he is tom\"; } } /** * 代理类。 实现的接口与委托类一模一样。 * 用户通过代理作为中间人去使用原对象拥有的功能。 * 但是真正执行的还是原来的对象。 */ public class UserToolsProxy implements IUser { private UserTools userTools ; public String getUserInfo() { //做授权判断 boolean isTheRightTime = true of false...; if(isTheRightTime) { return userTools.getUserInfo(); }else{ return \"wrong time\"; } } 动态代理 暂时没用过。 在java的动态代理机制中，有两个重要的类或接口，一个是 InvocationHandler(Interface)、另一个则是 Proxy(Class)，这一个类和接口是实现我们动态代理所必须用到的。~ 代理模式和接口回调的区别 跟做iOS的同事曾经讨论过，对方说代理模式和接口回调理解起来差不多。( 可能是iOS的代理的定义不一样?) 我个人认为这两者相差还是比较大的，出发点和定义都不一样。 单例模式（Singleton Pattern） 在Java应用中，单例对象能保证在一个JVM中，该对象只有一个实例存在。 使用场景： 1、某些大型的类创建频繁时会导致很大的系统开销。 2、软件系统中有些地方只能有一个实例，否则会出现各种问题。例如打印机为了避免状态不一致而采用单例模式。 缺点： 1、单例实例的生命周期和软件的生命周期一样长。如果它持有某些对象的引用 ，会导致该对象无法释放。 特点： 1、单例类只能有一个实例。 2、单例类必须自己自己创建自己的唯一实例。 3、单例类必须给所有其他对象提供这一实例。 4、构造方法限定为private，避免了类在外部被实例化，只能通过getInstance()方法访问。（此处不考虑反射机制） 单例模式分二种：饿汉式单例、懒汉式单例。 public class SingleTonBean { /**持有私有静态实例，防止被引用，此处赋值为null，目的是实现延迟加载*/ private static SingleTonBean instance = null ; /**私有化构造函数，防止被其他类实例化*/ private SingleTonBean() { //初始化操作 }// /**使用一个内部类来维护单例 *单例模式使用内部类来维护单例的实现。 *利用jvm提供的机制，加载类的线程互斥的，用来解决多线程访问的时候可能会遇到null的问题。 **/ private static class SingletonFactory { private static SingleTonBean instance = new SingleTonBean(); } /**获取实例,对外提供的唯一接口 */ public static SingleTonBean getInstance() { return SingletonFactory.instance; } /**为了能在序列化过程仍能保持单例的特性，需要添加一个readResolve()方法 */ private Object readResolve() { return getInstance(); } } 饿汉式单例 ： public class SingletonDemo1 { private SingletonDemo1(){ //构造方法是私有 } //饿汉式：被调用之前就自己创建好实例 private static final SingletonDemo1 singleton=new SingletonDemo1(); public SingletonDemo1 getIncetance(){ return singleton; } } 懒汉式单例 ： public class SingletonDemo2 { private static SingletonDemo2 singleton = null; private SingletonDemo2() { // 私有化构造方法 } public synchronized static SingletonDemo2 getIncetance() { if (singleton == null) { // 懒汉式：在调用的时候才实例化对象 singleton = new SingletonDemo2(); } return singleton; } } 使用类的静态方法也可以实现单例模式的效果，分析这两种方案的不同。 1、单例模式可以延迟初始化，有助于优化性能 。 2、待补充。 要点解析 1、单例模式和反序列化的问题 一般来说，一个类实现了Serializable接口，我们就可以将它写入内存然后再从内存中读取组装成一个跟原来一样的对象。此时，内存中存在N（N>=2）个相同的对象。 而单例模式要求JVM中只能有一个类的对象。如果不做特殊处理反序列就会违反单例模式的规则。 /** * 实现readResolve方法，一个class可以直接控制反序化返回的类型和对象引用。 * ObjectInputStream 会检查对象的class是否定义了readResolve方法。 * Method readResolveMethod = getInheritableMethod( cl, \"readResolve\", null, Object.class); */ private Object readResolve() throws ObjectStreamException { return INSTANCE; //直接返回已经存在单例对象，不再组装新的对象。确保唯一性。 } 原型模式 Prototype Pattern 原型模式特点 在于通过 克隆 一个已经存在的实例来返回新的实例，而不是新建实例。被复制的实例就是我们所称的“原型”。 特点 1、模型需要对外暴露自己实现的克隆接口。 使用场景 当创建新的对象实例较为复杂、成本较大时，使用原型模式可以简化对象的创建过程、节约资源。 // 创建原型对象 WeeklyLog log_previous = new WeeklyLog(); log_previous.setDate(\"第12周\"); //调用克隆方法创建克隆对象 WeeklyLog log_new = log_previous.clone(); log_new.setDate(\"第13周\"); 缺点 1、需要为每一个类配备一个克隆方法 ，当对已有的类进行改造时，需要修改源代码，违背了“开闭原则”。 2、如果对象复杂，实现深克隆的时候较麻烦。（每一层对象对应的类都必须支持深克隆）       注： 浅克隆、深克隆的概念请查阅其他资料。本章不予讲解。 命令模式 Command Pattern 类型 特点 命令 Command 有N种。包含具体的接收者。 接收者 Receiver 有N种 。执行具体逻辑的地方 。 请求者 Invoker 1种 。 只负责 接收命令并调用命令的执行方法。 示例 /**调用者 */ public class Invoker { /**接收具体命令 并执行*/ public void executeCmd(Command command) { command.execute(); } } /**具体的命令,例如打开连接 */ public class CommandOpenConnection implements Command { 　　private Receiver receiver; /**命令 和 接收者 绑定*/ 　　public CommandOpenConnection(Receiver receiver) { ...} /**执行命令*/ 　　public void execute() { 　　 receiver.doSomeThing(...); 　　} } /**具体的接收者*/ public class ReceiverOpenConnection implements Receiver { public void doSomeThing(...) { 具体的逻辑.... } } //使用场景 Receiver receiver=... ; Invoker invoker = ...; Command cmd1 = ... ; //Command cmd2 = ... ; // 调用者 更新命令 并发起执行 invoker.executeCmd(cmd1);    优点 1、请求者（Invoker） 和执行者（Receiver） 完全解耦。 2、添加新的命令 符合 “开闭原则” 。 缺点 1、一种命令 对应 一个命令类(xxx.java)。导致 类个数过多 。    命令模式 和 策略模式 的区别 1、命令模式 只是强调解耦合，调用者只是负责发起调用。不同的命令得到不同的处理结果 。 2、策略模式 强调 一个问题可以用多种策略方法来 获得相同的处理结果 。 备忘录模式 Memento Pattern 、快照模式 在不破坏封闭的前提下，保存对象当前状态，并且在需要的时候可以再次恢复到此状态。 数据库的 回滚操作、编辑器的 Ctrl+Z恢复 都有用到 备忘录模式。 如何理解“不破坏封闭的前提” 发起者只提供有限的接口（保存、恢复数据）。不暴露其他不该暴露的信息。 缺点 消耗资源。 /**发起者*/ public class Game { /**游戏开始时间*/ private int time; /**游戏人头数*/ private int killPeople; /** 将信息保存到备忘录*/ public GameInfo saveGameInfo() { ... GameInfo gameInfo= new GameInfo(time, killPeople); return gameInfo; } /** * 根据备忘录 恢复 信息 。 */ public void loadGame(GameInfo gameInfo) { ... time = gameInfo.getTime(); killPeople = gameInfo.getKillPeople(); ... } } /**备忘录角色 ,保存指定的状态信息*/ public class GameInfo { private int time; private int killPeople; public GameInfo(int time, int killPeople) { ... } } //使用 Game dota = new Game(); // 将状态保存到备忘录中 GameInfo info = dota.saveGameInfo(); // 根据备忘录 恢复数据 dota.loadGame(info); 外观模式 Facade Pattern 、门面模式 有一个系统 很大、很复杂，以至于一般的人不会用。即使会用也很麻烦。 这时，我们可以对这个系统做封装 ，让大家通过封装后的接口很方便地使用原来的系统 。 示例 开启电脑 需要经过多个步骤，接通电源、启动BIOS、加载系统等等。显然，用户不需要去操作这么繁琐复杂的流程 。 所以我们给用户暴露了一个简单的接口，只要一按开机键 就可以启动电脑了 。大大减小了系统使用的复杂度。 缺点 1、如果子系统做了修改 ， 外观类可能需要做相应修改。违背了开闭原则。 代理模式 、外观模式 的区别 1、侧重点不同， 代理强调 不直接访问原系统（因为权限等） 。 外观模式 强调 复杂系统的简化。 工厂方法模式（Factory Method Pattern） 又被称为多态工厂模式。 通常我们所说的工厂模式是指工厂方法模式。 工厂方法是针对每一种产品提供一个工厂类。通过不同的工厂实例来创建不同的产品实例。 反射生成对象只能适用一些最简单的情况，简单的创建一个对象。如果对象的创建过程比较复杂，例如要调用有参构造函数、创建之前要配置环境等等，需要将这些代码封装到工厂中。 /** * 定义工厂的公共行为。 * 可以用接口或抽象类。 */ public interface Factory { public Product produceProduct() ; } /** * 具体的产品 car */ public class Car implements Product { @Override public void getProductInfo() { System.out.println(\"汽车产品\"); }// }// /** * 具体的产品 bicycle */ public class Bicycle implements Product { @Override public void getProductInfo() { System.out.println(\"自行车产品\"); }// }// /** * 定义工厂的公共行为。 * 可以用接口或抽象类。 */ public interface Factory { public Product produceProduct() ; } /** * 具体的工厂类。BicycleFactory */ public class BicycleFactory implements Factory { @Override public Product produceProduct() { //做一些复杂的操作。比如连接数据库等 // ... //调用有参构造等 Bicycle bicycle = new Bicycle(); return bicycle; } }// /** * 具体的工厂类。CarFactory */ public class CarFactory implements Factory { @Override public Product produceProduct() { //做一些复杂的操作。比如连接数据库等 // ... //调用有参构造等 Car car = new Car(); return car; } }// /**使用场景*/ public static void main(String[] args) { //根据相关参数 生成具体的工厂对象。例如根据配置文件或者网络参数来决定 Factory factory ; factory= new CarFactory() ; //factory= new BicycleFactory() ; Product product = factory.produceProduct() ; product.getProductInfo(); }// 工厂方法模式优点： 1、它能够让工厂可以自主确定创建何种产品对象，而如何创建这个对象的细节则完全封装在不同的具体工厂内部。 2、加入新产品时，无须修改抽象工厂和抽象产品提供的接口，也无须修改其他的具体工厂和具体产品，而只要添加一个具体工厂和具体产品就可以了。 工厂方法模式缺点： 1、在添加新产品时，需要新加新的具体产品类和与之对应的具体工厂类，在一定程度上增加了系统的复杂度，有更多的类需要编译和运行，会给系统带来一些额外的开销。 策略模式和工厂模式有什么区别 1、侧重点不一样 。 工厂模式侧重构建过程，使用者拿到最终的“生产物”即可。 策略模式侧重 事件的行为，使用可互换的规则创建成功业务。 策略模式是开放的，大多数事情要你自己亲力亲为。而工厂模式作是封闭的，很多事情都帮组你做好了，你直接“点”就可以了。 工厂相当于黑盒子，策略相当于白盒子? 参考资料 建造者模式 Builder Pattern 适用于 构建流程非常复杂的 对象。 定义 将一个复杂对象的构造与它的表示分离，使同样的构建过程可以创建不同的表示。 1、对象的构建：对象的组装生成过程。 2、对象的表示：产品本身。产品的特性。 3、同样的创建过程：指挥者中定义的创建的相同流程。 4、创建不同的表示：不同的创建细节区分在构建者当中，调用不同的构建者会有不同的结果。 具有指挥者的建造者模式 （完整模式） // 具体的构建者 只负责 最后的构建细节。 // 不负责这些细节如何组装 class DevilBuilder extends ActorBuilder{ public void buildType() { ...} public void buildSex() { ... } public void buildFace() { ... } public void buildCostume() {...} public void buildHairstyle() {...} } // 指挥者 只负责构建顺序 class ActorController{ public Product getProduct(ActorBuilder ab) { ab.buildType(); ... ab.buildCostume(); // Product在ActorBuilder的构造函数中创建好 return ab.createAProduct(); } } //测试 // 构建顺序定义在 ActorController 中 ActorController controller = ...; // 产品不同部位的构建能力 定义在 builer 中 ActorBuilder builer=...; //根据构建者不同返回产品不同 Product product = controller.getProduct(builer); 没有指挥者的建造者模式（简略模式） 构建顺序 和构建能力 全部定义在 ActorBuilder 中 class DevilBuilder extends ActorBuilder{ public void buildType() { ...} public void buildSex() { ... } public void buildFace() { ... } public void buildCostume() {...} public void buildHairstyle() {...} public Product getProduct() { buildType(); ... buildCostume(); return createAProduct(); } } 建造者模式 和 工厂模式 的区别 工厂模式与 建造者模式的完整模式相比，就多了一个 指挥者。 不同的构建者的 构建流程 抽象出来放在一起了。 与简略模式相比，我感觉没啥区别。 建造者模式 和 策略模式 的区别 个人感觉只是定义的出发点不同。 从形式上看，都是根据传入不同的策略，获得不同的结果。（一种构建者可以看做一种策略） 抽象工厂模式（Abstract Factory Pattern） 工厂方法模式是一个具体工厂生产一种具体产品，抽象工厂模式是一个具体工厂生产一个品牌下的多种产品。 工厂方法模式解决了简单工厂模式中工厂类职责太重的问题。但由于工厂方法模式中的每个工厂只生产一类产品，可能会导致系统中存在大量的工厂类，势必会增加系统的开销。 此时，我们可以考虑将一些相关的产品组成一个“产品族”，由同一个工厂来统一生产，这就是抽象工厂模式的基本思想。 产品等级结构： 类似手机与androdi手机、mac手机的关系。手机和Android手机、mac手机具体手机产品之间构成了一个产品等级结构。 产品族: 同一个品牌下的各种产品，比如android手机和Android电视属于同一个产品族。 Abstract Factory Pattern优点： 1、隔离了具体类的生成，更换一个具体工厂就变得相对容易。 2、增加新的产品族很方便，无须修改已有系统，符合“开闭原则”。 Abstract Factory Pattern 缺点： 1、增加新的产品等级结构麻烦，违背了“开闭原则”。 增加新的产品族很方便，但是增加新的产品等级结构很麻烦，抽象工厂模式的这种性质称为“开闭原则”的倾斜性。 /** * 抽象产品 *Iphone */ public interface Iphone { public void getInfo(); } /** * 抽象产品 *Iphone */ public interface TV { public void getInfo(); } /** * 具体产品。 */ public class AndroidIphone implements Iphone { @Override public void getInfo() { System.out.println(\"mac 手机\"); } } /** * 具体产品。 */ public class MacIphone implements Iphone { @Override public void getInfo() { System.out.println(\"android 手机\"); } } /** * 具体产品。 */ public class AndroidTv implements TV { @Override public void getInfo() { System.out.println(\" Android 电视\"); } } /** * 具体产品。 */ public class MACTv implements TV { @Override public void getInfo() { System.out.println(\" MAC 电视\"); } } /** * 抽象工厂 */ public interface IFactory { public Iphone createPhone() ; public TV createTV() ; } /** * 具体工厂。 */ public class AndroidFactory implements IFactory { @Override public Iphone createPhone() { return new MacIphone(); } @Override public TV createTV() { return new MACTv(); } } /** * 具体工厂 */ public class MacFactory implements IFactory { @Override public Iphone createPhone() { return new AndroidIphone(); } @Override public TV createTV() { return new AndroidTv(); } } /*** * 测试场景 */ public static void main(String[] args) { IFactory factory = new AndroidFactory() ; //根据配置文件或者网络参数，动态决定采用哪一个工厂。 //IFactory factory = new MacFactory() ; //批量得到属于同一品牌下的产品。 Iphone phone = factory.createPhone() ; TV tv = factory.createTV() ; tv.getInfo(); }// 桥接模式 Bridge Pattern 如果一个类有多个变化维度。此时可以使用继承的方法进行组合 ，但是这样会产生大量的派生类 才能满足要求。 此时我们的桥接模式，采用聚合而非继承的方式 也可以实现同样的效果。但是需要的派生类就大大减少了。 抽象部分 、实现部分 概念参考自刘伟 。 假如一个类有两个独立的纬度，我们将与这个类关系最密切、最本质的那个纬度 称之为 “抽象部分”。而另外的一个纬度称之为“实现部分” 。 例如 一支毛笔，有“大小型号” 和\"能绘制的颜色\" 两个纬度 。因为毛笔一旦生产它的大小型号就已经被固定了，而能绘制的颜色可以根据沾染的涂料不同而变化。 所以， “型号”这个纬度划分为 “抽象部分” ，“颜色”划分为 “实现部分” 。 示意图 采用继承的方式去实现效果。需要较多的派生类。 采用桥接的方式去实现效果。型号和颜色互相组合即可实现。 //实现部分 public class Color{ String color=\"\"; public Color(String color) {...} } // 抽象部分 public class Size { Color color; String size =\"大号\" ; public Size(Color color){...} public void disPlay() { System.out.println(size+\" \"+ color.color+ \" 笔\"); } } //组合 Color white =new Color(\"白色 \"); Size size = new Size(white); size.disPlay(); //获得 大号白色笔 模板模式 、模板方法模式 、Template Method Pattern 模板方法使得子类可以在不改变算法结构的情况下，重新定义算法中的某些步骤。 为防止恶意操作，一般模板方法都加上 final 防篡改。 示例 /**抽象类*/ public abstract class AbstractComputer { /**开机*/ protected void powerOn() { ... } /**常规硬件检查*/ protected void checkHardware() { ...} /**加载 操作系统*/ protected void loadOS() { ...} /**默认无密码验证，直接进入系统*/ protected void login() { ... } /** * 模板方法，用 final修饰，防止被篡改 算法流程。 */ public final void startUp() { //公共方法 powerOn(); //有差异性的方法 checkHardware(); //公共方法 loadOS(); //有差异性的方法 login(); } } // 程序员的电脑 CoderComputer extends AbstractComputer... @Override protected void login() { // 验证用户名和密码 } //军用计算机 class MilitaryComputer extends AbstractComputer... @Override protected void checkHardware() { //进行 硬件防火墙 等安全设备是否正常 ... } @Override protected void login() { //验证 指纹 、 用户名、密码等 } AsyncTask 应用 模板方法 @MainThread public final AsyncTask execute(Params... params) { return executeOnExecutor(sDefaultExecutor, params); } @MainThread public final AsyncTask executeOnExecutor( Executor exec, Params... params) { ... onPreExecute(); ... exec.execute(mFuture); return this; } 状态模式 State Pattern 某种业务情况下，确实可以用 if else 来完成 ，但是由于 不同状态下的处理方法不一样。会导致大量的 if else 代码。 会造成代码复杂，不易维护等问题。 此时可以考虑用 状态模式 解决。 示例 一个订单的状态： 未支付、正在支付、已支付、申请退款，退款中，退款完成 //直接采用简单的 if else 方式 public void 支付（） { if(未支付) { //处理 支付操作 }else if(正在支付){ //提示 不符合操作条件。 } else if(退款完成){ //提示 不符合操作条件。 } } public void 退款（） { if(未支付) { //提示 不符合操作条件。 }else if(正在支付){ //提示 不符合操作条件。 } else if(退款完成){ //提示 不符合操作条件。 }else if(已支付){ // 处理退款操作.. } } //如果要新增 一个 \"退款审核\"状态 。 //此时需要去修改以上所有的 if else ,严重破坏 开闭原则 。 //采用状态模式 /**未支付状态*/ public class NoPayStatus { public NoPayStatus(Order order,String name) { //初始化订单信息 } public OrderStatus processOrder(Order order) { //处理当前状态下的订单， ... //根据处理结果，设置订单新的状态 OrderStatus state=new PayStatus(order,\"已支付\"); order.setStatus(state); return state; } } /**申请退款*/ public class ApplyDrawbackStatus { private Order order; private String name; public ApplyDrawbackStatus(Order order, String name) { //初始化订单信息 } @Override public OrderStatus processOrder(Order order) { //处理当前状态下的订单， ... //根据处理结果，设置订单新的状态 return new DrawbackStatus(order, \"订单回款中\"); } } //使用场景 //某个时刻根据情况根据具体情况给订单设置状态 Order order=new Order(); order.setStatus( 某个状态); .... //在另一个时刻，处理订单。 OrderStatus status=order.getStatus(); status.processOrder(order); 缺点 并没有完全符合 开闭原则 。 @Override public OrderStatus processOrder(Order order) { //如果要新增 一个 \"退款审核\"状态 。 //也需要修改相关代码 //return new DrawbackStatus(order, \"订单回款中\"); return new CheckDrawbackStatus(order, \"退款审核中\"); }       策略模式 和 状态模式 的区别 1、策略模式只是一个解决方案的封装 。重在外部对策略的选择或动态的切换。策略模式每个算法是相对独立的。 2、状态模式是初始化一个状态，之后的每个状态的变化都会指定下一个状态。状态模式中每个状态是存在相互转化的， 策略模式 Strategy Pattern /**抽象接口，定义共同操作*/ public interface Strategy { public double getValue(double paramA, double paramB); } /*** * 加法策略 */ public class AddStrategy implements Strategy { @Override public double getValue(double paramA, double paramB) { return paramA + paramB; } }// /*** * 减法策略 */ public class SubStrategy implements Strategy { @Override public double getValue(double paramA, double paramB) { return paramA - paramB; } }// /** * 根据传入的策略类型返回计算结果。 辅助类。 */ public class CalcClient { private Strategy strategy; public void setStrategy(Strategy strategy) { this.strategy = strategy; } public double calc(double paramA, double paramB) { return this.strategy.getValue(paramA, paramB); } } /////////////// 演示 ///////////////////// public static void main(String[] args) { double paramA = 5; double paramB = 21; //用if-else实现 （ 普通形式） System.out.println(\"普通方法-加法结果是：\" + calc(\"+\", paramA, paramB)); System.out.println(\"普通方法-减法结果是：\" + calc(\"-\", paramA, paramB)); //System.out.println(\"乘法结果是：\" + calc(\"*\", paramA, paramB)); //System.out.println(\"除法结果是：\" + calc(\"/\", paramA, paramB)); //策略模式 System.out.println(\"策略模式-加法结果是：\" + calc(new AddStrategy(), paramA, paramB)); System.out.println(\"策略模式-减法结果是：\" + calc(new SubStrategy(), paramA, paramB)); //System.out.println(\"乘法结果是：\" + calc(new MultiStrategy(), paramA, paramB)); //System.out.println(\"除法结果是：\" + calc(new DivStrategy(), paramA, paramB)); } /*** * 用if-else实现 （ 普通形式） */ public static double calc(String op, double paramA, double paramB) { if (\"+\".equals(op)) { return paramA + paramB; } else if (\"-\".equals(op)) { return paramA - paramB; } else if (\"*\".equals(op)) { return paramA * paramB; } else if (\"/\".equals(op)) { return paramA / paramB; } else { throw new IllegalArgumentException(\"未找到计算方法!\"); } } /*** * 策略模式 实现 */ public static double calc(Strategy strategy, double paramA, double paramB) { CalcClient calc = new CalcClient(); calc.setStrategy(strategy); return calc.calc(paramA, paramB); } 前者通过简单的if-else来解决问题，在解决简单问题事会更简单、方便; 后者则是通过给予不同的具体策略来获取不同的结果，对于较为复杂的业务逻辑显得更为直观，扩展也更为方便。 策略模式的优缺点： 优点： 1、结构清晰明了、使用简单直观。 2、耦合度相对而言较低，扩展方便。 3、操作封装也更为彻底，数据更为安全。 缺点： 1、随着策略的增加，子类也会变得繁多。 简单工厂模式（Simple Factory Pattern） 又叫做静态工厂方法（StaticFactory Method）模式。 注：简单工厂模式实际上不属于23个GOF模式。 工厂类根据传入的参量,动态的决定应该创建出哪一个产品类的实例的设计模式。一个工厂可以生产多种产品。 优点 使用者不需要去负责具体的创建过程，只需要向工厂传递参数信息就可以获得自己想要的产品。 缺点： 因为工厂类集中了所有实例的创建逻辑， 如果需要增加新的产品，就需要修改工厂类，不利于代码的维护。违背了“开闭原则” 。所以不推荐使用这种设计模式。 客户很爽，工厂很被动。 //demo: /** * 产品抽象类，定义产品共同的特效 */ public interface Product { public void getProductInfo() ; } /** * 具体的产品 car */ public class Car implements Product { @Override public void getProductInfo() { System.out.println(\"汽车产品\"); }// }// /** * 具体的产品 bicycle */ public class Bicycle implements Product { @Override public void getProductInfo() { System.out.println(\"自行车产品\"); }// }// /** * 简单工厂。 */ public class SimpleFactory { /** * 根据不同的参数进行判断，返回不同的结果。 * 如果增加了产品类，需要修改判断代码。 * 静态工厂方法 的“静态”体现在这个 static方法上 */ public static Product getProductInfo(String productType ) { Product product = null ; if(\"car\".equals(productType)){ product = new Car() ; }else{ product = new Bicycle() ; } return product; }// } /** * 测试场景 */ public static void main(String[] args) { //直接调用工厂类的 静态方法或的产品。 Product product =SimpleFactory.getProductInfo(\"car\") ; product.getProductInfo() ; }// 组合模式 Composite Pattern 、 整体-部分模式 组合模式将一批有共同特征的对象组合成 “树形结构”。 关键点是定义了一个抽象构件类，它既可以代表叶子，又可以代表容器，而客户端针对该抽象构件类进行编程，无须知道它到底表示的是叶子还是容器，可以对其进行统一处理。 透明组合模式 （推荐使用） 强调透明性一致性。 因为叶子节点不存在子节点，所以一些方法是无效的。可以用过 “提供异常处理或相关提示”来解决 。 安全组合模式 /**抽象节点 */ abstract class AbstractFile { public abstract void add(AbstractFile file); public abstract AbstractFile getChild(int i); public abstract void killVirus(); } /**叶子节点*/ class ImageFile extends AbstractFile { private String name; public ImageFile(String name) { ...} public void add(AbstractFile file) { // 子节点 不支持 当前方法 的相关提示 } public AbstractFile getChild(int i) { // 子节点 不支持 当前方法 的相关提示 return null; } public void killVirus() { //模拟杀毒 ... } } /**容器节点*/ class Folder extends AbstractFile { private ArrayList fileList=new ArrayList<>(); private String name; public Folder(String name) {...} public void add(AbstractFile file) { fileList.add(file); } public AbstractFile getChild(int i) { return (AbstractFile)fileList.get(i); } public void killVirus() { //递归调用 for(AbstractFile obj : fileList) { obj .killVirus(); } } } //使用 。针对抽象构件编程 // 子节点 AbstractFile folder2 = new Folder(\"图像文件夹\"); folder2.add(new ImageFile(\"xxx.jpg\")); folder2.add(new ImageFile(\"xxxx.gif\")); // 容器节点 AbstractFile file1 = new Folder(); folder1.add(folder2); folder1.killVirus(); 优点 1、将对象们进行树形分层，方便对整个某个层次的所有对象进行处理。 2、使用透明组合模式时， 新增节点(容器节点、子节点) 符合 “开闭原则” 。 装饰者模式 、Decorator Pattern 、包装模式 、Wrapper Pattern 在不改变一个对象原有结构和功能的前提下，给它新加一些额外的功能。 装饰模式是一种用于替代继承的技术。 /**被装饰的原始对象*/ public class ConcreteComponent extends MyComponent { /**原有功能*/ @Override public void operation() { ... } } 透明装饰模式 (尽量使用这种方式) 要求完全针对抽象编程。可以透明地使用装饰之前的对象和装饰之后的对象。 为了达到这种效果， 必须在构件对象的方法中调用 增强方法。 但是缺点是用户不能单独地调用那些增强的方法 。 /**具体装饰器*/ public class ConcreteDecoratorA extends MyComponent { MyComponent component ; /**持有被装饰的对象*/ public ConcreteDecoratorA(MyComponent component) { ... } public int operationA(){ ... 增强方法 ... } @Override public void operation() { // 区别点！！里面调用了 operationA（） operationA(); component.operation(); } } MyComponent myComponet1= new ConcreteComponent(...); // 针对MyComponent抽象编程 MyComponent myComponet2 = new ConcreteDecoratorA(myComponet1); myComponet1.operation(); //不能在外面调用额外功能 。- 编译 出错 myComponet2.operationA(); myComponet2.operation(); 半透明装饰模式 /**具体装饰器*/ public class ConcreteDecoratorA extends MyComponent { MyComponent component ; /**持有被装饰的对象*/ public ConcreteDecoratorA(MyComponent component) { ... } public int operationA(){ ... 增强方法 ... } @Override public void operation() { // 区别点！！ 在里面并没有调用 operationA() component.operation(); } } MyComponent myComponet1= new ConcreteComponent(...); ConcreteDecoratorA myComponet2 = new ConcreteDecoratorA(myComponet1); //透明装饰者模式 myComponet1.operation(); // 可以在外 调用增强方法 - 编译ok myComponet2.operationA(); myComponet2.operation(); 如何理解 “半透明装饰模式不能实现对同一个对象的多次装饰” 首先明确一点：半透明装饰模式 是将 增强方法 和原有方法 独立开来的。在装饰器中 原有方法并没有调用过增强方法。 因为装饰类持有的是 MyComponent 类型的引用，而 MyComponent 并不能调用增强方法。所以导致如下结果： 多次装饰的情况下，无法使用那些增强方法。 代理模式 与 装饰者模式 区别 代理模式的目标是控制对被代理对象的访问（强调控制） ，而装饰模式是给原对象增加额外功能 （强调增加功能）。 观察者模式 Observer Pattern 观察者模式 1、Observer Pattern用于建立一种对象与对象之间的依赖关系。 一个对象发生改变时将自动通知其他对象，其他对象将相应作出反应。 2、Observer Pattern包含1个观察目标和n(n>=1)观察者两类对象。一旦观察目标的状态发生改变，所有的观察者都将得到通知。 3、这种交互也称为发布-订阅(Publish-Subscribe)。 发布者发出通知时并不需要知道谁是它的观察者，可以有任意数目的观察者订阅它并接收通知。 4、凡是涉及到一对一或者一对多的对象交互场景都可以使用观察者模式。 观察者模式的应用 1、交通信号灯是汽车（驾驶员）的观察目标，而汽车是观察者。 随着交通信号灯的变化，汽车的行为也将随之而变化，一盏交通信号灯可以指挥多辆汽车。 2、在当前流行的MVC架构中也应用了观察者模式，它包含三个角色：模型(Model)，视图(View)和控制器(Controller)。 其中模型可对应于观察者模式中的观察目标，而视图对应于观察者，控制器可充当两者之间的中介者。 当模型层的数据发生改变时，视图层将自动改变其显示内容。 观察目标 Observer Pattern中，发生改变的对象称为观察目标。 观察者 而被通知的对象称为观察者。 1、一个观察目标可以对应多个观察者。 2、这些观察者之间可以没有任何相互联系。 3、可以根据需要增加和删除观察者，使得系统更易于扩展。 Observer Pattern优点 1、观察者模式可以实现表示层和数据逻辑层的分离，定义了稳定的消息更新传递机制，并抽象了更新接口，使得可以有各种各样不同的表示层充当具体观察者角色。 2、观察者模式在观察目标和观察者之间建立一个抽象的耦合。观察目标只需要维持一个抽象观察者的集合，无须了解其具体观察者。 3、观察者模式支持广播通信，观察目标会向所有已注册的观察者对象发送通知，简化了一对多系统设计的难度。 4、观察者模式满足“开闭原则”的要求，增加新的具体观察者无须修改原有系统代码，而且观察目标和观察者没有紧密地耦合在一起，因此它们可以属于不同的抽象化层次。在具体观察者与观察目标之间不存在关联关系的情况下，增加新的观察目标也很方便。 Observer Pattern缺点： 1、若一个观察目标对象有很多直接和间接观察者，将所有的观察者都通知到会耗时过多。 2、若观察者和观察目标之间存在循环依赖，观察目标会触发它们之间进行循环调用，可能导致系统崩溃。 3、Observer Pattern没有相应的机制让观察者知道所观察的目标对象是怎么发生变化的，而仅仅只是知道观察目标发生了变化。 Observer Pattern应用场景 1、邮件订阅和RSS订阅，当我们浏览一些博客或wiki时，当你订阅了该文章，如果后续有更新，会及时通知你。 demo: /** * 观察者抽象类，定义共同的行为 */ public interface Observer { public void update(); } /*** * 具体的观察者 1 */ public class Observer1 implements Observer { @Override public void update() { System.out.println(\"观察者 1收到通知\"); } }// /*** * 具体的观察者 2 */ public class Observer2 implements Observer { @Override public void update() { System.out.println(\"观察者 2收到通知\"); } }// /** * 被观察者接口。 * 定义一些 方法用来管理 观察者集合。 */ public interface Subject { /**添加观察者*/ public void addObserver(Observer observer) ; /**删除观察者*/ public void delObserver(Observer observer) ; /**通知观察者*/ public void notifyAllObservers(); }// /*** * 具体的 被观察者 （观察目标）。 */ public class MySubject implements Subject { /**线程安全的集合*/ private Vector myObservers ; /**构造函数*/ public MySubject () { myObservers = new Vector(); } @Override public void addObserver(Observer observer) { myObservers.add(observer) ; } @Override public void delObserver(Observer observer) { myObservers.remove(observer) ; } @Override public void notifyAllObservers() { //使用迭代器获取所有观察者 并通知 Iterator iterator = myObservers.iterator() ; while (iterator.hasNext()) { Observer observer = iterator.next(); observer.update(); }// }// } /**实际场景应用*/ public static void main(String[] args) { Observer1 ob1 = new Observer1() ; Observer2 ob2 = new Observer2() ; MySubject mySubject = new MySubject() ; mySubject.addObserver(ob1); mySubject.addObserver(ob2); mySubject.notifyAllObservers() ; }// 解释器模式 Interpreter Pattern 还未完全理解。 等过段时间再来更新.... 解释器模式为自定义语言的设计和实现提供了一种解决方案，它用于定义一组文法规则并通过这组文法规则来解释自定义语言中的句子。 #### 应用场景 1、正则表达式解释器 2、SQL语法的解释器 相关概念 特点 举例 终结符（表达式） 不可拆分的最小元素。 一个语法的规则不能改变终结符。 x -> xa a是终结符 非终结符（表达式） 可拆分元素。 非终结符是可以被取代的元素。运算符也是非终结符 x -> xa x 是非终结符 语言的文法规则 即语法规则。拥有自己的表达式和结构。 抽象语法树(Abstract Syntax Tree, AST) 用来直观地表示语言的构成。 每一棵抽象语法树对应一个语言实例。 终结符表达式类的实例作为树的叶子节点，非终结符表达式类的实例作为非叶子节点。 通过对抽象语法树的分析，可以识别出语言中的终结符类和非终结符类。 环境角色 存放文法中各个终结符所对应的具体值 #### 示例 Java无法直接解释类似“1+ 2 + 3 – 4 + 1”这样的字符串。 我们可以自己定义 一个解释器来解释这个语句 。 一些重复发生的问题，比如加减乘除四则运算，但是公式每次都不同，有时是a+b-cd，有时是ab+c-d，等等等等个，公式千变万化，但是都是由加减乘除四个非终结符来连接的，这时我们就可以使用解释器模式。 ``` ~~#### 缺点 1、 执行效率低。 2、 维护困难。~~ # 访问者模式 Visitor Pattern 访问者模式把 数据结构 和 作用于结构上的操作 解耦合 。适用于数据结构相对稳定算法又易变化的场景。 ## [示例](https://blog.csdn.net/lovelion/article/details/7433576) 以公司员工和部门的关系为场景。 ```java /**全职员工*/ public class FulltimeEmployee implements Employee { public FulltimeEmployee(String name, int workTime) {...} /**每个对象都会实现这个方法*/ @Override public void accept(Department handler) { //每个访问者都会有这个方法 handler.visit(this); } } /**人力资源部类：具体访问者类*/ public class HRDepartment implements Department { /**所有访问者都会重载 所有 visit方法*/ @Override public void visit(FulltimeEmployee employee) { ... } /***所有访问者都会重载 所有 visit方法 */ @Override public void visit(ParttimeEmployee employee) { ... } } //使用。访问者不同，会做出不同的处理结果 Employee employee = new FulltimeEmployee(...); Department dep = new HRDepartment(....) ; //Department dep = new FADepartment (....) ; employee.accept(dep); 优点 1、方便定义 新的访问者，实现新的数据操作。 //Department dep = new HRDepartment(....) ; //定义新的访问者 Department dep = new FADepartment (....) ; 缺点 1、违背了\"依赖倒置原则\" 。访问者依赖的是具体元素，而不是抽象元素。 public void visit(FulltimeEmployee employee) { ... } 2、增加新的元素类比较困难。 每增加一个元素类 , 访问者就要多加一个visit()。 // 有 n个元素类 就有 n 个visit 方法 @Override public void visit(FulltimeEmployee employee) { ... } .... @Override public void visit(ParttimeEmployee employee) { ... }    访问者模式 和 策略模式 的区别 我个人感觉这两个模式差不多。 个人体会到的区别： 1、策略模式是通过构造方法将策略传进去的 。 访问者模式 是通过普通的方法 accept() 将访问者（策略）传进的。 2、 体现在定义架构上 public class HRDepartment implements Department { @Override public void visit(FulltimeEmployee employee) { ... } ... @Override public void visit(ParttimeEmployee employee) { ... } } 责任链模式 Chain of Responsibility Pattern 其实 ，swith 、if-else 体现了最简单的责任链思想 。只是这种写法 比较臃肿、耦合度高。 优点 1、一个请求沿着一条“链”传递，申请者不需要知道是谁来批准这个请求。 批阅者也不需要这个请求来自谁。 这样将 申请者和批阅者优雅地解耦了。 2、容易拓展责任链 缺点 1、需要对链中责任人的遍历，如果责任人太多那么遍历必定会影响性能。 2、请求不一定会被处理掉。 代码示例 /**责任人的处理方法*/ public void handleRequest(ProgramApe ape){ if ( 有处理权限) { // 自己处理掉... } else { if (null != mSuperiorLeader) { //如果自己没有权限处理， 就交给上级处理 } else { //如果自己没有权限处理， 也没有其他领导。就抛出错误，提示该 //请求没有被处理掉 } } } //应用场景 //先来一个程序猿 这里给他一个三万以内的随机值表示需要申请的差旅费 ProgramApe ape = new ProgramApe((int) (Math.random() * 30000)); //再来四个领导 Leader leader = new GroupLeader(); Leader director = new Director(); Leader manager = new Manager(); Leader boss = new Boss(); //事先设置好 责任链之间的连接关系 leader.setLeader(director); director.setLeader(manager); manager.setLeader(boss); // 提交申请（不用写 if else 繁琐代码） leader.handleRequest(ape); 迭代器模式 Iterator Pattern 、游标模式 迭代器模式 提供一种机制 遍历一个聚合对象中的各个元素，而又不暴露其他细节。 /**具体迭代器*/ class ConcreteIterator implements MyIterator{ private List list = new ArrayList (); private int cursor =0; public ConcreteIterator(List list){ this.list = list; } public boolean hasNext(){ return !(cursor == list.size()); } public Object next(){ if(hasNext()){ return list.get(cursor++); } return null; } } /**具体的聚合类*/ class ConcreteAggregate { private List list = new ArrayList(); public MyIterator iterator(){ return new ConcreteIterator(list); } /** * 聚合类中的其他方法 ，处理其他逻辑 * fun1 、saveObj 、removeObj */ public void saveObj(Object obj) { ... } ... 其他逻辑... } //使用 // 聚合类 ConcreteAggregate ag = new ConcreteAggregate(); ag.saveObj(\"obj1\"); ag.saveObj(\"obj2\"); // 获取迭代器 MyIterator it = ag.iterator(); //根据迭代器 遍历 while(it.hasNext()){ ... } 优点 1、将聚合类 的 “数据存储” 和 \"数据遍历\" 分离 。 2、自定义的迭代器可以实现一些自己想要的遍历效果（逆序遍历、只遍历符合自己指定条件的对象等）。 缺点 1、一个具体的聚合类 对应一个 迭代器 ，略显繁琐。 注 由于java已经为我们对容器对象（Collection，List、Set、Map等）做了很好的封装，我们平时其实很少会自己实现迭代器模式。 适配器模式 Adapter Pattern 解决接口不兼容的问题。 A 需要 C接口， 但是系统只提供了B接口。 同时, A 和B 都不想改或者不能改。 如果，我们将B封装一下，改成C接口的规范。就解决了问题。 被适配者 ：即源接口 一、类适配器 （不推荐） 采用继承方案。 // 旧接口 提供220V电压 public class Voltage220 { public int output220V() { return 220; } } // 用户需要 5V的电压 public interface Voltage5{ int output5V(); } //新建适配器 public class VoltageAdapter extends Voltage220 implements Voltage5 { @Override public int output5V() { //获得旧接口的数据， 转换成用户需要的数据 int src = output220V(); return src / 44; } } 二、对象适配器 （推荐） 采用持有方案。 // 新建适配器 public class VoltageAdapter2 implements Voltage5 { private Voltage220 mVoltage220; public VoltageAdapter2(Voltage220 voltage220) {...} @Override public int output5V() { int src = mVoltage220.output220V(); return src / 44; } } 三、缺省适配器 、接口适配器模式（推荐） 原接口是 interface 。 // 原接口 public interface AnimatorPauseListener{ void onAnimationStart(Animator animation); void onAnimationEnd(Animator animation); ... void onAnimationResume(Animator animation) ; } // 新建适配器 public abstract class AnimatorListenerAdapter implements AnimatorListener { @Override public void onAnimationEnd(Animator animation){...} @Override public void onAnimationStart(Animator animation){...} @Override public void onAnimationResume(Animator animation) {...} } // 使用 XXX.addListener(new AnimatorListenerAdapter() { @Override public void onAnimationStart(Animator animation) { // 重新 需要的那个方法就行。 // 而不必 要实现 interface 中所有的方法，从而简化代码 } }); 四、双向适配器 （不推荐） 同时持有原接口和旧接口的对象。 class Adapter implements DesInterface,SrcInterface { private Des des; private Src src; public Adapter(Des des) {... } public Adapter(Src src) {...} public void() func1(){ src.xxx(); }; public void() func2(){ des.xxx(); }; } Android 中 常用的设计模式 单例模式 // 建造者模式 Builder // AlertDialog.Builder 观察者模式 // Rxjava ， 适配器模式 // 解决接口不兼容的问题 ，两个系统的接口不一样，我继承旧接口,然后... 代理模式 // 源码中 有大量用到 ActivityManagerProxy , AMS 无版权 可以无限制使用！ all right reserved，powered by Gitbook该文件更新时间： 2020-12-17 17:26:07 "},"chinese/设计模式/mvc等.html":{"url":"chinese/设计模式/mvc等.html","title":"mvc等","keywords":"","body":"常用架构 MVC 架构 1979年，Trygve Reenskaug 在Smalltalk-80系统上首次提出了MVC的概念， 最初的时候叫做Model-View-Controller-Editor。 MVC并不是一种设计模式，不在23种经典设计模式中。 可以理解为 MVC是一种架构模式，一种架构可能 运用到了多种设计模式。 Model 模型 适合做一些业务逻辑处理，比如数据库存取操作，网络操作，复杂的算法，耗时的任务等都在model层处理。 View 视图 处理数据显示的部分，XML布局可以视为V层，显示Model层的数据结果。 Controllor 控制器 处理用户交互问题。 mvc 优点 、缺点 // 优点 1、实现了分层开发 ,降低了代码的耦合 // 缺点 1、增加了代码编写的复杂性 2、MVC中 允许 M 层 和 V 层进行交互 ，解耦合不够彻底 MVP 架构 Model 业务逻辑和实体模型层 View 视图展示层。 V层没有任何的逻辑部分又不用主动监听数据，被称之为“被动视图”。 Presenter 负责view和model层的交互。 mvp 特点 于mvc相比，mvp有以下特点 1、 M 层和 V 层只能通过 P 层进行交互 2、V 层和 P 层通过接口进行交互 3、一个复杂的 V 层可以对应多个 P mvp 优点 、缺点 // 优点 1、相对mvc解耦更彻底 // 缺点 1、多了很多接口文件。 繁多的接口，繁琐的接口通信 , 在实际的开发过程中，很难严格遵循。 MVVM 、 MV-VM 架构 MVVM架构在一定程度上减少了MVP存在的以下缺点。 1、P 层与 V 层是通过接口进行交互的，接口粒度不好控制。 粒度太小，就会存在大量接口的情况，使代码太过碎版化; 粒度太大，解耦效果不好。 2、V 层与 P 层还是有一定的耦合度。 一旦 V 层某个UI元素更改，那么对应的接口就必须得改， 数据如何映射到UI上、事件监听接口这些都需要转变，牵一发而动全身。 3、复杂的业务同时也可能会导致 P 层太大。虽然可以 一个 V 对应 多个 P 。 MVVM模块 模块 说明 M Model 数据提供 V View 视图展示 VM ViewModel M 和 V 绑定 ， 监听数据变化，一旦有改变，就响应到另一方 mvvm的缺点 2、引入新框架，增加学习成本。 3、通过 数据绑定的方式 ，出现问题 ，不容易调试。 MVVM 实现数据绑定、完全解耦的原理 在安卓中，DataBinding 是 谷歌提供的一个工具， 可以将 V 和 M 进行数据绑定 。 能实现数据绑定的原因，我猜测是框架采用了 观察者模式 实现数据驱动， DataBinding 具体源码我暂时还未看过，只能是猜测 。 其他方向，例如前端也有类似的框架，例如 Vue.js DataBinding 完全解耦的方案中 ，如何管理生命周期 可以使用 谷歌的 LiveData 。 LiveData 具有生命周期感知能力，意指它遵循其他应用组件（如 Activity、Fragment 或 Service）的生命周期。 这种感知能力可确保 LiveData 仅更新处于活跃生命周期状态的应用组件观察者。 总结 1、MVC中 允许 M 层 和 V 层进行交互 ，耦合太高，不合理。 2、MVP 中 ， P 层与 V 层还是有一定的耦合度。还不够完美。 3、MVVM ，通过数据绑定的方式，实现数据监听 ，完全解耦。 无版权 可以无限制使用！ all right reserved，powered by Gitbook该文件更新时间： 2020-12-18 08:20:03 "},"chinese/数据结构/常用数据结构.html":{"url":"chinese/数据结构/常用数据结构.html","title":"基本算法","keywords":"","body":"常用数据结构 Hash 、Hash碰撞 // Hash 是一种信息摘要算法，一般用于验证完整性，它还叫做哈希、散列。我们平时使用的MD5,SHA1,SSL中的公私钥验证都属于Hash算法。 // Hash碰撞 好的Hash算法可以出计算几乎出独一无二的HashCode，如果出现了重复的hashCode，就称作碰撞; 不过就算是MD5这样优秀的算法也会发生碰撞，即两个不同的key也有可能生成相同的MD5。 哈希表 Hashtable Hashtable 和 HashMap 的内部数据结构相似。 // HashMap 和 Hashtable 的区别 Hashtable 已经被淘汰了,不用关注太多细节。 知道以下几个区别就好了。 1、HashMap可以允许key为null，value为null，Hashtable 都不允许为null 。 2、HashMap 没有提供同步机制，是线程不安全的，需要自己在外面写同步代码，Hashtable 部分方法上有自己的 synchronize 同步，是线程安全的。 3、父类不一样 ， 各自拥有的方法不完全一样 ， 扩充机制不一样 。 HashMap Hashtable和HashMap的内部数据结构相似. HashMap由数组+链表组成的，数组是HashMap的主体，链表则是主要为了解决哈希冲突而存在的。 HashMap中的链表出现越少，性能才会越好。当链表较长时，又会引入红黑树来解决性能问题。 // HashMap存储的步骤put（K,V） 传入key和value，计算key的hash值，根据hash值搜索在哈希表table中的索引位置， 若当前索引位置不为null，则对该位置的Entry链表进行遍历， 如果链中存在该key，则用传入的value覆盖掉旧的value，同时把旧的value返回。 入股链中不存在该key，就用key-value创建一个新的节点，并把该节点插入到该索引对应的链表的头部 // HashMap 如何解决 Hash碰撞问题的 根据不同的key 计算得到 hash值，如果有碰撞，就进入当前hash值索引对应的 链表中， 在同一条链表中 根据 不同的 key 来存储不同的 value值。 // HashMap的读取实现get（key，value） 读取的步骤比较简单，调用hash（key）求得key的hash值，然后调用indexFor（hash）求得hash值对应的table的索引位置，然后遍历索引位置的链表，如果存在key，则把key对应的Entry返回，否则返回null // HashMap键的遍历，keySet() HashMap遍历时，按哈希表的每一个索引的链表从上往下遍历。 // 缺点 1、在移动设备端内存资源很珍贵，HashMap为实现快速查询带来了很大内存浪费。 2、ArrayMap是非线程安全的类 。 android 对 HashMap 的优化 ArrayMap ArrayMap是Android api提供的 ，Android里的Bundle内部就是ArrayMap 。 ArrayMap有两个数组 。第一个数组存放存放item的hash值，第二数组是把key，value连续的存放在数组里， 通过先算hash在第一个数组里找到它的hash index，根据这个index在去第二个数组里找到这个key-value。 // ArrayMap 如何解决哈希碰撞问题的。（以下结论是我猜测的） 1、存储 如果产生了相同的哈希值了，如果他的key是相同的，就把key对应的value修改。如果key 不同，就会把当前哈希值也保存在哈希数组中(此时数组中有相同的哈希值)。 2、读取 由于存在hash碰撞的情况，而二分法查找到下标可能是多个连续相同hash值中的任意一个， 所以此时需要用equals比对对命中的Key对象是否相符，不相符时，从当前index先向后再向前遍历所有相同hash。 3、注意比较 与 HashMap解决哈希冲突方法的区别。 // 比 HashMap 更省内存。 ArrayMap 相对于 HashMap ，无需为每个键值对创建Node对象， 这就是为什么ArrayMap相对HashMap要节省空间。 // 缺点 1、ArrayMap查找时间复杂度O(logN)；HashMap查找、修改的时间复杂度为O(1)； 2、ArrayMap增加、删除操作需要移动成员，速度相比较慢 。 SparseArray 在 Android 中，IDE会提醒我们应该使用 SparseArray 替换掉 HashMap，其根本原因就在于 SparseArray 相比较 HashMap 会更省内存。 // 更省内存 1、SparseArray 对应的key只能是int类型，它不会对key进行装箱操作。 所以比 HashMap 更省内存。 2、SparseArray 不需要保存key所对应的哈希值，所以比 ArrayMap 更省内存。 // SparseArray 的 延迟回收 机制 当执行delete()或者removeAt()删除数据的操作，只是将相应位置的数据标记为DELETE，并设置mGarbage=true，而不会直接执行数据拷贝移动的操作。 比如删除某个数据后被标记删除，接着又需要在相同位置插入数据，则不需要任何数组元素的来回移动操作。所以SparseArray适合频繁删除和插入来回执行的场景。 栈 手写代码实现一个栈。 1、用数组实现 通过移动下标来模拟。 2、使用系统的 LinkedList 来实现。 Deque queue = new LinkedList(); queue.addFirst(e); queue.removeFirst(); 3、自己模拟单链表 实现栈 。 sample没有考虑线程安全等细节，只是简洁地展示关键思想 // 栈节点 public class Node{ public Object data;/**数据*/ public Node next ;/**下一个节点*/ public Node(Object data ,Node next) { this.data=data ; this.next =next; } } public class MyStack{ /**栈顶节点*/ private Node topNode ; /**栈大小*/ public int stackSize; // 入栈 public void push(Object data){ Node newNode = new Node(data, topNode);//新节点 topNode= newNode ; //对外公布 新栈顶元素 stackSize++ ; } // 出栈 public void pop() { Node temp= topNode ;//需要出栈的节点 topNode = temp.next ;//对外公布 新的栈顶元素 stackSize-- ; } /**打印该栈所有元素*/ public void showStackInfo() { Node temp =topNode ; if(temp==null) { System.out.println(\"空栈\"); return ; } while(temp !=null ) { System.out.println(\"栈节点值=\"+ temp.data); temp = temp.next; } } } // 测试 public static void main(String[] args){ MyStack myStack = new MyStack(); myStack.showStackInfo(); myStack.push(1) ; myStack.push(2) ; myStack.showStackInfo(); myStack.pop(); myStack.showStackInfo(); } 队列 队列的特点是“先进先出”。 阻塞队列 与普通队列的区别在于：当阻塞队列为空时，从队列中获取元素的操作将会被阻塞，或者当队列是满时，往队列里添加元素会被阻塞。 阻塞双端队列 指允许两端都可以进行入队和出队操作的阻塞队列。 常用队列 特点 常用方法 安全性 LinkedBlockingQueue 基于链表的单向队列 线程安全 LinkedBlockingDeque 基于链表的双端队列 interface BlockingQueue extends Queue ... interface BlockingDeque extends BlockingQueue , Deque {... class LinkedBlockingDeque ... implements BlockingDeque {... class LinkedBlockingQueue implements BlockingQueue... 无版权 可以无限制使用！ all right reserved，powered by Gitbook该文件更新时间： 2020-09-25 09:42:49 "},"chinese/常用算法/算法术语.html":{"url":"chinese/常用算法/算法术语.html","title":"算法术语","keywords":"","body":"算法术语 时间复杂度 在数据结构中,每个算法有他的时间复杂度 , 用O（）表示。括号里面是通过算法求出来的时间复杂度 , n*n 是n的平方，如果求出来是n*n+n 这时它的时间复杂度还是 0（n*n）, 因为规定时间复杂度是取它的最高次幂 递归 相同的结构层级嵌套，自我调用的过程。 迭代 迭代就像是操场永不回头的跑圈，不断利用相同的优化过程将输出作为新的输入，使问题推进到一个个里程碑，直到符合答案的要求。 计算1+2+3+…+n, sum1是递归, sum2是迭代. function sum1(n){ if (n == 0) { return 0; } else { return n + sum1(n - 1); } } function sum2(n){ var result = 0; for (var i = 1; i 无版权 可以无限制使用！ all right reserved，powered by Gitbook该文件更新时间： 2020-08-19 17:20:00 "},"chinese/常用算法/排序算法.html":{"url":"chinese/常用算法/排序算法.html","title":"排序算法","keywords":"","body":"排序算法 冒泡排序 核心思想是 \"冒泡\"。最后的效果是 第一个最小，最后一个最大，沉在最下。一次比较 可以让数值中最小的那个值冒出来。 然后依次比较，直到完成。 /** * int[] array = { 7, 3, 10, 0, 6 , 0 ,-56 }; * 冒泡排序 */ public static int[] sortBubble(int[] array){ //外层for 确定 排序趟次 for ( int i = 0 ; i i ; j--) { int temp; //将小的值往前移动 if(array[j] 归并排序 、合并排序 合并排序 体现了 分治思想 。 递归“分” 递归“分”的终止条件是“只剩下一个元素” 。 因为一个元素认为它有序 。 有序元素的“合” 先比一下 A指针 和 B指针 指向的两个元素谁比较小一点，然后把比较小的元素（此时假设A指针指向的元素小）放到C指针指的位置上。 A往前挪，C 往前挪 。然后继续比较A指针和B指针的两个元素。 合并排序缺点 需要额外的空间辅助。 /** * 归并 排序。 升序 */ public static void mergeSort(int[]array , int start , int end){ if(start>=end){ //递归终止条件 return ; }else{ int mid = (start + end )/2 ; //递归处理左边 mergeSort(array , start ,mid); //递归处理右边 mergeSort(array ,mid+1 ,end); //合并 排序好的左右 mergeAction(array ,start ,mid ,end); } } public static void mergeAction(int[]arr ,int start ,int mid , int end ){ //辅助数组空间 并不是 int[] tempArr = new int[arr.lengh] int[] tempArr = new int[end - start + 1]; //左数组的下标 int ptrA = start; //右数组的下标 int ptrB = mid +1; //辅助数组的下标 int ptrC=0; //循环比较，直至有一个区间被取完 while (ptrA 插入排序 无 递归排序 无 快速排序 之所以说它是快速的原因，不是因为它比其他的排序算法都要快。而是从实践中证明了快速排序在平均性能上的确是比其他算法要快一些 。 快速排序的基本思路 找一个基准元素，对数组进行调整， 调整的标准是，这个基准元素的左边存放的都是比这个元素小的，右边都是比这个元素大的。 然后分而治之，对左右两边的子数组利用同样的规则调整，调整到每一个子数组中都只有一个元素时结束。 （快排体现了分而治之的思想，一步步地把问题变小，最终解决。） 快排的理解 快排有多种理解角度，个人觉得从“挖坑填坑”的角度比较容易理解。 /**最基础的 快速排序*/ public void quickSort(int[] array, int left , int right){ if(left = base){ right-- ; } //找到坑值，填坑 array[left] = array[right] ; //从左边开始寻找坑值 while (left 选择排序 选择排序的思想：就是不断地从未排序的元素中选择最大（或最小）的元素放入已排好序的元素集合中，直到未排序中仅剩一个元素为止 。 选择排序 和冒泡排序有点类似，都是在一次排序后把最大(最小)的元素放到最前面。但是过程不同，冒泡排序是通过相邻的比较和交换。而选择排序是通过对整体的选择。 选择排序 可以看成 冒泡排序 的优化，只有在确定了最小数的前提下才进行交换，大大减少了交换的次数。 选择排序关键点 1、有序区间 、 无序区间 2、如何选出最大（/最小）元素 /** * 选择排序 升序 */ public static int [] sortSelect(int [] array){ int length = array.length; for(int i=0 ;i array[k]){ minPos=k ; } } //将当前趟次的结果放到 有序区间 if(array[minPos] 无版权 可以无限制使用！ all right reserved，powered by Gitbook该文件更新时间： 2020-08-19 17:20:00 "},"chinese/常用算法/查找算法.html":{"url":"chinese/常用算法/查找算法.html","title":"查找算法","keywords":"","body":"查找算法 二分查找 、折半查找 前提：数组是 排好序的。 （升序、降序都可以） 越界异常 int middle = (low+high)/2 // 错误写法 int middle = low + (high - low) / 2; // 正确写法 low 和 high 都是整形，当你的low和high很大的时候， low+high 就会产生溢出，low+high 的结果就会变为负数，数组越界了。 /** * @param array 升序 数组 * @param key 需要查找的值 */ public static int binarySearch(int[] array, int key) { int low = 0; int high = array.length - 1; while (low key) { high = middle - 1; } else if (array[middle] 顺序查找 优点： 算法简单 、 对线性链表也适用 缺点： 慢 public static int SequenceSearch(int[] array, int key){ int length = array.length ; for (int i=0 ;i 无版权 可以无限制使用！ all right reserved，powered by Gitbook该文件更新时间： 2020-08-19 17:20:00 "},"chinese/常用算法/大数相加.html":{"url":"chinese/常用算法/大数相加.html","title":"大数相加","keywords":"","body":"大数相加 如果利用java的 API ，就非常简单。 BigInteger value1= new BigInteger(\"-11\") ; BigInteger value2= new BigInteger(\"-11\"); BigInteger reslut = value1.subtract(value2) ; 无版权 可以无限制使用！ all right reserved，powered by Gitbook该文件更新时间： 2020-09-15 16:00:11 "},"chinese/常用算法/集合的所有子集.html":{"url":"chinese/常用算法/集合的所有子集.html","title":"获得集合的所有子集","keywords":"","body":"获得集合的所有子集 思想比较巧妙。 集合A={a,b,c}中的元素在每个子集中，要么存在，要么不存在。 映射关系： (1,1,1)->(a,b,c) --> 7 (1,1,0)->(a,b) --> 6 (1,0,1)->(a,c) --> 5 (1,0,0)->(a) --> 4 (0,1,1)->(b,c) --> 3 (0,1,0)->(b) --> 2 (0,0,1)->(c) --> 1 (0,0,0)->(空集) --> 0 public static void GetPowerSet(int nArray[] ) { // 一共多少种组合 0 ,1, 2 ... n-1 int end = 1 无版权 可以无限制使用！ all right reserved，powered by Gitbook该文件更新时间： 2020-08-19 17:20:00 "},"chinese/常用算法/扫描线种子填充算法.html":{"url":"chinese/常用算法/扫描线种子填充算法.html","title":"扫描线种子填充算法","keywords":"","body":"扫描线种子填充算法 一般用来 填充不规则多边形 该算法并不完美，对图片有要求，识别的也不是很精准 ，而且有锯齿。 ColourImageView.java public class ColourImageView extends ImageView { private Bitmap mBitmap; private Paint mPaint ; /** * 边界的颜色 */ private int mBorderColor = -1; private boolean hasBorderColor = false; private ImageTool imageTool; public ColourImageView(Context context, AttributeSet attrs) { super(context, attrs); imageTool = new ImageTool(mBorderColor, hasBorderColor ); mPaint = new Paint(); mPaint.setColor(Color.RED); } @Override protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) { super.onMeasure(widthMeasureSpec, heightMeasureSpec); // 规定让图片按比例显示 int viewWidth = getMeasuredWidth(); setMeasuredDimension(viewWidth, getDrawable().getIntrinsicHeight() * viewWidth / getDrawable().getIntrinsicWidth()); if (mBitmap == null) { Bitmap bm = ((BitmapDrawable) getDrawable()).getBitmap(); mBitmap = Bitmap.createScaledBitmap(bm, getMeasuredWidth(), getMeasuredHeight(), false); } } private int touchX ; private int touchY ; @Override public boolean onTouchEvent(MotionEvent event) { touchX = (int) event.getX(); touchY = (int) event.getY(); if (event.getAction() == MotionEvent.ACTION_DOWN) { fillColorToSameArea( ); } return super.onTouchEvent(event); } /** * 以触摸点为种子点 进行填充 */ private void fillColorToSameArea( ) { int bitmapWidth ; int bitmapHeight ; int[] pixels ; int currentTouchPixel ; currentTouchPixel = mBitmap.getPixel(touchX, touchY); if (currentTouchPixel == Color.TRANSPARENT || (hasBorderColor && mBorderColor == currentTouchPixel)) { return; } bitmapWidth = mBitmap.getWidth(); bitmapHeight = mBitmap.getHeight(); pixels = new int[bitmapWidth * bitmapHeight]; mBitmap.getPixels(pixels, 0, bitmapWidth, 0, 0, bitmapWidth, bitmapHeight); int newColor = randomColor(); //填色 imageTool.fillColor(pixels, bitmapWidth, bitmapHeight, currentTouchPixel, newColor,touchX, touchY); //重新设置bitmap mBitmap.setPixels(pixels, 0, bitmapWidth, 0, 0, bitmapWidth, bitmapHeight); setImageBitmap(mBitmap); invalidate(); } @Override protected void onDraw(Canvas canvas) { super.onDraw(canvas); canvas.drawCircle(touchX ,touchY ,10 ,mPaint); } /** * 返回一个随机颜色 */ private int randomColor() { Random random = new Random(); int color = Color.argb(255, random.nextInt(256), random.nextInt(256), random.nextInt(256)); return color; } } ImageTool.java public class ImageTool { private Stack mStacks = new Stack<>(); private int mBorderColor = -1; private boolean hasBorderColor = false; public ImageTool( int mBorderColor ,boolean hasBorderColor ){ this.mBorderColor = mBorderColor ; this.hasBorderColor= hasBorderColor ; } /** * @param pixels 像素数组 * @param currentTouchPixel 当前触摸点的 颜色 * @param newColor 填充色 */ public void fillColor(int[] pixels, int bitmapWidth, int bitmapHeight, int currentTouchPixel, int newColor, int x, int y) { //步骤1：将种子点(x, y)入栈； mStacks.push(new Point(x, y)); //步骤2：判断栈是否为空， // 如果栈为空则结束算法，否则取出栈顶元素作为当前扫描线的种子点(x, y)， // y是当前的扫描线； while (!mStacks.isEmpty()) { /* * 步骤3：从种子点(x, y)出发，沿当前扫描线向左、右两个方向填充，直到边界。 * 分别标记区段的左、右端点坐标为xLeft和xRight */ Point seed = mStacks.pop(); int count = fillLineLeft(pixels, currentTouchPixel, bitmapWidth, newColor, seed.x, seed.y); int left = seed.x - count + 1; count = fillLineRight(pixels, currentTouchPixel, bitmapWidth, newColor, seed.x + 1, seed.y); int right = seed.x + count; //从y-1找种子 if (seed.y - 1 >= 0){ findSeedInNewLine(pixels, currentTouchPixel, bitmapWidth, seed.y - 1, left, right); } //从y+1找种子 if (seed.y + 1 = 0) { int index = y * bitmapWidth + x; if (needFillPixel(pixels, pixel, index)) { pixels[index] = newColor; count++; x--; } else { break; } } return count; } /** * 往右填色，返回填充的个数 */ private int fillLineRight(int[] pixels, int currentTouchPixel, int bitmapWidth, int newColor, int x, int y) { int count = 0; while (x 0xFFBBBBBB ; // 直接跟当前pixel比较，有较明显的锯齿，原因不明 //return pixels[index] > pixel ; } } /** * 在新行找种子节点 */ private void findSeedInNewLine(int[] pixels, int currentTouchPixel, int bitmapWidth, int indexY, int left, int right) { // 获得该行的开始索引 int begin = indexY * bitmapWidth + left; // 获得该行的结束索引 int end = indexY * bitmapWidth + right; boolean hasSeed = false; int newSeedIndexX ; while (end >= begin) { if (pixels[end] == currentTouchPixel) { if (!hasSeed) { newSeedIndexX = end % bitmapWidth; mStacks.push(new Point(newSeedIndexX, indexY)); hasSeed = true; } } else { hasSeed = false; } end--; } } } 无版权 可以无限制使用！ all right reserved，powered by Gitbook该文件更新时间： 2020-08-19 17:20:00 "},"chinese/java基础/原码补码反码.html":{"url":"chinese/java基础/原码补码反码.html","title":"java部分","keywords":"","body":"原码补码反码 类型 正数规则 负数规则 其他 原码 0表示正号，1表示负号，后面是数值部分 跟正数一样 反码 与原码相同 原码的符号位不变，其它位取反 补码 与原码相同 反码+1 加法运算 只能通过 补码来运算，因为通过原码不能保证所有的计算都是正确的。 例如 ： 6+（-3） 补码存在的意义 1、 因为采用原码或反码 进行 减法运算 ，并不能保证结果正确。 为了保证计算正确， 因此设计了补码的规则 。至于为什么采用这样的设计就能保证结果正确。请查阅其他资料。 无版权 可以无限制使用！ all right reserved，powered by Gitbook该文件更新时间： 2020-08-19 17:20:00 "},"chinese/java基础/java虚拟机.html":{"url":"chinese/java基础/java虚拟机.html","title":"java虚拟机","keywords":"","body":"参考资料： 1、 深入理解Java虚拟机 无版权 可以无限制使用！ all right reserved，powered by Gitbook该文件更新时间： 2020-08-19 17:20:00 "},"chinese/java基础/类加载机制.html":{"url":"chinese/java基础/类加载机制.html","title":"类加载机制","keywords":"","body":"类加载机制 类的生命周期 java类加载器分类 从虚拟机层面角度分类 从虚拟机层面角度讲,分为两大类型的类加载器。 一是Bootstrap Classloader ，即启动类加载器（C++实现），它是虚拟机的一部分， 二是其他类型类加载器（JAVA实现），在虚拟机外部，并全部继承ClassLoader类。 从加载顺序角度来分类 1、Bootstrap ClassLoader 主要负责加载JVM自身工作所需要的类。 是由C/C++编写的，它本身是虚拟机的一部分，所以它并不是一个JAVA类，无法在java代码中获取它的引用。 所以getClass().getName()返回null。 System.out.println(System.getProperty(\"sun.boot.class.path\")); xxx\\jre\\lib\\resources.jar; xxx\\jre\\lib\\rt.jar; xxx\\jre\\lib\\sunrsasign.jar; xxx\\jre\\lib\\jsse.jar; xxx\\jre\\lib\\jce.jar; xxx\\jre\\lib\\charsets.jar; xxx\\jre\\lib\\jfr.jar; xxx\\jre\\classes 2、ExtClassLoader 负责装载JRE扩展目录ext下的jar类包。一般为JVM平台扩展工具。 System.out.println(System.getProperty(\"java.ext.dirs\")); xxx\\jre\\lib\\ext; C:\\Windows\\Sun\\Java\\lib\\ext 3、AppClassLoader(SystemAppClass) 如果应用程序中没有自定义过自己的类加载器，一般情况下这个就是程序中默认的类加载器。 System.out.println(System.getProperty(\"java.class.path\")); //这个路径其实就是当前java工程目录bin，里面存放的是编译生成的class文件。 F:\\aivin_space\\myEclipseSpace\\MySample\\bin 类加载之间的父子关系是怎样的 子类加载器和父类加载器的关系，是委派关系并不是继承关系。 双亲委派（parent delegation）模型 在加载类别时，每个类别加载器会先将加载类别的任务交由其parent， 如果parent找不到，才由自己负责加载， 如果自己也找不到，就会丢出 NoClassDefFoundError。 为什么要用“双亲委派模型” 防止内存中出现多份同样的字节码 。 比如两个类A和类B都要加载System类： 如果不用委托而是自己加载自己的， 那么类A就会加载一份System字节码， 然后类B又会加载一份System字节码， 这样内存中就出现了两份System字节码。 自定义类加载器的意义和使用场景 1、为了实现jdk的类加载器没有的某些功能。 例如Tomcat使用自定义的类加载器实现了热部署功能。 2、将java写的核心代码编译成.clas文件，然后将lass文件就加密。只有使用在自己的类加载器才能正确使用这些核心代码。 (因为只要获得了这个加载器，核心代码就可以轻易被获取。 所以要保护好自己的加载器。) 无版权 可以无限制使用！ all right reserved，powered by Gitbook该文件更新时间： 2021-01-08 15:06:47 "},"chinese/java基础/内存.html":{"url":"chinese/java基础/内存.html","title":"内存","keywords":"","body":"Java内存模型 其他语言，例如c/c++直接使用了物理硬件或操作系统的内存模型 ， 由于不同平台上内存模型的差异性，需要开发者针对不同的平台做相应的兼容处理。 Java内存模型是为了屏蔽各种硬件和系统的访问差异，达到一致的并发效果。 进一步解决多线程编程中的线程安全等问题。 运行时数据区域 (绿色部分是每个线程私有的，白色部分是线程共享的) 分为5块内存空间。 附：栈是运行的单位，而堆是存储的单元。 // 1、程序计数器 当前线程所执行的字节码的行号指示器。用来记录程序运行到哪里了，下一步又该执行哪一步操作。 // 2、本地方法栈 存储本地方法执行过程中的栈数据。 // 3、JVM栈（Java栈） 存放一个Java线程的运行状态。 // 4、堆 存放运行时产生的对象的。Java只能在堆中存放对象 // 5、方法区 方法区主要是用来存类型数据的，与类型相关的东西，比如常量，静态变量。 注：运行时常量池是方法区的一部分，用来存放编译器生成的各种字面量和符号引用。 基本概念 主内存 进程内存。 所有线程共享主内存。 工作内存 线程内存。 每个线程都有自己的执行空间(即工作内存)，线程执行的时候用到某变量， 首先要将变量从主内存拷贝的自己的工作内存空间， 然后对变量进行操作：读取，修改，赋值等，这些均在工作内存完成， 操作完成后再将变量写回主内存； 可见性 指当一个线程修改了共享变量的值，其他线程能够立即得知这个修改。 各个线程都从主内存中获取数据，线程之间数据是不可见的； 例如，主内存 变量A 原始值为1，线程1从主内存取出 变量A，修改A的值为2， 在线程1未将变量A写回主内存的时候，线程2拿到变量A的值仍然为1； 我们可以使用 volatile 或 synchronized 等机制 保证可见性。 有序性 如果在本线程内观察，所有的操作都是有序的； 指\"线程内表现为串行的语义\" 如果在一个线程中观察另一个线程，所有的操作都是无序的。 指\"指令重排序\"现象和\"工作内存与主内存同步延迟\"现象。 Java提供了 volatile 和 synchronized 来保证有序性 ， volatile 本身包含禁止指令重排序的语义， synchronized 则是由\"一个变量在同一个时刻只允许一条线程对其进行lock操作\"的规则来获得。 原子操作 、原子性 是指不会被线程调度机制打断的操作机制。 这种操作一旦开始，就一直运行到结束，中间不会有任何 context switch （切换到另一个线程）。 根据java 定义，原子操作是不会被打断地的操作，因此被认为是线程安全的。 java中可以通过锁和循环CAS的方式来实现原子操作。 指令重排序 即生成的机器指令与字节码指令顺序不一致。 为什么会有重排序? 为了提高执行效率，目前大多数现代微处理器都会采用将指令乱序执行。 在条件允许的情况下，直接运行当前有能力立即执行的后续指令，避开获取下一条指令所需数据时造成的等待。 int a = 1; int b = 2; int c = a + b; 将上面的代码编译成Java字节码或生成机器指令，大致可视为展开成了以下几步动作： 对a赋值1 --1 对b赋值2 --2 取a的值 --3 取b的值 --4 将取到两个值相加后存入c --5 在上面5个动作中，动作1可能会和动作2、4重排序， 动作2可能会和动作1、3重排序，动作3可能会和动作2、4重排序， 动作4可能会和1、3重排序。但动作1和动作3、5不能重排序。 动作2和动作4、5不能重排序。因为它们之间存在数据依赖关系， 一旦重排，as-if-serial语义便无法保证。 as-if-serial 语义 所有的动作都可以为了优化而被重排序， 但是必须保证它们重排序后的结果和程序代码本身的应有结果是一致。 所以，重排序不会发生在有数据依赖的操作之中。 8大原子操作 为了解决主内存和工作线程的一致性问题，Java定义了如下原子操作. 1、 lock 锁定 作用于主内存，把变量标记为一条线程独占状态。 2、unlock 解锁。 作用于主内存，释放后的变量才能被其他线程锁定。 3、 read 读取 作用于主内存。 将变量的值从主内存传输到工作内存中。 4、load 载入 作用于工作内存。将从主内存中得到的变量值放入工作内存的变量副本中。 5、 use 使用。 作用于工作内存。 将工作内存中的变量的值传递给执行引擎。 6、assign 赋值 作用于工作内存。将执行引擎传递过来的值赋值给工作内存中的变量副本。 7、store 存储 作用于工作内存。 将工作内存中的变量值传递到主内存。 8、write 写入 作用于主内存。将从工作内存中传递过来的值 赋值给主内存的变量。 无版权 可以无限制使用！ all right reserved，powered by Gitbook该文件更新时间： 2021-01-06 16:10:38 "},"chinese/java基础/GC机制.html":{"url":"chinese/java基础/GC机制.html","title":"GC机制","keywords":"","body":"gc机制 GC机制的诞生时间大于Java。在早期的一些语言也曾使用过GC机制。 经过多年的发展，GC机制已经已经进入了“自动化”时代了，我们为什么还要去了解GC机制呢？ 因为深入了解GC机制能更好地排查内存溢出泄露问题。 当GC机制成为高并发的瓶颈时，我们可以通过监控和调节GC过程，采取合适的优化方案。 普通的程序员也可以从GC机制中学习到它们优秀的策略。 判断对象是否存活的方法 1、引用计数算法 (Reference Counting) 给对象中添加一个引用计数器,每当有一个地方引用它时,计数器值就加1; 当引用失效时,计数器值就减1;任何时刻计数器为0的对象就是不可能再被使用的。 java已经摈弃了这种方案。因为很难解决对象之间的互相循环引用的问题。 2、可达性分析算法( Reachability Analysis) / 根搜索算法( GC Root Tracing) 目前主流编程语言(java,C#等)中,都是称通过可达性分析来判定对象是否存活的。 该算法的基本思路就是通过一系列的“GC Roots”对象作为起始点,从这些节点开始向下搜索(搜索所走过的路径称为引用链), 当一个对象到GC Roots没有任何引用链相连(用图论的话来说,就是从GC Roots到这个对象不可达)时,则证明此对象是不可用的。 如下图所示，对象object 5、object 6、object 7虽然互相有关联,但是它们到GC Roots是不可达的,所以它们将会被判定为是可回收的对象。 Java语言中 可作为GC Roots的对象 1、虚拟机栈(栈帧中的**本地变量表**)中引用的对象。 2、持久代中类**静态属性引用的对象**。 3、持久代中**常量引用的对象**。 4、本地方法栈中JNI(即一般说的Native方法)引用的对象。 垃圾收集算法 标记-清除算法 首先标记出所有需要回收的对象，标记完成后统一回收被标记过的对象。 缺点： 1、效率不高。标记和清除过程效率都不高。 2、空间问题。标记清除后会产生大量不连续的内存碎片。 复制算法 将内存均分为两块，每次只用其中一块。当着一块的内存用完了，就将还存活的对象复制到另一块内存上。 然后将已经使用过的这块内存一次性清理掉。 优点： 实现简单，运行高效。 缺点： 浪费内存，可用内存较少。 标记-整理 算法 标记过程与 “标记-清除”算法一样。然后，让所有存活的对象向一端移动，最后直接清理掉端边界以外的内存。 分代收集算法 该算法是目前大部分JVM的垃圾收集器采用的算法。 核心思想是根据对象存活的生命周期将内存划分为若干个不同的区域。然后根据各个年代的特点采用适当的收集算法。 内存划分类型 内存被分为下面三个区域 。 Enden、form survicor space、to survivor space。 新生代 绝大多数最新被创建的对象会被分配到这里。对象从这个对象消失的过程称为”minor GC”。 特征： （1）GC的发生相对比较频繁和迅速高效。 （2）包含了许多短周期对象。 老年代 (1)、从新生代存活下来的对象会被拷贝到这里，它的空间比新生代要大 (2)、GC操作不是很频繁，但是耗时比新生代中的GC要长。 内存占用的增长比较缓慢。 对象从老年代消失的过程称为”major GC”或者”full GC”。 永久代 (方法区/持久代) 用来存放类常量和字符串常量(并不是用来存储那些从老年代存活下来的对象)。它也会发生GC操作。 内存分配与回收机制 对象优先在Eden分配 对象一般在新生代Eden区中分配，当Eden区没有足够的空间进行分配时，虚拟机将发起一次Minor GC 。 大对象直接就进入老年代 大对象(类似很长的字符串或数组 需要大量连续内存空间的对象)。 长期存活的对象将进入老年代 虚拟机给每个对象定义了一个对象年龄计数器。对象再Survivor区中每熬过一次Minor GC,年龄就会增加1岁。当年龄增加到一定程度(默认配置15岁)，对象就会被移动到老年代中。 动态对象年龄判定 并不是一定要达到规定的年龄，对象才会被移动到老年代中。 如果Survivor空间中相同年龄 所有对象的大小的总和大于Survivor空间的一半，年龄>=该年龄的对象就会直接被移动到老年代中。 空间分配担保 在执行Minor GC之前，虚拟机先检查老年代最大可用的连续空间是否大于新生代所有对象总空间，如果ok，那么此次Minor GC可以安全进行。否则，虚拟机会查看HandlePromotionFailure设置值是否允许担保失败。如果允许，那么会继续检查老年代最大可用的连续空间是否大于历次晋升到老年代对象的平均大小，如果大于，将尝试着进行一次Minor GC，(尽管此次 Minor GC是有风险的)；如果小于，或者HandlePromotionFailure设置不允许冒险，就改为执行 Full GC（不执行 Minor Gc）。 拓展知识点 Java中引用的类型 1、强引用 类似Object obj= new Object(); 只要强引用还存在，GC永远不会回收掉被引用的对象。 2、软引用 可用SoftReference实现软引用。 系统内存不足时，会把软引用关联的对象加入回收范围并进行回收，回收后如果内存还是不足才会抛出内存溢出异常。 3、弱引用。 可用WeakReference实现。 当GC执行时，无论当前内存是否充足，都会将若引用关联的对象回收掉。 4、虚引用 可用PhantomReference实现。 为一个对象设置虚引用的唯一目的就是希望对象被回收时系统能提供一个系统通知。 finalize() finalize()的发明是为了向c/c++程序员妥协。 在Java中使用finalize()方法反而会带来更多的不确定性。 所以在Java中不推荐使用这个方法，不建议对象进行自我拯救。 类似于“关闭外部资源”之类的工作可以交给try-finally或其他方式完成。 被GC判断为”垃圾”的对象一定会回收吗 在可达性分析算法中不可达的对象,也并非是“非死不可”的, 这时候它们暂时处于“缓刑”阶段,要真正宣告一个对象死亡,至少要经历 两次标记过程。 如果对象在进行可达性分析后发现没有与GC Roots相连接的引用链,那它将会被第一次标记并且进行一次筛选, 筛选的条件是此对象是否有必要执行finalize()方法。 当对象没有覆盖finalize()方法,或者finalize()方法已经被虚拟机调用过,虚拟机将这两种情况都视为“没有必要执行”。(即意味着直接回收)。 如果这个对象被判定为有必要执行finalize()方法,那么这个对象将会放置在一个叫做F-Queue的队列之中, 并在稍后由Finalizer线程(虚拟机建立的、低优先级)去触发finalize()方法。 finalize()方法是对象逃脱死亡命运的最后一次机会,稍后GC将对F-Queue中的对象进行第二次小规模的标记, 如果对象要在finalize()中成功拯救自己——只要重新与引用链上的任何一个对象建立关联即可, 譬如把自己(this关键字)赋值给某个类变量或者对象的成员变量,那在第二次标记时它将被移除出“即将回收”的集合; 如果对象这时候还没有逃脱,那基本上它就真的被回收了。 任何一个对象的finalize()方法只能被系统自动调用一次。所以对象自我拯救的次数有限。 无版权 可以无限制使用！ all right reserved，powered by Gitbook该文件更新时间： 2020-08-19 17:20:00 "},"chinese/java基础/对象内存布局.html":{"url":"chinese/java基础/对象内存布局.html","title":"对象内存布局","keywords":"","body":"对象内存布局 在HotSpot虚拟机中，对象在内存中存储的布局分为 对象头Header、实例数据Instance Data、对齐填充Padding。 // 对象头 object header , 包括了关于堆对象的布局、类型、GC状态、同步状态和标识哈希码的基本信息。 Java对象和vm内部对象都有一个共同的对象头格式。 // 实例数据 Instance Data ,主要是存放类的数据信息，父类的信息，对象字段属性信息。 // 对齐填充 Padding, 为了字节对齐，填充的数据，不是必须的。 对齐填充并不是必然存在的，无特别含义，起着占位符的作用， HotSpotVM的自动内存管理系统要求对象起始地址必须是8字节的整数倍，也就是对象的大小必须是8字节的整数倍， 对象头正好是8字节的倍数，所以当对象实例数据部分没有对齐，就需要通过对齐填充来补全。 对于Java和C、C++、C#这类高级语言，因为编译器的存在， 编译器或虚拟机会自动帮我们进行字节对齐补白。无需手动去处理。 为什么要进行内存对齐 // 平台原因 不是所有的硬件平台（例如某些嵌入式系统中使用的低端微处理器）都能访问任意地址上的任意数据， 某些硬件平台只能访问对齐的地址，否则会出现硬件异常。 // 性能原因 如果数据存放在未对齐的内存空间中，则处理器访问变量时需要做两次内存访问， 而对齐的内存访问仅需要一次访问。 显然，内存对齐在某些情况下可以减少读取内存的次数以及一些运算，性能更高。 另外，由于内存对齐保证了读取 b 变量是单次操作，在多核环境下，原子性更容易保证。 但是内存对齐提升性能的同时，也需要付出相应的代价。 由于变量与变量之间增加了填充，并没有存储真实有效的数据，所以占用的内存会更大。 这也是一个典型的空间换时间的应用场景。 如何解决 内存对齐 带来的内存浪费问题 有内存对齐就会有内存浪费的情况，所以为了减少内存浪费， 并达到内存对齐的目的，JVM就会将字段重新排列。 java -version // 查看虚拟机类型 java version \"1.8.0_151\" Java(TM) SE Runtime Environment (build 1.8.0_151-b12) Java HotSpot(TM) 64-Bit Server VM (build 25.151-b12, mixed mode) 由于HotSpot虚 拟机的自动内存管理系统要求对象的起始地址必须是8字节的整数倍， 因此当对象实例部分数据没有对齐时，就需要对剩余的部分进行填充。 补齐位的存在就是为了补齐8字节，每一个java对象的大小都是8的倍数。 // 字段重排规则 (Java HotSpot(TM) ) 1、总的规则是 (对象头 + 实例数据 + padding) %8 == 0 且 0 OFFSET SIZE TYPE DESCRIPTION 0 4 (object header) 4 4 (object header) 8 4 (object header) // header 下面属性顺序跟申明顺序可能不一致 12 2 char TestBean.charValue1 14 2 char TestBean.charValue2 16 8 long TestBean.longValue2 24 8 double TestBean.doubleValue1 32 8 double TestBean.doubleValue2 40 1 byte TestBean.byteValue1 41 1 boolean TestBean.booleanValue2 42 1 byte TestBean.byteValue2 43 5 (loss due to the next object alignment) Instance size: 48 bytes jol-cli 查看 对象内存布局信息 https://repo.maven.apache.org/maven2/org/openjdk/jol/jol-cli/ 下载一个 full 版本 //查看对象内部信息. String inInfo=ClassLayout.parseInstance(bean).toPrintable() ; //查看对象外部信息，包括引用的对象. String outInfo=GraphLayout.parseInstance(bean).toPrintable() ; //查看对象总大小. long allInfo=GraphLayout.parseInstance(bean).totalSize(); 无版权 可以无限制使用！ all right reserved，powered by Gitbook该文件更新时间： 2021-01-08 10:27:50 "},"chinese/java基础/线程详解.html":{"url":"chinese/java基础/线程详解.html","title":"线程详解","keywords":"","body":"锁 、同步 等 相关概念 原语 所谓原语，一般是指由若干条指令组成的程序段， 用来实现某个特定功能，在执行过程中不可被中断。 可重入 可重入函数保证了在多线程条件下，函数的状态不会出现错误。 以下分别是一个不可重入和可重入函数的示例。 // func1是不可重入的 , 因为tmp是 static 全局变量，多线程访问时，会出现问题。 static int tmp; void func1(int* x, int* y){ tmp=*x; *x=*y; *y=tmp; } //func2是可重入的 void func2(int* x, int* y){ int tmp; tmp=*x; *x=*y; *y=tmp; } 线程中断 中断是一种特殊的电信号。 处理器接受到中断后，会马上向操作系统反映此信号的到来，然后就由 操作系统 负责处理这些新到来的数据。 要中断一个Java线程，可调用线程类对象的实例方法：interrupte()。 其本质只是设置该线程的中断标志，将中断标志设置为true，并根据线程当前的状态决定做出不同的响应。 synchronized 悲观锁 就是悲观思想，即认为写多，遇到并发写的可能性高， 每次去拿数据的时候都认为别人会修改， 所以每次在读写数据的时候都会上锁，这样别人想读写这个数据就会block直到拿到锁。 synchronized 的实现原理 暂未学习 CAS (Compare-and-Swap) 乐观锁 、 非阻塞同步 基于 冲突检测 的乐观并发策略 ， 先将内存的值进行保存，当操作完成时再判断保存的值和当前内存的值是否相同， 如果不同则说明其他线程操作了该数据，所以需要重试或者放弃。 这种乐观的并发策略不需要把线程挂起，因此这种 同步措施 称为 非阻塞同步。 ABA问题 是指在 CAS 操作中带来的一个潜在问题。 例如，线程1将初始值为A的变量 先修改成B，再修改回成A。 线程B的 CAS 操作无法分辨当前V值是否发生过变化。 线程状态的转换 公平锁 Fair 加锁前检查是否有排队等待的线程，优先排队等待的线程，先来先得。 非公平锁 Nonfair 加锁时不考虑排队等待问题，直接尝试获取锁，获取不到自动到队尾等待。 类锁 、对象锁 synchronized 修饰静态方法获取的是类锁， synchronized 修饰普通方法或代码块获取的是对象锁。 获取了类锁的线程和获取了对象锁的线程是不互斥的。 Lock 接口 public interface Lock {... 相比于 synchronized , Lock 接口 具有一些更强的特性 。 1、尝试非阻塞的获取锁 tryLock() ， 当前线程尝试获取锁，如果该时刻锁没有被其他线程获取到，就能成功获取并持有锁 2、能被中断的获取锁 lockInterruptibly() 获取到锁的线程能够响应中断，当获取到锁的线程被中断的时候，会抛出中断异常同时释放持有的锁 3、超时的获取锁tryLock(long time, TimeUnit unit) 在指定的截止时间获取锁，如果没有获取到锁返回false 独享锁 、共享锁 、读写锁 ReadWriteLock 独享锁是指该锁一次只能被一个线程所持有，例如 synchronized 。 共享锁是指该锁可被多个线程所持有。 ReadWriteLock rtLock = new ReentrantReadWriteLock(); rtLock.readLock();//共享锁 rtLock.writeLock();//互斥锁 ReadWriteLock rtLock = new ReentrantReadWriteLock(); ReentrantLock 重入锁 private void func1(ReentrantLock lock){ //如果已经被锁定了 就会忽略。不会等待。 boolean result = lock.tryLock() //如果被锁定了，就会尝试等待指定时长。如果还没有就放弃等待。 boolean result = lock.tryLock(5 , TimeUnit.SECONDS) 死锁 多个线程同时被阻塞，它们中的一个或者全部都在等待某个资源被释放。由于线程被无限期地阻塞。 //java 死锁产生的四个必要条件： 1、互斥使用，即当资源被一个线程使用(占有)时，别的线程不能使用. 2、不可抢占，资源请求者不能强制从资源占有者手中夺取资源，资源只能由资源占有者主动释放。 3、请求和保持，即当资源请求者在请求其他的资源的同时保持对原有资源的占有。 4、循环等待，即存在一个等待队列：P1占有P2的资源，P2占有P3的资源，P3占有P1的资源。 这样就形成了一个等待环路。 当上述四个条件都成立的时候，便形成死锁。当然，死锁的情况下如果打破上述任何一个条件，便可让死锁消失。 线程同步 机制 同步一般指的是在多个数据库、文件、模块、线程之间用来保持数据内容一致性的机制。 程同步的真实意思和字面意思恰好相反，其实是“线程排队”, 几个线程之间要排队，一个一个对共享资源进行操作，而不是同时进行操作。 1、java的每个对象都有一个内置锁。 2、同步是高开销，尽量减少同步的内容。一般同步关键代码（代码块）即可。 线程阻塞 阻塞指的是暂停一个线程的执行以等待某个条件发生（如某资源就绪）。 线程 相关方法 sleep() sleep 允许线程在指定的时间内进入阻塞状态，不能得到CPU 时间， 指定的时间一过，线程重新进入可执行状态。 只是不参与cpu时间的竞争， 已经拿到手的锁资源并不释放 （此时不一定占有锁）。 sleep 方法时间到了会自动醒过来， 时间没到可以用interrupt方法强行唤醒。 suspend() 、 resume() 两方法配套使用，调用suspend()进入阻塞状态。 不会立即的停止，而是执行到一个安全点后挂起 ，不会自动恢复。 调用resume()进入唤醒状态。 在多线程场景中很容易造成死锁，目前这2个方法已经被废弃。 yield() 线程礼让、让步。 yield 方法让当前正在执行的线程放弃当前分得的CPU时间， 它只是将该线程从运行状态转入就绪状态。 只是礼让当前的cpu使用权，让系统的线程调度器重新调度一次。 很有可能，当这个线程调用了yield()方法后它又马上抢占了CPU的执行权，继续执行。 wait() 、 notify() wait 、 notify 两个方法配套使用 。都是Object的方法。并不是Thread独有的。 这里要明确 线程等待的就是一个对象发出的信号，所以要基于对象而存在。 wait、 notify 必须在 synchronized 同步方法或块中调用 。 否则运行时会抛出 IllegalMonitorStateException 异常 。 // 为什么java规定 wait()，notify()和notifyAll()必须在同步块或同步方法中调用, // 而 suspend()、 resume()可以在任何地方都调用？ 1、首先suspend()、 resume()是基于线程存在的。 wait()、notify()基于对象存在的。 2、既然是基于对象的，此时在这个对象上可能同时有多个线程调用wait()/notify()方法， 依然存在并发的问题，理论上也需要一个锁来控制。 调用wait进入阻塞后，会释放占用的锁。 obj.wait( time ) ， 超时自动唤醒或者由notify( )、notifyAll()唤醒 进入就绪状态。 obj.wait( ) ，由notify( )、notifyAll( )唤醒 进入就绪状态。 调用wait会让当前线程释放这个对象的锁。 （线程此时不一定持有锁，如果没有锁就忽略，如果占有锁就会释放） 如果多个线程调用了某个对象的 wait() ， 对象的notify()被调用时 是随机选择一个线程唤醒 。 如果多个线程调用了某个对象的 wait() ， notifyAll()被调用时 将这些线程全部唤醒，抢到锁的那个线程 进入就绪状态 。 线程竞争对象的锁。 join() 线程A 里面 调用了 线程B.join() 。 此时线程A进入阻塞状态 ，线程B执行。 直到线程B执行完毕或者被打断，线程A才能恢复继续执行 。 主要用于线程之间的交互。 同步机制有哪些 同步方法 //锁住 当前方法 public synchronized void funcA(){ } //锁住 当前类 public static synchronized void funcB(){ } 同步代码块 synchronized(object) { //同步是一种高开销的操作，通常没有必要同步整个方法， //使用synchronized代码块同步关键代码即可。 } 使用 volatile //一个变量使用volatile后，它将具有以下两种特性： 1、此变量对所有线程可见。体现了 可见性。 当一条线程修改了这个变量的值，新的值对于其他线程来说是立即得知的。(普通变量不能实现这一点。) 2、 volatile 禁止CPU进行指令重排序优化。体现了 有序性 普通的变量可能会进行指令重排序，所以不能保证变量赋值操作的顺序与程序代码中的执行顺序一致。 重入锁 ReentrantLock boolean fair= false ;//fair为true表示是公平锁 。默认非公平。 ReentrantLock reentrantLock = new ReentrantLock(fair) ; private void func1(ReentrantLock lock){ //如果已经被锁定了 就会忽略。不会等待。 boolean result = lock.tryLock() //如果被锁定了，就会尝试等待指定时长。如果还没有就放弃等待。 boolean result = lock.tryLock(5 , TimeUnit.SECONDS) if(result){ try{ //执行相关操作 }finally{ //释放锁 lock.unlock(); } 使用 api LinkedBlockingQueue 阻塞队列 使用java封装的帮助类，实现多线程安全。 每次只允许 一个线程去队列里面存放对象 。 BlockingQueue outQueue = new LinkedBlockingQueue<>(Integer.MAX_VALUE); outQueue.put(msg); msg = outQueue.poll(); 使用 Java api Atomic 原子变量 java.util.concurrent.atomic包提供 Atomic 用CAS方式实现 原子操作。 原子操作就是指将读取变量值、修改变量值、保存变量值, 看成一个整体来操作,即这几种行为要么同时完成，要么都不完成。 根据java 定义，原子操作是不会被打断地的操作，因此被认为是线程安全的。 // 原子更新基本类型类 （没有 double 和float的封装类型） AtomicInteger atomicInt = new AtomicInteger(100); AtomicBoolean atomicBoolean = new AtomicBoolean(false); AtomicLong atomicLong = new AtomicLong(1000000); private void func1( ){ //原子更新数组类 int[]arrayInt ={1,30}; AtomicIntegerArray atomicIntArray = new AtomicIntegerArray(arrayInt); atomicIntArray.getAndSet(i, newValue); atomicIntArray.addAndGet(i, delta); //AtomicReferenceFieldUpdater 一个基于反射的工具类，它能对指定类的指定的volatile引用字段进行原子更新。(这个字段不能是private的) AtomicReferenceFieldUpdater updater=AtomicReferenceFieldUpdater.newUpdater(Dog.class,String.class,\"name\"); updater.compareAndSet(dog1,dog1.name,\"test\") ; //AtomicMarkableReference ,为解决 CAS 操作中潜在的 ABA 问题 设计的解决方案。 AtomicMarkableReference atomicMarkRef= new AtomicMarkableReference (\"StrMsg\", false) ; if(!atomicMarkRef.isMarked()){ atomicMarkRef.set(\"bbb\", true); }; //AtomicStampedReference 用法与 AtomicMarkableReference 类似 } 线程池 为什么要用线程池: 1、减少了创建和销毁线程的次数，每个工作线程都可以被重复利用，可执行多个任务。 2、可以根据系统的承受能力，调整线程池中工作线线程的数目，防止因为消耗过多的内存 newSingleThreadExecutor() 类型1 创建一个单线程的线程池。 这个线程池只有一个线程在工作，也就是相当于单线程串行执行所有任务。 如果这个唯一的线程异常结束，会有一个新的线程来替代它。 此线程池保证所有任务的执行顺序按照任务的提交顺序执行。 // interface ExecutorService ExecutorService pool = Executors.newSingleThreadExecutor(); pool.execute(runnable); newFixedThreadPool(n) 类型2 创建固定大小的线程池。 每次提交一个任务就创建一个线程，直到线程达到线程池的最大大小。 线程池的大小一旦达到最大值就会保持不变，如果某个线程因为执行异常而结束，那么线程池会补充一个新线程。 ExecutorService pool =Executors.newFixedThreadPool(10); pool.execute(runnable); newCachedThreadPool() 类型3 创建一个可缓存的线程池。 如果线程池的大小超过了处理任务所需要的线程，那么就会回收部分空闲（60秒不执行任务）的线程， 当任务数增加时，此线程池又可以智能的添加新线程来处理任务。 此线程池不会对线程池大小做限制， 线程池大小完全依赖于 JVM 能够创建的最大线程大小。 ExecutorService pool=Executors.newCachedThreadPool(); pool.execute(runnable); newScheduledThreadPool(n) 类型4 支持定时及周期性任务执行 。 // interface ScheduledExecutorService extends ExecutorService ScheduledExecutorService pool =Executors.newScheduledThreadPool(10); pool.scheduleAtFixedRate(runnable, initialDelay, period, unit); pool.execute(runnable); jva 官方 ScheduledThreadPoolExecutor 帮助类 ScheduledThreadPoolExecutor(n) 并不是第5种线程池类型，而是一个类， 用来生成 newScheduledThreadPool(n) 类型的线程池。 自JDK1.5开始，JDK提供了 ScheduledThreadPoolExecutor 类来支持周期性任务的调度。 在这之前的实现需要依靠 Timer 、 TimerTask 或者其它第三方工具来完成。 但Timer有不少的缺陷。 // ScheduledThreadPoolExecutor implements ScheduledExecutorService ScheduledThreadPoolExecutor pool =new ScheduledThreadPoolExecutor(10); pool.scheduleAtFixedRate(runnable, initialDelay, period, unit); pool.execute(runnable); 第三方 guava-17.0.jar 线程池帮助类 可以使用 guava-17.0.jar 中的一些更方便地使用线程池。 该 jar包封装了一些方法，可以让我们方便地自定义 核心线程数、最大线程数量，拒绝策略，超时时间等。 public class MyThreadPoolTool { private ExecutorService threadPool = null ; public MyThreadPoolTool(){ } private ExecutorService getThreadPool() { if (threadPool == null) { // guava-17.0.jar ThreadFactory threadFactory = new ThreadFactoryBuilder().setNameFormat(\"wk-pool-%d\").build(); RejectedExecutionHandler handler =new ThreadPoolExecutor.AbortPolicy(); if (threadPool == null) { threadPool = // 核心线程数量 ,最大线程数量 , 空闲时间 ， 时间单位 ，任务队列 ，创建工厂 ，异常提示 // 当线程池数量超过 corePoolSize 以后，空闲时间超过 keepAliveTime 线程会被终止 new ThreadPoolExecutor( 100 , 100 , 100 , TimeUnit.MICROSECONDS , new LinkedBlockingQueue(Integer.MAX_VALUE) , threadFactory , handler ) ; } } return threadPool; } public void addTask(Runnable runnable) { if (threadPool == null) { getThreadPool(); } // 如果你配置的拒绝策略是 AbortPolicy // 显式地shutdown()之后，再向线程池提交任务时 //会抛出ThreadPoolExecutor$AbortPolicy.rejectedExecution if(!threadPool.isShutdown()) { threadPool.submit(runnable) ; } } public void isShutdown() { if (threadPool != null) { if(!threadPool.isShutdown()) { threadPool.shutdownNow() ; } } } } 阿里巴巴开发规范 ,不允许使用 Executors 来创建线程池 规范要求线程池不允许使用Executors去创建，而是通过 ThreadPoolExecutor 的方式， 这样的处理方式让写的同学更加明确线程池的运行规则，规避资源耗尽的风险。 线程池拒绝策略 RejectedExecutionHandler handler1 =new ThreadPoolExecutor.AbortPolicy(); // 丢弃任务并抛出 RejectedExecutionException 异常。 RejectedExecutionHandler handler2 =new ThreadPoolExecutor.DiscardPolicy(); // 丢弃任务，但是不抛出异常 RejectedExecutionHandler handler3 =new ThreadPoolExecutor.DiscardOldestPolicy(); // 丢弃队列最前面的任务，然后重新提交被拒绝的任务 RejectedExecutionHandler handler4 =new ThreadPoolExecutor.CallerRunsPolicy(); // 由调用线程（提交任务的线程）处理该任务 线程池 如何设置 任务优先级 给线程池配置 PriorityBlockingQueue 而不是 LinkedBlockingQueue 。 PriorityBlockingQueue 是具有优先级的队列，传入的对象必须实现comparable接口。 每次添加一个元素，PriorityBlockingQueue 中 的 对象 都会执行 compareTo() 进行排序。 // 注意：优先级仅在有任务等待执行时才有意义。 假如核心线程设置为 10 ，但是你同时提交了5个线程，因为资源充足， 并不一定会按照 优先级 顺序执行，而是同时执行。 只有核心线程不足时，才会按照优先级执行。 public class PrioritizedRunnable implements Runnable, Comparable { private int priority; PrioritizedRunnable(int priority ) { this.priority = priority; } @Override public int compareTo(PrioritizedRunnable secondOne) { return Integer.compare(secondOne.priority, priority); } @Override public void run() { SystemClock.sleep(10); WkLogTool.showLog(\"priority=\"+priority); } } private void testThreadPool( ){ ThreadPoolExecutor executor = new ThreadPoolExecutor( 1, 20, // 测试的时候 注意 corePoolSize 的设置 Long.MAX_VALUE, TimeUnit.NANOSECONDS, new PriorityBlockingQueue<>()); executor.execute( new PrioritizedRunnable(5)); executor.execute( new PrioritizedRunnable(1)); executor.execute( new PrioritizedRunnable(4)); executor.execute( new PrioritizedRunnable(49)); executor.execute( new PrioritizedRunnable(3)); executor.execute( new PrioritizedRunnable(2)); executor.execute( new PrioritizedRunnable(100)); // java.util.concurrent.FutureTask cannot be cast to java.lang.Comparable //executor.submit(runnable1) ; } // 补充：经过测试，执行的顺序 不一定是 100 、49、...1， // 还有可能是 4、100、... 原因猜测是(不太确定，以后再补充)：Java是抢占式的，优先级高只是优先让当前线程执行， 并不保证优先级高的一定先执行。 如何禁止用户 手动创建 线程 使用 自定义 lint 。 无版权 可以无限制使用！ all right reserved，powered by Gitbook该文件更新时间： 2021-01-07 20:00:31 "},"chinese/java基础/equals，hashcode和==的区别.html":{"url":"chinese/java基础/equals，hashcode和==的区别.html","title":"equals，hashcode和==的区别","keywords":"","body":"相等判断 针对基本数据类型 == 比较的是它们的值是否相同 。 针对(类、接口、数组)这样的引用数据类型 。 == 比较的是它们在内存中的地址（在栈中）。 如果要比较引用对象的值是否相同，就需要重写equals方法。可以根据自己定义的规则判断对象是否相同。 hashCode()在hashSet这种集合中的使用 java规定： Set中元素无序，元素不可重复。 需要解决的问题：如何高效地判断新加的元素是否与集合中的元素不一样，从而保证保证元素不重复 ？ 解决办法： 我们可以用equals方法依次判断是否相等。但是，每增加一个元素就检查一次，那么当元素很多时，后添加到集合中的元素比较的次数就非常多了。这显然会大大降低效率。 于是，Java采用了哈希表的原理： 当集合要添加新的元素时， 先调用这个元素的hashCode方法，就一下子能定位到在hash表中的位置。 如果这个位置上没有元素，它就可以直接存储在这个位置上，不用再进行任何比较了； 如果这个位置上已经有元素了（hash碰撞现象），就调用它的equals方法与新元素进行比较，相同的话就不存，不相同就（再次求hashcode）散列其它的地址。 这样一来实际调用equals方法的次数就大大降低了，几乎只需要一两次。 如何重写hashCode() hashSet这种集合判断集合中对象是否相同，为了提升效率 ，首先进行hashCode比较 ，然后再调用 equals比较 。 @Override public int hashCode(){ int hashCode = 0; //自定义系数，随意写。只要不是特别大或特别小 导致最后hash值查出int的范围即可 int k1=5 ; //最后的hash值生成原则： 用到类里面的所有属性。 hashCode = k1 * age + name.hashCode(); return hashCode ; } @Override public boolean equals(Object obj){ //对象地址完全一样，对象肯定相等 if (obj == this){ return true; } //如果类型都不一样了，肯定不相等 if (!(obj instanceof Bean1)) { return false; } //根据自定义规则判断是否相等 Bean1 bean = (Bean1)obj; return bean.name.equals(name) && bean.age == age; } 开发中需要注意的问题 重写了equals() 就必须重写 hashCode()方法。 同一个对象，hashCode 一定相同。 否则就会违背以下的规则： equal objects must have equal hash codes · 无版权 可以无限制使用！ all right reserved，powered by Gitbook该文件更新时间： 2020-08-19 17:20:00 "},"chinese/java基础/深度拷贝.html":{"url":"chinese/java基础/深度拷贝.html","title":"深度拷贝","keywords":"","body":"深度拷贝 public List deepCopy(List src) { ByteArrayOutputStream byteOut = new ByteArrayOutputStream(); ObjectOutputStream out = new ObjectOutputStream(byteOut); out.writeObject(src); ByteArrayInputStream byteIn = new ByteArrayInputStream(byteOut.toByteArray()); ObjectInputStream in = new ObjectInputStream(byteIn); List dest = (List) in.readObject(); return dest; } // 深度克隆ByteBuffer private ByteBuffer deepCloneByteBuffer(ByteBuffer original) { ByteBuffer clone = ByteBuffer.allocate(original.capacity()); original.rewind(); clone.put(original); // 用put接口，才会把byte数组的内容拷贝到ByteBuffer中 original.rewind(); clone.flip(); return clone; } 无版权 可以无限制使用！ all right reserved，powered by Gitbook该文件更新时间： 2020-08-26 10:45:02 "},"chinese/java基础/java多态.html":{"url":"chinese/java基础/java多态.html","title":"java多态","keywords":"","body":"从一定角度来看，封装和继承几乎都是为多态而准备的。 多态的定义：指允许不同类的对象对同一消息做出响应。即同一消息可以根据发送对象的不同而采用多种不同的行为方式。 以下是现实生活中多态的例子。比方说按下 F1 键这个动作，如果当前在 Word 下弹出的就是 Word 帮助； 在 Windows 下弹出的就是 Windows 帮助和支持。同一个事件发生在不同的对象上会产生不同的结果。 Java中多态的实现方式： 1、接口实现 2、继承父类进行方法重写 3、同一个类中进行方法重载 。（特殊- 有争议） 方法重载 为什么可以实现多态？？ 多态分为编译时多态和运行时多态。 其中编译时多态是静态的，主要是指方法的重载，它是根据参数列表的不同来区分不同的函数，通过编辑之后会变成两个不同的函数，在运行时谈不上多态。 注意 方法重载这个多态和另外另个多态方式的不同 。 （个人感觉跟上面那个多态的定义不太符合。） Java实现多态有三个必要条件： 1、继承 （extends 、 implements） 2、重写 3、向上转型 //例如 ： Object cat = new Cat() 无版权 可以无限制使用！ all right reserved，powered by Gitbook该文件更新时间： 2020-08-19 17:20:00 "},"chinese/java基础/类_接口.html":{"url":"chinese/java基础/类_接口.html","title":"类_接口","keywords":"","body":"类、接口 接口完全是抽象的，不存在任何方法的实现。接口只是一种形式，接口自身不能做任何事情。 抽象类，除了不能实例化之外，它和普通的Java类没有任何区别。 抽象类接口区别 以下是常用的几点区别。另外的小细节可以在编码的时候体会得到。 1、抽象类可以有构造器 ，接口不能有构造器 问：抽象类不能new，但抽象类里为什么还要有构造方法？ 答：抽象类可以有成员变量，他们的初始化怎么做呢？这么一样你就明白为什么抽象类可以有构造函数了。 2、接口和抽象类可以被new吗 ？ Java语言规范规定了抽象类不能实例化 。接口也不能被new出来 。 但是我们平时有时会见到一些迷惑性的代码，其实那是创建了匿名内部类 。具体请参考匿名内部类的定义。 匿名内部类 造成 new 出一个 抽象函数或接口实例 的假象 // java编译器特有的写法？？ AbstractClassA test1= new AbstractClassA() { @Override public void func1() { System.out.println(\"func1...\"); } }; //错误写法，无法通过编译 AbstractClassA test2= new AbstractClassA(); 内部类 可以将一个类的定义放在另一个类的定义内部，这就是内部类。 使用内部类最大的优点就在于它能够非常好的解决多重继承的问题， 如果我们不需要解决多重继承问题，那么我们自然可以使用其他的编码方式 。 内部类是个编译时的概念，一旦编译成功后，它就与外围类属于两个完全不同的类（当然他们之间还是有联系的）。 内部类它可以无限制地访问外围类的元素。 Java中内部类主要分为成员内部类、局部内部类、匿名内部类、静态内部类。 内部类类名规则 , 带 $ 的函数 public class TestClass { // 内部类 private MyTestCallback myTestCallback = new MyTestCallback() { @Override public void showMsg(String msg) { } }; } // 编译成功后，发现有生成 TestClass$1.class class TestClass$1 implements MyTestCallback { TestClass$1(TestClass this$0) { this.this$0 = this$0; } public void showMsg(String msg) { } } 实现多重继承的方案 1、接口, 无需多说。 2、内部类。 // 这种方式实现多重继承，我认为不太优雅。 public class Father { public void strong(){ } } public class Mother { public void kind(){ } } public class Son { // 通过 2个内部类，获得两个父类的能力。 class Father_1 extends Father{ } class Mother_1 extends Mother{ } } 匿名内部类 匿名内部类没有名字 ，创建格式如下 。 new 父类构造器（参数列表）|实现接口（） { //匿名内部类的类体部分 } // 匿名内部类参数为何要为final 1、首先在内部类编译成功后，它会产生一个class文件，该class文件与外部类并不是同一class文件，仅仅只保留对外部类的引用。 2、内部类并不是直接调用方法传递的参数，而是利用自身的构造器对传入的参数进行备份， 自己内部方法调用的实际上时自己的属性而不是外部方法传递进来的参数。 3、在内部类中的属性和外部方法的参数两者从外表上看是同一个东西，但实际上却不是，也就是说在内部类中我对属性的改变并不会影响到外部的形参， 而然这从程序员的角度来看这是不可行的，毕竟站在程序的角度来看这两个根本就是同一个， 如果内部类该变了，而外部方法的形参却没有改变这是难以理解和不可接受的，所以为了保持参数的一致性，就规定使用final来避免形参的不改变。 （规定的！！） 父类的静态方法能否被子类重写 Java静态方法形式上可以重写，但从本质上来说不是Java的重写。 静态方法： java中 static修饰符修饰的方法就是静态方法。 所谓静态就是指：在编译之后所分配的内存会一直存在，不会被回收，直到程序退出内存才会释放这个空间。 static方法不是后期绑定的，它在编译期就绑定了。 静态方法是不需要对象的。自然无法根据对象的类去覆盖方法。 如果父类中定义的静态方法在子类中被重新定义，那么定义在父类中的静态方法将被隐藏。 public class Father { public static void test(){ } } public class Son extends Father{ public static void test(){ } } // Son 中有test这方法， Son.test() 执行的就是 son的test ，如果没有这个方法，调用的就是father的test . Son.test(); 无版权 可以无限制使用！ all right reserved，powered by Gitbook该文件更新时间： 2020-12-31 16:36:16 "},"chinese/java基础/泛型详解.html":{"url":"chinese/java基础/泛型详解.html","title":"泛型详解","keywords":"","body":"泛型是什么 在 Java5 以前，普通的类和方法只能使用特定的类型， 但是如果编写的代码需要应用于多种类型，这种严苛的限制对代码的束缚就会很大。 所以 Java5 引入泛型，泛型实现了参数化类型， 使得你编写的组件(通常是集合)可以适用于多种类型。 泛型将类型参数化,让编译器在编译期间帮忙检查类型错误。 在定义的时候你不知道这个地方需要什么类型的数据，只有实际使用的时候才会知道。 使用泛型 前 Object 是所有类的根类， 任何类的对象都可以设置给该Object引用变量，使用的时候可能需要类型强制转换 。 需要开发者手动做强制转换，但是如果开发者判断失误，程序运行会崩溃。 有很大的安全隐患。 使用泛型 后 这样设计的容器在使用时编译器就可以帮忙做很大一部分的类型安全检查工作了， 这就避免了很多运行时的ClassCastException异常， 程序员也无需记住各种对象的类型和担心类型匹配问题了。 (编译器在编译是就帮我们做检查，更容易发现错误。) List list = new ArrayList(); Bean bean = list.get(0) ; // 无需手动转换 泛型 通配符 原则上来讲，使用任何字母或字符串都是可以的， 但是为了代码的可读性，我们一般有如下约定。 E - Element //在集合中使用，因为集合中存放的是元素 T - Type // 类型 K - Key //键 V - Value // 值 N - Number // 数字 ? - //表示不确定的java类型、无界通配符 泛型的应用范围 泛型接口 、泛型类 、泛型方法 泛型类 public class Tool { private T value ; } 泛型接口 public interface Person { T getType(); }} 泛型方法 // 说明当前是一个泛型方法，并且将类型定义为T200 // 返回值 为 T200 public T200 showKeyName (List list) { return list.get(0) ; } public class Tool { // 静态方法不能使用类定义的泛型。 public static void show(T200 t){ // 这样使用编译器会报错 } } 泛型与可变参数 //printMsg(\"111\",222,\"aaaa\",\"2323.4\",55.55); public static void printMsg( T300... args){ for(T300 t : args){ System.out.println(\"t is \" + t); } } 泛型的 类型擦除 Java泛型 是从JDK 1.5才开始加入的， 因此为了兼容之前的版本， Java在语法上支持泛型，但是在编译阶段会进行所谓的“类型擦除”， 将所有的泛型表示（尖括号中的内容）都替换为具体的类型（其对应的原生态类型）， 就像完全没有泛型一样。 // 类型擦除验证 List list1 = new ArrayList<>(); List list2 = new ArrayList<>(); boolean result = list1.getClass() == list2.getClass() result 结果是true。 说明两个传入了不同泛型的List最终都编译成了ArrayList，成为了同一种类型， 原来的泛型参数String和Integer被擦除掉了。 协变 、逆变 、型变 、不变 定义 型变 分为 逆变 和 协变, 与不变对应。均用来描述类型转换后的继承关系; 其定义： A、B表示类型， f(⋅)表示某种类型转换，例如 f(A)=ArrayList ，f(A)=[]A ≤表示继承关系（A≤B表示A是由B派生出来的子类） 若 A≤B ，有f(A)≤f(B)成立； f(⋅) 是协变 的， 若 A≤B ，有f(B)≤f(A)成立；f(⋅) 是逆变 的 若 A≤B ，f(A) 与 f(B) 相互之间没有继承关系。 f(⋅) 是不变 的 数组的 协变 、泛型的 不变 BFruit[] BFruits = new Apple[3];// (通过) 说明 数组是 协变 的 ArrayList list = new ArrayList()//(报错)说明泛型 不是 协变 的 ArrayList list2 = new ArrayList()//(报错)说明泛型不是 逆变 的 泛型中 ? extends 和 ? super Java中泛型是不变的，可有时需要实现逆变与协变，怎么办呢？ 这时，通配符? 派上了用场。 上界通配符 实现了泛型的协变 ArrayList list3 = new ArrayList(); 下界通配符 实现了泛型的逆变 List list4 = new ArrayList(); 为什么 协变 只能读不能存 ？ BFruit[] fruits =new Banana[5] ; fruits[0] =new Apple(); System.out.println(fruits[0]);// 编译通过，但是运行报错 java.lang.ArrayStoreException ArrayList list3 = new ArrayList(); list3.add( new Apple()) ; // ( 编译报错) list3.add( new Banana()) ; // ( 编译报错) // 因为根据 里氏替换原则 ，list3 可能是 list3 = new ArrayList() // 也可能是 list3 = new ArrayList() // 如果不加限制地存进去，那么取出来的时候 ，类型转换就存在 转换异常 。 为什么 逆变 取出来的 只能放在 Object 中 ？ List list4 = new ArrayList(); list4.add( new Meat()) ; // (通过) list4.add( new Banana()) ; // (通过) Apple fruit1 =list4.get(0) ; // (编译报错) Banana fruit2 =list4.get(0) ; // (编译报错) BFruit fruit3 =list4.get(0) ; // (编译报错) Object object =list4.get(0) ; // (通过) // 因为 list4 限定的是下界是 BFruit 类型, // 编译器并不知道 里面存取的确切的类型是什么，没法找到一个合适的类型接受返回值。 // 所以只能放 Object 中 。 补充理解 ArrayList list // 定义一个list，存放 BFruit 和子类 是 BFruit的对象 。 List list ; // 定义一个list ，存放 BFruit 和 父类是 BFruit 的对象。 PECS 原则 究竟什么时候用extends什么时候用super呢？《Effective Java》给出了答案： PECS: producer-extends, consumer-super. 如果它表示一个 T 生产者，就使用 如果它表示一个 T 消费者， 就使用 PECS 这个助记符突出了 通配符类型 的基本原则。 无版权 可以无限制使用！ all right reserved，powered by Gitbook该文件更新时间： 2021-01-12 10:59:45 "},"chinese/java基础/容器类之间的区别.html":{"url":"chinese/java基础/容器类之间的区别.html","title":"容器类之间的区别","keywords":"","body":"容器类之间的区别 Array ，Arrays Array：就是数组。（我没怎么用过） Arrays：是Array的工具类，其静态方法定义了对Array的各种操作。 Collection 、 Collections Collection是接口，集合。 Collections是工具类。提供静态方法 封装了一些对集合的操作。 无版权 可以无限制使用！ all right reserved，powered by Gitbook该文件更新时间： 2020-08-19 17:20:00 "},"chinese/java基础/为什么要使用泛型.html":{"url":"chinese/java基础/为什么要使用泛型.html","title":"为什么要使用泛型","keywords":"","body":"http://blog.csdn.net/wgp15732622312/article/details/63683751 还未整理。。。 无版权 可以无限制使用！ all right reserved，powered by Gitbook该文件更新时间： 2020-08-19 17:20:00 "},"chinese/java基础/Java枚举.html":{"url":"chinese/java基础/Java枚举.html","title":"Java枚举","keywords":"","body":"Java枚举 [JDK1.5 ,+∞ ) 支持枚举 为了唯一性，所以规定了构造函数不能为public、protected 只能是private 或 不写 简单枚举 public enum CarType { BWO ,DZ ,AD } CarType type= CarType.DZ ; switch (type) { case BWO: System.out.println(\"宝马\"); break; case DZ: System.out.println(\"大众\"); break; case AD: System.out.println(\"奥迪\"); break; default: break; } 枚举类 public enum CarType { //初始化枚举实例 ，必须在构造函数前面 BWOINFO(1 ,\"宝马\" ,500.0), // 初始的值 对应构造函数的顺序 DZINFO( 2 ,\"大众\" ,600.0), ADOINFO(3 ,\"奥迪\" ,700.0) ; private int carId ; private String carName ; private double price ; private CarType(int id ,String name ,double price){ this.carId =id ; this.carName = name ; this.price = price ; } ... get set 方法 ... } // 单个实例 CarType car = CarType.BWOINFO; System.out.println(car.getCarName() + \" \" + car.getPrice()); // 修改枚举实例的值 car.setPrice(888.0); // 遍历枚举类中的所有实例 for (CarType temp : CarType.values()) { System.out.println(temp.getCarName() + \" \" + temp.getPrice()); } 枚举的缺点 每一个枚举值都是一个对象,在使用它时会增加额外的内存消耗 ，同时也会增加 DEX文件的大小 。 所以android官方文档建议尽量避免使用枚举。 Android 中枚举的替代方案 @IntDef 1、添加依赖 implementation 'com.android.support:support-annotations:28.0.0-rc02' 2、定义 public class MyDefBean { //先定义 常量 public static final int SUNDAY = 0; public static final int MONDAY = 1; public static final int TUESDAY = 2; //用 @IntDef \"包住\" 常量 声明构造器 @IntDef({SUNDAY, MONDAY,TUESDAY }) // @Retention 定义策略 @Retention(RetentionPolicy.SOURCE) // 定义‘接口’ public @interface WeekDays {} } 3、使用 @MyDefBean.WeekDays int currentDay = SUNDAY; void test(@MyDefBean.WeekDays int today) { switch (today) { case MyDefBean.MONDAY: break; case SUNDAY: break; case MyDefBean.TUESDAY: break; default: break; } } 无版权 可以无限制使用！ all right reserved，powered by Gitbook该文件更新时间： 2020-08-19 17:20:00 "},"chinese/java基础/自定义异常.html":{"url":"chinese/java基础/自定义异常.html","title":"自定义异常","keywords":"","body":"自定义异常 自定义异常方式我用的较少，一般都习惯用回调的方式回调逻辑错误。 不过，自定义错误有一个优点，方便定位异常具体地点。(点击即可跳转) public class WkException extends Exception { private static final long serialVersionUID = 1L; private String errorInfo ; private int errorCode= -100 ; public WkException(String errorInfo){ this.errorInfo = errorInfo ; } public WkException(int errorCode ,String errorInfo){ this.errorCode = errorCode ; this.errorInfo = errorInfo ; } @Override public String toString() { return errorCode+\" \"+errorInfo; } } // 使用 public static void checkValue(int value ) throws WkException{ if(value>4){ throw new WkException(1001, \"数据错误\"); } } try { checkValue(10); } catch (WkException e) { e.printStackTrace(); } 无版权 可以无限制使用！ all right reserved，powered by Gitbook该文件更新时间： 2020-08-26 11:14:24 "},"chinese/java基础/java注解.html":{"url":"chinese/java基础/java注解.html","title":"java注解","keywords":"","body":"java注解 注解 是在 Java SE 5.0 版本中开始引入的概念。 元注解 元注解是一种基本注解， 它能够应用到其它的注解上面。 元注解类型 说明 其他 @Retention 说明了这个注解的的存活时 @Retention(RetentionPolicy.RUNTIME) @Retention(RetentionPolicy.SOURCE ) @Retention(RetentionPolicy.CLASS ) @Documented 能将注解中的元素包含到Javadoc中去 - @Target 指定了注解运用的地方 @Target(ElementType.ANNOTATION_TYPE ) //可以给一个注解进行注解 @Target(ElementType.CONSTRUCTOR ) //可以给构造方法进行注解 @Target(ElementType.FIELD ) // 可以给属性进行注解 @Target(ElementType. LOCAL_VARIABLE) //可以给局部变量进行注解 @Target(ElementType.METHOD ) // 可以给方法进行注解 @Target(ElementType. PACKAGE) //可以给一个包进行注解 @Target(ElementType.PARAMETER ) //可以给一个方法内的参数进行注解 @Target(ElementType.TYPE ) //可以给一个类型进行注解，比如类、接口、枚举 @Inherited 如果一个f类被 @Inherited 注解过的注解 进行注解的话， 那么如果它的子类没有被任何注解应用的话， 那么这个子类就继承了超类的注解。 - @Repeatable Java 1.8 重复注解 ， 注解的值可以同时取多个 @Person(role=\"coder\") @Person(role=\"PM\") public class SuperMan{... Java内置的注解 说明 备注 @Deprecated 标记过时 - @Override 标记复写 - @SuppressWarnings 阻止编译器报警告提示 @SuppressWarnings(\"all\") // 抑制所有警告 @SuppressWarnings(\"boxing\") // 抑制装箱、拆箱操作时候的警告 @SuppressWarnings(\"cast\") // 抑制映射相关的警告 @SuppressWarnings(\"dep-ann\") // 抑制启用注释的警告 @SuppressWarnings(\"deprecation\") // 抑制过期方法警告 @SuppressWarnings(\"fallthrough\") // 抑制确在switch中缺失breaks的警告 @SuppressWarnings(\"finally\") // 抑制finally模块没有返回的警告 @SuppressWarnings(\"hiding\") // 忽略 关于隐藏的本地变量的警告 @SuppressWarnings(\"incomplete-switch\") // 忽略没有完整的switch语句 @SuppressWarnings(\"nls\") // 忽略非nls格式的字符 @SuppressWarnings(\"null\") // 忽略对null的操作 @SuppressWarnings(\"rawtypes\") // 使用generics时忽略没有指定相应的类型 @SuppressWarnings(\"restriction\") // 忽略 使用不建议或者禁止的引用的警告 @SuppressWarnings(\"serial\") // 忽略在serializable类中没有声明serialVersionUID变量 @SuppressWarnings(\"static-access\") // 抑制不正确的静态访问方式警告 @SuppressWarnings(\"synthetic-access\") // 抑制子类没有按最优方法访问内部类的警告 @SuppressWarnings(\"unchecked\") // 抑制没有进行类型检查操作的警告 @SuppressWarnings(\"unqualified-field-access\") // 抑制没有权限访问的域的警告 @SuppressWarnings(\"unused\") // 抑制没被使用过的代码的警告 @SafeVarargs JDK 7 阻止编译器产生 unchecked 这样的警告，效果跟 @SuppressWarnings(\"unchecked\")相同 注意：使用了这种注解后，开发者要确保自己的类型转换是没有问题的，否则运行时会报错的 @FunctionalInterface Java 1.8 当你写的接口不符合函数式接口定义的时候，编译器会报错 注解的属性 (成员变量) 注解只有属性，没有方法。 注解的属性在注解的定义中以“无形参的方法”形式来声明， 其方法名定义了该成员变量的名字，其返回值定义了该成员变量的类型。 自定义注解 一般在制作自己的框架 或者某种小工具时， 我们可以使用自定义注解 。 注意： 如果仅仅自定义了注解，并使用在代码中。这些注解并不会起作用。 如果想要真正使用上它们，你还得写一个其他工具类，利用反射等原理。 @Retention(RetentionPolicy.RUNTIME) public @interface TestAnnotation { public int id() default -1; public String msg() default \"Hi\"; } 注解与反射 通过反射获取 注解的内容。 private void testAninotation(Class clz) throws Exception { // 检测 某个类是否应用了 指定的注解 boolean hasAnnotation = clz.isAnnotationPresent(TestAnnotation.class); if(hasAnnotation){ TestAnnotation testAnnotation = clz.getAnnotation(TestAnnotation.class); //testAnnotation.id()+\" \"+testAnnotation.msg() } // 检测 某个 属性 是否应用了 指定的注解 // private void test( int age , String name ){...} /// 获取所有属性 Field[] fields = clz.getDeclaredFields(); Field a = MainActivity.class.getDeclaredField(\"testMsg\"); a.setAccessible(true); TestAnnotation testAnnotation1 = a.getAnnotation(TestAnnotation.class); if ( testAnnotation1 != null ) { // } ///检测 某个 方法 是否应用了 指定的注解 . test 是方法名 ///获取所有的类 Method[] method = clz.getDeclaredMethods(); Method testMethod = clz.getDeclaredMethod(\"test\" ,int.class ,String.class); if ( testMethod != null ) { Annotation[] ans = testMethod.getAnnotations(); for( Annotation annotation : ans) { // annotation.annotationType().getName() if(annotation instanceof TestAnnotation){ testMethod.setAccessible(true); // 在反射中调用 某个类的方法 // 第一个参数 是类的实例 ， 以后的多个参数都是方法需要的参数 testMethod.invoke( new MainActivity() , 20 , \"aivin\") ; } } } } 无版权 可以无限制使用！ all right reserved，powered by Gitbook该文件更新时间： 2020-08-19 17:20:00 "},"chinese/java基础/java8新特性.html":{"url":"chinese/java基础/java8新特性.html","title":"java8新特性","keywords":"","body":"java8新特性 java8新特性 说明 1、Lambda表达式 - 2、接口的默认方法与静态方法 - 3、方法引用 - 4、重复注解 - 5、扩展注解的支持 6、Optional - 7、Stream - 8、Date/Time API (JSR 310) - 9、JavaScript引擎Nashorn 10、Base64 java8对Base64进行优化后，放到java.util包下 Java Lambda Lambda是Java8的新特性 ，是一个语法糖 // 语法格式 (params) -> expression (params) -> statement (params) ->{ statements; } // List循环 List list = ...; list.forEach( reslut -> { reslut +=\"_修改过\" ; }); // 循环输出 list.forEach(System.out::println); //Map循环 Map map =...; map.forEach( (key ,value)-> { value +=100 ; }); map.forEach( ( key ,value ) -> System.out.println( \"key=\"+key +\" value=\"+value) ); // List 条件过滤 List result1 = // 将list转为 流 list.stream() // 将符合条件的元素过滤出来 .filter( line -> line.contains(\"aa\")) // 收集并将输出的流转为 list .collect(Collectors.toList()); result1.forEach(System.out::println); // 对象排序 List listSort= ... ; listSort.sort( (Student stu1 , Student stu2) -> stu1.age- stu2.age); listSort.forEach( (sutdent) -> { System.out.println(sutdent.name+\" : \"+sutdent.age); }); 接口的默认方法与静态方法 public interface MyMathTool { // 被 default关键字 修饰过的 sqrt 方法 将在子类上可以直接使用. // 可以有多个 默认方法 default double sqrt(int a) { return Math.sqrt(a); } } // 被 static修饰的方法 ，跟普通类的静态方法一样可以直接调用 // 可以有多个 静态方法 static double cacle(int a, int b){ return a+b ; } 方法引用 方法引用是 lambda 表达式的一种语法糖, 为了简化代码和加速开发。 当我们想要实现一个函数式接口的那个抽象方法，但是已经有类实现了我们想要的功能， 这个时候我们就可以用方法引用来直接使用现有类的功能去实现。（至于为什么可以这样，我暂时还不知道，没看源码。） 方法引用规定：实现抽象方法的参数列表，必须与方法引用方法的参数列表保持一致。返回值就不作要求。 引用分类 分类 说明 引用方法 类名::静态方法名 类名::实例方法名 实例::实例方法名 引用构造器 引用数组 // 实例::实例方法名 Consumer consumer = System.out::println; consumer.accept(\"This is Major Tom\"); // 类名::静态方法名 Function f = Math::abs; Long result = f.apply(-3L); // 类名::实例方法名 // 这个地方有点不太好理解。 // 可以暂时这样理解： 生成了一个 BiPredicate 实例b ， // 并且 b中的 方法 test里面的内容和 String类的静态方法 equals 一模一样 BiPredicate b = String::equals; b.test(\"abc\", \"abcd\"); // 引用构造器 Function fun = StringBuffer::new; StringBuffer buffer = fun.apply(10); // 引用数组 Function fun2 = Integer[]::new; Integer[] arr2 = fun2.apply(10); 函数式接口 Functional Interface 为了更友好的支持 Lambda 表达式，Java 8引入了函数式接口的概念。 所谓的函数式接口，就是是一个接口，这个接口只能有一个 抽象方法 。 1、Java 8为函数式接口引入了一个新注解 @FunctionalInterface，主要用于编译级错误检查， 加上该注解，当你写的接口不符合函数式接口定义的时候，编译器会报错。 2、加不加@FunctionalInterface对于接口是不是函数式接口没有影响， 该注解只是提醒编译器去检查该接口是否仅包含一个抽象方法 3、函数式接口里是可以包含默认方法 、静态方法、Object里的public方法 当一个类是函数式接口的时候，我们可以直接使用Lambda表达式来实例化它， 而不用写很多模板式代码。 @FunctionalInterface public interface Consumer { void accept(String msg); } // 传统 命令式、面向对象 编程 Consumer consumer = new Consumer() { @Override public void accept(String msg) { } }; // Lambda 表达式写法 更简洁 Consumer consumer2 = (String msg) -> { } ; 内置的函数式接口 为了方便开发者，java8内置了一批函数式接口。 Java8内置的函数式接口 参数类型 返回类型 用途 Consumer T void 对类型T参数操作，无返回结果，包含方法 void accept(T t) Supplier 无 T 返回T类型参数，方法时 T get() Function T R 对类型T参数操作，返回R类型参数，包含方法 R apply（T t） Predicate T boolean 断言型接口，对类型T进行条件筛选操作，返回boolean，包含方法 boolean test（T t） BinaryOperator T,T T 对类型T对象进行二元运算，并返回T类型的结果，包含方法T apply(T t1,T t2) BigConsumer T,U void 对类型T，u参数进行操作，包含方法void accept（T t,U u） BiConsumer 代表了一个接受两个输入参数的操作，并且不返回任何结果 BiFunction 代表了一个接受两个输入参数的方法，并且返回一个结果 BinaryOperator 代表了一个作用于于两个同类型操作符的操作，并且返回了操作符同类型的结果 BiPredicate 代表了一个两个参数的boolean值方法 BooleanSupplier 代表了boolean值结果的提供方 Consumer 代表了接受一个输入参数并且无返回的操作 DoubleBinaryOperator 代表了作用于两个double值操作符的操作，并且返回了一个double值的结果。 DoubleConsumer 代表一个接受double值参数的操作，并且不返回结果。 DoubleFunction 代表接受一个double值参数的方法，并且返回结果 DoublePredicate 代表一个拥有double值参数的boolean值方法 DoubleSupplier 代表一个double值结构的提供方 DoubleToIntFunction 接受一个double类型输入，返回一个int类型结果。 DoubleToLongFunction 接受一个double类型输入，返回一个long类型结果 DoubleUnaryOperator 接受一个参数同为类型double,返回值类型也为double 。 IntBinaryOperator 接受两个参数同为类型int,返回值类型也为int 。 IntConsumer 接受一个int类型的输入参数，无返回值 。 IntFunction 接受一个int类型输入参数，返回一个结果 。 IntPredicate 接受一个int输入参数，返回一个布尔值的结果。 IntSupplier 无参数，返回一个int类型结果。 IntToDoubleFunction 接受一个int类型输入，返回一个double类型结果 。 IntToLongFunction 接受一个int类型输入，返回一个long类型结果。 IntUnaryOperator 接受一个参数同为类型int,返回值类型也为int 。 LongBinaryOperator 接受两个参数同为类型long,返回值类型也为long。 LongConsumer 接受一个long类型的输入参数，无返回值。 LongFunction 接受一个long类型输入参数，返回一个结果。 LongPredicate R接受一个long输入参数，返回一个布尔值类型结果。 LongSupplier 无参数，返回一个结果long类型的值。 LongToDoubleFunction 接受一个long类型输入，返回一个double类型结果。 LongToIntFunction 接受一个long类型输入，返回一个int类型结果。 LongUnaryOperator 接受一个参数同为类型long,返回值类型也为long。 ObjDoubleConsumer 接受一个object类型和一个double类型的输入参数，无返回值。 ObjIntConsumer 接受一个object类型和一个int类型的输入参数，无返回值。 ObjLongConsumer 接受一个object类型和一个long类型的输入参数，无返回值。 Predicate 接受一个输入参数，返回一个布尔值结果。 Supplier 无参数，返回一个结果。 ToDoubleBiFunction 接受两个输入参数，返回一个double类型结果 ToDoubleFunction 接受一个输入参数，返回一个double类型结果 ToIntBiFunction 接受两个输入参数，返回一个int类型结果。 ToIntFunction 接受一个输入参数，返回一个int类型结果。 ToLongBiFunction 接受两个输入参数，返回一个long类型结果。 ToLongFunction 接受一个输入参数，返回一个long类型结果。 UnaryOperator 接受一个参数为类型T,返回值类型也为T。 函数式编程 functional programming 命令式 编程语言包括 过程式编程 和 面向对象编程(OOP) 。 函数式编程( FP ) 是一种 编程范式 ，是一种编程思想。 // 命令式编程 更加注重 “如何做”，主要思想是关注计算机执行的步骤，即一步一步告诉计算机先做什么再做什么。 // 声明式编程 主要思想是告诉计算机应该做什么，但不指定具体要怎么做，SQL语句就是最明显的一种声明式编程的例子。 //函数式编程 函数式编程和声明式编程是有所关联的，他们都只关注做什么而不是怎么做。 但函数式编程不仅仅局限于声明式编程。 OOP 关注对象方法的调用，而 FP关注函数之间的调用。 // 函数式编程的特点 1、函数是一等公民。函数可以作为参数 也可以作为返回值。 函数与其他数据类型一样，处于平等地位。 var print = function(i){ console.log(i);}; [1,2,3].forEach(print); // print 就是一个函数，可以作为另一个函数的参数。 2、无副作用。 所有功能就是返回一个新的值，没有其它行为，不修改外部的值 ,不改变 input。 3、引用透明 只依赖于输入的参数，任何时候只要参数相同，引用函数所得到的返回值总是相同的。 4、易于 并发编程 因为它不修改变量，所以根本不存在\"锁\"线程的问题。 总是感觉 Java8的函数式编程有点奇怪。 网上很多文章直接将 函数式编程跟 lambd 或 流式 对应。感觉不太对。 以下举例来自 阮一峰 的博客 现在有这样一个数学表达式 (1 + 2) * 3 - 4 ， 传统的过程式编程，可能这样写： var a = 1 + 2; var b = a * 3; var c = b - 4; 函数式编程要求使用函数，我们可以把运算过程定义为不同的函数，然后写成下面这样 var result = subtract( multiply( add(1,2) , 3), 4); 为什么 函数式编程 又被大量采用和支持 c++ 11 、Java8 都纷纷加入支持 1、精简代码，去掉冗余的模板代码 2、函数式编程 天生的 可以并行特性 。 现在 cpu 和 内存 越来越够用 ， 对于越来越庞大的代码，与其 费大力气去 解决 各种锁和同步问题， 不如直接改用根本不会导致这些问题的 FP 方案 。 匿名函数 参考匿名类。 匿名函数就是一个没有名字的函数。 常与 Lambda 搭配使用 // 新建了一个Runnable 对象。省略了 Runnable 的run函数的名字. Runnable r = () -> System.out.println(\"Thread start...\"); new Thread(r).start(); Optional 是一个封装了一个元素的容器，而这个元素可以是null也可以是其它任意类型的。 Optional 的方法 说明 Optional.of(T t) 创建一个 Optional 实例 Optional.ofNullable(T t) 若 t 不为 null,创建 Optional 实例,否则创建空实例 Optional.empty() 创建一个空的 Optional 实例 optional.get() 获取Optional中的值 optional.isPresent() 判断optional对象是否有值 Stream 这个 Stream 并不是我们以前认识的IO流， 而是一个数据渠道，用于操作数据源（集合、数组等）所生成的元素序列。 Stream API 提供了一种高效且易于使用的处理数据的方式 ，例如 非常复杂的查找、过滤和映射数据等 。 Stream 不会改变源对象。它会返回一个持有结果的新Stream（这样可以链式编程）。 Stream 延迟执行 只要Stream的方法返回的对象是Stream，这些方法就是延迟执行的方法 。 一般在Stream流中，一个方法返回的不是Stream，基本就是 迫切方法 。 // 由集合创建 Stream List list = new ArrayList<>(); //获取一个顺序流 Stream stream = list.stream(); //获取一个并行流 Stream parallelStream = list.parallelStream(); // 由数组创建流 Integer[] nums = new Integer[8]; Stream stream3 = Arrays.stream(nums); // 由值创建流 Stream stream4 = Stream.of(1,2,3,4,5); // 由函数创建流 , 会不停打印一个随机数 Stream.generate(() -> Math.random()).forEach(System.out::println); Stream.iterate(1, (x) -> x + 1).forEach(System.out::println); // 筛选 ,自定义 List list2 = Arrays.asList(2, 3, 5, 4, 4,4, 1, 8, 10, 9, 7, 6); list2.stream() .filter((e) -> e > 5).forEach(System.out::println); // 筛选 ，去重 list2.stream() .distinct() .forEach(System.out::println); // 切割 ，限定个数 list2.stream().limit(3).forEach(System.out::println); // 返回一个去掉了前 n 个元素的流。若元素不足 n 个，则返回一个空流。 list.stream().skip(3).forEach(System.out::println); // 映射 , 将 参数 经过自定义处理后 再返回 list2.stream() .map(x -> x*x) .forEach(System.out::println); // 特殊的 映射操作 ， 结果一定要是 double类型 list2.stream() .mapToDouble(x -> x+0.1) .forEach(System.out::println); // 特殊的映射 ， 将流中的每个元素映射成一个流 list2.stream() .flatMap( xxx ) .forEach(System.out::println); // 按自然顺序排序 list2.stream() .sorted() .forEach(System.out::println); // 自定义排序 list.stream() .sorted( (x,y) -> -x.compareTo(y) ) .forEach(System.out::println); // 检查是否匹配所有元素 ,(是否全部元素都大于2) boolean allMatch = list2.stream() .allMatch(x -> x > 2); // 匹配元素位置 Optional first = list2.stream() .findFirst(); int val = first.get(); // 求最大值 最小值 Optional first1 = list2.stream() .min(Integer::compareTo); Optional first2 = list2.stream() .max(Integer::compareTo); Integer val1 = first.get(); // 将流中元素收集到List中 List resultList = list2.stream() .collect(Collectors.toList()); // 将流中元素收集到Set中 Set resultSet = list2.stream() .collect(Collectors.toSet()); 日期时间 API 在旧版的 Java 中，日期时间 API 存在很多问题，比如线程安全问题 、命名、设计、分包不合理等问题。 Java 8 提供的日期时间 API都在java.time包下， 这个包涵盖了所有处理日期(date)，时间(time)，日期/时间(datetime)， 时区（zone)，时刻（instant），间隔（duration）与时钟（clock）的操作 // 获取当前日期时间 LocalDateTime now = LocalDateTime.now(); int year = now.getYear(); int month = now.getMonthValue() ; int day = now.getDayOfMonth() ; // 将当前日期时间减去两天 LocalDateTime dateTime2 = now.minusDays(2); // 将当前日期时间加上五天 LocalDateTime dateTime3 = now.plusDays(5); // 构造一个指定日期时间的对象 , 年 月 日 时 分 LocalDateTime dateTime = LocalDateTime.of(2016, 10, 23, 8, 20); // 获取当前时间的时间戳 Instant instant = Instant.now(); // 结果跟System.currentTimeMillis()一样 long milli = instant.toEpochMilli(); // 时区偏移 OffsetDateTime dateTime4 = instant.atOffset(ZoneOffset.ofHours(8)); //时间间隔 LocalTime start = LocalTime.now(); LocalTime end = LocalTime.now(); Duration duration = Duration.between(start, end); // 日期间隔 LocalDate startDate = LocalDate.of(2015, 3, 4); LocalDate endDate = LocalDate.of(2017, 8, 23); Period period = Period.between(startDate, endDate); // 日期格式化 为字符串 ， 内置格式 LocalDate now6 = LocalDate.now(); String strNow = now6.format(DateTimeFormatter.BASIC_ISO_DATE); // 日期格式化 为字符串 ， 自定义格式 String strNow2 = now6.format(DateTimeFormatter.ofPattern(\"yyyy年MM月dd日\")); // 将字符串转换成日期 LocalDate date = LocalDate.parse(strNow2, DateTimeFormatter.ofPattern(\"yyyy年MM月dd日\")); // 目前支持的时区 Set set = ZoneId.getAvailableZoneIds(); //获取当前时区的日期时间 ZonedDateTime now3 = ZonedDateTime.now(); //获取美国洛杉矶时区的日期时间 ZonedDateTime USANow = ZonedDateTime.now(ZoneId.of(\"America/Los_Angeles\")); 重复注解 在 java8 以前，同一个程序元素前最多只能有一个相同类型的注解； 如果需要在同一个元素前使用多个相同类型的注解，则必须使用注解“容器”。 java8简化了使用的步骤，虽然仍然要定义“容器” 。但是直接使用的就是注解。 // java8 之前的写法 @Retention(RetentionPolicy.RUNTIME) public @interface Authority { String role(); } @Retention(RetentionPolicy.RUNTIME) public @interface Authorities { Authority[] value(); } @Authorities({@Authority(role = \"Admin\"), @Authority(role = \"Manager\")}) private void test( ) { ... } // java8 及之后的写法 @Retention(RetentionPolicy.RUNTIME) @Repeatable(Authorities.class) public @interface Authority { String role(); } @Retention(RetentionPolicy.RUNTIME) public @interface Authorities { Authority[] value(); } @Authority( role = \"Admin\" ) @Authority( role = \"Manager\" ) private void test( ) { ... } 无版权 可以无限制使用！ all right reserved，powered by Gitbook该文件更新时间： 2020-12-30 15:35:24 "},"chinese/通信方式/通信方式.html":{"url":"chinese/通信方式/通信方式.html","title":"通信方式","keywords":"","body":"http 、https 方式 1、http是基于 TCP/IP 的应用层协议 。 2、 采用 “一问一答” 模式 ，并不会保持长连接。 3、HTTP允许传输任意类型的数据对象。传输的类型由Content-Type加以标记。 Content-type HTTP Content-type 手册 文件扩展名 Content-Type .*（ 二进制流，不知道下载文件类型） application/octet-stream .txt text/plain .xml text/xml .css text/css .html text/html .js application/x-javascript 以下是RFC1867协议为HTTP协议的基础上|-为INPUT标签增加了file属性 文件扩展名 Content-Type 无文件的表单提交 application/x-www-form-urlencoded 有文件的表单提交 multipart/form-data 没查到何人何时 添加支持“json提交格式 ”的。 文件扩展名 Content-Type json格式的请求 application/json 建立、断开 http连接 http建立连接，底层是通过 Tcp协议 经过了3次握手、断开经过4次挥手。具体请查看tcp的相关知识。 TCP/IP协议族 https请求 即使采用了 HTTPS，也可以实现中间人攻击，或者进行数据解密等，但是，目前 HTTPS 目前使用的加密算法需要巨大的计算量才能破解 HTTPS 的目的主要有三个， 一个是数据的保密性，你给别人送个邮包，但邮包是打了封印的，快递员不知道包里装的是啥。 第二是数据的完整性，快递员不知道邮包是啥，但可以掉包啊，HTTPS 发现了掉包的数据，可以拒收。 第三就是身份验证，HTTPS 可以保证邮包被正确的送到指定的接收方，而不是第三方。 https相关术语 专业名词 解释 其他 SSL（Secure Sockets Layer） 网景公司设计的 单向证书认证 任何客户端都可以访问服务器 双向证书认证 被允许的客户端才能访问服务器 对称加密 加密和解密时使用的是同一个秘钥 非对称加密 用公钥加密，私钥解密 https 在内容传输的加密上使用的是对称加密，非对称加密只作用在证书验证阶段。 公钥 负责加密 在网络上传输 私钥 负责解密 本地保管，别人无法获取 // 对称加密 常见的 对称加密算法 有 DES、3DES、Blowfish、IDEA、RC4、RC5、RC6 、 AES 。 在数据传送前，发送方和接收方必须商定好秘钥。 用同一个秘钥进行加密和解密。如果一方的秘钥遭泄露，那么整个通信就会被破解。 // 非对称加密 常见的非对称加密算法有: RSA、ECC 、Diffie-Hellman、El Gamal、DSA 秘钥自己私下保管，公钥可以公开 ，别人通过公钥加密的信息发给你，只有通过私钥才能解密。 不用担心别人把秘钥泄露而导致整个通信被破解。 // md5 md5 不是对称和非对称算法。而是一种机制，一般用来做一致性校验。 对任何文件或内容 都生成 一串 32位的字符。不能根据字符反推。 比如一个很大的文件，下载完成之后要验证下 md5和给出的是否一致，如果不一致 说明你下载出错了或者文件被别人修改过。 虽然MD5 有很小很小的概率发生碰撞(可以忽略不计)，是一种非常优秀的算法。 ftp 第三方工具ftp4j ftp登录 public void run(){ //标记是否登录成功 boolean loginError = false ; try { mFTPClient.setType(FTPClient.TYPE_BINARY); //中文文件名 乱码处理 mFTPClient.setCharset(\"GBK\"); //登录成功后FTP服务器返回的欢迎语句 String[] welcome = mFTPClient.connect(FTP.HOST_IP, FTP.HOST_PORT); mFTPClient.login(FTP.HOST_USER, FTP.HOST_PASSWORD); mHandler.sendEmptyMessage(FTP.MSG_CMD_CONNECT_OK); }catch (Exception e) { loginError = true ; } if(loginError && FTP.mDameonRunning){ mHandler.sendEmptyMessageDelayed(FTP.MSG_CMD_CONNECT_FAILED, 2000); } } ftp删除文件（夹） public void run(){ try { if (isDirectory) { //删除文件夹 mFTPClient.deleteDirectory(realivePath); } else { //删除文件 mFTPClient.deleteFile(realivePath); } mHandler.sendEmptyMessage(FTP.MSG_CMD_DELE_OK); } catch (Exception ex) { mHandler.sendEmptyMessage(FTP.MSG_CMD_DELE_FAILED); } } ftp断开连接 if (mFTPClient != null){ try { mFTPClient.disconnect(true); } catch (Exception ex) { ex.printStackTrace(); } } ftp文件下载 if(! localFile.exists()){ long fileSize = ftpFile.getSize() ; if(fileSize > 0){ mFTPClient.download( ftpFile.getName(), new File(localFilePath), new DownloadFTPDataTransferListener(ftpFile.getSize())); }else{ //文件异常的情况 下载发生异常the size of file muset be larger than zero. } } ftp 获取文件列表 @Override public void run(){ try { mFTPClient.changeDirectory(FTP.FTPSMAllPICDIR); FTPFile[] ftpFiles = mFTPClient.list(); synchronized (mLock){ mFileList.clear(); //数组拷贝到list中去 mFileList.addAll(Arrays.asList(ftpFiles)); } mHandler.sendEmptyMessage(FTP.MSG_CMD_LIST_OK); } catch (Exception ex) { mHandler.sendEmptyMessage(FTP.MSG_CMD_LIST_FAILED); } }// ftp 文件上传（进度条） try { File file = new File(path); mFTPClient.upload(file, new DownloadFTPDataTransferListener( file.length())); } catch (Exception ex) { return false; } ftp 连接守护进程 //在子线程中定时判断 if (mFTPClient != null && !mFTPClient.isConnected()){ try { //解决中文件名乱码问题 mFTPClient.setType(FTPClient.TYPE_BINARY); mFTPClient.setCharset(\"GBK\"); mFTPClient.connect(FTP.HOST_IP, FTP.HOST_PORT); mFTPClient.login(FTP.HOST_USER, FTP.HOST_PASSWORD); Thread.sleep(FTP.MAX_DAMEON_TIME_WAIT); } catch (Exception ex) { } } FTP 传输进度 回调 public class DownloadFTPDataTransferListener implements FTPDataTransferListener{ /**已经传送量*/ private int totolTransferred = 0; /**数据总量*/ private long fileSize = -1; public DownloadFTPDataTransferListener(long fileSize){ if (fileSize 使用场景 FtpManager ftpManager = new FtpManager(); //然后 ftp 的相关操作 要放到子线程中去执行。 建议使用线程池。 sockt tcp_udp 进行tcp通信时，需要注意处理 粘包的问题。然后控制好休眠时间 和 接收的 buffer[] 大小。 TCP标志位 (位码) 标记 含义 SYN synchronous 建立联机 ACK acknowledgement 确认 PSH push传送 FIN finish结束 RST reset重置 URG urgent紧急 术语 Sequence number 顺序号码 Acknowledge number 确认号码 MSL Maximum Segment Lifetime ，报文最长存活时间 tcp相关问题 为什么连接的时候是三次握手，2次不行吗? 为了让服务器、客户端端彼此知道 自己+对方的 接收、发送功能正常。 自己模拟一下就知道至少需要三次。 为什么连接的时候是三次握手，关闭的时候却是四次挥手？ 关闭连接时，当Server端收到FIN报文时，很可能并不会立即关闭SOCKET， 所以只能先回复一个ACK报文，告诉Client端，\"你发的FIN报文我收到了\"。 只有等到我Server端所有的报文都发送完了，我才能发送FIN报文，因此不能一起发送。 故需要四步挥手。 （为了争取一段缓冲时间，完成正在进行的数据传输） 为什么客户端在TIME-WAIT状态必须等待2MSL (Maximum Segment Lifetime) 的时间？ 为了保证客户端发送的最后一个ACK报文段能够到达服务器。 因为这个ACK报文段有可能丢失，因而使处在LAST-ACK状态的服务器收不到对已发送的FIN+ACK报文段的确认。 服务器会超时重传这个FIN+ACK报文段。而客户端就能在2MSL时间内收到这个重传的FIN+ACK报文段。 接着客户端重传一次确认，重新启动2MSL计时器。 最后客户端和服务器都正常进入到CLOSED状态。 粘包处理 目前不是最优方法，速度有点慢。想到高效的方法再补充。 public class AirUnPackTools{ /**帧头*/ private static final byte packHead1= (byte) 0xDD; /**是否在有效数据之内*/ private static boolean isContinue = false ; private static byte mlastByte =(byte) 0x00 ; /**byte索引 ， 用来指示 关键字 和 长度 */ private static int mByteIndex = 0; /**当前帧的长度*/ private static int mFrameLengh =0 ; /**临时list*/ private static List lastBytesList = new ArrayList<>() ; /**数据段 数据长度 */ private static int mbyteCount = 0; /**遥控器返回的消息类型 = 0x55 ,5a ,5b ， 00为默认状态，无意义*/ private static byte msgType =0x00 ; public static DronePacket320 unPackageofGround(byte mByte){ DronePacket320 packetGround = null ; //判断是否是帧开头 switch (mByte) { case packHead1: // 连续出现2个DD ，说明这是帧头 if(mlastByte == packHead1 ) { lastBytesList.clear(); lastBytesList.add(packHead1) ; mByteIndex = 0; isContinue = true ; } break; } if(isContinue) { boolean reslut = getUnpackagedFrame(mByte); if(reslut) { packetGround = new DronePacket320() ; packetGround.msgType = msgType ; packetGround.bytes = listToBytesArray(lastBytesList) ; }else{ packetGround = null ; } }else{ packetGround = null ; } mlastByte = mByte ; return packetGround ; } public static byte [] listToBytesArray(List list) { byte[] bytes = new byte[list.size()] ; for(int i= 0; i public class DronePacket320{ public short msgType; public byte[] bytes; } //使用 for (int i = 0; i 第三方库 netty 用来连接tcp、接收 和发送数据的 public interface MyNettyCallBack{ /**tcp成功建立连接*/ public static final int Key_State_connect=1 ; /**tcp断开*/ public static final int Key_State_disConnect=2 ; /**tcp正在重连*/ public static final int Key_State_isReConnect=3 ; /**连接发生异常*/ public static final int Key_State_error=4; /**连接手动关闭*/ public static final int Key_State_close=5; /**连接正常-正在接收数据*/ public static final int Key_State_recevieData=6; /**服务器返回信息给客户端*/ public void sendMsgToUser(byte[] reslut , int state ,String stateMsg) ; } public class NettyTcpTools{ private int port; private String host; private SocketChannel socketChannel; private Bootstrap bootstrap; private boolean isConnect = false; /**是否需要重连*/ private boolean isRepeate = false; /**用来区分是用户主动断开还是异常导致断开用户主动断开的话就不用去重连*/ private boolean isStopByUser =false ; /**通信管道*/ private ChannelFuture future = null; /**状态回调*/ private MyNettyCallBack myNettyCallBack ; /**线程池工具*/ private MyThreadPoolTools myThreadPoolTools ; public NettyTcpTools(String host , int port){ this.port = port; this.host = host; bootstrap = new Bootstrap(); bootstrap.channel(NioSocketChannel.class); //保持长连接 bootstrap.option(ChannelOption.SO_KEEPALIVE, true); //自动调整下一次缓冲区建立时分配的空间大小，避免内存的浪费 bootstrap.option(ChannelOption.RCVBUF_ALLOCATOR, new AdaptiveRecvByteBufAllocator(1024, 1024 * 32, 1024 * 64)); bootstrap.group( new NioEventLoopGroup()); bootstrap.remoteAddress(host, port); bootstrap.handler(new ChannelInitializer() { @Override protected void initChannel(SocketChannel socketChannel) throws Exception { //超时处理 socketChannel.pipeline().addLast(new IdleStateHandler(3, 3, 3 ,TimeUnit.SECONDS)); //接收服务器信息 socketChannel.pipeline().addLast( new NettyClientHandler()); } }); } private void gotoConnectTcp(){ closeThreadPool(); myThreadPoolTools= new MyThreadPoolTools(); Runnable task = new Runnable() { @Override public void run() { isStopByUser = false ; try { if (future != null) { boolean isActive = future.channel().isActive() ; boolean isOpen = future.channel().isOpen() ; MyLogUtils.mLog_iNormal(\"连接测试：isActive=\" + isActive +\" isOpen=\"+ isOpen); /* 这个地方注意了： 如果 没有关闭，会导致多个tcp连接 使用 网络调试助手.exe 进行调试查看*/ future.channel().close(); } future = bootstrap.connect(new InetSocketAddress(host, port)).sync(); if (future.isSuccess()) { socketChannel = (SocketChannel) future.channel(); sendMsgToUser(null ,MyNettyCallBack.Key_State_connect ,\"connect server Success\"); isConnect = true; return; } } catch (Exception cause) { sendMsgToUser(null ,MyNettyCallBack.Key_State_error ,\"error2:\"+cause.toString()); } //连接状态在此处处理 repeateTcp(); } }; if (myThreadPoolTools == null) { myThreadPoolTools= new MyThreadPoolTools(); } myThreadPoolTools.addTask(task); } public void startTcpTools(){ gotoConnectTcp(); } private void closeThreadPool(){ if(myThreadPoolTools!=null) { myThreadPoolTools.shutdownThreadPool(); myThreadPoolTools=null ; } } public void nettySendBytes(final byte[] bytesSend) { Runnable runnable = new Runnable() { @Override public void run() { if (isConnect) { ByteBuf buf = Unpooled.buffer(bytesSend.length); buf.writerIndex(); buf.writeBytes(bytesSend); socketChannel.writeAndFlush(buf); } } } ; if (myThreadPoolTools == null) { myThreadPoolTools= new MyThreadPoolTools(); } myThreadPoolTools.addTask(runnable); } public class NettyClientHandler extends SimpleChannelInboundHandler{ @Override protected void channelRead0(ChannelHandlerContext channelHandlerContext,ByteBuf byteBuf) throws Exception { //这里是接受服务端发送过来的消息 byte[] result = new byte[byteBuf.readableBytes()]; byteBuf.readBytes(result); /*这种方式会定长读取，后面有很多00 00 00 byte[] bytes = byteBuf.array();*/ sendMsgToUser(result ,MyNettyCallBack.Key_State_recevieData ,\"channelRead0\"); } /**这里是断线要进行的操作*/ @Override public void channelInactive(ChannelHandlerContext ctx) throws Exception { super.channelInactive(ctx); ctx.close() ; if(!isStopByUser) { sendMsgToUser(null ,MyNettyCallBack.Key_State_disConnect ,\"channelInactive\"); repeateTcp(); } } /**这里是出现异常的话要进行的操作*/ @Override public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception { //ctx.close() ; sendMsgToUser(null ,MyNettyCallBack.Key_State_error ,\"error1:\"+cause.toString()); repeateTcp(); } /**用来处理读写超时的 自定义操作*/ @Override public void userEventTriggered(ChannelHandlerContext ctx, Object evt) throws Exception { super.userEventTriggered(ctx, evt); if (evt instanceof IdleStateEvent) { IdleStateEvent event = (IdleStateEvent) evt; if (event.state().equals(IdleState.READER_IDLE)) { // 在指定的时间内没有收到服务器的反馈信息 } else if (event.state().equals(IdleState.WRITER_IDLE)) { //在指定的时间内没有像服务器发送过信息 } else if (event.state().equals(IdleState.ALL_IDLE)) { //在指定的时间内 既没有收到过信息 也没有发送过信息 } } } } // 设置消息回调接口，用来获取从服务器返回的消息。 public void setMyNettyCallBack(MyNettyCallBack myNettyCallBack) { this.myNettyCallBack = myNettyCallBack ; } private void sendMsgToUser(byte[] result , int state ,String sendMsgToUser) { if (myNettyCallBack != null) { myNettyCallBack.sendMsgToUser(result ,state ,sendMsgToUser); } } // tcp重连 private void repeateTcp() { if(isStopByUser) { return; } if (!isRepeate) { if (isConnect) { isConnect = false; //断线监听在此处处理 } isRepeate = true; sendMsgToUser(null ,MyNettyCallBack.Key_State_isReConnect ,\"repeateTcp\"); try { TimeUnit.SECONDS.sleep(5); } catch (InterruptedException e) { e.printStackTrace(); } isRepeate = false; startTcpTools(); } } // 关闭 tcp连接 public void nettyToolsClose() { resetState(); closeThreadPool(); if (future != null && future.channel() != null) { if (future.channel().isOpen()) { sendMsgToUser(null ,MyNettyCallBack.Key_State_close ,\"close\"); future.channel().close(); } } } private void resetState() { isConnect = false; isRepeate=false; isStopByUser = true ; } } 拓展知识 数字信号 、模拟信号 模拟信号和数字信号之间是可以相互转换的。 模拟信号：时间连续，幅值连续。 数字信号：时间离散，幅值离散。 在电学中，将连续变化的电压、电流等物理量称为模拟信号，而离散变化的电压、电流则称为数字信号。 模拟信号在日常生活中很常见，譬如家用的220V交流电压、环境温度及光线的变化、蓄电池的放电、人的说话声，这些皆为模拟信号。 数字信号的波形如上图所示，是一个由一系列高低电平组成的离散变化的物理量。数字信号在生活中较少见。 数字信号就是一系列的“0”和“1”的组合。 咱们自然界中各种事物变化，都是模拟信号，比如，随着时间的流逝，太阳缓缓升起， 在这里，时间是连续变化的，太阳的位置也是连续变化的，每一个时间点，对应于一个太阳的位置。 现在，咱们为了研究太阳位置的变化规律，要将这个时间与太阳的位置变化关系交给计算机研究。 有个问题：咱们的时间是连续的，可以无限分下去的，同样的，太阳的位置点也可以有无穷多个，咱们该如何把这么多的数据存储起来呢？ 并且，对于咱们的研究来说，真的需要将这么多的数据存储下来吗？ 所以咱们要进行离散化的处理，比如早晨8点到10点，每隔5分钟，咱们记录一个太阳的位置，这样，储存的数据是不是大大减少了？ 现在，对于这个问题，咱们的时间变量，变成了每隔五分钟一个，咱们的太阳位置，也相对应的变成了离散化的， 也就是说，时间是离散化的，幅值也是离散化的。变成了一个数字信号，也就可以交给计算机处理啦。 OSI ( Open System Interconnection ) 七层模型 // 物理层 物理设备、例如网线、电缆、集线器等. // 链路层 数据链路层，负责对于底层物理信号识别成某种信息。为了匹配物理层电气特征。 将比特组合成字节,再将字节组合成帧,使用链路层地址 (以太网使用MAC地址)来访问介质,并进行差错检测。 链路层就像同城跑腿（网络层是跨城跑腿，类似邮局快递等），你把货交给他，告诉他地址，他直接送达。 链路层识别mac地址，链路联通后，交换机学习各端口的mac地址，建立mac地址转发表，然后链路层就开始工作了。 // 网络层 就是通常说的IP层。这一层就是我们经常说的IP协议层。IP寻址、IPV4 / IPV6 等。 本层通过IP寻址来建立两个节点之间的连接，为源端的运输层送来的分组，选择合适的路由和交换节点， 正确无误地按照地址传送给目的端的运输层。 网络层按理来说，数据链路层已经能够起到信息识别的作用了，为何还需要网络层呢？ 关键就在于数据链路层所能识别出的信息，能够很好的被机器理解。但不能很好的被人所理解。所以需要构建一层来方便人来进行处理。 为什么有了MAC地址，还需要IP地址？ 历史原因：以太网诞生于因特网之前，在IP地址之前MAC地址就已经在使用了。两者结合使用，是为了不影响已存在的协议 分层实现：对网路协议进行分层以后，数据链路层的实现不需要考虑数据之间的转发，网络层的实现不需要考数据链路层的影响。 分工合作：IP地址是会随着主机接入网络的不同而发生改变的，而MAC一般不会改变。这样的话，我们可以使用IP地址进行寻址，当数据报和目的主机处于同一网络时，就使用MAC地址进行数据交付。 // 传输层 对网络层的进一步封装，TCP 、UDP 就是这一层。 // 会话层 负责建立和断开通信连接（数据流动的逻辑通路）。 例如要根据你自己的逻辑，来决定什么时候要进行数据连接、数据重连、连接断开等。 // 表示层 主要负责数据格式的转换。将设备固有的数据格式转换为网络标准传输格式，不同设备对同一比特流解释的结果可能会不同。 例如同样的一串 byte[]数据，不同的APP采用的不是同一套解析协议，所以要根据不同的协议转为APP能识别的信息。 // 应用层 有些分层版本中，将 会话层+表示层+ 应用层 = 统一称为应用层。 因为会话层和表示层没有办法完全抽象成公共层，一般都是和应用层一起实现。 就是各个公司开发的不同的应用。例如 HTTP超文本传输、 HTTPS FTP文件传输 、SMTP邮件传输 等不同侧重方向的传输协议。 usb 通信 AOA协议 Google推出的 Android开放配件协议AOA（Android Open Accessory Protocol）及配件开发工具包ADK（Accessory Development Kit） 提供了Android设备与Android配件通过USB或蓝牙进行通信的API， 为基于Android系统的智能设备控制外设提供了条件。 利用Android，系统可以连接从家用电器到重型机械、机器人等多种设备。 当前项目用到的是 android 的AOA协议。遥控器作为主机供电，移动设备（手机、平板）作为从机。 使用方法请自行查阅相关文档。 使用场景一 ：android设备作为从机 参考资料 这种模式是Android定义的一种新的通讯模式，它将usb配件作为协议交互的主要角色，配件内置USB Embedded Host端，可以为Android手机供电，并且识别Android手机，建立数据通道。使得配件成为一个简化版的PC Host端。 usb通信demo MusbAccessoryManager.java /** * usb 操作管理类 */ public class MusbAccessoryManager{ private Context mCtx; /**文件操作符*/ private ParcelFileDescriptor fileDescriptor; /**输入流*/ private FileInputStream inputStream; /**输出流*/ private FileOutputStream outputStream; /**读线程*/ private AccessoryReadThread readThread; /**写线程*/ private AccessoryWriteThread writeThread; /**解析线程*/ private BytesDataRepackThread repackThread ; /**usb 通信是否在进行*/ private boolean enableThread; /**发送队列*/ private BlockingQueue outQueue; /**读取队列*/ private BlockingQueue readQuene; /**回调接口 - 状态标记*/ private IOperateResultCallBack iUsbResultCallBack ; /**回调接口 - byte[] 传输*/ //private IBytesTransferInterface iGetBytesInterface ; /**解析后的数据对象 回调-*/ private IUsbPackageTransferInterface iusbpackageTransInterface ; /**读入流 时的休眠间隔 微秒*/ private final long READ_STRING_SLEEPTIME= 20L; /**写入流 时的休眠间隔*/ private final long WRITE_STRING_SLEEPTIME= 60L; /**解析 byte[] 时的休眠间隔*/ private final long REPACKAGE_SLEEPTIME= 0L; /** 调整读取大小*/ private byte[] buffer= new byte[2048 * 3] ; public MusbAccessoryManager(Context context , IOperateResultCallBack iUsbResultCallBack , IUsbPackageTransferInterface iusbpackageTransInterface) { this.mCtx = context; fileDescriptor = null; inputStream = null; outputStream = null; readThread = null; writeThread = null; repackThread =null ; enableThread = false; this.iUsbResultCallBack= iUsbResultCallBack; this.iusbpackageTransInterface = iusbpackageTransInterface; outQueue = new LinkedBlockingQueue(Integer.MAX_VALUE); readQuene = new LinkedBlockingQueue<>(Integer.MAX_VALUE) ; } /** * 添加数据 到发送队列 */ public void addMessage(MyBytesTransfer msg) { try { outQueue.put(msg); }catch (Exception e) { MyLogUtils.mLog_iNormal(\"usb设备== 发送异常1 =\"+e.getMessage()); } } /** * 打开USB通信 */ public void OpenAccessory(UsbAccessory accessory) { if (!enableThread) { fileDescriptor = ((UsbManager) mCtx.getSystemService(Context.USB_SERVICE)).openAccessory(accessory); if (fileDescriptor != null) { FileDescriptor fd = fileDescriptor.getFileDescriptor(); inputStream = new FileInputStream(fd); outputStream = new FileOutputStream(fd); if (inputStream == null || outputStream == null) { // 读取流异常 iUsbResultCallBack.onResultCallBack(MyStateConfig.STATE_2); return; } //连接成功 iUsbResultCallBack.onResultCallBack(MyStateConfig.STATE_14); enableThread = true; readThread = new AccessoryReadThread(inputStream); readThread.start(); writeThread = new AccessoryWriteThread(outputStream); writeThread.start(); repackThread = new BytesDataRepackThread() ; repackThread.start(); }else{ toastMsg(\"fileDescriptor==null \" ) ; } } }// /** * 关闭连接、清空队列、停止线程 */ public void CloseAccessory() { try { if (fileDescriptor != null) { fileDescriptor.close(); } if (outputStream != null) { outputStream.close(); } if (inputStream != null) { inputStream.close(); } }catch (Exception ie) { ie.printStackTrace(); } outQueue.clear(); readQuene.clear(); enableThread = false; fileDescriptor = null; outputStream = null; inputStream = null; } /** 读取子线程 */ private class AccessoryReadThread extends Thread { private FileInputStream inStream; public AccessoryReadThread(FileInputStream stream) { this.inStream = stream; } @Override public void run() { while (enableThread) { try { int realReaded = inStream.read(buffer); // 将Buffer中有效的数据拷贝出来 if(realReaded>0) { byte [] realBytes = MyStringUtils.subBytes(buffer, 0 , realReaded) ; readQuene.put(realBytes); } } catch (Exception e) { com.walkera.base.utils.MyLogUtils.mLog_iNormal(\"usb设备== 接收异常=\"+e.getMessage()); MyApplication.usbReadStreamState= MyStateConfig.STATE_8; //发生异常，继续执行 continue; } MyApplication.usbReadStreamState= MyStateConfig.STATE_9; try { TimeUnit.MICROSECONDS.sleep(READ_STRING_SLEEPTIME); } catch (InterruptedException e) { e.printStackTrace(); } } // end while } // end run }// /** *发送子线程 */ private class AccessoryWriteThread extends Thread { private FileOutputStream outStream; public AccessoryWriteThread(FileOutputStream outputStream) { this.outStream = outputStream; } @Override public void run() { MyBytesTransfer msg; while (enableThread){ try{ if (outStream != null) { msg = outQueue.poll(); if (msg != null) { sendByteDataToServer(msg.bytes ); msg = null; }else{ } } else{ MyApplication.usbWriteStreamState= MyStateConfig.STATE_11; outQueue.clear(); } MyApplication.usbWriteStreamState= MyStateConfig.STATE_10; try { Thread.sleep(WRITE_STRING_SLEEPTIME); } catch (InterruptedException e) { e.printStackTrace(); } }catch (Exception ex) { com.walkera.base.utils.MyLogUtils.mLog_iNormal(\"发送测试3= msg=\"+ex.getMessage()); MyApplication.usbWriteStreamState= MyStateConfig.STATE_11; } } } /** * 将数据发送给服务器 */ private void sendByteDataToServer(byte[] buffer) { try { if (outStream != null) { iUsbResultCallBack.onResultCallBack(MyStateConfig.STATE_13); outStream.write(buffer, 0, buffer.length); outStream.flush(); } }catch (IOException ex) { iUsbResultCallBack.onResultCallBack(MyStateConfig.STATE_12); } }// } /** * 解析 重组包 子线程 */ private class BytesDataRepackThread extends Thread{ @Override public void run() { while (enableThread) { if(readQuene!=null) { byte[] realBytes = readQuene.poll() ; if(realBytes!=null) { rePackageForBytes(realBytes) ; } } try { Thread.sleep(REPACKAGE_SLEEPTIME); } catch (InterruptedException e){ e.printStackTrace(); } } // while }//end run } /*** * 重组包 ， 将遥控器 、 飞控、视屏数据分开 . */ private void rePackageForBytes(byte[] bytes) { if(bytes!=null) { int size =bytes.length ; for(int i=0 ; i UsbMsgClient.java /** * 功能描述： 负责 用usb方式的通信方式 给其他部件提供发送和接收数据的功能 */ public class UsbMsgClient{ private Context mCtx ; /**usb管理类*/ private UsbManager usbmanager ; /**usb 操作管理类*/ private MusbAccessoryManager mubAccessoryManager; /**对外暴露的接口 ，以便其他模块获取 对应的数据*/ private IUsbMsgBackInterface iUsbMsgBackInterface ; /** * @param iUsbMsgBackInterface 对外暴露的接口 ，以便其他模块获取 对应的数据 * @param iUsbResultCallBack usb 返回状态码 */ public UsbMsgClient (Context mCtx ,IUsbMsgBackInterface iUsbMsgBackInterface ,IOperateResultCallBack iUsbResultCallBack) { this.mCtx = mCtx; this.iUsbMsgBackInterface= iUsbMsgBackInterface ; usbmanager=((UsbManager) mCtx.getSystemService(Context.USB_SERVICE)) ; mubAccessoryManager = new MusbAccessoryManager(mCtx , iUsbResultCallBack ,iusbpackageTransInterface); discoverAccessories(); }// /**回调 来自usb的数据*/ private IUsbPackageTransferInterface iusbpackageTransInterface = new IUsbPackageTransferInterface() { @Override public void transferUsbPackageBean(MyBytesTransfer myBytesTransfer) { if(myBytesTransfer != null) { // 4759图传 - 3678飞控 - 5869 遥控器 if( Arrays.equals(myBytesTransfer.msgType, MyStateConfig.VEDEO_DATA_RECEIVE)) { //视屏数据 iUsbMsgBackInterface.getUsbVedioByte(myBytesTransfer); }else if(Arrays.equals(myBytesTransfer.msgType, MyStateConfig.FC_DATA_RECEIVE)) { //飞控数据 iUsbMsgBackInterface.getUsbFcByte(myBytesTransfer); }else if(Arrays.equals(myBytesTransfer.msgType, MyStateConfig.RC_DATA_RECEIVE)) { //遥控器数据 iUsbMsgBackInterface.getUsbRcByte(myBytesTransfer); } } } } ; /** * 扫描usb设备 发现从设备 */ private void discoverAccessories() { UsbAccessory[] list = usbmanager.getAccessoryList(); if (list != null && list.length!=0) { openTheAccessory(list[0]); }else { //MyToastTools.toastWarning(mCtx ,mCtx.getString( R.string.v5_str_1)); } }// /** * 连接 指定设备 */ private void openAccessory(UsbAccessory accessory) { mubAccessoryManager.OpenAccessory(accessory); // 延时 n秒 发送打开session命令 new Handler().postDelayed(new Runnable() { @Override public void run() { byte[] openSession = { (byte)0xDD , (byte)0xDF ,(byte)0x06 ,(byte)0x00 } ; sendBytesToDevices(openSession); } } , 2000) ; } /** * 连接USB设备 */ private void openTheAccessory(UsbAccessory accessory) { if (accessory == null) { MyToastTools.toastWarning(mCtx ,mCtx.getString( R.string.v5_str_2)); }else { if (usbmanager.hasPermission(accessory)) { openAccessory(accessory); }else { com.walkera.base.utils.MyLogUtils.mLog_iNormal(\"usb设备== 无权限1\"); } } } /** * 通知遥控器关闭 */ private void closeSession() { byte[] closeSession = { (byte)0xDD , (byte)0xDF ,(byte)0x07 ,(byte)0x00 } ; sendBytesToDevices(closeSession); } /** * 关闭usb收发工具 */ public void closeUsbMsgClinet() { closeSession(); new Handler().postDelayed(new Runnable() { @Override public void run() { closeAccessory(); } }, 500); } /** * 断开设备 */ private void closeAccessory(){ if (mubAccessoryManager != null) { mubAccessoryManager.CloseAccessory(); } } /** * 发送数据 */ public void sendBytesToDevices( byte[] data ) { if (mubAccessoryManager != null) { mubAccessoryManager.addMessage(new MyBytesTransfer(data , MyStateConfig.STATE_6,null)); } } } MyStateConfig.java public class MyStateConfig{ /**请求usb访问的自定义权限*/ public static final String ACTION_USB_ACCESSORY_PERMISSION = \"com.wk.USB_ACCESSORY_PERMISSION\"; /**当前参数无意义 */ public final static int STATE_NULL = -100 ; /**所有的状态的初始化状态 */ public final static int STATE_0 = 0 ; /** usb退出 */ public final static int STATE_1 =1 ; /** usb连接异常 , 读取流异常 */ public final static int STATE_2 =2 ; /** usb 权限被拒绝了 */ public final static int STATE_3 =3; /**接收usb byte 正式*/ public final static int STATE_4 =4; /**接收usb byte 测试*/ public final static int STATE_5 =5; /**发送的bytes[]*/ public final static int STATE_6 =6; /**接收到的byte[]*/ public final static int STATE_7 =7; /**usb输入流异常*/ public final static int STATE_8 =8; /**usb输入流正常*/ public final static int STATE_9 =9; /**usb输出流正常*/ public final static int STATE_10 =10; /**usb输出流异常*/ public final static int STATE_11 =11; /**发送失败*/ public final static int STATE_12 =12; /**发送成功*/ public final static int STATE_13 =13; /**Usb连接成功*/ public final static int STATE_14 =14; /**属于相机数据 */ public final static int STATE_15 = 15 ; } xml中的一些配置、usb插入、拔出监听 请参考官网 使用 /**usb收发工具*/ private UsbMsgClient usbMsgClient ; //初始化usb数据接收器 usbMsgClient = new UsbMsgClient( mContext ,iUsbMsgBackInterface ,iUsbResultCallBack) ; //发送byte[]数据 usbMsgClient.sendBytesToDevices(code); //关闭连接 usbMsgClient.closeUsbMsgClinet(); /** * 接收 usb 返回数据 */ private IUsbMsgBackInterface iUsbMsgBackInterface = new IUsbMsgBackInterface(){ /**视屏数据*/ @Override public void getUsbVedioByte(MyBytesTransfer vedioData) { //解码... } /**飞控数据*/ @Override public void getUsbFcByte(MyBytesTransfer fcData) { //解析飞控数据 } /**遥控器数据*/ @Override public void getUsbRcByte(MyBytesTransfer rcData) { //解析遥控器数据 } } ; /** * 接收 usb 操作、状态码 */ private IOperateResultCallBack iUsbResultCallBack = new IOperateResultCallBack(){ @Override public void onResultCallBack(int state ){ //状态码 } }; 私有协议 参数类型对应的字节数 类型 对应字节数 备注 bit 1/8 byte 1 char 1 (char在java中是2个字节) boolean 1 uint8 1 uint8_t 1 uint16 2 int16 2 short 2 int 4 float 4 int32 4 uint32_t 4 double 8 long 8 心跳机制 心跳机制 在私有协议中，我们常常需要用心跳来判断对方是否已经掉线。比如持续20秒收不到约定的信号，判断为对方掉线。 public abstract class HeartBeatTask implements Runnable { private String taskName ; public HeartBeatTask( ){ taskName = \"beatTask_\"+System.nanoTime() ; } public String getTaskName() { return taskName; } } public class WkHeartBeatTool { private ScheduledExecutorService mScheduledExecutorService; private HashMap map ; public WkHeartBeatTool() { initTool(); } public int getTaskNum(){ return map==null? 0 : map.size() ; } private void initTool() { mScheduledExecutorService = Executors.newScheduledThreadPool(5);// 线程池大小 5 map = new HashMap() ; } public void startTheBeatAction(HeartBeatTask task , int period){ if(map.containsKey(task.getTaskName())){ System.out.println(\"心跳正在进行，无需重复添加\"); return ; } Future future = mScheduledExecutorService.scheduleAtFixedRate( task , 0, period, TimeUnit.MILLISECONDS); map.put(task.getTaskName() , future) ; } public void shutDownTheBeatAction(HeartBeatTask task ){ Future future = map.get(task.getTaskName()) ; if(future!=null){ future.cancel(true) ; map.remove(task.getTaskName()) ; }else{ System.out.println(\"你指定的这个心跳任务已经不存在，无需关闭\"); } } public void startDelayedAction( HeartBeatTask task , int delayTime){ mScheduledExecutorService.schedule( task, delayTime ,TimeUnit.MILLISECONDS ); } public void shutDownAll() { if (mScheduledExecutorService != null) { mScheduledExecutorService.shutdownNow(); // 强制关闭 mScheduledExecutorService = null; } map.clear(); map=null ; } } WkHeartBeatTool heartBeatTool = new WkHeartBeatTool() ; HeartBeatTask task1 = new HeartBeatTask() { public void run() { ...} }; heartBeatTool.startTheBeatAction(task1, 1000) ;// 开始心跳 heartBeatTool.shutDownTheBeatAction(task1) ;// 停止心跳 heartBeatTool.startDelayedAction(task1, 5 * 1000) ;// 发送延时任务 int sum = heartBeatTool.getTaskNum() ;// 获取 心跳任务总数 heartBeatTool.shutDownAll() ;// 关闭所有任务 并销毁工具 无版权 可以无限制使用！ all right reserved，powered by Gitbook该文件更新时间： 2021-01-08 09:10:51 "},"chinese/java基础/数据解析.html":{"url":"chinese/java基础/数据解析.html","title":"数据解析","keywords":"","body":"数据解析 json解析 fastjson 阿里出品 ，零依赖 。 https://github.com/alibaba/fastjson compile 'com.alibaba:fastjson:1.1.70.android' String detail = JSON.toJSONString(listToStore) ; //list数组转string JSONArray array = JSONArray.parseArray( string ); // string 转json数组 List saveBeans = JSONObject.parseArray(array.toJSONString(), XXBean.class); // JSONArray 转List对象 XXBean item = JSON.parseObject(string, XXBean.class); //json字符串转对象 Protocol Buffer developers protobuf github protobuf 相比于XML或Json格式存储数据， 数据量较大时，通过Protocol Buffers来定义的文件体积更小，解析速度更快 。 //感觉跟自定义私有协议差不多，只是proto使用起来会更方便一点，比如数据的转换和拓展... 1、引入辅助插件protobuf-gradle-plugin // 最新版本请参考官网 https://github.com/google/protobuf-gradle-plugin classpath 'com.google.protobuf:protobuf-gradle-plugin:0.8.12' // (项目最外层build.gradle) 2、导入 protocol库 （考虑到文件大小，Android采用精简版 protobuf-lite） // 具体版本请参考 https://search.maven.org/artifact/com.google.protobuf/protobuf-lite compile \"com.google.protobuf:protobuf-lite:3.0.1\" //app层build.gradle 3、应用插件 apply plugin: 'com.google.protobuf' // app层build.gradle 4、其他配置 // app层build.gradle protobuf { protoc { artifact = 'com.google.protobuf:protoc:3.0.0' } plugins { javalite { artifact = 'com.google.protobuf:protoc-gen-javalite:3.0.0' } } generateProtoTasks { all().each { task -> task.builtins { remove java } task.plugins { javalite { } } } } } 5、编写.proto文件 在src\\main\\ 目录下新建proto文件夹 ，新建 xxx.proto文件 // 版本号为3 syntax = \"proto3\"; //自动生成的对应的Java文件放这个目录下 option java_package = \"com.myProto.pack\"; // java_multiple_files 为true时，生成的Java类将是包级别的，否则会在一个包装类中。 option java_multiple_files = true; // 该文件对应的Java类名，不用写了，因为 message Person已经写了 //option java_outer_classname = \"Person\"; message Person { //proto3 已经取消了默认值的设置。 // 这里的1 2 3是字段号，不是默认值 string name =1; bool isMan =2; int32 age =3; double money =4; string phone =5 ; } 6、编译工程，系统就会自动生成对应的Java文件。 7、Java层使用和解析数据 private void test(){ Person person = Person.newBuilder(). setName(\"aivin666\") .setIsMan(true) .setAge(20) .setMoney(1000) .setPhone(\"13650909087\") .build(); byte[] dataSend = person.toByteArray();// 对象转byte[] Person result = Person.parseFrom(dataSend); //byte[]转对象 } 无版权 可以无限制使用！ all right reserved，powered by Gitbook该文件更新时间： 2020-09-24 11:26:26 "},"chinese/android基础/android相关概念.html":{"url":"chinese/android基础/android相关概念.html","title":"android部分","keywords":"","body":"安卓基本概念 虚拟机对比 JVM Java Virtual Machine。基于栈 ，运行java字节码。 DVM Dalvik Virtual Machine 。 运行自谷歌定义的 .dex字节码格式。 Dalvik 基于寄存器的架构， 更适合资源紧张的系统。 ART Android runtime 。 Android 4.4 开始加入 ART模式。 ART下，应用在第一次安装的时候，字节码就会预编译成机器码，首次启动会变慢， 但是以后每次启动执行的时候，都可以直接运行。（空间换时间） 双缓冲 两个线程配合完成某一项工作，一个线程做A部分（例如绘制UI）， 另一个线程做B事情（例如读取资源，计算数据）。 常见的例子： 1、TCP数据传输， 数据的收发速度不一致可能导致数据的丢失。 数据线发送到缓冲区中，然后从缓冲区中取走。 有效地防止了数据的丢失。 2、复杂图像绘制过程中。 线程A将一帧的计算结果放在缓冲区中，线程绘制完当前帧后再去缓冲区中取下一帧完整的绘制资源。 这样就可以避免画面闪烁结果。 很多图形操作都很复杂，需要大量的计算，很难访问一次显示缓冲区就能写入待显示的完整图形数据， 通常需要多次访问显示缓冲区，每次访问时写入最新计算的图形数据。 而这样造成的后果是一个需要复杂计算的图形，你看到的效果可能是一部分一部分地显示出来的，造成很大的闪烁不连贯。 硬件加速 图形的绘制如果是 GPU处理的就是 硬件加速绘制，如果是 CPU 处理的 就是软件绘制。 硬件加速使用 GPU 进行View上的绘制操作。 硬件加速可以在以下四个级别开启或关闭： Application ： 为整个 APP开启 Activity： activity 范围 Window： window 范围 getWindow().setFlags( WindowManager.LayoutParams.FLAG_HARDWARE_ACCELERATED View： view 范围 oneView.setLayerType(View.LAYER_TYPE_SOFTWARE, null); 并非所有的2D绘图操作支持硬件加速。所以硬件加速的开关分为四个层次。 以下是已知不支持硬件加速的绘图操作(需要最新的请查阅官网) 支持硬件加速情况 Canvas 第一次支持 Paint 第一次支持 drawBitmapMesh() (colors array) 18 setAntiAlias() (for text) 18 drawPicture() 23 setAntiAlias() (for lines) 16 drawPosText() 16 setFilterBitmap() 17 drawTextOnPath() 16 setLinearText() ✗ drawVertices() ✗ setMaskFilter() ✗ setDrawFilter() 16 setPathEffect() (for lines) ✗ clipPath() 18 setRasterizer() ✗ clipRegion() 18 setShadowLayer() (other than text) ✗ clipRect(Region.Op.XOR) 18 setStrokeCap() (for lines) 18 clipRect(Region.Op.Difference) 18 setStrokeCap() (for points) 19 clipRect(Region.Op.ReverseDifference) 18 setSubpixelText() ✗ clipRect() with rotation/perspective 18 Xfermode 第一次支持 Shader 第一次支持 PorterDuff.Mode.DARKEN (framebuffer) ✗ ComposeShader inside ComposeShader ✗ PorterDuff.Mode.LIGHTEN (framebuffer) ✗ Same type shaders inside ComposeShader ✗ PorterDuff.Mode.OVERLAY (framebuffer) ✗ Local matrix on ComposeShader 18 Drawing operation to be scaled 第一次支持 drawText() 18 drawPosText() ✗ drawTextOnPath() ✗ Simple Shapes* 17 Complex Shapes* ✗ drawPath() ✗ Shadow layer ✗ SharedPreferences 一些简单的、无安全风险的键值对数据，可以通过 SharedPreferences 保存。 SharedPreferences 是一个轻量级的xml键值对文件 。 文件保存在 /data/data//shared_prefs 中，明文可见。 用真机中的文件夹管理器一般看不到，可以用过 Androidstudio 去看。 在 SharedPreferencesImpl.java 中 private void startLoadFromDisk() { new Thread(\"SharedPreferencesImpl-load\") { ... loadFromDisk(); // 开启子线程读取 }.start(); } SharedPreferences apply 和 commit 的区别 apply() 进行提交会先写入内存，然后异步写入磁盘， commit() 是直接写入磁盘。 如果频繁操作的话 apply 的性能会优于 commit 。 如果希望立刻获取存储操作的结果，并据此做相应的其他操作，应当使用 commit。 Application // Application 中显示 Dialog (AlertDialog) 借助 ActivityLifecycleCallbacks 的生命周期回调 获得 Context new AlertDialog.Builder(mContext); // 通过 Application 传值 缺点 无版权 可以无限制使用！ all right reserved，powered by Gitbook该文件更新时间： 2021-01-05 16:52:23 "},"chinese/android基础/常用代码块.html":{"url":"chinese/android基础/常用代码块.html","title":"常用代码","keywords":"","body":"常用代码片段 数组操作 list去重 将重复值去掉，同时不能破坏现有的顺序。 private List removeDuplicate(List list) { Set set = new HashSet(); List newList = new ArrayList(); for (String str : list) { // 借助set的特性 if (set.add(str)) { newList.add(str); } } return newList; } String 操作 字符串切割 String [] array= myString.split(\"[.]\"); 分割字符 表达 . \"[.]\" | \"\\\\|\" * \"\\\\*\" \\ \"\\\\\\\\\" [ \"\\\\[\" ] \"\\\\]\" String 简单格式化 return String.format(\"bookId= %s, bookName=%s]\", bookId, bookName); strig 和 byte[] 互相转换 byte[] bytes = \"hello world\".getBytes(StandardCharsets.UTF_8); String hello = new String(bytes , StandardCharsets.UTF_8); 代码超时 函数超时、 执行超时、等待超时、连接超时 final ExecutorService exec = Executors.newFixedThreadPool(1); Callable call = new Callable() { public String call() throws Exception { // 耗时操作... Thread.sleep(1000 * 3); return \"执行结果(成功或失败)\"; } }; try { Future future = exec.submit(call); // 超时时间 设置 String result = future.get(1000 * 5, TimeUnit.MILLISECONDS); System.out.println(\"执行未超时:\" + result); } catch (TimeoutException ex) { System.out.println(\"处理超时\"); ex.printStackTrace(); } catch (Exception e) { System.out.println(\"处理失败.\"); e.printStackTrace(); } exec.shutdown(); } 对象排序 Collections.sort(mBeanList, new Comparator() { @Override public int compare(MyBean bean1, MyBean bean2) { // 按照对象属性排序 return = bean1.xx - bean2.xx; } }); 数组操作 数组相等 Arrays.equals(myArray, NSS_MSG_TYPE_GET_MAIN_STREAM); 数组打印 System.out.println(Arrays.toString(myArray)); 数组扩容 public String [] getNewArrayWithMoreSpaceString( String [] oldArray ,String [] increceData){ String [] lastArray=new String[oldArray.length+increceData.length]; //数组复制 System.arraycopy(oldArray, 0, lastArray, 0, oldArray.length); System.arraycopy(increceData, 0, lastArray, oldArray.length+1, increceData.length); return lastArray ; } byte[]相关 byte[]和基础数据互转 例如一个32位long数据，0x12345678: 0x12345678 高字节 -----------------> 低字节 内存低地址 -----------------> 内存高地址 大端模式 0x12 0x34 0x56 0x78 //符合人的直观认识 小端模式 0x78 0x56 0x34 0x12 // int 转为 byte byte intTo1ByteHex(int intVaue ){ return Integer.valueOf(intVaue & 0xff).byteValue(); } // byte 转 int int bytes1ToInt(byte src) { return src & 0xFF; } // int 转 byte[4] ,大端模式 byte[] intTo4ByteBig(int n) { byte[] b = new byte[4]; b[3] = (byte) (n & 0xff); b[2] = (byte) (n >> 8 & 0xff); b[1] = (byte) (n >> 16 & 0xff); b[0] = (byte) (n >> 24 & 0xff); return b; } // int 转 byte[4],小端模式 byte[] intTo4ByteLittle(int n) { byte[] b = new byte[4]; b[0] = (byte) (n & 0xff); b[1] = (byte) (n >> 8 & 0xff); b[2] = (byte) (n >> 16 & 0xff); b[3] = (byte) (n >> 24 & 0xff); return b; } // byte[4] 转int ，小端模式 int bytes4ToIntLittle(byte[] bytes ) { int int1=bytes[0]&0xff; int int2=(bytes[1]&0xff)> 8 & 0xff); return b; } // short 转 byte[2] ，小端模式 byte[] shortTo2ByteLittle(short n) { byte[] b = new byte[2]; b[0] = (byte) (n & 0xff); b[1] = (byte) (n >> 8 & 0xff); return b; } // byte[2] 转 short ,小端模式 short byte2ToShortLittle(byte[] b) { return (short) (((b[1] > 56)); b[6] = (byte) (0xff & (value >> 48)); b[5] = (byte) (0xff & (value >> 40)); b[4] = (byte) (0xff & (value >> 32)); b[3] = (byte) (0xff & (value >> 24)); b[2] = (byte) (0xff & (value >> 16)); b[1] = (byte) (0xff & (value >> 8)); b[0] = (byte) (0xff & value); return b; } // double 转 byte[8] ,大端模式 byte[] doubleTo8Bytes_Big(double d){ long l = Double.doubleToLongBits(d); byte[] b = new byte[8]; b[0] = (byte) (0xff & (l >> 56)); b[1] = (byte) (0xff & (l >> 48)); b[2] = (byte) (0xff & (l >> 40)); b[3] = (byte) (0xff & (l >> 32)); b[4] = (byte) (0xff & (l >> 24)); b[5] = (byte) (0xff & (l >> 16)); b[6] = (byte) (0xff & (l >> 8)); b[7] = (byte) (0xff & l); return b; } /** * byte[8] 转 double */ double bytes8ToDouble(byte[] bytes, boolean littleEndian) { ByteBuffer buffer = ByteBuffer.wrap(bytes,0,8); if(littleEndian){ buffer.order(ByteOrder.LITTLE_ENDIAN); }else{ buffer.order(ByteOrder.BIG_ENDIAN); } long l = buffer.getLong(); return Double.longBitsToDouble(l); } 获得校验位 /* 只保留低八位，高位舍去。 P1=s/256; //整除高8位 P0=s%256; //取余是低8位 */ public static byte[] getVerifyValue(byte [] lastBytes){ byte checksum = 0; for (int i = 0; i = 0; i--) { array[i] = (byte)(b & 1); b = (byte) (b >> 1); } return array; } // byte[] 转换成十六进制字符串 ,方便打印查看 String byte2HexStr(byte[] b){ String stmp ; StringBuilder sb = new StringBuilder(\"\"); for (int n = 0; n 文件操作 获得指定文件的byte数组 public byte[] getBytesFromFile(File file){ byte[] buffer = null; try { if(!file.exists()){ file.createNewFile(); } FileInputStream fis = new FileInputStream(file); ByteArrayOutputStream bos = new ByteArrayOutputStream(1000); byte[] b = new byte[1000]; int n; while ((n = fis.read(b)) != -1) { bos.write(b, 0, n); } fis.close(); bos.close(); buffer = bos.toByteArray(); } catch ( Exception e) { e.printStackTrace(); } return buffer; } 根据byte数组，生成文件 public void getFileFromBytes(byte[] bfile, File file ,boolean isAppend){ BufferedOutputStream bos = null; FileOutputStream fos = null; try { fos = new FileOutputStream(file ,isAppend); bos = new BufferedOutputStream(fos ); bos.write(bfile); } catch (Exception e) { e.printStackTrace(); } finally { if (bos != null) { try { bos.close(); } catch (IOException e1) { e1.printStackTrace(); } } if (fos != null) { try { fos.close(); } catch (IOException e1) { e1.printStackTrace(); } } } } 保存String到本地 public boolean saveTxtToSdWithAppend(String messgeStr, String filePath, boolean isAppend){ File file = new File(filePath); try { file.createNewFile(); } catch (IOException e) { e.printStackTrace(); } boolean resultFlage = true; try { // 打开一个写文件器，是否追加形式 FileWriter writer = new FileWriter(filePath, isAppend); writer.write(messgeStr + \"\\r\\n\"); writer.close(); } catch (IOException e) { resultFlage = false; e.printStackTrace(); } return resultFlage; } 从txt(小文件) 获取String public String getStringFromTxt(File file) { StringBuffer sb = new StringBuffer(); try { BufferedReader rd = new BufferedReader(new FileReader(file)); String s = rd.readLine(); while (null != s) { sb.append(s); s = rd.readLine(); } } catch (FileNotFoundException e) { e.printStackTrace(); } catch (IOException e) { e.printStackTrace(); } return sb.toString(); } 按行读取(较大文件) 、解决乱码问题 public void read(String filePath, String logPath) throws Exception { RandomAccessFile raf = new RandomAccessFile(filePath, \"r\"); // 设置指针的位置为文件的开始部分 raf.seek(currentInex); long totalLenth = raf.length(); while (currentInex 递归 遍历文件夹 public void getFileList(String strPath) { File dir = new File(strPath); File[] files = dir.listFiles(); if (files != null) { for (File file : files) { if (file.isDirectory()) { getFileList(file.getAbsolutePath()); } else { // 文件 } } } } 时间间隔 public static String getConversationDateString(String result) throws Exception{ if(!result.equals(\"\")){ SimpleDateFormat sdf = new SimpleDateFormat(\"MM-dd HH:mm\"); SimpleDateFormat sdfDay = new SimpleDateFormat(\"MM-dd\"); String now = sdf.format(new Date()); Date oldTime = null; Date newTime = null; oldTime = sdf.parse(result); newTime = sdf.parse(now); long time = newTime.getTime() - oldTime.getTime(); int day; String[] olds = sdfDay.format(oldTime).split(\"-\"); String[] news = sdfDay.format(newTime).split(\"-\"); if(news[0].equals(olds[0])){ day = Integer.valueOf(news[1]) - Integer.valueOf(olds[1]); }else{ Calendar cal = Calendar.getInstance(); //月份设置要减1，所以设置1月就是1-1，设置2月就是2-1，如此类推 cal.set(Calendar.MONTH, 1-1); cal.add(Calendar.MONTH, -(Integer.valueOf(news[0]) - Integer.valueOf(olds[0]))); //得到上一个月最最后一天日期(31/30/29/28) int oldDay=cal.getActualMaximum(Calendar.DAY_OF_MONTH) - Integer.valueOf(olds[1]); day = oldDay + Integer.valueOf(news[1]); } if(time 求夹角 根据正切公式 /**根据两个点获取 斜率*/ public static double getXl(MyPointBean bean1, MyPointBean bean2) { double xlValue = 0; xlValue = (bean2.getY() - bean1.getY()) / (bean2.getX() - bean1.getX()); return xlValue; } /**根据2条线的斜率 获得之间的夹角*/ public static double getAngle(double xl_1, double xl_2) { double angleValue = 0; // 反正切 angleValue = Math.atan((xl_2 - xl_1) / (1 + xl_1 * xl_2)); // 将弧度转为度数 return Math.toDegrees(angleValue); } 遍历map 遍历set Map map=new HashMap(); //方法一 ，需要遍历 两次 for (Object object : map.keySet()) { String key = (String) object; Integer value = (Integer) map.get(key); } // 方法二， 只需遍历一次 （推荐） Set> entrySet = map.entrySet(); for (Entry object : entrySet){ Object key = object.getKey(); Object value = object.getValue(); } //遍历set Set set=new HashSet(); Iterator iterator=set.iterator(); while (iterator.hasNext()) { String obj = iterator.next(); } 随机数 Random Math.Random() 范围是 [0,1) 生成 [startNum,endNum) public int getRadomInt(int startNum, int endNum){ return new Random().nextInt(endNum - startNum) + startNum; } 生成 [startNum,endNum] public int getRadomInt2(int startNum, int endNum){ return new Random().nextInt(endNum - startNum + 1) + startNum; } 文件解压缩 zip解压缩是基于 pache的 ant.jar 实现 。 /** * 解压耗时操作应该在子线程中进行。 */ public class ZipUtil{ private byte[] buf; public ZipUtil(){ this.buf = new byte[ 1024*4]; } /** * @param zipFileAbsulutPaht 压缩文件的绝对路径 xxx/xxx.zip * @param destFileDir　　　解压到的目录　 */ public void unZip(String zipFileAbsulutPaht, String destFileDir) { FileOutputStream fileOut; File file; InputStream inputStream; try { //生成一个zip的文件 ZipFile zipFile = new ZipFile(zipFileAbsulutPaht); //遍历zipFile中所有的实体，并把他们解压出来 for (@SuppressWarnings(\"unchecked\") Enumeration entries = zipFile.getEntries(); entries.hasMoreElements();) { ZipEntry entry = entries.nextElement(); //生成他们解压后的一个文件 String tempNameFile=entry.getName() ; file = new File(destFileDir+File.separator+tempNameFile.replace(\"\\\\\", \"/\")); if (entry.isDirectory()) { file.mkdirs(); } else { File parent = file.getParentFile(); if (!parent.exists()) { parent.mkdirs(); } //获取出该压缩实体的输入流 inputStream = zipFile.getInputStream(entry); fileOut = new FileOutputStream(file); int length = 0; //将实体写到本地文件中去 while ((length = inputStream.read(this.buf)) > 0) { fileOut.write(this.buf, 0, length); } fileOut.close(); inputStream.close(); } } zipFile.close(); } catch (IOException ioe) { ioe.printStackTrace(); } } } // 使用 new ZipUtil().unZip(mnt/xxx/xxx.zip , mnt/xx/xx/); URLEncoder 中文 判断是否有中文 URLEncoder.encode(str ,\"UTF-8\")); public static boolean isChineseChar(String str){ boolean temp = false; Pattern p=Pattern.compile(\"[\\u4e00-\\u9fa5]\"); Matcher m=p.matcher(str); if(m.find()){ temp = true; } return temp; } 正则换URL字符串里面的汉字部分 public static String encode(String str, String charset) { Pattern p = Pattern.compile(\"[\\u4e00-\\u9fa5]\"); Matcher m = p.matcher(str); StringBuffer b = new StringBuffer(); while (m.find()) { m.appendReplacement(b, URLEncoder.encode(m.group(0), charset)); } m.appendTail(b); return b.toString(); } 其他 判断是否是闰年 if (n%400==0 ||n%4==0 && n%100!=0) { //闰年 } 双击退出 、按键监听 private long lastTime = 0 ; private void exitActivity( ) { if (System.currentTimeMillis() - lastTime 不定参数 //相当于是二维数组，arg中每个空间保存一个数组 public void method(int[]...arg); 倒计时 简单场景就使用Chronometer。 复杂场景使用网上很多开源的，比如小米时钟、锤子时钟中的实现思路。 选中效果 xxx.setSelected(false); 全屏、去掉标题栏 //在setContentView之前设置 requestWindowFeature(Window.FEATURE_NO_TITLE); //Activity supportRequestWindowFeature(Window.FEATURE_NO_TITLE); // ok AppCompatDialog getWindow().setFlags(WindowManager.LayoutParams.FLAG_FULLSCREEN, WindowManager.LayoutParams.FLAG_FULLSCREEN); getWindow().setFlags(WindowManager.LayoutParams.FLAG_FORCE_NOT_FULLSCREEN, WindowManager.LayoutParams.FLAG_FULLSCREEN); //extends AppCompatActivity android:theme=\"@style/Theme.AppCompat.Light.NoActionBar\" getSupportActionBar().hide(); 启动默认浏览器 Intent intent =newIntent(); intent.setAction(\"android.intent.action.VIEW\"); Uri content_url =Uri.parse(\"http://www.xxx.com\"); intent.setData(content_url); startActivity(intent); 启动第三方应用 PackageManager pm = this.getPackageManager(); Intent intent = pm.getLaunchIntentForPackage(\"xxx.包名.xxx\"); try { startActivity(intent); } catch (Exception e) { //请先安装 } ```text 系统分享功能 Intent wechatIntent = new Intent(Intent.ACTION_SEND); wechatIntent.setPackage(\"com.tencent.mm\");//微信 wechatIntent.setType(\"text/plain\"); wechatIntent.putExtra(Intent.EXTRA_TEXT, \"hello world\"); try{ context. startActivity(wechatIntent); }catch (Exception e){ //请先安装微信 } ### 使用自定义字体 ```text AssetManager mgr = getAssets(); Typeface tf = Typeface.createFromAsset(mgr, \"fonts/2.TTF\");// 文件在assets/fonts目录下 textView.setTypeface(tf); XML解析 SAX：Simple API for XML。 相比于DOM，SAX是一种速度更快，更有效的方法。它逐行扫描文档，一边扫描一边解析。 不用实现调入整个文档，占用资源少。尤其在嵌入式环境中，如android，极力推荐使用SAX解析。 复制粘贴 // 得到剪贴板管理器 ClipboardManager cmb = (ClipboardManager) context.getSystemService(Context.CLIPBOARD_SERVICE); //复制 cmb.setText( msg); // 粘贴 String msg=cmb.getText().toString() 防止 Toast 重复提示 private static Toast mToast; public void showMsg(Context context, String msg) { if (mToast == null) { mToast = Toast.makeText(context, msg, Toast.LENGTH_SHORT); } else { //直接设置，不用重复创建 mToast.setText(msg); } mToast.show(); } res/raw和assets // res/raw和assets的相同点： 1、两者目录下的文件在打包后会原封不动的保存在apk包中，不会被编译成二进制。 // res/raw和assets的不同点： 1、res/raw中的文件会被映射到R.java文件中，访问的时候直接使用资源ID即R.id.filename； 2、assets文件夹下的文件不会被映射到R.java中，访问的时候需要AssetManager类。 3、res/raw不可以有目录结构； 4、而assets则可以有目录结构，也就是assets目录下可以再建立文件夹 performClick Custom view FloatingforView overrides onTouchEvent but not performClick less... case MotionEvent.ACTION_UP: performClick(); break; @Override public boolean performClick() { return super.performClick(); } 保存控件截图 public static Bitmap saveViewBitmap(View view) { view.setDrawingCacheEnabled(true); view.buildDrawingCache(true); Bitmap cacheBitmap = view.getDrawingCache(true); Bitmap destBitmap = Bitmap.createBitmap(cacheBitmap); cacheBitmap.recycle(); view.setDrawingCacheEnabled(false); return destBitmap; } 图片转byte[] ByteArrayOutputStream stream = new ByteArrayOutputStream(); bitmap.compress(Bitmap.CompressFormat.JPEG, 100, stream); byte[] array = stream.toByteArray(); 图片转Base64 ByteArrayOutputStream bStream = new ByteArrayOutputStream(); bitmap.compress(Bitmap.CompressFormat.PNG, 100, bStream); byte[] bytes = bStream.toByteArray(); return Base64.encodeToString(bytes, Base64.DEFAULT); 占位符 学号：%1$d ;姓名：%2$s ;成绩：%3$.2f String result = String.format(testStr,1001,\"张三\",9.235); %N代表第N个参数，如%3代表的是第三个参数； $是结束符； d/s/.2f代表的是整数/字符串/保留2位小数点的浮点数 图片平铺 android:background=\"@drawable/redline_verticalbitmap\" 环境变量配置 1、建->变量名：JAVA_HOME 变量值：D:/Java/jdk1.6.0_12(这只是我的JDK安装路径) 2、编辑->变量名：Path 在变量值的最前面加上：%JAVA_HOME%/bin;%JAVA_HOME%/jre/bin 3、新建->变量名：CLASSPATH 变量值：.;%JAVA_HOME%/lib;%JAVA_HOME%/lib/dt.jar;%JAVA_HOME%/lib/tools.jar 分别输入java，javac，java -version 命令测试是否配置成功 SDK解压，把解压后文件夹的tools目录添加到环境变量path中 查看配置好的变量、jdk当前路径、jdk安装路径 echO %JAVA_HOME% //字母o java javac 显示版本正常，也能够编译成功，运行java 的时候出现找不到类的错误。 在classpath中添加 .; 即可解决。 ByteBuffer相关 // 深度克隆ByteBuffer private ByteBuffer deepCloneByteBuffer(ByteBuffer original) { ByteBuffer clone = ByteBuffer.allocate(original.capacity()); original.rewind(); // 用put接口，才会把byte数组的内容拷贝到ByteBuffer中 clone.put(original); original.rewind(); clone.flip(); return clone; } //java.nio.ByteBuffer变量解释 int position 读写位置，表示当前进行读写操作时的位置。 position的位置会随着数据的写入而移或者读取一个字节一个字节的移动。 比如添加一个byte类型的数据position会+1, 添加一个int类型的数据position会+4 int limit 读写限制, 缓冲区可以进行读写的范围的最大值。 int capacity 容量，它的值是在创建缓冲区的时候指定的，设定后无法对其进行修改。 int mark 临时标记变量，用来存储 postion的。 //常用方法 ByteBuffer= allocate(int capacity) 分配一个新的字节缓冲区。 ByteBuffer= allocateDirect(int capacity) 分配新的直接字节缓冲区。 int =position() 获取position Buffer= position(10) ; 设置 position int =limit() 获取limit Buffer =limit(10) 设置limit int =capacity() 获取capacity byte[] = array() Buffer= flip() 把limit设为当前position，把position设为0 Buffer= mark() 将存储当前position的值，等下次调用reset()方法时，会设定position的值为之前的标记值； Buffer= reset() Buffer= rewind() 把position设为0，limit不变 Buffer= clear() 把position设为0，把limit设为capacity。并不是清空内容 ByteBuffer= compact() 将 position 与 limit之间的数据复制到buffer的开始位置， 若 position 与limit 之间没有数据的话发，就不会进行复制 。 其实就是删除已读过的数据复制后 position = limit -position,limit = capacity 。 ByteBuffer= wrap(byte[] array, int offset, int length) limit 等于 offset ByteBuffer= wrap(byte[] array ) 这个缓冲区的数据会存放在byte数组中，bytes数组或buff缓冲区任何一方中数据的改动都会影响另一方。 ByteBuffer= slice() 返回原ByteBuffer的一个镜像，所有改变互相可见 ByteBuffe=r put(byte[] src) 将一个数组写入 ByteBuffer= put(byte b) 将一个byte写入，postion+1 ByteBuffer= put(int index, byte b) 把src中可读的部分（也就是position到limit）写入此byteBuffer ByteBuffer =get(byte[] dst) 将内容读取到然后放到 dst中 byte= get() 读取一个byte EditText 1、解决 在 PopupWindow 中 ，EditText 有时无法获取输入法焦点。 在 PopupWindow 中设置一下 this.setFocusable(true); 2、让 EditText 默认不获取焦点 在 EditText 的父容器中加入以下两个配置，让其抢夺到焦点。 android:focusableInTouchMode=\"true\" android:focusable=\"true\" PopupWindow 1、PopupWindow 在 xml 中设置宽高无效的原因和解决方案： PopupWindow 没有继承 Viewgroup ，因此最外层布局属性的宽高无效， 解决方法是：在xml中套两层，第二层指定长宽。 或者在代码中直接动态设置。 SharedPreferences SharedPreferences 的替代方案 ，使用腾讯的 MMKV . https://github.com/Tencent/MMKV // 设置 缓存失效时间 思路是 MMKV 保存配置时，将当前时间和要有效时长一起保存进去， 取出来的时候判断一下，是否超时了。 如果超时了就返回NULL。 如何判断一个 APP 在前台还是后台 借用系统 ActivityLifecycleCallbacks 的回调来进行判断。 进入后台后，有一些机型貌似弹不出toast，比如华为M3 。 暂时没找到解决办法，我试过一些银行的APP 和所得税APP，同样也弹不出来。 // 原理：程序中任何一个activity处于后台时(onStope)都将触发提醒。 // 所以，如果顶层activity中onStope方法被执行，则认为程序处于后台。 public class MyAppLifecycleHandler implements Application.ActivityLifecycleCallbacks { private int started = 0; private int stopped = 0; private String lastActivitName ; private boolean flag = true; public MyAppLifecycleHandler(String name){ lastActivitName= name ; } @Override public void onActivityCreated(Activity activity, Bundle savedInstanceState) { } @Override public void onActivitySaveInstanceState(Activity activity, Bundle outState) { } @Override public void onActivityResumed(Activity activity) { } @Override public void onActivityPaused(Activity activity) { } @Override public void onActivityStarted(Activity activity) { ++started; } @Override public void onActivityStopped(final Activity activity) { ++stopped; if (!isApplicationInBackground()){ return; } flag = true; new Handler().postDelayed(new Runnable() { @Override public void run() { if ( flag ) { Toast.makeText(activity, \"WkPlayer被切换至后台\", Toast.LENGTH_SHORT).show(); } } // 延时的作用是用来等待一下，看 onActivityDestroyed 是否被执行了。 } ,500) ; } @Override public void onActivityDestroyed(Activity activity) { if (lastActivitName.contains(activity.getClass().getSimpleName())) { flag = false; } } private boolean isApplicationInBackground() { return started == stopped; } } // Application 中调用 MyAppLifecycleHandler lifecycleHandler = new MyAppLifecycleHandler( FileExplorerActivity.class.getSimpleName() ) ; unregisterActivityLifecycleCallbacks(lifecycleHandler); registerActivityLifecycleCallbacks( lifecycleHandler ) ; 无版权 可以无限制使用！ all right reserved，powered by Gitbook该文件更新时间： 2021-01-05 16:39:11 "},"chinese/android基础/android坐标体系.html":{"url":"chinese/android基础/android坐标体系.html","title":"android坐标体系","keywords":"","body":"屏幕坐标系 在Android系统中，屏幕的左上角是坐标系统的原点（0,0）坐标。 原点向右延伸是X轴正方向，原点向下延伸是Y轴正方向。       View坐标系 View坐标系以父视图的左上角为坐标原点。 getTop(); //获取子View左上角距父View顶部的距离 getLeft(); //获取子View左上角距父View左侧的距离 getBottom(); //获取子View右下角距父View顶部的距离 getRight(); //获取子View右下角距父View左侧的距离       //触摸点相对于其所在视图坐标的坐标 event.getX(); event.getY(); //触摸点相对于屏幕的坐标 event.getRawX(); event.getRawY(); 无版权 可以无限制使用！ all right reserved，powered by Gitbook该文件更新时间： 2020-08-19 17:20:00 "},"chinese/android基础/事件分发机制.html":{"url":"chinese/android基础/事件分发机制.html","title":"事件分发机制","keywords":"","body":"事件分发理解 一个事件包括三个部分： ACTION_DOWN 、ACTION_MOVE、ACTION_UP 。 如果事件被拦截了导致 ACTION_DOWN都没能接收到，后面两个步骤肯定是没有的。 事件类型 MotionEvent.ACTION_DOWN //按下View(所有事件的开始) MotionEvent.ACTION_UP //抬起View MotionEvent.ACTION_MOVE MotionEvent.ACTION_CANCEL // 非人为原因，事件取消 事件分发的主要对象 1、Activity 通过其他回调方法与Window、View交互 2、View 3、ViewGroup // (ViewGroup extends View) 跟事件相关的常用方法 // Activity dispatchTouchEvent(MotionEvent ev) // 当事件传递给当前对象时，最先被调用 onTouchEvent(MotionEvent event) // 被 dispatchTouchEvent 被调用 // View dispatchTouchEvent(MotionEvent ev) // 当事件传递给当前对象时，最先被调用 onTouchEvent(MotionEvent event) // 被 dispatchTouchEvent 被调用 //ViewGroup //(ViewGroup extends View) dispatchTouchEvent(MotionEvent ev) // 当事件传递给当前对象时，最先被调用 onTouchEvent(MotionEvent event) // 被 dispatchTouchEvent 被调用 onInterceptTouchEvent(MotionEvent ev) // 用来决定是否拦截事件。只有在ViewGroup才有这个方法。被 dispatchTouchEvent 调用。 事件分发、消费顺序 事件如果被上级拦截(return true)，下级就无法收到。 事件如果被下级消费掉(return true)，就不会继续往上传。 分发顺序 Activity –> 外层ViewGroup –> 内层ViewGroup –> View 消费顺序 View –> 内层ViewGroup –> 外层ViewGroup –> Activity Activity事件分发详情 事件开始 --> Activity.dispatchTouchEvent{ getWindow().superDispatchTouchEvent(ev) } --> PhoneWindow(Window).superDispatchTouchEvent{ return mDecor.superDispatchTouchEvent(event) } --> DecorView(FrameLayout).superDispatchTouchEvent{ return super.dispatchTrackballEvent(event) // super是ViewGroup，所以Activity 跟Goup连接起来了 } --> 如果ViewGroup把事件消耗掉，返回true ，Activity的dispatchTouchEvent 就直接返回true ，事件结束。 否则就去调用Activity的onTouchEvent ，然后事件结束。 View事件分发详情 dispatchTouchEvent( ) --> onTouch (setOnTouchListener) 如果onTouch消耗掉事件，返回true --> 事件结束 如果onTouch 不处理事件，返回 false --> onTouchEvent --> performClick --> onClick(setOnClickListener)--> 事件结束 ViewGroup事件分发详情 dispatchTouchEvent() --> onInterceptTouchEvent() --> ... 事件分发图解 无版权 可以无限制使用！ all right reserved，powered by Gitbook该文件更新时间： 2020-09-10 10:53:57 "},"chinese/android基础/view的加载流程-原理.html":{"url":"chinese/android基础/view的加载流程-原理.html","title":"view的加载流程-原理","keywords":"","body":"相关类 Activity.java Activity是通过Window间接的操纵View实例。 Window.java、PhoneWindow.java Window是抽象类。 PhoneWindow是Window的唯一实现类， 主要是为 View 提供展示策略，比如标题栏，默认背景颜色等。 WindowManager.java 管理Window。 WindowManagerService.java android的窗口管理服务 DecorView.java 继承自FramentLayout 。 DecorView 为整个 Window 界面的最顶层 View。 用 Hierarchy Viewer这个工具查看DecorView的布局， 发现继承自 Activity 和 AppCompatActivity 后的结构是不一样的。 如果选用的主题不一样，结构也会不一样。具体结构请自行用工具查看分析。 但是我们自己添加的布局一般都是加载到 id/content 的 ViewGroup 中去了。 ViewRootImpl.java 、ViewRoot(已经废弃) 从字面上来看，ViewRootImpl 是 ViewRoot 的实现， 其实不是的。 ViewRoot 是Android2.2以前的，2.2之后就被 ViewRootImpl 替代了。 ViewRootImpl 作为 DecorView 和 WindowManager 之间的桥梁。 Activity、Window、ViewRootImpl、DecorView之间的联系 Activity中包含一个Window ,Window中包含一个DecorView 。 MainActivity.this.getWindow() .getDecorView(); setContentView()后的加载流程 一路追踪源码，发现用户的view是被添加到mContentParent中。 ViewGroup mContentParent = generateLayout(mDecor); ViewGroup contentParent = (ViewGroup)findViewById(ID_ANDROID_CONTENT); public static final int ID_ANDROID_CONTENT = com.android.internal.R.id.content; PhoneWindow 是在哪里初始化的 无版权 可以无限制使用！ all right reserved，powered by Gitbook该文件更新时间： 2021-01-08 15:32:31 "},"chinese/android基础/自定义控件.html":{"url":"chinese/android基础/自定义控件.html","title":"自定义控件","keywords":"","body":"自定义控件 自定义View的意义 1、实现基础控件无法做到的特效。 2、代码封装后方便给其他成员共用，无需重复造轮子。 3、将控件的内部逻辑封装在自定义View中，便于应用内解耦 Android自定义View类型 1、组合控件 将基础控件(TextView、ProgressBar等)组合而成，比如下拉刷新控件等。 2、完全自定义控件 继承 View(UI在主线程中绘制)、ViewGroup 等顶级控件或 SurfaceView 特定控件。 难点在于程序的设计、事件传递处理、效率优化。 SurfaceView extends View ，但是是一个比较特殊的系统控件。UI在一个子线程中进行绘制。 view自定义属性 通过定义属性，使得开发者可以在xml中对控件进行一些参数配置。 不过，我不喜欢这种方式，我习惯在代码中配置。 LayoutInflater 它的作用类似于 findViewById(),不同点是LayoutInflater是用来找 layout 下xml布局文件，并且实例化。 而findViewById() 是找具体xml下的具体控件。 LayoutInflater inflater1 = activity.getLayoutInflater(); LayoutInflater inflater2 = LayoutInflater.from(this); LayoutInflater inflater3 = (LayoutInflater)activity.getSystemService(LAYOUT_INFLATER_SERVICE); // XmlPullParser parser, ViewGroup root, boolean attachToRoot // 参数意义：parser :R.layout.abc , root :root布局 attachToRoot :是否加到root布局中 View itemView=inflater1.inflate(R.layout.abc, null); 注意： 通过 inflate 获得的view 是获取到的长宽都是为0 。 // itemView.getWidth() 、itemView.getHeight() 都会为0 为了能获得长宽，我目前采用的是如下方式 ： 将这个布局放到启动页下 ，通过 findViewById 的方式获取到后 保存起来给其他用 。 MeasureSpec MeasureSpec 通过一个int数值(widthMeasureSpec 、heightMeasureSpec)计算“模式”和“大小”， 前2位表示“大小的模式” ，后30bit表示 “尺寸大小” int mode=MeasureSpec.getMode(widthMeasureSpec); int size=MeasureSpec.getSize(widthMeasureSpec); //MeasureSpec.EXACTLY 用的较多。父容器已经检测出子View所需要的精确大小。 在该模式下，View的测量大小即为 SpecSize 。 //MeasureSpec.UNSPECIFIED 父容器未能检测出子View所需要的精确大小，但是指定了一个可用大小即specSize 在该模式下，View的测量大小不能超过SpecSize。用得少。 //MeasureSpec.AT_MOST 父容器不对子View的大小做限制 。用得少。 如何获取 自定义控件的宽高 1、addOnGlobalLayoutListener private void test(){ final View thisView = this; this.getViewTreeObserver().addOnGlobalLayoutListener(new ViewTreeObserver.OnGlobalLayoutListener() { @Override public void onGlobalLayout() { thisView.getViewTreeObserver().removeOnGlobalLayoutListener(this); int height = thisView.getMeasuredHeight(); int width = thisView.getMeasuredHeight() ; } }); } 2、view.post() 、 view.postDelayed() view.post() 方法在整个view树的 performMeasure 、 performLayout 、performDraw执行完后， 才被主线程轮询到，才得到执行。 因此整个View树都完成了测量，布局，绘制。 所以可以拿到宽高信息。 如何触发重新绘制 invalidate() 、postInvalidate() 首次 View 的绘制流程是在什么时候触发的 UI 绘制相关函数 onMeasure() 测量 View 的大小。决定了 view 本身的大小。 protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) { int widthMode=MeasureSpec.getMode(widthMeasureSpec); int widthSize=MeasureSpec.getSize(widthMeasureSpec); int heighMode=MeasureSpec.getMode(heightMeasureSpec); int heighSize=MeasureSpec.getSize(heightMeasureSpec); int mesW= widthMode==MeasureSpec.EXACTLY ? widthSize: dip2px(getContext(),100); int mesH =heighMode==MeasureSpec.EXACTLY ? heighSize : (int) (mesW*ratio) ; setMeasuredDimension(mesW,mesH); // 使得测量结果生效 } onLayout() 用来决定 View 在 ViewGroup中的位置如何。 在 ViewGroup 中是 abstract,所以必须重写。 在View中是空函数，一般不用重写。 protected void onLayout(boolean boo, int l, int t, int r, int b) { for (int j=0;j layout() 确定View自己的位置。 ViewGroup中的 是 final void layout ，不能重写。 View中 public void layout ，可以重写。但是一般不重写。 在 父容器中直接让子View直接调用即可。 for (int j=0;j onDraw() 决定如何绘制这个 View 。 onSizeChanged() 该方法在当前View尺寸变化时被调用 。 可以在这里重新获取view的长宽等参数。 protected void onSizeChanged(int w, int h, int oldw, int oldh) { super.onSizeChanged(w, h, oldw, oldh); if (w != oldw || h != oldh) { mHeight = h; mMaxOverScrollDistance = w / 2.f; } } measure() // 测量入口，一般不用重写。 public final void measure(int widthMeasureSpec, int heightMeasureSpec){ } dispatchDraw() 绘制子View。 View 没有重写 dispatchDraw的必要。 ViewGroup 貌似一般也不用重写 dispatchDraw ，只是在合适的地方调用一下自己的这个方法，使得自己的子View都去重新绘制。 invalidate() 、postInvalidate() 都是用于刷新界面。 invalidate 在UI线程调用。 postInvalidate 在非UI线程调用，将非UI线程切换到UI线程，最后也是调用invalidate 。 在 View 已被附加在 当前窗口的前提下，invalidate 一定会引起 onDraw 。 如果是 ViewGroup ，默认是认为不需要重新绘制的 ， 如果没有设置过背景 ，调用 invalidate ，viewGroup 的 onDraw 不会被调用。 invalidate 不会导致 onMeasure 和 onLayout 被调用，而 OnDraw 会被调用。 requestLayout() 常用于更新 。 requestLayout 会导致调用 measure()过程 和 layout()过程， 将会根据标志位判断是否需要 onDraw。 invalidate 会导致调用 onDraw 。 所以一般而言，如果是绘制内容变了就调用 invalidate ， 如果是位置变了就调用 requestLayout 。 requestLayout 会导致 onMeasure 和 onLayout 被调用。不一定会触发 OnDraw 。 setWillNotDraw( ) setWillNotDraw(true) // 设置后 就不会调用 onDraw() 。一般用来优化GroupView View中默认设置为false ,ViewGroup默认设置为true 。 自定义控件示例 分贝波形图 https://gitee.com/Aivin_CodeShare/android_tool_code/raw/master/AudioWaveView.java 瀑布流 现在的 RecyclerView 已经直接支出 瀑布流布局了。 // 实现思路 将手机屏幕分成N块 ， 每当需要添加一张图片时，会将这张图片的宽度压缩成和列一样宽，再按照同样的压缩比例对图片的高度进行压缩， 然后在这三列中找出当前高度最小的一列，将图片添加到这一列中。 之后每当需要添加一张新图片时，都去重复上面的操作，就会形成瀑布流格局的照片墙。 然后解决下内存溢出问题。 手势控件 GestureDetector ，ScaleGestureDetector 。 支持识别 向左 、向右、 向上 、向下 、手势放大 、手势缩小 、停止缩放、 双击、 单击 、 长按 。 https://gitee.com/Aivin_CodeShare/android_tool_code/raw/master/GestureView.java 无版权 可以无限制使用！ all right reserved，powered by Gitbook该文件更新时间： 2021-01-08 14:58:36 "},"chinese/android基础/进程通信.html":{"url":"chinese/android基础/进程通信.html","title":"进程通信","keywords":"","body":"多进程通信 进程通信、多进程通信、 进程间通信 进程和线程的区别 一个程序至少有一个进程,一个进程至少有一个线程。 区别的本质 : 操作系统对他们的调度和资源分配不同。 从逻辑角度来看，多线程的意义在于一个应用程序中，有多个执行部分可以同时执行。 但操作系统并没有将多个线程看做多个独立的应用来实现进程的调度和管理以及资源分配。 进程是具有一定独立功能的程序关于某个数据集合上的一次运行活动,进程是系统进行资源分配和调度的一个独立单位。 进程在执行过程中拥有独立的内存单元，而多个线程共享内存，从而极大地提高了程序的运行效率。 进程和线程的主要差别在于它们是不同的操作系统资源管理方式。 进程有独立的地址空间，一个进程崩溃后，在保护模式下不会对其它进程产生影响。 所以多进程的程序要比多线程的程序健壮，但在进程切换时，耗费资源较大，效率要差一些。 dvm指dalivk的虚拟。每一个Android应用程序都在它自己的进程中运行,都拥有一个独立的 Dalvik虚拟机实例。 而每一个DVM都是在Linux 中的一个进程,所以说可以认为是同一个概念. 进程级别 、进程优先级 前台进程 > 可见进程 > 服务进程 > 后台进程 > 空进程 // 前台进程 正在与用户交互的进程。 //可见进程 可以被看见，但是并没有正在交互。 例如你的　activity　被一个悬浮窗或者系统弹窗挡住部分了。 // 服务进程 例如 下载进程、音乐播放进程 // 后台进程 例如　按下 Home 键 进入了后台。 // 空进程; 只是出于缓存的目的而被保留,为了更加有效地使用内存而不是完全释放掉 ， 只要系统需要可以随时杀掉它们。 如何提高进程优先级 我们并不能直接指定 XX进程是 前台进程 或可见进程。而是由系统来判断决定的。 我们只能尽可能地让进程的优先级可能高一点。这就是 “进程保活” 的话题了。 例如 指定优先级 多进程的使用场景 1、将核心模块跑在一个进程中， 降低被系统kill的概率。 2、android系统的内存限制是针对进程的，多开几个进程 可以获得更多的内存。 3、模块化开发，子进程中崩溃并不会导致主进程崩溃。提高程序的健壮性 。 4、需要调用其他应用提供的数据。 APP使用多进程带来的不良影响 因为多进程导致多个虚拟机，会导致以下问题出现： 1、静态成员和单例模式完全失效 。 2、线程同步机制完全失效。 3、SharedPreferences 的可靠性下降 ，这是因为 Sp 不支持两个进程并发进行读写， 有一定几率导致数据丢失。 4、 Application 会多次创建。 Android 系统在创建新的进程时会分配独立的虚拟机， 所以这个过程其实就是启动一个应用的过程， 自然也会创建新的Application。 5、进程间传递的信息要么是 基本数据类型 ，要么就必须能被序列化 。 android 进程间通信方案 1、 Intent + Bundle 同一个app中的不同进程单向通信。一般用于四大组件中。 2、socket socket都可以实现网络通信，那么实现跨进程通信自然是ok的。开销大。 3、通过文件 不同的进程通过对同一个文件进行读写来实现信息交互。 4、ContentProvider 基于 Binder的 ContentProvider 可以让 一个应用向其他应用暴露接口，提供数据。 5、BroadcastReceiver 通过广播播放实现单方面通知。 6、android.os.Messenger 基于AIDL。串行通信。 一个 server 运行在一个 apk 中 ， 另一个apk 绑定服务，发送和接收信息。 7、AIDL 和 Binder 支持并发交互。 相关术语 RPC Remote Procedure Call Protocol， 远程过程调用协议 。 IPC inter process communication ，多进程通信的过程。 oom_adj 对于每一类别的进程会有其oom_adj值的取值范围。在系统执行低杀操作时，会从oom_adj值越高的开始杀。 Binder Binder是一种用来实现进程间通信的架构。 Android基于Linux的， Linux 现有的进程通信手段有以下几种： 1、管道 ; 2、消息队列; 3、共享内存; 4、套接字; 5、信号量。 既然安卓因为基于Linux，已经拥有这么多的IPC通信方案了，为什么还要引入Binder方案呢。 注：( Binder 不是Android提出来的一套新的进程间通信机制，它是基于OpenBinder实现的。) 这是主要从以下几个原因考虑的： 1、效率。 // 对于消息队列、 Socket 和 管道来说， 数据先从发送方的缓存区拷贝到内核开辟的缓存区中，再从内 核缓存区拷贝到接收方的缓存区， 一共两次拷贝。 2、稳定性 。 // 因为共享内存需要处理并发同步问题， 容易出现死锁和资源竞争， 稳定性较差。 3、安全性。 // 传统 Linux IPC 的接收方无法获得对方进程可靠的 UID/PID，从而无法鉴别对方身份。 Binder是一种架构(定义了一种通信机制)， 这种架构提供了服务端接口、Binder驱动、客户端接口三个模块。 Binder使用Client-Server通信方式，安全性好，简单高效，再加上其面向对象的设计思想， 独特的接收缓存管理和线程池管理方式，成为Android进程间通信的中流砥柱。 Binder 通信原理概略 因为安全机制， 一个进程不能直接操作或者访问另一个进程，只能通过IPC方案进行访问。 // 基本原理 Linux系统将一个进程分为用户空间和内核空间。 对于进程之间来说， 用户空间的数据不可共享， 内核空间的数据可共享。 用户空间可以通过系统回调与内核空间通信。 如果在内核空间中有一个模块，能够完成数据的转发，就实现了跨进程通信。 Binder的通信模型有4个角色： 1、Binder Client // 使用数据 ，进程A。 2、Binder Server // 提供数据，进程B。 3、Binder Driver // Binder驱动，将数据从进程B的用户空间中拷贝到进程A的用户空间。 4、ServiceManager // 管理数据查询和注册。 进程C 。 AIDL Android Interface definition language ， 是一种android内部进程通信接口的描述语言。用来定义进程间的通信接口。 当作为客户的一方和要和作为服务器的一方进行通信时，需要指定一些双方都认可的接口， 这样才能顺利地进行通信。而AIDL就是定义这些接口的一种工具。 为什么要借助AIDL来定义，而不直接编写接口呢（比如直接通过Java定义一个Interface）？ 里涉及到IPC的问题。 在Android平台下,各个进程都占有一块自己独有的内存空间， 各个进程在通常情况下只能访问自己的独有的内存空间，而不能对别的进程的内存空间进行访问。 进程之间如果要进行通信，就必须先把需要传递的对象分解成操作系统能够理解的基本类型， 并根据你的需要封装跨边界的对象。而要完成这些封装工作，需要写的代码量十分地冗长而枯燥。 因此Android提供了AIDL来帮助你完成这些工作。 AIDL 支持的数据类型 1、Java 的基本数据类型 2、List 和 Map 元素必须是 AIDL 支持的数据类型 Server 端具体的类里则必须是 ArrayList 或者 HashMap 3、其他 AIDL 生成的接口 4、实现 Parcelable 的实体 aidl in out // 一般而言，客户端是调用接口， 服务端是服务实现 in 表示数据只能由接口的调用进程流向接口的实现进程， out 表示数据只能由接口的实现进程流向接口的调用进程， inout 则表示数据可在接口的调用进程与实现进程之间双向流通。 AIDL 实例Demo 代码下载： https://gitee.com/hnyer/aidl-demo 1、ERROR: Process 'command 'F:\\sdk2\\build-tools\\30.0.1\\aidl.exe'' finished with non-zero exit value -1073741701 原因是： buildToolsVersion 可能不兼容，尝试改一下 版本号。 //buildToolsVersion \"30.0.1\" //编译不过 buildToolsVersion \"29.0.1\" // 编译ok XXX bookManager = XXX.Stub.asInterface(service); // 根据server 获取在aidl中的自定义接口 XX.asBinder().isBinderAlive() // isBinderAlive ，判断binder是否还存在 xx.asBinder().isBinderAlive() // asBinder ,根据自定义 aidl接口获得 binder对象 // CopyOnWriteArrayList 一个系统类，只有写入和写入之间需要进行同步等待。 但是有不少缺点：一是内存占用问题，毕竟每次执行写操作都要将原容器拷贝一份，数据量大时，对内存压力较大 ； 二是无法保证实时性，由于其实现策略的原因，写和读分别作用在新老不同容器上， 在写操作执行过程中，读不会阻塞但读取到的却是老容器的数据。 // RemoteCallbackList 用来存储监听接口。本质是一个 ArrayMap，内部自动实现了线程同步的功能。 xx.getBroadcastItem(i) // 根据索引获取接口 xx.beginBroadcast() // 获取接口个数。beginBroadcast 必须与 finishBroadcast 配对使用 xx.finishBroadcast() xx.register() //添加接口 xx.unregister() // 移除接口 // IBinder.DeathRecipient unlinkToDeath() // 服务端监听客户端进程是否挂掉 // 启动方式 因为 startService 方式不能获得service的方法，所以不能不能拿到AIDL定义的接口，无法双向通信。 所以只能用 bindService 方式，根据 ServiceConnection 获得接口。 无版权 可以无限制使用！ all right reserved，powered by Gitbook该文件更新时间： 2020-12-22 08:58:44 "},"chinese/android基础/Binder详解.html":{"url":"chinese/android基础/Binder详解.html","title":"Binder详解","keywords":"","body":"Binder详解 从英文字面上意思看， Binder 具有粘结剂的意思，那么它把什么东西粘结在一起呢？在Android系统的Binder机制中，Binder由 Client、Server、Service Manager和Binder驱动组成。Binder就是一种把这四个组件粘合在一起的粘结剂了。 为什么要采用Binder Linux已经有多种跨进程通信方式，Android为何还要采用Binder？ 因为 更高效、更安全。 方式 缺点 优点 数据拷贝次数 共享内存 控制机制复杂 0 Binder 可以建立私有通道、有UID鉴别身份 1 socket 开销大、效率低 2 管道、消息队列 效率低 2 Binder 通信采用 C/S架构。 Binder框架定义了四个角色：Server、Client、ServiceManager 、驱动。 这四个角色的关系和互联网类似：Server是服务器，Client是客户终端，SMgr是域名服务器（DNS），驱动是路由器。 1、BinderDriver 尽管名叫“驱动”实际上和硬件设备没有任何关系，存在于内核空间中。 Android系统已经实现。 2、ServerManager 提供了查询服务和注册服务的功能。 Android系统已经实现。 Service Manager是一个守护进程。 3、BinderClient 调用其他进程中的相关服务。由开发者实现。 4、Binder Server 提供相关的服务。由开发者实现。 关键类、方法 1、Native端： IBinder 、 BBinder 、 BpBinder 、 IPCThread 、 ProcessState、 IInterface 、JavaBBinder jni端： android_util_Binder.cpp 、 2、Java端： IBinder 、 Binder、 BinderProxy （Binder的一个内部类）、 Stub、 Proxy 、ServiceManager（Java源码 被@hide了） 3、Binder Driver 端： binder_proc、 binder_thread、 binder_node 、ioctl（是一个函数） 关键名词 实名Binder 注册了名字的Binder。 Binder实体 Binder实体实际上是binder_node结构体的对象。 Binder引用 每一个Binder引用都是某一个Binder实体的引用。 0号引用 我们可能会发现一个细节：SMgr是一个进程，Server是另一个进程，Server向SMgr注册Binder必然会涉及进程间通信。当前实现的是进程间通信却又要用到进程间通信，这就好象蛋可以孵出鸡前提却是要找只鸡来孵蛋。 Binder的实现比较巧妙：预先创造一只鸡来孵蛋：系统给Smgr创建一个特殊专门的Binder实体。 它没有名字也不需要注册。一个Server若要向SMgr注册自己Binder就必需通过0这个引用号和SMgr的Binder通信。类比网络通信，0号引用就好比域名服务器的地址。 匿名 Binder Server端可以通过已经建立（通过实名Binder实现）的Binder连接将创建的Binder实体传给Client 。由于这个Binder没有向SMgr注册名字，所以是个匿名Binder。 匿名Binder为通信双方建立一条私密通道，只要Server没有把匿名Binder发给别的进程，别的进程就无法通过穷举或猜测等任何方式获得该Binder的引用。 为什么Binder只进行了一次数据拷贝？ mmap()分配的内存除了映射进了接收方进程里，还映射进了内核空间。所以调用copy_from_user()将数据拷贝进内核空间也相当于拷贝进了接收方的用户空间 。 数据从发送方的缓存区拷贝到内核的缓存区，而接收方的缓存区与内核的缓存区被是映射到同一块物理地址的，因此只需要一次拷贝即可。 先把数据拷贝到内核的缓存区，然后再从内核的缓存区拷贝给接收方。这样做会产生两次数据的拷贝。linux中的管道通信就是采取这种方式。 简单理解                   Binder 通信模型、 Binder 架构       Binder 机制 Binder 驱动       Binder 进程与线程       ServiceManager启动       ServiceManager 注册服务       ServiceManager 获取服务       进行一次完整通讯 Binder通信命令字 命令 含义 说明 BINDER_WRITE_READ 该命令向Binder写入或读取数据 常用的命令 BINDER_SET_MAX_THREADS 该命令告知Binder驱动接收方线程池中最大的线程数 - BINDER_SET_CONTEXT_MGR 将当前进程注册为SMgr。 - BINDER_THREAD_EXIT 通知Binder驱动当前线程退出了。 - BINDER_VERSION 获得Binder驱动的版本号 - Binder写操作命令字 命令 含义 说明 BC_TRANSACTION Client向Server发送请求数据 最常用 BC_REPLY Server向Client发送回复数据 最常用 BC_ACQUIRE_RESULT、 BC_ATTEMPT_ACQUIRE 尚未实现 BC_FREE_BUFFER 释放一块映射的内存 BC_INCREFS、BC_ACQUIRE 、BC_RELEASE 、BC_DECREFS 增加或减少Binder的引用计数 BC_INCREFS_DONE 、BC_ACQUIRE_DONE 处理完毕反馈信息 BC_REGISTER_LOOPER 通知驱动线程池中一个线程已经创建了 BC_ENTER_LOOPER 通知驱动该线程已经进入主循环，可以接收数据 BC_EXIT_LOOPER 通知驱动该线程退出主循环，不再接收数据 BC_REQUEST_DEATH_NOTIFICATION 要求驱动在Binder实体销毁得到通知 BC_DEAD_BINDER_DONE 收到销毁通知的进程在删除引用后用本命令告知驱动 Binder读操作命令字 命令 含义 说明 BR_ERROR 发生内部错误 BR_OK 、BR_NOOP 操作完成 BR_SPAWN_LOOPER 向接收方发送该命令要求创建更多线程以备接收数据 BR_TRANSACTION 、BR_REPLY 表示当前接收的数据是请求还是回复 BR_ACQUIRE_RESULT 、BR_ATTEMPT_ACQUIRE 、BR_FINISHED 尚未实现 BR_DEAD_REPLY 交互过程中如果发现对方进程或线程已经死亡则返回该消息 BR_TRANSACTION_COMPLETE 发送数据包后，收到该消息做为成功发送的反馈 BR_INCREFS 、BR_ACQUIRE 、BR_RELEASE 、BR_DECREFS 用于管理强/弱指针的引用计数 BR_DEAD_BINDER 、BR_CLEAR_DEATH_NOTIFICATION_DONE 收到死亡通知书 BR_FAILED_REPLY 如果发送非法引用号则返回该消息 Binder接收/发送数据包的标准格式 成员 含义 说明 union {     size_t handle;void *ptr;} target; 指明发送目的地 void *cookie; 存放的是创建Binder实体时由该接收方自定义的任意数值，做为与Binder指针相关的额外信息存放在驱动中。 unsigned int code; 存放收发双方约定的命令码 unsigned int flags; 与交互相关的标志位 pid_t sender_pid;、uid_t sender_euid; 该成员存放发送方的进程ID和用户ID，由驱动负责填入 size_t data_size; 缓冲区存放的数据长度。 size_t offsets_size; 偏移位置 union { struct { const void buffer; const void offsets; } ptr; uint8_t buf[8]; } data; 放要发送或接收到的数据, 无版权 可以无限制使用！ all right reserved，powered by Gitbook该文件更新时间： 2020-08-19 17:20:00 "},"chinese/android基础/Handler详解.html":{"url":"chinese/android基础/Handler详解.html","title":"Handle详解","keywords":"","body":"Handle、Looper 、Message、MessageQueue 模型 简单的说：一个线程开启一个无限循环模式，不断遍历自己的消息列表，如果有消息就挨个拿出来做处理，如果列表没消息，自己就堵塞（相当于wait，让出cpu资源给其他线程），其他线程如果想让该线程做什么事，就往该线程的消息队列插入消息，该线程会不断从队列里拿出消息做处理。 Looper.prepare() --> sThreadLocal.set(new Looper(quitAllowed)); Looper.loop() // 记住这点就不会弄错执行线程的问题 handleMessage 最终在哪个线程执行 , 要看 Looper 是由哪个 线程创建的。 Message 定义了消息必要的描述和属性数据。 public final class Message implements Parcelable{ public int what;//用来标识一个消息.区分来源 public int arg1; //简单消息 public int arg2; public Object obj; //任意类型数据 public Messenger replyTo; Bundle data;//存储复杂点的对象 Handler target;//发送和处理消息关联的 Handler Runnable callback; //消息的回调 ...... } // 获取 Message 的方式 Message message ; message= new Message(); // Return a new Message instance from the global pool. // Allows us to avoid allocating new objects in many cases. message= Message.obtain(); message= Message.obtain( message ) ; message= Message.obtain( handler ) ; message= Message.obtain( handler, what) ; message= Message.obtain( handler ,runnable) ; // 效果跟 Message.obtain( handler ) 一样 ，因为最终也是执行到了 Message.obtain( handler ) message= handler.obtainMessage(); message= handler.obtainMessage( what); MessageQueue 消息队列 ,提供入队、出队等功能。系统只会自动给主线程建立 MessageQueue。 (子线程也可以有 MessageQueue，只是需要调用 Looper.prepare(); ) boolean enqueueMessage(Message msg, long when) Message next() Handle 负责 Message 的发送和执行处理等。 handler.post(runnable) ; handler.postAtTime(runnable ,0) ; handler.postDelayed( runnable ,0) ; handler.sendMessage(message); handler.sendEmptyMessage( 1 ); handler.sendMessageDelayed(message, 0); // 以上 6个函数 都最后会 被执行到 sendMessageAtTime() handler.sendMessageAtTime(message ,0) ; // 插入到消息队列最前面 handler.postAtFrontOfQueue(runnable) ; Looper 循环器，扮演 MessageQueue 和 Handler 之间桥梁的角色，循环取出 MessageQueue 里面的Message，并交付给 Handler 进行处理。 Looper 在prepare中通过ThreadLocal保证了每个线程Looper对象的唯一性， 对于每个线程，有唯一的Looper对象和MessageQueue队列。 loop() 中有一个死循环 for (;;) ，会不断调用 MessageQueue 的next()，当有消息就处理，否则就阻塞等待。 Looper.loop(); // 死循环 判断是否有需要处理的 Message public static void loop(){ final Looper me = myLooper(); final MessageQueue queue = me.mQueue; for (;;) { Message msg = queue.next(); //如果没有消息则阻塞。 msg.target.dispatchMessage(msg); //将消息进行分发 处理 } } HandlerThread HandlerThread extends Thread.. HandlerThread 是一个内部实现了 Looper循环的线程 。 Android中多线程的场景很多，为了解决多线程问题，Android提供了很多方案。 线程池整体量级有些偏重， HandlerThread 是一种轻量的多线程解决方案。 mHandler = new Handler( mHandlerThread.getLooper()){ public void handleMessage(Message msg){ // 这里是子线程 ，可以执行耗时操作 activity.runOnUiThread(new Runnable() { @Override public void run() { // 这里是主线程 } }); } }; mHandler.sendEmptyMessage(MSG_UPDATE_INFO); mHandler.removeMessages(MSG_UPDATE_INFO); mHandlerThread.quit(); ThreadLocal 从ThreadLocal这个名字看，它带着浓浓的“本地线程”的味道； 其实 ThreadLocal并不是用来操作什么本地线程而是用于实现不同线程的数据副本。 每一个线程都可以独立地改变自己的副本并且不会影响其它线程所持有的对应的副本。 在 Looper.java 中 有使用到 ThreadLocal 的这特性。 static final ThreadLocal sThreadLocal = new ThreadLocal(); //将新创建的对象的引用保存到各线程的自己的一个map中 sThreadLocal.set(new Looper(quitAllowed)); public static Looper myLooper() { // 各线程从自己的map中取出放进去的对象， // 因此取出来的是各自自己线程中的对象 ,使得每个 thread 都有自己独立的 handle return sThreadLocal.get(); } 一个线程有几个Looper 因为在调用 Looper.prepare() 给当前线程新建 Looper 时有判断 , 所以 只能有一个 Looper private static void prepare(boolean quitAllowed){ if (sThreadLocal.get() != null) { throw new RuntimeException(\"Only one Looper may be created per thread\"); } sThreadLocal.set(new Looper(quitAllowed)); } 判断是否是主线程 通过判断两个线程的 Looper 是否是同一个。 return Looper.myLooper() == Looper.getMainLooper(); Can't create handler inside thread that has not called Looper.prepare() 在子线程中 直接调用 Handler handler=new Handler() ,会提示这个错误。 因为 在 Handle 的构造函数中 对 Looper 进行检查 mLooper = Looper.myLooper(); if (mLooper == null) { throw new RuntimeException( \"Can't create handler inside thread \" + Thread.currentThread() + \" that has not called Looper.prepare()\"); } 所以需要 手动调用 Looper.prepare() private static void prepare(boolean quitAllowed) { if (sThreadLocal.get() != null) { throw new RuntimeException(\"Only one Looper may be created per thread\"); } sThreadLocal.set(new Looper(quitAllowed)); // 通过 ThreadLocal 给当前线程设置 looper } 而且需要手动调用 Looper.loop() ,开启 handle 对应 looper 的死循环 for (;;) 为什么主线程中 新建Handle 不要手动调用 Looper.prepare() 和 Looper.loop() 因为在 ActivityThread.java 中的 public static void main(String[] args) 函数中 系统已经 启用了 Looper.prepareMainLooper() 、Looper.loop() 主线程中的Looper.loop()一直无限循环为什么不会造成ANR 为什么当主线程处于死循环的 Message msg = queue.next() 这句会阻塞线程的代码的时候不会产生 ANR 异常, 1、当没有消息的时候会阻塞 2、其他线程有消息发过来，它马上就会被唤醒，去分发message。 所以 阻塞是有的，但是不会报ANR 。 因为ANR的根本原因是在等待的时间内没有回应， 你都没有 Message 要处理，我当然不需要任何回应。 ANR (Application Not Responding )原理 ANR的监控和处理，是在系统层做的。 系统服务发出一条指令后会在约定的时间等待返回， 如果在约定时间内没有返回，系统就会给出 ANR 提示。 为什么 Handler 有潜在内存泄露 在 Activity 中 用这种内部类的方式 新建 handle， handle就会持有外部类 activity 的引用， Handler handler = new Handler() { ... }; 同理 ，Runnable 也会拥有 外部类 activity 的引用 handler.postDelayed(new Runnable() { public void run() { ... } }) Runnable 被封装成 Message 被 MessageQueue 持有，所以 activity 被 MessageQueue 间接持有了。 activity 退出时，如果延时时间还没到，所以 activity 无法被释放掉。 至于为什么 内部类会持有外部类的引用 ，可以查阅其他博客。 通过 WeakReference 解决 handle 内存泄漏 private static class MyHandler1 extends Handler { //WeakReference 当GC执行时，无论当前内存是否充足，都会将弱引用关联的对象回收掉。 private final WeakReference weakReference; public MyHandler1(InfoHudViewHolder controller) { weakReference = new WeakReference<>(controller ); } @Override public void handleMessage(Message msg) { InfoHudViewHolder holder = weakReference.get() ; if(holder==null){ return; } } } // 使用 MyHandler myHandler =new MyHandler(this) ; 为什么 在子线程中调用 activity.runOnUiThread() 也可以更新UI new Thread(new Runnable() { activity.runOnUiThread(new Runnable() ... ) }).start(); public final void runOnUiThread(Runnable action) { if (Thread.currentThread() != mUiThread) { // 在子线程中调用activity.runOnUiThread( ... ) 的情况 mHandler.post(action); } else { // 在主线程中调用activity.runOnUiThread( ... ) 的情况 action.run(); } } 从源码可以得知 ，如果调用 runOnUiThread()的线程就是主线程，就立马执行。 如果是在子线程中调用，就会把 Runnable 封装成 Message ，进入消息队列， 最后会转发给 创建 mHandler 所在的线程执行 ，Handler mHandler = new Handler(); mHandler 是系统在 Activity.java 中创建，所以最后会在主线程中执行了。 为什么 在子线程中调用 handler.post(new Runnable...) 也可以更新UI // 前提条件 ： handler是在 主线程中新建的 new Thread(new Runnable() { handler.post(new Runnable() { // 更新 UI } ).start(); 跟踪源码发现 执行 post 后 ，会经过 一系列函数 ，将 Runnable 包装成 Message ， 最后分发回 handler所依附线程(主线程)中运行。 private static Message getPostMessage(Runnable r) { Message m = Message.obtain(); // 包装 Runnable 给 Message m.callback = r; return m; } public void dispatchMessage(@NonNull Message msg) { if (msg.callback != null) { handleCallback(msg); // 执行 Runnable 的run 函数 } } private static void handleCallback(Message message) { message.callback.run(); } handler 为什么可以更新UI 、为什么可以实现线程间通信 现在有A、B两个线程，在A线程中创建了handler，然后在B线程中调用 A线程的 handler发送一个message。 当A线程创建handler的时候，同时创建了 MessageQueue 与 Looper， Looper在A线程中被调用，进入 for (;;) 循环 ，轮询 MessageQueue 是否有需要处理的消息。 在B线程使用 A线程中的 handler发送一个message ,将message插入到handler对应的MessageQueue中， Looper发现有message插入到MessageQueue中，便取出message执行相应的逻辑， 因为Looper.loop() 是在A线程中启动的，对应的 MessageQueue 和 Looper 都是属于 A线程的 ， 所以 Handle 的方法 handleMessage() 是在 A线程中执行。 Runnable 是一定运行在子线程中吗 Runnable 运行在子线程中是错误的观念。 runnable只是创建了一个执行任务的对象，但是它本身并不会创建一个新的子线程。 最终的执行线程是要看 所依附的线程 。 1、举例 handler.post(runnable) // The runnable will be run on the thread to which this handler is attached. public final boolean post(@NonNull Runnable r) { return sendMessageDelayed(getPostMessage(r), 0); } 2、举例view.post(runnable) The runnable will be run on the user interface thread. MessageQueue 如何对 Message 排序的 通过时间排序 。 public final boolean postDelayed(@NonNull Runnable r, long delayMillis) { return sendMessageDelayed(getPostMessage(r), delayMillis); } public final boolean sendMessageDelayed(@NonNull Message msg, long delayMillis) { ... // SystemClock.uptimeMillis() Returns milliseconds since boot, not counting time spent in deep sleep return sendMessageAtTime(msg, SystemClock.uptimeMillis() + delayMillis); } boolean enqueueMessage(Message msg, long when) { synchronized (this) { ... msg.when = when; Message p = mMessages; // 下一条信息 boolean needWake; // 根据 when 进行顺序排序，将消息插入到其中 if (p == null || when == 0 || when Handler.postDelayed()是如何 实现实现延时执行的 会马上进入队列的，而不是等时间到了再加入队列。 Handler 不是自己处理 Delay，而是交给了MessageQueue处理。 大概流程如下： 1、postDelay 一个延时10秒钟的A消息进队，MessageQueue调用 nativePollOnce ()阻塞，Looper阻塞； 2、紧接着post 一个B消息进队，判断现在A时间还没到、正在阻塞，把B插入消息队列的头部（A的前面）， 然后调用nativeWake()方法唤醒线程； 3、MessageQueue.next()方法被唤醒后，读取消息链表，第一个消息B无延时，直接返回给Looper，执行B消息。 4、Looper for(;;) 处理完这个消息再次调用next()方法，MessageQueue继续读取消息链表， 假如消息A还没到时间，继续阻塞；直到阻塞时间到或者下一次有Message进队再次唤醒； 这样就实现了延时。 Handler.postDelayed() 的延时方法是一定非常精准吗 这种方式是不精准的。 Message的执行时机是在加入队列时就计算好的。 sendMessageAtTime(msg, SystemClock.uptimeMillis() + delayMillis); 然后 Looper.looper()函数中的 for (;;) 是串行执行的，执行了上一条后再去判断下一个Message 是否要执行。 (handle 和 Looper 是处于一个线程，所以执行一条才能下一条)。 举个夸张的例子， myThread1.handler1.postDelayed(new Runnable() { @Override public void run() { long time =System.currentTimeMillis() - timeStart ; Wklog.d(\"延时5秒执行=\"+ Thread.currentThread().getId()+\" 间隔描述=\"+ (time/1000)); } } ,5*1000) ; myThread1.handler1.post(new Runnable() { @Override public void run() { timeStart = System.currentTimeMillis() ; Wklog.d(\"马上执行线程=\"+ Thread.currentThread().getId() ); Thread.sleep(3*1000); //Thread.sleep(7*1000); } } }) ; handler1.postDelayed 按计划是延时5秒执行的， handler1.post 是马上执行的 。 如果 post的 Handle在5秒内执行完毕， postDelayed的Runable 还是按照原计划 5秒后执行， 如果 post的 Handle 超过5秒执行完毕， postDelayed的Runable 就不能实现延时5秒了，而是7秒了。 因为，本来应该在 for(;;)判断是否要执行下一条的时间里 却在执行 耗时操作，错过了。 MessageQueue 中为什么不用 wait 而用 epoll 进行等待呢 在旧版本中，是用的wait 实现等待。 后来需要处理 native 层的一些事情，改成 select 再改成 epoll private native void nativePollOnce(long ptr, int timeoutMillis) 实现等待 。 https://android.googlesource.com/platform/frameworks/base/+/46b9ac0ae2162309774a7478cd9d4e578747bfc2%5E%21/#F16 如何退出 Looper 循环 、退出 Handle handler.getLooper().quit(); // 我手动调用这个代码 // Looper.java public void quit() { mQueue.quit(false); } // MessageQueue.java void quit(boolean safe) { synchronized (this) { if (mQuitting) { return; } mQuitting = true; // 1、标记可以退出 if (safe) { removeAllFutureMessagesLocked(); // 2、删除相关数据 } else { removeAllMessagesLocked(); } nativeWake(mPtr); // 3、唤醒线程 } } 然后再来看 Looper.java 中的 loop() 函数 public static void loop() { for (;;) { Message msg = queue.next(); // might block ， if (msg == null) { // 6、nex 返回空 ，退出 loop循环 return; } msg.recycleUnchecked(); } } // MessageQueue.java Message next() { for (;;) { // nativePollOnce 用于“等待”, 直到下一条消息可用为止 // 4、被step3唤醒 ，继续往下执行 nativePollOnce(ptr, nextPollTimeoutMillis); synchronized (this) { if (mQuitting) { // 5、mQuitting 在 step 1被设置为 true了 ，所以返回 null dispose(); return null; } } 主线程 的 looper 能否 quit() void quit(boolean safe) { if (!mQuitAllowed) { throw new IllegalStateException(\"Main thread not allowed to quit.\"); } } 从源码可知，主线程的Looper 禁止开发者 quit 。 因为主线程中的 handle 要处理很多事情，退出之后 整个APP就没得玩了。 private class H extends Handler｛ public void handleMessage(Message msg) { switch (msg.what) { case LAUNCH_ACTIVITY case RELAUNCH_ACTIVITY: { case PAUSE_ACTIVITY: { case PAUSE_ACTIVITY_FINISHING: case STOP_ACTIVITY_SHOW: case STOP_ACTIVITY_HIDE: case LOCAL_VOICE_INTERACTION_STARTED: ... Handler 如何确保线程安全 // 与 handle 对应的 MessageQueue ，Message 进入队列 synchronized 上锁了 boolean enqueueMessage(Message msg, long when) { // MessageQueue.java synchronized (this) { // Looper 中获取 Message 时 MessageQueue 的next 也被上锁了 for (;;) { // Looper.java Message msg = queue.next(); Message next() { // MessageQueue.java synchronized (this) { ... } } 手写 handle 机制 实现 线程间通信 handle 不仅仅只用于 主线程 和子线程的通信 ，也可以实现 子线程和子线程的通信 。 可以参考我的 demo https://gitee.com/hnyer/my-handle 无版权 可以无限制使用！ all right reserved，powered by Gitbook该文件更新时间： 2020-12-07 15:34:12 "},"chinese/android基础/Fragment详解.html":{"url":"chinese/android基础/Fragment详解.html","title":"Fragment详解","keywords":"","body":"Fragment详解 一个Fragment总是嵌入到一个Activity，是一个模块化的View，它的生命周期受它所嵌入的Activity生命周期的的影响。可以动态的添加、替换、移除某个Fragment。 fragment的优势 同样的界面 ， fragment 比activity 占用内存更少 ，响应速度更快 。 Fragment生命周期 activity与fragment生命周期的关系 与activity相同的生命周期函数 onCreate 、onStart 、onResume、onPause、onStop 、onDestroy 与activity相比多出的生命周期函数 onAttach 、onDetach 、onActivityCreated 、onViewCreated 、onCreateView 、onDestroyView 常用函数 getSupportFragmentManager 获得碎片管理者 getChildFragmentManager 获取自己的FragmentManager对象。 getFragmentManager 获取的是父Fragment(如果没有，则是FragmentActivity)的FragmentManager对象。 getBackStackEntryCount 从管理器中得到Fragment当前已加入Fragment回退栈中的fragment的数量。 onHiddenChanged onHiddenChanged 不是生命周期函数 ，通过 hide 和 show 进行触发。 无版权 可以无限制使用！ all right reserved，powered by Gitbook该文件更新时间： 2020-12-18 08:52:57 "},"chinese/android基础/Android启动模式.html":{"url":"chinese/android基础/Android启动模式.html","title":"Android启动模式","keywords":"","body":"Android启动模式 activity 生命周期 onDestroy // onStop 和 onDestroy 回调为什么会延时 由于要关闭的 或者要打开的 Activity 往主线程的 MessageQueue 中发送了 大量的 Message , 导致主线程一直在不断的进行消息循环处理这些消息而没有得到停歇。 App 侧就不能向 AMS 告知自己有空闲时间来处理 AMS 侧的任务。 所以，finish Activity B后，onDestroy不会被及时回调。 具体延时多久，要看主线程什么时候闲下来。 // 为什么 Activity.finish() 之后 10s 才 onStop 、onDestroy 除正常流程外，Android 系统另行安排了一套流程来保证即使正常流程被阻断以后，Activity B还是能被销毁。 ActivityStac.java 中 // schedule an idle timeout in case the app doesn't do it for us. mStackSupervisor.scheduleIdleTimeoutLocked(next); this.mHandler.sendMessageDelayed(msg, 10000L); // 10s onRestart 经过测试，以下几种情况 onRestart()方法 会被调用 1、按下home键之后，然后切换回来 2、从本Activity跳转到另一个Activity之后，按 back键返回原来 Activity 3、从本Activity切换到其他的应用，然后再从其他应用切换回来 onStop 两个Activity之间跳转 , 从A跳到B ，A的 onStop 是否执行 取决于 B是否完全覆盖在 A上 导致A整个不可见。 如果 B 是透明的 Activity 或者是个 Dialog 样式 ，A 的 onStop 并不会被执行。 按 Back 键 后，activity 的生命周期变化 这些东西 写个简单demo 实验一把 当场就能出结果。 面试官要是硬要你回答，就是沙比。 按 Home 键 后，activity 的生命周期变化 这些东西 写个简单demo 实验一把 当场就能出结果。 activity 启动另外一个activity的时候横屏切换再点击返回，过程中发生的生命周期 这些东西 写个简单demo 实验一把 当场就能出结果。 启动模式 通过使用不同的启动模式，来控制是否生成唯一还是多个activity实例 。来满足不同的使用场景 。 standard 模式 默认模式。每当有一次Intent请求，就会创建一个新的Activity实例 。 并且被放到启动它的那个Activity所属的任务栈中。 singleTop 模式 栈顶复用。 栈顶有此实例就使用（调用 onNewIntent()方法） ，没有就重新创建。(调用onCreate()方法) singleTask 模式 栈内复用。 若栈中已有该Activity的实例，就重用该实例(调用onNewIntent()方法)。 并且会将它所在任务栈之前的所有activity实例移除掉。因此该实例就处于栈顶了。 若栈中不存在该实例，将会onCreate()。 可以用在 消除交互界面的嵌套循环 场景。 singleInstance 模式 全局唯一。 Activity单独占用一个Task栈 。整个系统中是单例的。 启动模式属性 // taskAffinity android:taskAffinity=\"task001\" 它倾向于将 taskAffinity 属性相同的Activity，扔进同一个Task中。指定Activity希望归属的栈 // allowTaskReparenting 任务状态是否始终由系统来维护 android:allowTaskReparenting=\"true\" //默认false 任务栈 task stack 每次启动新的Activity都将被添加到Activity Stack。 用户返回就会将当期的activity实例出栈。 如果当前栈空了，就会进入 Home screenn 所在的栈 。 1、一个应用程序一被启动,系统就给它分配一个任务栈 。 一个应用程序一个任务栈。 2、一个任务栈中存放多个activity ,可以来自不同的应用程序。 查看 系统的任务栈 、 Activity 栈信息 、各个栈的 Activity 列表 adb shell dumpsys activity 指定启动模式 代码方式 优先级大于 xml方式 // xml方式 // 代码方式 Intent intent = new Intent( this ,TestActivity.class); intent.addFlags(Intent.FLAG_ACTIVITY_SINGLE_TOP); this.startActivity(intent); Intent的 Flag标志 官网flags Intent的Flag标志 意义 FLAG_ACTIVITY_NEW_TASK 默认的跳转类型 FLAG_ACTIVITY_SINGLE_TOP singletop模式 FLAG_ACTIVITY_BROUGHT_TO_FRONT FLAG_ACTIVITY_CLEAR_TOP SingleTask模式 FLAG_ACTIVITY_NO_HISTORY Activity不会保留在栈中 FLAG_ACTIVITY_NO_ANIMATION 不使用过渡动画 FLAG_ACTIVITY_EXCLUDE_FROM_RECENTS 最近应用里面查看不到这个activity的启动记录 无版权 可以无限制使用！ all right reserved，powered by Gitbook该文件更新时间： 2020-12-21 10:10:24 "},"chinese/android基础/Service服务.html":{"url":"chinese/android基础/Service服务.html","title":"Service 服务","keywords":"","body":"Service 服务 Service 是运行在主线程中的， 所以 Service 处理不当 也是会引起 ANR 的。 如果有耗时操作在Service里，就必须用子线程处理 。 Service的意义 1、优先级高，不容易被系统杀死。用来实现需要稳定、长时间运行的模块。 (Service的优先级高于后台挂起的Activity， 也高于Activity所创建的Thread) 2、用在一些不适合activity的的场景。例如音乐播放和文件下载等场景 。 Service 启动方式 因为 startService 方式不能获得service的方法，所以不能不能拿到AIDL定义的接口，无法双向通信。 所以aidl中只能用 bindService 方式，根据 ServiceConnection 获得接口。 start模式 一旦启动，Service将一直运行在后台，即便启动Service的组件已被destroy。 Intent intent = new Intent(this, MyNormalService.class); startService(intent);//启动服务 stopService(intent) ;//停止服务 //或在服务类中 调用 stopSelf(); bind模式 通过绑定方式启动的Service是一个client-server结构。 多个组件可与一个service绑定，service不再与任何组件绑定时，该service会被destroy。 Intent intent = new Intent(MainActivity.this, MyNormalService.class) ; this.bindService( intent, serviceConnection , BIND_AUTO_CREATE ); // 绑定 this.unbindService(serviceConnection); // 解绑 // 启动远程service ,比如aidl通信时，service不在同一个APP。 Intent intent=new Intent(); intent.setAction(\"com.remoteService.test\"); //用来识别service的标记 intent.setPackage(\"com.wk.iadlservice\"); // 服务所在的应用id bindService(intent, mConnection, Context.BIND_AUTO_CREATE); ServiceConnection serviceConnection = new ServiceConnection(){ @Override public void onServiceConnected(ComponentName name, IBinder service) { MyNormalService.MyBinder myBinder = (MyNormalService.MyBinder) service ; myBinder.func1();//调用自定义Binder中的方法 } @Override public void onServiceDisconnected(ComponentName name) { } } ; //MyNormalService.java @Override public IBinder onBind(Intent intent){ return new MyBinder(); } class MyBinder extends Binder{ public void func1(){ ... } } public class MyNormalService extends Service{ // 通过start方式启动 时回调的方法 @Override public IBinder onBind(Intent intent){ .... } // 通过bind方式启动 回调的方法 @Override public int onStartCommand(Intent intent, int flags, int startId){ ... } } bindService( , ,) bindService( , , int flags ) flags 含义 BIND_AUTO_CREATE //若绑定服务时服务未启动，则会自动启动服务。 BIND_DEBUG_UNBIND // 使用此标志绑定服务之后的unBindService 方法会无效。 这种方法会引起内存泄露，建议只在调试时使用。 BIND_NOT_FOREGROUND // 被绑定的服务进程优先级不允许被提到 FOREGROUND 级别 BIND_ABOVE_CLIENT // 如果当绑定服务期间遇到OOM需要杀死进程，客户进程会先于服务进程被杀死。 BIND_WAIVE_PRIORITY // 被绑定的服务进程不会被OOM列入猎杀对象中。 service 生命周期 // 手动调用方法 startService() stopService() bindService() unbindService() // 内部自动调用的方法 onCreat() onStartCommand() 开始服务 onDestroy() onBind() onUnbind() onStartCommand() 默认情况下， onStartCommand 返回值 START_STICKY_COMPATIBILITY 或 START_STICKY 。 1、START_STICKY // 会重启服务，可能会传递null的intent。 如果Service所在的进程，在执行了onStartCommand方法后，被清理了， 那么这个Service会被保留在已开始的状态，但是不保留传入的Intent， 随后系统会尝试重新创建此Service，由于服务状态保留在已开始状态， 所以创建服务后一定会调用onStartCommand方法。 如果在此期间没有任何启动命令被传递到service，那么参数Intent将为null，需要我们小心处理。 2、START_NOT_STICKY // 不会重启服务。这是最安全的选项 如果Service所在的进程，在执行了onStartCommand方法后，被清理了，则系统不会重新启动此Service。 3、START_REDELIVER_INTENT // 会重启服务。传入最后一个intent 。 如果系统在 onStartCommand() 返回后终止服务，则会重建服务，并通过 传递给服务的最后一个 Intent。 4、START_STICKY_COMPATIBILITY // 是START_STICKY 的兼容版本，但是不能保证被清理后 onStartCommand方法一定会被重新调用。 前台服务、后台服务 // 1、前台服务 前台服务必须给状态栏提供一个通知 。 系统内存不足的时候不允许系统杀死的服务。 // 参数一：唯一的通知标识；参数二：通知消息。 xx.startForeground(12345, notification);// 开始前台服务 xx.stopForeground(true);// 停止前台服务--参数：表示是否移除之前的通知 IntentService 1、public abstract class IntentService extends Service.. 2、HandlerThread thread = new HandlerThread(\"IntentService[\" + mName + \"]\").. 3、mServiceHandler = new ServiceHandler(mServiceLooper).. 1、内部已经采用了独立的子线程处理问题。无需手动开启子线程。 2、内部采用队列处理问题。 不用考虑多线程并发问题。 3、任务结束后会自动停止。无需手动调用停止代码。 解决Service内存泄漏问题。 Service 和 Activity 通信 1、bindService 启动的服务 通过 ServiceConnection 拿到 service的引用，给它发送数据。 activity - > service 通过发送广播，广播在通过回调接口 把消息传给 activity 。 service -> activity 2、startService 启动的服务 eventbus等第三方库 实现 activity - > service 。 // 如果不用第三方库 怎么实现？ 通过广播 发消息给activity 。 service -> activity 无版权 可以无限制使用！ all right reserved，powered by Gitbook该文件更新时间： 2020-12-18 09:05:23 "},"chinese/android基础/BroadcastReceiver.html":{"url":"chinese/android基础/BroadcastReceiver.html","title":"BroadcastReceiver 广播","keywords":"","body":"BroadcastReceiver 广播 Service 向activity中传递数据，更新UI时不太方便，此时可以使用广播来实现。 // 在 Service 中发送广播 Intent intent = new Intent(); intent.setAction( MyConfig.KEY_BROADCAST_ACTIONFLAG ); intent.putExtra(MyConfig.KEY_BROADCAST_MSG,msg); service.sendBroadcast(intent); // 定义广播，并传入一个接口，方便回调给activity public class BroadcastReceiver extends BroadcastReceiver { private MsgCallBack msgCallBack ; public BroadcastReceiver(MsgCallBack msgCallBack){ this.msgCallBack =msgCallBack; } @Override public void onReceive(Context context, Intent intent) { String msg = intent.getStringExtra( MyConfig.KEY_BROADCAST_MSG); msgCallBack.onGetMsg(msg); } } // activity中注册广播 IntentFilter intentFilter = new IntentFilter(); intentFilter.addAction(MyConfig.KEY_BROADCAST_ACTIONFLAG); broadcastReceiver = new BroadcastReceiver(msgCallBack); registerReceiver(broadcastReceiver, intentFilter); // 解绑广播 unregisterReceiver(broadcastReceiver); // 在回调接口中更新UI @Override public void onGetMsg(final String msg) { ((Activity)context).runOnUiThread(new Runnable() { @Override public void run() { showInfoTv.setText(msg); } }); } 无版权 可以无限制使用！ all right reserved，powered by Gitbook该文件更新时间： 2020-09-17 11:33:08 "},"chinese/android基础/动画详解.html":{"url":"chinese/android基础/动画详解.html","title":"动画详解","keywords":"","body":"多个动画之间，是可以组合在一起同时播放的。 AnimatorSet.playTogether(xxx) 动画类型 帧动画 、Drawable Animation、Frame Animation 容易OOM， 将一个完整的动画拆分成一张张单独的图片， 然后再将它们连贯起来进行播放，类似于动画片的工作原理。 补间动画 、View Animation、TweenedAnimation 补间动画 就是在两点之间插入渐变值来平滑过渡。 只能平移、缩放、旋转、透明度。不能拓展效果。 // 特点 1、XML声明文件存放在res/anim目录； 2、基于 Animation 和 AnimationSet 的类结构； 3、效果由四个因素决定：1）初始状态；2）结束状态；3）持续时间；4）Interpolator // 不足之处 1、只能够作用在View上。 2、补间动画机制是使用硬编码的方式来完成的， 功能限定死 淡入淡出(透明度)、缩放(大小)、平移(位置)、旋转四种， 基本上没有任何扩展性可言。 例如不能实现对View的背景色进行动态地改变。 3、它只是改变了View的显示效果而已，而不会真正去改变View的属性。 例如屏幕的左上角有一个按钮，补间动画将它移动到了屏幕的右下角，你点击这个按钮，点击事件不会触发， 因为实际上这个按钮还是停留在屏幕的左上角，只不过补间动画将这个按钮绘制到了屏幕的右下角而已。 （想真正移动某组件，需要在动画结束后添加代码实现。） 属性动画 、Property Animation 顾名思义，通过控制对象的属性，来实现动画效果。 可以拓展动画效果。可以作用于View和非View对象 。 // 特点 1、需要Android API level 11 （android3.0）以上使用。 2、XML文件存放在res/animator目录下； 3、基于Animator和AnimatorSet的类结构； // 优点 1、可以对所有的 Object对象的 任意属性进行操作。 2、动画效果不局限于 透明度、缩放 、平移 、旋转四种效果。 3、因为是一种不断地对值进行操作的机制，并将值赋值到指定对象的指定属性上， 所以不仅仅是一种视觉上的动画效果了。 例如我们通过属性动画来移动一个按钮，那么这个按钮就是真正的移动了， 而不再是仅仅在另外一个位置绘制了而已。 ValueAnimator 是对 值 的平滑过渡动画。你拿到不断变化的值后，你想干嘛就干嘛。 private void testValueAnimator(final View someView){ ValueAnimator valueAnimator = ValueAnimator.ofFloat(0f, 180f) ; valueAnimator.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() { @Override public void onAnimationUpdate(ValueAnimator valueAnimator) { // 拿到这个不断变化的值， 可以给 view的某个属性赋值，或其他 float value = (Float) valueAnimator.getAnimatedValue(); someView.setRotation(value); } }); } ObjectAnimator // ObjectAnimator extends ValueAnimator ObjectAnimator 继承了 ValueAnimator 的所有方法和特性， 并且还封装很多实用的方法，方便开发人员快速实现动画。 private void testObjectAnimator( View someView ){ ObjectAnimator objectAnimator = ObjectAnimator.ofFloat(someView ,\"rotation\" , 0 ,360 ,180 ,0 ); objectAnimator.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() { @Override public void onAnimationUpdate(ValueAnimator valueAnimator) { float value = (float) valueAnimator.getAnimatedValue(); Log.d(\"testTag\" , String.valueOf(value)) ; } }); objectAnimator.setDuration(2000).start(); } ViewPropertyAnimator 虽然属性动画给我们提供了 ValueAnimator 类和 ObjectAnimator 类， 在正常情况下，基本都能满足我们对动画操作的需求， 但ValueAnimator类和ObjectAnimator类本身并不是针对View对象的而设计的， 而我们在大多数情况下主要都还是对View进行动画操作的， 因此Google官方在Android 3.1系统中补充了 ViewPropertyAnimator 类， ViewPropertyAnimator 拥有更好的性能， 他解决了View在使用属性动画时步骤繁琐，效率低下的问题。 因为 提供了更简洁的链式调用设置多个属性动画，这些动画可以同时进行的。 多个属性动画是一次同时变化，只执行一次UI刷新。，也就是只调用一次invalidate, 而n个 ObjectAnimator 就会进行n次属性变化，就有n次 invalidate 。 ViewPropertyAnimator animator = view.animate() ; animator.setDuration(1000) ; animator.translationXBy(100f) ;//每次点击都会向右偏移 //animator.translationX(100f)//点击一次会向右偏移，再点击没效果 animator.start() ; 矢量动画 svg SVG（Scalable Vector Graphics）是Android 5.0中新加入的一个新特性 。 svg文件 使用xml格式定义 。 svg图片可以无限拉伸并不会变形和锯齿。 // svg在安卓上使用稍显复杂 ， 使用 Lottie 库 + AE 导出的json文件 可以更方便快捷地实现同样的效果 。 同时 Lottie 兼容 android 、ios、React Native 、web 。 https://github.com/airbnb/lottie-android 无版权 可以无限制使用！ all right reserved，powered by Gitbook该文件更新时间： 2021-01-07 08:48:19 "},"chinese/android基础/屏幕刷新机制.html":{"url":"chinese/android基础/屏幕刷新机制.html","title":"屏幕刷新机制","keywords":"","body":"屏幕刷新机制 CPU 计算屏幕数据、GPU 进一步处理和缓存、最后 display 再将缓存中（buffer）的屏幕数据显示出来。 屏幕每一帧的画面可以持续 16.6ms，当过了 16.6ms，底层就会发出一个屏幕刷新信号，而屏幕就会去显示下一帧的画面。 当屏幕刷新信号到的时候，屏幕就去将 CPU 计算的屏幕画面数据显示出来；同时 CPU 也接收到屏幕刷新信号，所以也开始去计算下一帧的屏幕画面数据。 在每一次屏幕刷新信号来的时候都会去切换这一帧的画面，这点我们是控制不了的，是底层的工作机制。 当用户不操作了、当前界面也没动画 时 ，CPU没有 下一帧画面数据需要计算，但是底层仍然会以固定的频率来切换每一帧的画面，只是它后面切换的每一帧画面都一样，所以给我们的感觉就是屏幕没刷新。 CPU 绘制视图树来计算下一帧画面数据的工作是在屏幕刷新信号来的时候才开始工作的，而当这个工作处理完毕后，也就是下一帧的画面数据已经全部计算完毕，也不会马上显示到屏幕上，而是会等下一个屏幕刷新信号来的时候再交由底层将计算完毕的屏幕画面数据显示出来。 https://www.jianshu.com/p/0d00cb85fdf3 无版权 可以无限制使用！ all right reserved，powered by Gitbook该文件更新时间： 2020-08-19 17:20:00 "},"chinese/android基础/WebView详解.html":{"url":"chinese/android基础/WebView详解.html","title":"WebView详解","keywords":"","body":"WebView详解 [ Android4.4, +∞) Chromium内核取代了Webkit内核。 [ Android5.0, +∞) WebView移植成了一个独立的apk，可以不依赖系统而独立存在和更新。 [ Android7.0, +∞) 如果用户手机里安装了 Chrome ， 系统优先选择 Chrome 为应用提供 WebView 渲染。 [ Android8.0, +∞) 默认开启WebView多进程模式，即WebView运行在独立的沙盒进程中。 无版权 可以无限制使用！ all right reserved，powered by Gitbook该文件更新时间： 2020-08-19 17:20:00 "},"chinese/android基础/图表绘制.html":{"url":"chinese/android基础/图表绘制.html","title":"图表绘制","keywords":"","body":"图表绘制 MPAndroidChart https://github.com/PhilJay/MPAndroidChart 是 Android 中一个较流行的第三方开源库 。 适用于 Android 2.2 ( API 8 ) 及以上。 本次讲解基于 v3.0.3 版本。 MPAndroidChart 的动画机制只在Android API 11 及以上有效 。 无版权 可以无限制使用！ all right reserved，powered by Gitbook该文件更新时间： 2020-08-19 17:20:00 "},"chinese/android基础/沉浸式.html":{"url":"chinese/android基础/沉浸式.html","title":"沉浸式","keywords":"","body":"沉浸式 Android 至4.4才开始支持沉浸式状态栏 。 所谓的 沉浸式 就是 可以设置手机状态栏的背景 。 实际的效果其实就是透明的状态栏，然后在状态栏的位置显示我们自定义的颜色 或图片 。 这里 有一个比较好用的第三方库 ImmersionBar 无版权 可以无限制使用！ all right reserved，powered by Gitbook该文件更新时间： 2020-08-19 17:20:00 "},"chinese/android基础/svg绘制不规则图形.html":{"url":"chinese/android基础/svg绘制不规则图形.html","title":"svg绘制不规则图形","keywords":"","body":"svg 、vector SVG Scalable Vector Graphics 、矢量图 在各种设备上能实现自然伸缩或扩展而不影响图片质量。 参考 https://github.com/zhangjundi/taiwanDemo 1、加载、解析 svg文件 ，获得 path 数据 2、将path数据转换为 Path 对象。谷歌官方有现成的工具类 PathParser.java。 3、将解析出来的所有path绘制出来 4、判断点击点是否在当前path范围内。 public boolean isInArea(Path mPath ,float x, float y){ RectF r=new RectF(); mPath.computeBounds(r, true); Region re=new Region(); re.setPath(mPath, new Region((int)r.left,(int)r.top,(int)r.right,(int)r.bottom)); return re.contains((int)x, (int)y); } vector vector 就是Android中的矢量图使用方案。 Android 5.0发布的时候，Vector只支持Android 5.0+。 不过自从AppCompat 23.2之后，Google做了兼容处理 ， 只需要引用com.android.support:appcompat-v7:23.2.0以上的版本就 适用于Android 2.1以上的所有系统 。 vector标签属性 意义 width 图形宽度 height 图形高度 viewportHeight 画布高度 viewportWidth 画布宽度 group 对Path进行分组 path 对应一个Pathname // path名字fillAlpha//填充透明度fillColor //填充颜色strokeColor//线条颜色 pathData //path指令strokeWidth//线条宽度 Android基于vector文件绘制不规则图形的例子 无版权 可以无限制使用！ all right reserved，powered by Gitbook该文件更新时间： 2020-08-26 09:32:13 "},"chinese/android基础/Glide图片三级缓存.html":{"url":"chinese/android基础/Glide图片三级缓存.html","title":"Glide图片三级缓存","keywords":"","body":"Glide图片三级缓存 Glide 特点 https://github.com/bumptech/glide 1、Glide.with(xxx)方法 接受 Context、Activity 、 Fragment 。 建议使用后面两个。因为图片加载会和Activity 、Fragment的生命周期保持一致。 2、支持加载 gif 格式。 缓存类型 缓存类型 说明 原图 原始图片 处理图 经过压缩和变形等处理后的图片 缓存存储位置 可以设置 最大内存缓存空间大小、最大磁盘缓存空间大小、 缓存失效时间 。 存储位置 | 缓存策略 | 采用算法 -|-|- 1、内存缓存| 缓存处理图|LruCache + 弱引用 2、磁盘缓存|1、只缓存处理图 2、 只缓存原图 3、缓存原图和处理图 4、什么都不缓存| 3、网络资源|| LruCache 算法 Least Recently Used Cache /近期最少使用 。核心思想是当缓存满时，会优先淘汰那些近期最少使用的缓存对象。 Glide 简单使用 RequestOptions requestOptions = new RequestOptions() .placeholder(R.mipmap.icon_us) //.diskCacheStrategy(DiskCacheStrategy.NONE) //.skipMemoryCache(true) // 缓存失效策略 ，key 不一样 缓存就会失效 .apply(RequestOptions.signatureOf(new ObjectKey(getSignatureKey()))) .error(R.mipmap.icon_us); Glide.with(activity) // 根据路径、File 加载 .load(filePath) .apply(requestOptions) .into(userImg); private long getSignatureKey() { ///long key = System.currentTimeMillis() / INVALID_TIME long key = System.currentTimeMillis() ; return key ; } // 当通过get访问接口 ，直接返回图片流的时候。 可以直接加载这个接口也可以显示。 // 不需要 去 加载接口返回的值。 无版权 可以无限制使用！ all right reserved，powered by Gitbook该文件更新时间： 2020-08-26 09:51:56 "},"chinese/android基础/相机模块.html":{"url":"chinese/android基础/相机模块.html","title":"相机模块","keywords":"","body":"相机模块 从Android 5.0(21)开始， android.hardware.Camera 被废弃 ，启用 android.hardware.Camera2 。 Android相机兼容性问题非常大,如果只是拍照,尽量调用系统相机,如果需要预览和拿视频流, 可以基于某些第三方库开发。 natario1 CameraView     谷歌非官方 cameraview     基于谷歌非官方 cameraview     camerakit-android 参考资料 拍出来的照片旋转了 获取照片的角度值，然后再用矩阵纠正过来。 拍照后闪退 部分机型对自家相机做了优化，会销毁我们的activity。 根据调试情况，在onSaveInstanceState()中保存对应状态即可。 图片无法显示 图片太大导致OOM ，对图片进行压缩即可。 自拍镜像 开启前置摄像头后，预览的画面和拍照后的画面是左右相反的。进行图片翻转即可。 预览画面 贴图 相机 + opengl es 方案。 无版权 可以无限制使用！ all right reserved，powered by Gitbook该文件更新时间： 2020-08-19 17:20:00 "},"chinese/android基础/地图模块.html":{"url":"chinese/android基础/地图模块.html","title":"地图模块","keywords":"","body":"地图模块 坐标类型 // 世界标准地理坐标 、WGS-84 国际标准，从国际标准GPS设备中获取到的坐标都是 WGS84 。 WGS－84 坐标系是美国建立的GSP原始坐标系； // 中国国测局地理坐标 、 GCJ-02 、 火星坐标 中国标准，国家测绘局 发布的坐标系 。在中国，必须至少使用GCJ02对地图进行首次加密。 火星坐标系统 ，就是中国设计的一个加密插件，是对真实地图进行人为的加偏处理，按照一定的加偏算法，将真实的坐标加密成虚假的坐标。 加偏处理不是线性的加偏，所以各地的偏移情况都会有所不同。这样一来地图的坐标就与实地的坐标不相符了，于是大家把这种坐标戏称为\"火星坐标\" 。 // CGCS2000 坐标系 China Geodetic Coordinate System 2000 ,是我国建立的大地坐标系，类似于WGS－84坐标系，是原始坐标系。 // 搜狗坐标系 由GCJ-02进行进一步的偏移算法得到。 // 百度地理坐标 、 BD-09 百度标准， 在GCJ02 的基础上进行二次加密。 各个地图软甲采用的坐标系 在中国，任何一个地图产品 至少使用GCJ-02进行首次加密，不允许直接使用WGS-84坐标下的地理数据，同时任何坐标系均不可转换为WGS-84坐标。 网上有人总结反推的一些转换接口，都是有偏差的。对精度非常严格的使用场景，要慎重使用。 基于 GCJ-02 转 WGS-84 的转换结果都有偏差。 基于 WGS-84 转 GCJ-02 的转换结果没有偏差。 // 百度地图 1、境内、包括港澳台 : BD09 。 2、境外 : WGS-84 。 // 高德地图: 1、境内：GCJ-02 2、境外：暂不支持 // 腾讯地图 1、境内：GCJ-02 2、境外：暂不支持 // google地图 1、境内：GCJ-02 , 数据来源于高德，两者互通。 2、境外：WGS-84 。 // bing地图 ,微软的 全球统一：WGS-84 。Bing地图图源较老 。 // 天地图 全球统一 ：CGCS2000 地图坐标互相转换 https://github.com/hnyer/JZLocationConverter-for-Android 高德地图 根据指定经纬度显示和导航 String.format(Locale.getDefault(), \"https://m.amap.com/share/index/lnglat=%f,%f\" , xx.longitude ,xx.latitude) ; 隐藏左下角Logo // 高德地图隐藏左下角Logo UiSettings settings = aMap.getUiSettings(); settings.setLogoBottomMargin(-50);//高德logo图标无法移除 ，但是可以通过设置偏移的位置 来隐藏它 地理围栏 https://lbs.amap.com/api/android-location-sdk/guide/additional-func/local-geofence/ 加载谷歌瓦片地图数据 http://mt0.google.cn/vt/lyrs=y&hl=en&gl=en&src=app&x=6678&y=3558&z=13&s= // ok http://mt0.google.cn/vt/lyrs=y&x=6678&y=3558&z=13http://mt0.google.cn/vt/lyrs=y@110&x=6678&y=3558&z=13 格式 http://mt0.google.cn/vt/lyrs={lyrs}&hl=en&gl=en&src=app&x=%d&y=%d&z=%d&s= http://mt0.google.cn/vt/lyrs={lyrs}&x=%d&y=%d&z=%d // 一般用这个就可以了，不需要很多其他参数 // 服务器地址 ，可选，效果都是一样的 http://mt0.google.cn http://mt1.google.cn http://mt2.google.cn http://mt3.google.cn // x 列号 、 y 行号 、 z zoom级别 // hl :en 、 zh-CN // gl : en 、cn // src : 标记来自哪里的请求？ // s : 作用未知，可用可不用。随便填 。 // lyrs m：路线图 ​t：地形图 ​s：卫星图 ​p：带标签的地形图 ​y：带标签的卫星图 ​h：标签层（路名、地名等） 我看到其他有些后面跟了个@参数，暂时不知道什么作用。lyrs=m@167000000 。不用貌似也没有问题。 经过测试发现 谷歌中国，高德 都采用了 火星坐标系。不过谷歌中国同时也提供了 wgs84坐标系方式的地图，只要修改一个参数即可， 将gl=cn去掉，则下载的地图 就变成了 wgs84,否则 则是火星坐标系。 高德地图 加载 .mbtiles 文件 mbtiles 文件其实就是一个 sqllite 数据库文件。此处给出我写的一个demo。关键点在于 y 坐标的转换。 https://gitee.com/Aivin_CodeShare/android_tool_code/raw/master/MbTilesDataTool.java 如果 高德要加载国外地图，需要 Mbtiles 是个有偏移过的 数据库。 如何编辑和生成 mbtiles 文件暂时没有研究。暂由客户自己提供。 其他 禁飞区 大疆禁飞区查询 https://www.dji.com/cn/flysafe/geo-map 优凯限飞区查询与下载 http://xianfei.u-care.net.cn/#/downLoad 在线导入kml查看效果图 http://geojson.io/#map=2/20.0/0.0 Java主要用dom4j包解析kml文件。 无版权 可以无限制使用！ all right reserved，powered by Gitbook该文件更新时间： 2020-12-30 09:19:55 "},"chinese/android基础/屏幕适配.html":{"url":"chinese/android基础/屏幕适配.html","title":"屏幕适配","keywords":"","body":"屏幕适配 术语 术语 解释 屏幕尺寸 屏幕的对角线的长度 屏幕分辨率 屏幕的宽和高的像素数 density 屏幕密度，等于dpi/160 。 表示 每英寸有多少个显示点 dpi 像素密度 ， dots per inch px 每一个光点就是一个像素。 dp , dip device independent pixels ， 基于屏幕密度抽象长度单位，在每英寸160点的显示器上，1dp = 1px。 ppi pixels per inch 屏幕尺寸、屏幕分辨率、像素密度的关系 为什么规定160dpi规格的显示器上，1dp = 1px px=dp*（dpi/160） Google的官方文档中给出解释，因为第一款Android设备（HTC的T-Mobile G1）是属于160dpi的。于是就成为标准了。 常用公式 px = density * dp // 例如 density=2时 ，1dp =2px density = dpi / 160 // 例如 dpi=320时 ， density =2 px = (dpi / 160) * dp // 例如 dpi=320时 ， 1dp = 2px 引起适配问题的根源 1、屏幕密度不一样 density 。 举例： A 、B 手机的分辨率都是 1080 *1920 ， 但是 A的 密度为 160 ， B的密度为 320 。 此时你设置一条线的长度 为 1080dp ，在A手机上 刚好占满 长度， 但是在 B手机中只能占据一半 。 2、设备的长宽比例不一样。 假如 设计师的 基于 4：3 比例的屏幕设计的效果图 ，无论如何不可能跟 在 16：9上的效果一样的。 采用的适配方案一般是根据图片宽度 跟比等比例决定图片的高度。 适配思路 因为目前设备的长宽比是不一样的，所以一套设计图在不同的设备上的效果不可能是一模一样的。一般遵循以下原则即可。 1、可以上下滑动的界面，保证宽的纬度与设计图一致 。 2、不支持上下滑动的界面 ，保证高的纬度与设计图一致 。 //为了满足“显示比例和设计的长宽比例一致”，某些地方只能做留白处理。 3、 多使用 wrapcontent matchparent 以及线性布局的权重 4、多套xml 布局 方案 // 感觉很繁琐，基本很难采用。 布局限定符。 业界 推荐的 适配方案 1、今日头条的 代码 更改 屏幕密度 density 的方案。 缺点就是非常依赖设计图，假如引入的第三方的一些控件 跟设计图相差较大，效果就不太好。 2、多套 diments.xml 方案。将市面上主流的手机 收集起来，生成 values-sw320dp 等 values-xxx 的文件夹 ， 每个文件夹里 有同名文件 diments.xml , xxdp ,xx的值各不相同。 缺点是会增加 xml 文件数量 增加apk 大小。 其他 //以 设计师给定的 图片屏幕尺寸作为标准 ， 返回当前设备下的触摸点坐标 public static int getValues_x(Context context, int value_x){ return (int) ((float) value_x / 720 * MyDeviceInforHelper .getWindowWidth(context)); } 无版权 可以无限制使用！ all right reserved，powered by Gitbook该文件更新时间： 2020-10-15 17:28:54 "},"chinese/android基础/sdk开发.html":{"url":"chinese/android基础/sdk开发.html","title":"sdk开发","keywords":"","body":"SDK开发 将一些业务逻辑独立出来，打包成jar、so、aar，暴露一些APIs给外部调用，也可以称为SDK。 SDK 不同于普通应用,不能频繁的进行更新,以免让开发者觉得 SDK 不稳定或者让开发者频繁的集成 。 为了安全起见,数据加密类、模块算法类都都应该采用NDK开发 。 sdk加密方案 方案名字 缺点 优点 代码混淆 1、有些类不能混淆（例如工具类，自定义控件等，如果被混淆了用户就不方便调用），所以对代码架构要求比较高。2、混淆后的代码虽然不易识别了，但是仔细分析还是能看懂的。 修改class的字段 某些字段对运行没有影响，但是能导致别人无法反编译。 自定义类加载器ClassLoader ClassLoader容易被攻破 jvmti 不适用于Android平台？（我暂时还未测试成功） SDK 版本号命名及修改原则 SDK版本号命名和我们以往的命名规则并无太大不同,通由4部分组成,格式为: V主版本号_子版本号_阶段版本号_日期版本号_希腊字母版本号 比如：V1_1_2_161209_beta. 希腊字母版本号说明 1、Alpha版:内部测试版。此版本表示该软件在该阶段主要是以实现功能为主,Bug相对较多,需要继续修改,通常只在内部流通流通而不对外开放。 2、Beta版:外部测试版。该版本相对Alpha已经有了很大的改进,不存在严重的Bug,但还是存在一些缺陷,需要进一步的测试以检查和消除Bug。 3、RC版: 该版本已经相当成熟,不存在导致错误的Bug，与正式版相差无几。 4、Release版:该版本意味着”最终版本”,是最终交付用户或者公开发布的版本,也称为标准版。在发布的时候回以符合R来代替Release单词。 版本号修改规则 1、 主版本号变化:当功能模块有较大的变化或者整体架构发生变化 2、子版本号变化:当功能有一定变化 3、阶段版本号变化:一般是Bug修复或者较小的变动,根据反馈,需要经常发布修订版本. 4、日期版本号(161209):用于记录修改项目的当前日期,每天对项目的修改都要更改日期版本号. 5、希腊字母版本号:此版本号用于标注当前软件处于那个开发阶段,当软件进入到另一个阶段是需要修改. API版本管理 原则上SDK API一旦公开发布后其状态应为不可变。 1、对于特殊情况下API的变更,需要遵守”开闭原则” 2、在需要废除某些方法时,需要在正式版发版前使用 @deprecated 标识。并给出替代方案和开始废弃的 SDK版本号。 经验之谈 原文 http://blog.csdn.net/dd864140130 有删减。 //SDK实现目标 1、简洁易用 SDK不应该对宿主应用有过多的代码侵入,也不应该有复杂频繁的接入工作。 当我们需要使用该 SD K的服务时,通过一行代码便可启用 Ad.init(this,params) 2、稳定 ① SDK的API一旦确定,如无非常严重情况不可更改。 ②、必须确保SDK自身运行的稳定,并且保证接入方不会因为我们的SDK产生不稳定。 ③、不能频繁更新迭代。防止增加用户负担。 //SDK整体架构设计 模块化开发 根据单一职责将系统拆分为不同的小模块，每个模块保持相对独立。 模块之间通过协议或接口通信，以减少相互之间的依赖耦合。 为了安全起见, 核心逻辑应该采用NDK开发。 //API版本管理 原则上SDK API一旦公开发布后，应为不可变。 对于特殊情况下API的变更,需要遵守”开闭原则”: 1、在需要调整SDK API时,优先选择添加新方法,而不是在原方法上修改 。 2、在需要废除某些方法时,需要在正式版发版前使用 @deprecated 标识,并标明开始废弃的版本。 sdk开发-Module支持c++ 1、按照正常流程创建一个支持c++的项目。 此时 CMakeLists.txt 文件在 app 这个项目里面。 2、新建一个module ，并添加到app中。 3、将 CMakeLists.txt 剪切到 module对应的 目录下。 4、 同理 ，以下代码也剪切到 module对应的文件中去。 externalNativeBuild { cmake { path \"CMakeLists.txt\" } } externalNativeBuild { cmake { cppFlags \"-std=c++11 -frtti -fexceptions\" } } 5、刷新工程即可。 无版权 可以无限制使用！ all right reserved，powered by Gitbook该文件更新时间： 2020-09-24 11:36:25 "},"chinese/android基础/APP优化.html":{"url":"chinese/android基础/APP优化.html","title":"APP优化","keywords":"","body":"性能优化 启动优化 // 冷启动 、热启动 当启动应用时，后台已有该应用的进程， 所以在已有进程的情况下，这种启动会从已有的进程中来启动应用，这个方式叫热启动。 按back键、home键，应用虽然会退出，但是该应用的进程是依然会保留在后台。 因为一个应用从新进程的创建到进程的销毁，Application只会初始化一次， 所以热启动的过程只需要创建和初始化一个 MainActivity 就行了，而不必创建和初始化 Application 。 冷启动就是从0开始启动 App 。 // 冷启动优化 1、Application中对 第三方的SDK进行异步或延时初始化 。 2、做一个闪屏界面。在展示的这段时间里，去加载下一页需要的资源。 // 热启动优化 在app 退出时 不要finish ，而是 moveTaskToBack ，即模拟 HOME按键的事件 。 UI流畅度优化 、界面卡顿 排查及优化 Skipped 60 frames! The application may be doing too much work on its main thread. 在大部分Android平台的设备上，Android系统是 16ms (1000 /60 = 16.67 ) 刷新一次，也就是一秒钟60帧。 要达到这种刷新速度就要求在ui线程中处理的任务时间必须要小于16ms，如果ui线程中处理时间长， 就会导致跳过帧的渲染，也就是导致界面看起来不流畅，卡顿。 卡顿引起的具体原因 1、cpu 占用过高，容易卡顿 。一般是 后台线程处理的东西太繁忙。 注意逻辑的优化，线程不要空跑。 2、主线程 绘制时间过长。 UI的层级别太大 ，不要冗余嵌套 卡顿检测 Choreographer 使用 Androidstudio 自带的 工具，和一些第三方的监控工具 例如 BlockCanary 就差不多了。 // FPS ( Frames Per Second ) 即 Frame Rate，单位 fps，是指 gpu 生成帧的速率 ，Android中更帧率相关的类是 SurfaceFlinger 。 SurfaceFlinger (SurfaceFlinger.h) 是Android的一个 native进程 ， 接受多个来源的图形显示数据，将他们合成，然后发送到显示设备。 // VSync (Synchronization ) ,垂直同步 信号。 Android系统每隔16ms发出 VSync 信号，触发对UI进行渲染， Android 4.1 开始引入 VSync 机制，用来同步渲染， 让 UI 和 SurfaceFlinger 可以按硬件产生的 VSync 节奏进行工作。 WkHeartBeatTool wkHeartBeatTool = new WkHeartBeatTool(); wkHeartBeatTool.startTheBeatAction(new HeartBeatTask() { @Override public void run() { // 一秒钟统计一次 ，如果小于 60 ，就说明掉帧了 WkLogTool.showLog(\"fps====\"+count); count= 0 ; } } ,1000); // Choreographer 编舞者 ，统计一秒内 count 的数量 ， Choreographer.getInstance() .postFrameCallback( new Choreographer.FrameCallback() { // frameTimeNanos: The time in nanoseconds when the frame started being rendered, @Override public void doFrame(long frameTimeNanos) { count++ ; Choreographer.getInstance().postFrameCallback(this); } }); 排查 线上App ,用户反馈卡顿的问题 1、记录用户的使用机型和使用场景。例如操作流程、网络环境 2、加入卡顿检测机制，有第三方的 SDK 也可以自己写 ， 将卡顿时的堆栈信息记录并回传，定位分析。 内存优化 1、别频繁GC 2、控制好对象的引用，防止对象一直无法释放。 apk瘦身 最主要的是 从图片资源 、第三方库 和 .so 方面考虑 。 1、 用lint检查， 删除无用资源 2、 用tinypng等压缩图片。 3、用webp格式图片 4、开启代码混淆 5、删除冗余代码。 稳定性 优化 稳定的纬度： 1、崩溃角度 非常重要，出现闪退现象会导致用户体验非常差。 容错机制，发生异常尽量不要闪退，而是给出提示。 不要随意使用try catch去隐藏问题：而应该从源头 了解崩溃的本质原因，保证后面的运行流程。 2、性能稳定 启动速度、流畅卡顿程度、内存占用、耗电量、界面绘制速度、网络流量、 保证业务功能可用。ANR 响应超时、 能持续运行多长时间 3、业务可用性纬度。 保证APP主流程 和核心路径的稳定可用性。确保核心业务高可用。因为核心业务覆盖的人群最多。 其他方面只有经常用的人才有可能触发。 保证业务可用的高效可用，性能不能相差起伏太大。 解决方案： 1、预防为主、监控修复为辅 ①、开发阶段 ，采用成熟稳定方案、加强编码能力； 对APP的 cpu、内存、进程线程数、网络流量、耗电量、log记录、启动页耗时 等信息记录和分析 ②测试阶段：加强机型覆盖测试、压力测试、特殊场景测试(例如无网络、故意下发错乱数据等)； 从用户角度入手，尽量模拟真实使用场景、测试验证。不要从开发者角度进行测试。 线下大规模覆盖测试、发现问题 解决问题； ③发布阶段：进行灰度发布、多轮发布 ； 发布前多测试、捕获异常上传并分析 、发新包修复或者热修复。 如果新发布的功能出现BUG，可以通过远程开关进行关闭功能模块，不让该功能显示。 ④ 运维阶段： 版本回退策略、热修复、发布新版本 线上定位问题 定位机型。 发生崩溃异常时，需要远程上报相关信息，包括 报错信息、机型、系统版本、APP版本、渠道等。 监控工具： 1、例如Android 自带的 monkey 2、 腾讯的 Bugly 3、阿里的 mobileperf 单元测试 // 黑盒测试 一般而言，都是自己或者测试做做黑盒测试，模仿用户使用场景 使用即可。 我问过很多人，他们基本都是这样测试后就上线了。 // 白盒测试 1、对于一些 要求严谨的大型 app ，例如 微信 支付宝，肯定是要做白盒测试了。 黑盒测试无法完全覆盖，一旦出错，损失无法承受 ，当然，这种级别的测试，都有专门的测试人员。 2、有一些大型的app ,编译时间比较长，或者路径比较深。采用手动点击试验看效果的方法，会比较浪费时间。 为了免去编译安装的等待时间，要引入白盒测试，缩短自测的时间。 // TDD ( Test-Driven Development ) 测试驱动开发 单元测试 JUnit4 方案 Androidstudio 自带。 测试运行在本地开发环境的Java虚拟机上，无需连接Android设备或模拟器。 因此，无法获得Android相关的API，只能测试只使用Java API的一些功能。 @Test 表示此方法为测试方法 @Before 在每个测试方法前执行，可做初始化操作 @After 在每个测试方法后执行，可做释放资源操作 @Ignore 忽略的测试方法 assertEquals 断言传入的预期值与实际值是相等的 assertArrayEquals 断言传入的预期数组与实际数组是相等的 assertNull 断言传入的对象是为空 assertTrue 断言条件为真 assertSame 断言两个对象引用同一个对象，相当于“==” assertThat 断言实际值是否满足指定的条件 @Ignore(\"等会再测\") @Test public void getAppVersion(){ } @Test public void valueAdd() { MyDeviceTool tool = new MyDeviceTool() ; int sum = tool.valueAdd(10 ,5); assertEquals(5 ,sum); } 单元测试 Instrumentation 方案 需要将整个项目打包成apk，上传到模拟器或真机上，就跟运行了一次app 。 最近的文章(20201222)讲到 Androidstudio +Instrumentation 比较少， Androidstudio3.4.1 默认生成的代码中也没有 Instrumentation 相关配置， 是被替代了吗，暂时去看看其他的方案。 单元测试 robolectric 方案 With Robolectric, your tests run in a simulated Android environment inside a JVM, without the overhead of an emulator. http://robolectric.org https://github.com/robolectric/robolectric // 配置 testImplementation 'junit:junit:4.12' testImplementation 'org.robolectric:robolectric:4.1' testImplementation 'org.robolectric:shadows-multidex:4.1' testOptions { unitTests { includeAndroidResources = true } } // 会提示下载文件失败，你可以手动下载一下。 Downloading: org/robolectric/android-all/9-robolectric-4913185-2/android-all-9-robolectric-4913185-2.jar from repository sonatype at https://oss.sonatype.org/content/groups/public/ Transferring 118099K from sonatype 下载地址就是按提示拼接一下,将下载好的文件放到 android-all-9-robolectric-4913185-2.jar.tmp 目录下 ， 用 everything 全局搜索一下。 ----> https://oss.sonatype.org/content/groups/public/org/robolectric/android-all/9-robolectric-4913185-2/android-all-9-robolectric-4913185-2.jar // 简单示范 @RunWith(RobolectricTestRunner.class) @Config( sdk = 28) public class TestShow { @Test public void myTest(){ Context context = RuntimeEnvironment.application.getApplicationContext() ; MyDeviceTool myDeviceTool = new MyDeviceTool(); String packageName =myDeviceTool.getPackageName(context) ; WkLogTool.showLog(\"packageName=\"+packageName); } } 我用的较少，一般只是用来测试一下逻辑。 无版权 可以无限制使用！ all right reserved，powered by Gitbook该文件更新时间： 2020-12-30 15:47:36 "},"chinese/android基础/权限配置.html":{"url":"chinese/android基础/权限配置.html","title":"权限配置","keywords":"","body":"权限配置 动态权限申请第三方辅助工具 一般权限 这类权限一般不涉及用户隐私，是不需要用户进行授权的，比如手机震动、访问网络等 普通权限 含义 ACCESS_LOCATION_EXTRA_COMMANDS 访问额外的位置提供命令 ACCESS_NETWORK_STATE 访问有关GSM网络信息 ACCESS_NOTIFICATION_POLICY ？ ACCESS_WIFI_STATE 访问Wi-Fi网络状态信息 BLUETOOTH 连接到已配对的蓝牙设备 BLUETOOTH_ADMIN 允许程序发现和配对蓝牙设备 BROADCAST_STICKY 允许一个程序广播常用intents CHANGE_NETWORK_STATE 允许程序改变网络连接状态 CHANGE_WIFI_MULTICAST_STATE ？ CHANGE_WIFI_STATE 允许程序改变Wi-Fi连接状态 DISABLE_KEYGUARD 允许程序禁用键盘锁 EXPAND_STATUS_BAR 允许一个程序扩展收缩在状态栏 GET_PACKAGE_SIZE 允许一个程序获取任何package占用空间容量 INSTALL_SHORTCUT ？ INTERNET 允许程序打开网络套接字 KILL_BACKGROUND_PROCESSES ？ MODIFY_AUDIO_SETTINGS 　允许程序修改全局音频设置 NFC ？ READ_SYNC_SETTINGS 允许程序读取同步设置 READ_SYNC_STATS 　允许程序读取同步状态 RECEIVE_BOOT_COMPLETED 允许程序接收到 REORDER_TASKS 允许程序改变Z轴排列任务 REQUEST_INSTALL_PACKAGES ？ SET_ALARM ？ SET_TIME_ZONE 允许程序设置时间区域 SET_WALLPAPER 允许程序设置壁纸 SET_WALLPAPER_HINTS 允许程序设置壁纸hits TRANSMIT_IR ？ UNINSTALL_SHORTCUT ？ USE_FINGERPRINT ？ VIBRATE 允许访问振动设备 WAKE_LOCK ？ WRITE_SYNC_SETTINGS 允许程序写入同步设置 危险权限 1、需要用户授权。必须在Manifest中申明，否则申请时不提示用户，直接回调开发者权限会被拒绝。 2、同一个权限组的任何一个权限被授权了，这个权限组的其他权限也自动被授权。 3、申请某一个权限的时候系统弹出的Dialog是对整个权限组的说明，而不是单个权限。 4、Android 6.0开始需要动态权限申请 危险权限 含义 READ_CALENDAR WRITE_CALENDAR 日历 CAMERA 相机 READ_CONTACTS WRITE_CONTACTS GET_ACCOUNTS 联系人 ACCESS_FINE_LOCATION ACCESS_COARSE_LOCATION 位置 RECORD_AUDIO 麦克风 READ_PHONE_STATE CALL_PHONE READ_CALL_LOG WRITE_CALL_LOG ADD_VOICEMAIL USE_SIP PROCESS_OUTGOING_CALLS 手机 BODY_SENSORS 传感器 SEND_SMS RECEIVE_SMS READ_SMS RECEIVE_WAP_PUSH RECEIVE_MMS 短信 READ_EXTERNAL_STORAGE WRITE_EXTERNAL_STORAGE 存储 常用权限配置 无版权 可以无限制使用！ all right reserved，powered by Gitbook该文件更新时间： 2020-12-30 17:25:22 "},"chinese/android基础/App发布.html":{"url":"chinese/android基础/App发布.html","title":"App发布","keywords":"","body":"代码混淆 混淆规则 guardsquare androidstudio 混淆配置 // build.gradle 文件下 (这是系统默认生成的，可以修改) 1、导入 xxx\\tools\\proguard\\proguard-android.txt 。 这里面是一些比较常规的不能被混淆的代码规则。 2、导入当前工程里面的 proguard-rules.pro 。这里是一些自定义的混淆规则。 proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.pro' //是否开启混淆 true or false minifyEnabled true 不能混淆的内容 混淆了这些内容，会导致出错。 1、 自定义控件 2、 枚举 3、 第三方库中的类 （作者一般会标明） 4、 运用了反射的类 5、 使用了 Gson 之类的工具的实体类 6、 WebView 的 JS 的接口方法 7、 Parcelable 的子类和 Creator 静态成员变量不混淆 设置 不参与混淆 # 保持该包下的类名 (子包下的会被混淆) -keep class cn.wk.test.* # 把本包和所含子包下的类名都保持 -keep class cn.wk.test.** # 保持类名和里面的内容不被混淆 -keep class com.example.bean.** { *; } 自用的 aar 混淆 # 代码混淆压缩比，在0~7之间，默认为5,一般不下需要修改 -optimizationpasses 5 # 混淆时不使用大小写混合，混淆后的类名为小写 -dontusemixedcaseclassnames # 不混淆第三方引用的库 不忽略library里面非public修饰的类 ？？？ -dontskipnonpubliclibraryclasses # 指定不忽略非public类里面的成员和方法 -dontskipnonpubliclibraryclassmembers # 不做预检验， 去掉这一步可以加快混淆速度 -dontpreverify # 把所有信息都输出，而不仅仅是输出出错信息 -verbose #apk 包内所有 class 的内部结构 ?? -dump class_files.txt # 列出了没有被混淆的类和成员 -printseeds seeds.txt #列出从 apk 中删除的代码 -printusage unused.txt #混淆前后的映射 -printmapping mapping.txt # 混淆时所采用的算法 ，后面的参数是一个过滤器 # 这个过滤器是谷歌推荐的算法，一般不改变 -optimizations !code/simplification/artithmetic,!field/*,!class/merging/* #保留Annotation不混淆 -keepattributes *Annotation*,InnerClasses # 避免混淆泛型 -keepattributes Signature # 保留异常 -keepattributes Exceptions # 抛出异常时保留代码行号 -keepattributes SourceFile,LineNumberTable # 不打印指定类的警告信息 -ignorewarnings #==================================【项目配置】================================== # 保留所有的本地native方法不被混淆 -keepclasseswithmembernames class * { native ; } # 保留了继承自Activity、Application (四大组件等)这些类的子类 -keep public class * extends android.app.Activity -keep public class * extends android.app.Application -keep public class * extends android.app.Service -keep public class * extends android.content.BroadcastReceiver -keep public class * extends android.content.ContentProvider -keep public class * extends android.app.backup.BackupAgentHelper -keep public class * extends android.preference.Preference -keep public class * extends android.view.View -keep public class com.android.vending.licensing.ILicensingService -keep public class * extends android.database.sqlite.SQLiteOpenHelper{*;} # 如果有引用android-support-v4.jar包，可以添加下面这行 -keep public class com.null.test.ui.fragment.** {*;} #如果引用了v4或者v7包 -dontwarn android.support.** # 保留Activity中的方法参数是view的方法 -keepclassmembers class * extends android.app.Activity { public void * (android.view.View); } # 枚举类不能被混淆 -keepclassmembers enum * { public static **[] values(); public static ** valueOf(java.lang.String); } # 不混淆反射 -keepattributes EnclosingMethod # 保留自定义控件(继承自View)不能被混淆 -keep public class * extends android.view.View { public (android.content.Context); public (android.content.Context, android.util.AttributeSet); public (android.content.Context, android.util.AttributeSet, int); public void set*(***); *** get* (); } # 保留Parcelable序列化的类不能被混淆 -keep class * implements android.os.Parcelable{ public static final android.os.Parcelable$Creator *; } # 保留Serializable 序列化的类不被混淆 -keepclassmembers class * implements java.io.Serializable { static final long serialVersionUID; private static final java.io.ObjectStreamField[] serialPersistentFields; !static !transient ; private void writeObject(java.io.ObjectOutputStream); private void readObject(java.io.ObjectInputStream); java.lang.Object writeReplace(); java.lang.Object readResolve(); } # 对R文件下的所有类及其方法，都不能被混淆 -keepclassmembers class **.R$* { *; } # 对于带有回调函数onXXEvent的，不能混淆 -keepclassmembers class * { void *(**On*Event); } #==================================【根据自己的项目（自己写的代码），配置需要 忽略混淆的类================================== -keep class org.litepal.** { *; } -keep class com.walkera.wktools.** { *; } #==================================【根据自己的项目（自己引用的第三方jar），配置需要 忽略混淆的类================================== # ant.jar #-libraryjars libs/ant.jar -keep class org.apache.** { *; } # ftp4j.jar #-libraryjars ./libs/ftp4j-1.7.2.jar -keep class it.sauronsoftware.** { *; } # guava.jar #-libraryjars ./libs/guava-17.0.jar -keep class com.google.** { *; } # netty.jar #-libraryjars ./libs/netty-all-4.0.25.Final.jar -keep class io.netty.** { *; } # nineoldandroids.jar #-libraryjars ./libs/nineoldandroids-2.4.0.jar -keep class com.nineoldandroids.** { *; } 渠道包 为什么需要打渠道包 1、为了区分用户从哪个 渠道下载的，比如官网、应用宝、华为、小米等商店， 因为一般是分渠道进行推广的，这样就能统计出每个渠道的推广效果进而进行调整。 2、可以针对每个不同渠道的 APP配置不同的 APP名字 和APP logo、包名。 例如 搜狗输入法小米版、搜狗输入法华为版。 多渠道 打包 方案 目前公司APP集中于官网发布，暂时用不上。需要的时候再来更新具体使用方法。 1、gradle 官方方案。 2、其他一些第三方的插件，例如美团就有一个 Walle（瓦力）https://github.com/Meituan-Dianping/walle Sqlite 数据库升级 public class XXXHelper extends SQLiteOpenHelper { /** * 1、在第一次打开数据库的时候才会走 * 2、在清除数据之后再次运行-->打开数据库，这个方法会走 * 3、没有清除数据，不会走这个方法 * 4、数据库升级的时候这个方法不会走 */ @Override public void onCreate(SQLiteDatabase db) { } /** * 1、这个方法只有当数据库已经存在，而且版本升高的时候，才会调用 * 2、第一次创建数据库的时候，这个方法不会走 * 3、清除数据后再次运行(相当于第一次创建)这个方法也不会走 */ @Override public void onUpgrade(SQLiteDatabase db, int oldVersion, int newVersion) { } } onCreate() onUpgrade() 是数据库创建和升级的重要函数，在里面进行 sql 语句操作即可。 只是 在升级的逻辑会比较麻烦和繁琐， 因为升级情况会比较多， 比如用户可能是从 版本1 、2、3、4... 升级到版本10的，要针对这几种情况都要做相应的逻辑。 如果不想写sql 语句，可以使用 郭霖 开源的 LitePal Android 数据库。 封装的比较好 ，增删改查、数据库升级 事务操作都有。 无版权 可以无限制使用！ all right reserved，powered by Gitbook该文件更新时间： 2020-12-30 17:08:02 "},"chinese/android基础/APP的启动流程.html":{"url":"chinese/android基础/APP的启动流程.html","title":"APP的启动流程","keywords":"","body":"android 相关 启动流程 本文的分析都是 基于 android-7.1.1-r1 的源码。 有些类可能在高版中会被废弃。 例如 自 API 26(android8.0 ) ，代理类 ActivityManagerProxy 已经被删除。 init 进程 它是内核启动的第一个用户级进程,它的进程号总是1 。 init的入口函数 // system/core/init/init.cpp int main(int argc, char** argv) { property_init(); // 对属性进行初始化 start_property_service(); // 启动属性服务 parser.ParseConfig(\"/init.rc\"); // 解析init.rc配置文件并启动zygote进程 } zygote 进程 ，受精卵 进程 zygote 由 init进程 通过 fork 的方式创建启动的。 zygote 是Android系统上所有应用进程的父进程，我们系统上app的进程都是由这个zygote分裂出来的。 SystemServer 进程 zygote 进程 fork 出 SystemServer 进程 android\\internal\\os\\ZygoteInit.java public static void main(String argv[]) { startSystemServer(abiList, socketName); // 启动 SystemServer 进程 ，根据反射 fork 出 } PackageManagerService 服务 、PMS 由 SystemServer 服务启动 。 // SystemServer.java , startBootstrapServices() mPackageManagerService = PackageManagerService.main(... ); ActivityManagerService 服务 、 AMS 由 SystemServer 服务启动 。 所有的APP应用都需要 与 AMS 打交道. // SystemServer.java , startBootstrapServices() mActivityManagerService = mSystemServiceManager.startService( ActivityManagerService.Lifecycle.class).getService(); Launcher 启动流程 、 Launcher3 app Launcher app 由 AMS 启动 。 // ActivityManagerService.java , Intent getHomeIntent() { // 启动 的 桌面程序 intent.addCategory(Intent.CATEGORY_HOME); } Launcher APP 启动流程 1、内核启动 2、内核启动 init 进程 3、init 进程 fork Zygote 进程 4、zygote 进程 fork 出 SystemServer 进程 5、SystemServer 服务 启动 AMS 、 PackageManagerService 服务 6、AMS 启动 Launcher app 点击桌面 app 图标 到打开 APP的流程 1、点击App图标，Launcher 用 Binder 跨进程 向 SystemServer 进程发起 startActivity 请求 2、SystemServer 进程接收到请求后，向 zygote 进程发送创建进程的请求 3、zygote 进程 fork 出新的子进程（即App进程） 4、App进程 通过 Binder 向 SystemServer 进程发起 attachApplication() 请求 5、SystemServer 进程在收到请求后，进行一系列准备工作后， 再通过 Binder 向App进程 发送 scheduleLaunchActivity() 请求； 6、App进程 的 binder 线程 ApplicationThread 在收到请求后， 通过handler向主线程发送 LAUNCH_ACTIVITY 消息； 7、主线程在收到 Message 后，通过 handler 机制 创建目标Activity，并回调 Activity.onCreate() 等方法。 Activity 启动流程 、startActivity 启动过程 整个流程有点复杂，不看着源码讲有点麻烦。可以参考这篇博客 http://gityuan.com/2016/03/12/start-activity/ 相关类 Instrumentation .java 每个 Activity 都持有 Instrumentation 对象的一个引用， 但是整个进程只会存在一个 Instrumentation 对象。 Instrumentation 这个类里面的方法大多数和 Application 和 Activity 有关， 这个类就是完成对 Application 和 Activity 初始化和生命周期的工具类 ,是一个大管家。 ActivityThread 在 ActivityThread .java 中定义 负责与 AMS 交互。 ApplicationThread 在 ActivityThread .java 中定义 ActivityStack ActivityStackSupervisor ActivityManagerProxy ApplicationThreadProxy 无版权 可以无限制使用！ all right reserved，powered by Gitbook该文件更新时间： 2021-01-05 16:38:37 "},"chinese/android基础/Android外挂.html":{"url":"chinese/android基础/Android外挂.html","title":"Android外挂","keywords":"","body":"安卓外挂 AccessibilityService https://gitee.com/hnyer/wechat-tool 安卓辅助功能服务 。简单的说无障碍就是一个后台监控服务，当你监控的内容发生改变时，就会调用后台服务的回调方法。 4.0以前，Accessibility功能单一，仅能过单向获取窗口信息(获取输入框内容)； 4.0及以后，Accessibility增加了与窗口元素的双向交互，可以操作窗口元素(点击按钮)。 具体案例可以参考 开头的demo 。 无版权 可以无限制使用！ all right reserved，powered by Gitbook该文件更新时间： 2020-09-18 14:43:22 "},"chinese/android基础/智能家居.html":{"url":"chinese/android基础/智能家居.html","title":"智能家居","keywords":"","body":"智能家居 http://hnyer.gitee.io/nativedev/chinese/linux/linux%E5%9F%BA%E7%A1%80.html?h=%E6%A0%91%E8%8E%93%E6%B4%BE 红外遥控器 红外遥控功能从Android4.4之后才开始支持。 家电遥控器通信距离往往要求不高，而红外的成本比其它无线设备要低的多，所以家电遥控器应用中红外始终占据着一席之地。 遥控器的基带通信协议很多，大概有几十种，常用的就有 ITT 协议、NEC 协议、Sharp 协议、Philips RC-5 协议、Sony SIRC 协议等。 用的最多的就是 NEC 协议了。 NEC协议 有开发需求的时候 再查文档 进行调试。 https://gitee.com/hnyer/ir_-remote-control MediaPlayer 、 SoundPool MediaPlayer 不支持同时播放多个音频 。可以同时新建多个 MediaPlayer 实例进行播放，不过这样比较消耗系统资源。 如果需要同时播放多个音频，可以考虑 SoundPool 。 以下是我封装的 示例代码。 MediaPlayerHolder 、 SoundPoolTool (这个demo SoundPool 我做了限制，一次只能播放一个音频，需要播放多个的，需要修改一下) 无版权 可以无限制使用！ all right reserved，powered by Gitbook该文件更新时间： 2020-12-23 16:39:25 "},"chinese/python/python基础.html":{"url":"chinese/python/python基础.html","title":"python部分","keywords":"","body":"Python 推荐使用 PyCharm 这个IDE进行代码编写。 Java 是强类型，编译型语言。 Python 是弱类型、解释型语言，运行速度比java慢。python的源码不能加密。 python -V //查看当前版本 python版本 import sys print (sys.version) python3 数据类型 Python中的变量不需要声明。 1、字符串 2、数字 3、列表 4、元组 5、集合 6、字典 7、日期 if 判断 age = 20 if age > 18: print('aaa') elif age >= 6: print('bbb') else: print('ccc') for 循环 list = [100, 200, 300] for temp in list: print(temp) while 循环 N = 10 x = 0 while x 6: break 列表 # 集合中数据类型可以不一样的 mList = ['Michael', 100, True] print(\"第一个数据=\" + mList[0]) print(\"最后一个数据=\" + str(mList[-1])) print(\"数组大小=\" + str(len(mList))) mList.append('AA') mList.insert(0, 'BB') # 删除最后一个 mList.pop() # 删除指定索引的数据 mList.pop(1) 元组 类似java中的数组 t = ('AA', 1 , True) print (t) 字典 dict = { 'Adam': 95, 'Lisa': \"aaaaaaa\", 'Bart': True } # 根据 key 获得 值 for mkey in dict: print(dict[mkey]) # 获得全部的值 for temp in dict.values(): print(temp) # 取出键值对 for key, value in dict.items(): print(key, ' ，', value) 类、对象 # 继承自 object class Person3(object): # 类属性 address='地球' # 构造方法 def __init__(self, name): # 对象属性 # 公开 self.name = name # 公开 self._sex = '女' #私有 self.__job = '学生'#外部不可以访问 # 类方法 @classmethod def getAddress(self): return self.address # 对象方法 def printInfo(self): print(\"当前对象名字是：\", self.name) # 设置、获取属性 p= Person3('小芳') setattr(p, 'name', 'small dog') msg = getattr(p, 'name') # 对象类型判断 if isinstance(p,object): print('类型判断正确') else: print('类型判断错误') 连接 mysql 安装 pymysql 插件。 如果使用的是pycharm， 是可以指定python环境目录的。方便灵活切换2.x和3.x . import pymysql from poetry.author import Author conn= pymysql.connect( host='114.xx.xx.65', port=3306, user='xx', passwd='xx',db='xx',charset='UTF8') print(\"获得数据库连接:\") print(conn) cursor = conn.cursor() def addAuthor(author): sql = ' insert into poetryauthor( mname, msex , mdesc, mpic,mtime,mtype ) values( \"%s\" ,\"%s\" ,\"%s\" ,\"%s\" ,\"%s\" ,\"%s\" ) '\\ % (author.mname, author.msex, author.mdesc, author.mpic, author.mtime, author.mtype) cursor.execute( sql) newId = int(conn.insert_id()) conn.commit() print(\"插入 新记录的id是: \", newId) def deleteAuthorById( mId): sql = 'delete from poetryauthor where mId = %d '% (mId) count = cursor.execute(sql) conn.commit() print(\"删除结果：\", count) def updateAutorById(author ,mId): sql = 'update poetryauthor set mname=\"%s\", msex=\"%s\", mdesc=\"%s\", mpic=\"%s\", mtime=\"%s\" , mtype=\"%s\" where mId=%d ' \\ % (author.mname, author.msex, author.mdesc, author.mpic, author.mtime, author.mtype, mId) count = cursor.execute(sql) print(\"更新结果：\", count) conn.commit() def queryAuthor(): count=cursor.execute('select * from poetryauthor') print('共有'+str(count)+' 条记录') rows = cursor.fetchall() for row in rows: mid = row[0] mname = row[1] msex = row[2] mdesc = row[3] mpic = row[4] mtime = row[5] mtype = row[6] print(mid, mname, msex , mdesc, mpic,mtime,mtype) # 测试 author = Author(\"李白2\", \"男1\" , \"牛逼诗人1\", \"baidu.com...png1\", \"唐代1\" , \"浪漫主义1\") # addAuthor(author) # queryAuthor() # deleteAuthorById(5) # updateAutorById(author , 6) # queryAuthor() # 关闭连接等... cursor.close() conn.commit() conn.close() 中文乱码 1、先用chardet检测读取到的内容的编码 chardet.detect(content) 2、转换成合适的编码格式 html = unicode(content, \"gb2312\").encode(\"utf8\") pip 安装库 pip 是Python的软件包管理系统，Python语言自带的命令行工具，它可以安装和管理第三方软件包。 pip install requests pip install beautifulsoup4 http://www.lfd.uci.edu/~gohlke/pythonlibs/ urllib、urllib2 在Python3已拆分更名为urllib.request和urllib.error urllib GET f=urllib.urlopen(\"http://m.cnblogs.com/\") s=f.read() print s 带参数 GET params = urllib.urlencode({'id': 8, 'name': 'jack', 'age': 25}) f = urllib.urlopen(\"http://localhost:18797/MailClient/test.aspx?%s\" % params) print f.read() POST params = urllib.urlencode({'id': 8, 'name': 'jack', 'age': 25}) f = urllib.urlopen(\"http://localhost:18797/MailClient/test.aspx\",params) print f.read() import urllib URL='http://192.168.0.102:8081/findYou/pointsApi/queryAllPointsTaskFy/{offset}/{limit}' URL= URL.replace('{offset}','0') URL = URL.replace('{limit}','1') f=urllib.urlopen(URL) s=f.read() print s //下载 import urllib import urllib.request import os def downCallBack(a, b, c): ''''' a:已经下载的数据块 b:数据块的大小 c:远程文件的大小 ''' per = 100.0 * a * b / c if per > 100: per = 100 print('下载进度： %.2f%%' % per) url = 'http://www.python.org/ftp/python/2.7.5/Python-2.7.5.tar.bz2' local = os.path.join('F:\\\\pythonDown\\\\', 'downDemo.zip') urllib.request.urlretrieve(url, local, downCallBack) 无版权 可以无限制使用！ all right reserved，powered by Gitbook该文件更新时间： 2020-12-23 17:29:33 "},"chinese/python/python爬虫.html":{"url":"chinese/python/python爬虫.html","title":"python爬虫","keywords":"","body":"python 爬虫 古诗文网 爬取作者信息 (静态页面) // 数据库帮助类 class MySqlTool(object): def __init__(self): self.conn = pymysql.connect(host='xx.xx.xx.xx65', port=3306, user='xx', passwd='xx', db='xx', charset='UTF8') print(\"获得数据库连接:\") print(self.conn) self.cursor = self.conn.cursor() def addAuthor(self ,author): sql = \" insert into poetryauthor( mname, msex , mdesc, mpic,mtime,mtype ) values( '%s','%s','%s','%s','%s','%s' ) \" \\ % (author.mname, author.msex, author.mdesc, author.mpic, author.mtime, author.mtype) self.cursor.execute(sql) newId = int(self.conn.insert_id()) self.conn.commit() print(\"插入 新记录的id是: \", newId) def deleteAuthorById(self, mId): sql = 'delete from poetryauthor where mId = %d ' % (mId) count = self.cursor.execute(sql) self.conn.commit() print(\"删除结果：\", count) def updateAutorById(self, author, mId): sql = \" update poetryauthor set mname= '%s', msex='%s', mdesc='%s', mpic='%s', mtime='%s' , mtype='%s' where mId=%d \" \\ % (author.mname, author.msex, author.mdesc, author.mpic, author.mtime, author.mtype, mId) count = self.cursor.execute(sql) print(\"更新结果：\", count) self.conn.commit() def queryAuthor(self): count = self.cursor.execute('select * from poetryauthor') print('共有' + str(count) + ' 条记录') rows = self.cursor.fetchall() for row in rows: mid = row[0] mname = row[1] msex = row[2] mdesc = row[3] mpic = row[4] mtime = row[5] mtype = row[6] print(mid, mname, msex, mdesc, mpic, mtime, mtype) def closeConnection(self): # 关闭连接等... self.cursor.close() self.conn.commit() self.conn.close() // 作者类 class Author(object): # 构造方法 def __init__(self ,mname, msex , mdesc, mpic,mtime,mtype): self.mname = mname self.msex = msex self.mdesc = mdesc self.mpic = mpic self.mtime = mtime self.mtype = mtype # 对象方法 def printInfo(self): print(\"当前对象信息：\", self.mname, self.msex, self.mtime, self.mtype, self.mpic, self.mdesc) // 入口程序 user_agent = 'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_11_5)' headers = {'User-Agent': user_agent} session = requests.session() sqlTool = MySqlTool() def getAsleep(): sleepTime = random.uniform(0, 2) print(\"休眠：\", sleepTime) time.sleep(sleepTime) def getUrlData( url ,mTime): # print(\"--------------------------------------\") # print(url) page = session.get(url, headers=headers) soup = BeautifulSoup(page.text, 'lxml') # contents = soup.findAll('div', class='left') datas = soup.findAll(name='div', attrs={\"class\": \"left\"}) for data in datas: items = data.findAll( name= 'div',attrs={\"class\": \"sonspic\"}) for item in items: urlDiv = item.find( name= 'div',attrs={\"class\": \"divimg\"}) if not urlDiv is None: imgUrl= urlDiv.find(name= 'img') name= imgUrl['alt'] pic= imgUrl['src'] descP = item.find( name= 'p',attrs={\"style\": \" margin:0px;\"}) desc= descP.text pos = desc.index(\"►\") # 去掉无用的内容 desc = desc[0:pos] author = Author(name, \"\", desc, pic, mTime, \"\") author.printInfo() sqlTool.addAuthor(author) print(\"--------------------------------------\") dict = { # \"先秦\": 4, # \"两汉\": 10, \"魏晋\": 13, \"南北朝\": 20, \"隋代\": 3, \"唐代\": 232, \"五代\": 4, \"宋代\": 583, \"金朝\": 10, \"元代\": 64, \"明代\": 279, \"清代\": 598 } for mkey in dict: index = 0 sum = dict[mkey] while index 喜马拉雅 json解析 + 文件下载 import requests import urllib.request import demjson user_agent = 'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_11_5)' headers = {'User-Agent': user_agent} session = requests.session() def getAsleep(): sleepTime = random.uniform(0, 2) print(\"休眠：\", sleepTime) time.sleep(sleepTime) def downAFile(fileName ,fileUrl ,downCallBack): downPath = 'F:\\\\小伊\\\\%s.m4a'%(fileName) print(\"正在下载：\" ,fileName) urllib.request.urlretrieve(fileUrl, downPath ,downCallBack) def downCallBack(downedCount, countSize, allSize): per = 100.0 * downedCount * countSize / allSize if per > 100: per = 100 print('下载进度： %.2f%%' % per) def getUrlData( url ): page = session.get(url, headers=headers) jsonData = page.text bean1 = demjson.decode(jsonData) bean2 = bean1['data'] bean3 = bean2['tracksAudioPlay'] for data in bean3: name = data['trackName'] # print(\"名字：\" ,name) arrays= name.split(\"-\") if len(arrays) 权谋网 文章 // 获取文章列表 import requests from bs4 import BeautifulSoup user_agent = 'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_11_5)' headers = {'User-Agent': user_agent} session = requests.session() def getAndSaveUrl( url): print(url) page = session.get(url, headers=headers) soup = BeautifulSoup(page.text, 'lxml') contents = soup.findAll('div', id='contentleft') for child in contents: item = child.findAll('h2') for hValue in item: aValue = hValue.find('a') title = aValue.string url = aValue['href'] print(title) f = open('D:/网址.txt', 'a') f.write('\\n' + url) # sum大小 请根据网站最新页数调整 sum = 181 index =1 while index 每日毒鸡汤 public void getWeatherOfFoshanNanhai() { String url= \"https://lwdjt.com\"; String filePath =\"c://test/毒鸡汤.txt\" ; File file = new File(filePath); try { if(!file.exists()){ file.createNewFile(); } } catch (IOException e) { e.printStackTrace(); } FileWriter writer = new FileWriter(filePath, true); int count = 1; while (count 无版权 可以无限制使用！ all right reserved，powered by Gitbook该文件更新时间： 2020-12-23 17:27:33 "},"chinese/kotlin/kotlin部分.html":{"url":"chinese/kotlin/kotlin部分.html","title":"kotlin部分","keywords":"","body":"kotlin Kotlin 是 JetBrains 开发的基于 JVM 的语言。完全兼容java。 DSL（domain specific language） 领域专用语言：专门解决某一特定问题的计算机语言，比如大家耳熟能详的 SQL 和正则表达式。 相关 库、工具 // Anko 以往的布局都是要从 XML 中解析出来。 而 Anko 则是直接创建 View，用代码构建布局，省去了解析 XML 的时间。 // ktor 由 Kotlin 团队打造的 Web 框架 ，可以用来编写服务器。 Kotlin Android 扩展 https://www.kotlincn.net/docs/tutorials/android-plugin.html findViewById() 。尽管存在一系列的开源库能够为这个问题带来解决方案。 现在 Kotlin 安卓扩展插件能够提供与这些开源库功能相同的体验，不需要添加任何额外代码。 apply plugin: 'kotlin-android-extensions' //扩展插件 import kotlinx.android.synthetic.main.＜布局＞.* //关联xml 访问范围 private, protected //子类可见 internal // 同一模块 public 数据类型 Byte、Short、Int、Long、Float、Double 、Boolean 、String 变量 、常量 var value : Int = 10 // 变量 val name : String =\"abcdedfdfa\" // 常量 类型转换 var info : String = \"100\" var info2 :Int = info.toInt() var info3 :String = info2.toString() 将y转为String类型 ，如果转换失败就会返回null 。 val x: String? = y as? String // 转换失败就会抛出异常 val x: String? = y as String 位运算符 shl —— 类似Java的> ushr —— 类似Java的>>> and —— 类似Java的& or —— 类似Java的| xor —— 同Java中的按位异或 ^ inv —— Java中的按位取反 - 函数 // fun ,有参数 ，有返回值 fun sum(a: Int, b: Int): String { return (a + b).toString() } // 无返回值 fun showInfo(a: Int, b: Int){ } // vararg是关键字 可变参数 fun vars(vararg v:Int){ for(vt in v){ //... } } 字符串模板 val age :Int = 20 var info :String =\"年龄是$age\" //复杂格式 var info2 = \"$info 字符串长度是${info.length}\" 集合 // List val list: List = listOf(1, \"2\", 3) // Array val faces = Array(5) { \"a\" } // Array初始化，大小5，初始值为\"a\" // Set val set: Set = setOf(1, \"2\", 3, \"3\") // Map val map: Map = mapOf(\"k1\" to \"v1\" , \"k2\" to 3) indices //collection.joinToString(xxx) 对集合中的元素进行简单的拼接 // collection.any(XXX) Returns `true` if at least one element matches the given [predicate]. 空指针 //? 表示可为null var ageString : String ? //?. 为空就返回null ，不是空 就返回 对应的值 ageString =student ?. name // ?: ageString 为空就用默认值 ，否则用取得的值 var info :String? info = ageString ?: \"21\" // !! 非空断言 ageString不为空时获取对应的值 ，否则直接报错 。 val length : Int = ageString!!.length // 判断是否为空 var flag : Boolean = ageString.isNullOrBlank() let 常与非空判断符?. 一起使用 mSurfaceTexture?.let { // compoundDrawables 不为空就执行... // it 是指 mSurfaceTexture mCamera?.setSurfaceTexture(it) } @标签 ## return@ return@XXlabel 语法用于指定此语句从几个嵌套函数中返回哪个函数。 对象 所有的类都继承自 Any 。 默认所有的类都是final类型 。 // (info: String) 是主构方法 open class Person (info: String){ // 可以被重写 open var info : String =\"人类\" var age1 : Int = 25 // 次构造函数 constructor(info: String ,age: Int) : this(info) { this. info = info this.age1 = age } // open 普通函数 ,可以被重新 open fun showInfo(){ } // 普通函数 不可以被重新 fun showInfo2(){ } } public class Student(info: String) : Person(info) { override var info : String =info // 次构造函数 constructor(info: String ,age: Int) : this(info) { this. info = info this.age1 = age } // override 重写函数 override fun showInfo() { super.showInfo() } } // 测试 var student1 : Student = Student(\"新人类\" ,19) var student2 : Student = Student(\"新人类\" ) 类初始化 kotlin增加了一个新的关键字init用来处理类的初始化问题， init模块中的内容可以直接使用构造函数的参数。 继承 Kotlin 中所有类都继承该 Any类，Any是所有类的超类。 如果一个类要被继承，需要用open 关键字进行修饰。 函数重写、属性重写 在基类中，使用fun声明函数时，默认不能被子类重写。如果需要被子类重写。 需要用open修饰它, 然后子类重写方法使用 override 说明 。 接口 interface Language { fun chinease(msg :String ) fun english(msg :String ) } // Person 是父类 ， Language是接口 public class Student(info: String) : Person(info),Language{ override fun english(msg: String) { } override fun chinease(msg: String) { } .... } apply 调用对象的apply函数，在函数范围内， 可以任意调用该对象的任意方法，并返回该对象。 with 将对象作为函数的参数，在函数内可以通过 this指代该对象。 返回值为函数的最后一行或return表达式 when 表达式类似 java 中的 switch . 可以用when替换复杂的if/else语句 。 在when中，else同switch的default。这是你给出的当你的表达式没有覆盖情况下的解决方案。 intArrayOf 创建一个int数组 循环 for(i in 0..9){ // [0,9] } (0 until 9){ // [0,9) } mapTo // mapTo 与循环搭配使用。此处的解释是： // [0 ,size)中循环取索引i ，新建BeanB对象，并将这些对象全部添加到集合 listA中 (0 until mTitles.size) .mapTo( listA) { BeanB( array1[it], array2[it] ) } 三目表达式 kotlin不支持。 请直接使用 if else来代替 data data class , 在 Kotlin 中，不需要自己动手去写一个 JavaBean， 可以直接使用 DataClass，使用 DataClass 编译器会默默地帮我们生成以下函数 。 双冒号 :: // 调用d对象的方法getResult d::getResult 原生字符串 三引号 A raw string is delimited by a triple quote (\"\"\" xxx \"\"\"), contains no escaping and can contain newlines and any other characters. val str:String= \"\"\" the price is$\\d 199 \"\"\" 拓展函数 如果一个类没有定义某个功能，可以在类外（具体使用的地方）写一个拓展函数。 拓展函数名可以跟类的原有函数名字相同，但是会优先使用类的原有函数。 空对象也可以使用拓展函数。 this指的是被改造的那个对象是例。 class User(var name:String) /**扩展函数**/ fun User.Print(){ print(\"用户名 $name\") } fun main(arg:Array){ var user = User(\"Runoob\") user.Print() } 伴生对象 Kotlin移除了static的概念。 通常用 object 和 companion object 来实现 使用\"object\"修饰静态类 被修饰的类，可以使用类名.方法名的形式调用 var version_name1 = Util.getName() object Util { fun getName(): String { return BuildConfig.VERSION_NAME } } 使用\"companion object\"修饰静态方法 可以使用类名.方法名的形式调用 var version_name2 = Util2.getName() class Util2 { companion object { fun getName(): String { return BuildConfig.VERSION_NAME } } } 数据类 kotlin的数据类 类似java中手动创建的 javaBean ，用来传递数据 。 用关键字 data 申明。 数据类不能继承其他类（可以实现其他接口） 。 在使用数据类时，与普通类无异 。 密封类 用关键字 sealed 申明。 密封类就像一个更强大的枚举。密封类只有固定子类 。 枚举 enum class Color{ RED,BLACK } 枚举可以被初始化 enum class Color(val rgb: Int) { RED(0xFF0000), GREEN(0x00FF00) } 挂起函数 用 Suspend 修饰 等xx函数执行完才会输入某个结果。 但是线程并不会阻塞。 类似回调的使用 协程 Coroutine 协程并不是 Kotlin 提出的，概念已经提出很久了。 java 原生语法暂未支持 ,但是可以通过一些第三方的框架来实现。 对操作系统来说，线程是最小的执行单元，进程是最小的资源管理单元。 协程不是被操作系统内核所管理，是完全由程序所控制的。 一个进程可以拥有多个线程一样，一个线程可以拥有多个协程。 当系统线程较少的时候没有什么问题，当线程数量非常多的时候，却产生了问题。 一是系统线程会占用非常多的内存空间，二是过多的线程切换会占用大量的系统时间。 协程运行在线程之上，当一个协程执行完成后，可以选择主动让出，让另一个协程运行在当前线程之上。 协程并没有增加线程数量，只是在线程的基础之上通过 分时复用 的方式运行多个协程， 协程的切换在用户态完成，切换的代价比线程从用户态到内核态的代价小很多。 协程跑在单个线程内，是单线程下的并发 。不适合 CPU 密集型任务 ，适合 IO密集型任务。 此外，协程代码中决不能出现阻塞，否则整个线程都会停下来等待该操作完成。 kotlin 协程 引入 https://github.com/Kotlin/kotlinx.coroutines implementation 'org.jetbrains.kotlinx:kotlinx-coroutines-core:1.4.2' implementation 'org.jetbrains.kotlinx:kotlinx-coroutines-android:1.4.2' val jobWork= GlobalScope.launch( Dispatchers.Main ){ }// 工作线程 val mainWork =GlobalScope.launch(Dispatchers.IO) { }// 主线程切换 jobWork.cancel() // 取消协程 协程作用域 CoroutineScope 暂未学习 协程上下文 CoroutineContext 暂未学习 命名参数 、 默认参数 函数定义：第一个参数没有默认值，后面的都有默认值 fun reformat(str: String, normalizeCase: Boolean = true, upperCaseFirstLetter: Boolean = true, divideByCamelHumps: Boolean = false, wordSeparator: String= \"bbb\") { // .... } //不会引起歧义的时候调用 (全部使用默认值) reformat(\"tom\") //有歧义时，必须要指定参数名字。 指定命名。否则不知道你要将值赋给谁 reformat(\"tom\" , upperCaseFirstLetter= false) kotlin main 入口函数 fun main(args: Array){ println(\"hello kotlin\") } java 调用 kotlin // Companion 是关键字 ， newInstance 是kotlin中的静态方法 mFragments[FIRST] = DeviceFragment.Companion.newInstance(); kotlin 调用 java val javaDemo = JavaDemo() //新建对象 val msg =javaDemo.helloMsg // 调用对象的方法 println(\"msg=\"+ msg) kotlin 调用 jni external表示将一个声明标记为不是在 Kotlin 中实现. init { System.loadLibrary(\"joke-lib\") } external fun getWXAPPID(): String init kotlin增加了一个新的关键字 init 用来处理类的初始化问题， init模块中的内容可以直接使用构造函数的参数。 对象表达式 对象表达式，是一种代替Java中的匿名内部类的方法。 使用object关键字来进行编写。比匿名内部类更先进。 可以实现多个接口。 // 关键 object : 指明 tab_layout.setOnTabSelectListener( object : OnTabSelectListener { // 设置监听函数 }) 监听函数 private val onGestureListener = object : RecordButton.OnGestureListener { override fun onUp() { } } 新建对象 java中新建对象要用到new 关键字。 kotlin中没有new关键字。 直接写类名 即可。 get set 方法 kotlin中可以直接使用对象的属性，不用调用 get和set方法。 //这是FragmentActivity.java中的源码 public FragmentManager getSupportFragmentManager() { return mFragments.getSupportFragmentManager(); } 为了获得一个 FragmentManager 实例， java中需要这样写 this.getSupportFragmentManager() , 而kotlin中可以直接这样使用 this.supportFragmentManager 注意 getSupportFragmentManager 和getSupportFragmentManager 之间的特点。（符合set和get的命名规范的） //var 默认有get set方法。不写就用默认的。 var heiht: Float = 145.4f private set // 说明这个set方法是私有的 // 重写了get方法 private val isViewAttached: Boolean get() = mRootView != null 延迟初始化 、 懒加载 lateinit 和 lazy 、notNull 1、lateinit 、notNull 只用于var，lazy只用val 2、lateinit 不能用在可空的属性上和 基本类型上。 让编译期忽略对属性未初始化的检查，后续在哪里以及何时初始化还需要开发者自己决定。 （让编译器别BB，我知道这个变量一定要初始化，别老是提醒我） 3、lazy 用到的时候才会调用，生成过程只会执行一次， 多次调用用到的是第一次生成的结果 。 private val linearLayoutManager by lazy { LinearLayoutManager(activity, LinearLayoutManager.VERTICAL, false) } 4、一般情况使用lateinit修饰符，最为优雅。 当类型是原生类型，或者为局部变量时，只能只用notNull委托。 var context: Context by Delegates.notNull() 委托 by Kotlin 直接支持委托模式 。 委托属性也是一种 约定 。 setValue 和 getValue都需带有 operator 关键字修饰。 operator fun getValue(thisRef: Any?, property: KProperty): T { return xx } operator fun setValue(thisRef: Any?, property: KProperty, value: T) { // } 星号 * 将数组展开并传入可变参数 val arr = intArrayOf(2, 1, 3) sumTest( * arr) // 星号的意思是将数组中的值取出来作为可变参数 private fun sumTest( vararg values :Int ){ // 参数是可变参数 } 泛型 跟java的泛型差不多。参考java即可。 return@ return@XXlabel 语法用于指定此语句从几个嵌套函数中返回哪个函数。 无版权 可以无限制使用！ all right reserved，powered by Gitbook该文件更新时间： 2021-01-05 11:04:28 "},"chinese/flutter/flutter部分.html":{"url":"chinese/flutter/flutter部分.html","title":"flutter部分","keywords":"","body":"flutter部分 flutter 配置 1、修改整个工程的文件夹名字， 修改后需要在工程里 重新命名xxx.imld的名字（例如 wk-weather.iml ） 2、版本号在 pubspec.yaml version 中配置 version: 1.0.20201109+1 1.0.20201109 是版本标记 ， 1是版本号 3、隐藏右上角 debug 标记 debugShowCheckedModeBanner: false, Your Flutter application is created using an older version of the Android embedding. It's being deprecated in favor of Android embedding v2 在 application 标签下 添加 签名配置 keystore 跟Android 工程 一样配置即可。 app 显示调试模式界面 import 'package:flutter/rendering.dart'; void main() { debugPaintSizeEnabled = true; runApp( ) ; } flutter工程中 Android部分爆红 如果工程能正常运行，请不要理会。 编写Android部分代码时你重新用Androidstudio打开Android部分即可，它也是一个Android工程。 // 如果是 build.gradle 中 Properties 、GradleException 爆红 按照提示引入 sdk ，并将 GradleException 改成 Exception ，然后重新刷新工程即可。 flutter 插件开发 Android项目部分爆红 在Android的 build.gradle下加入以下配置，引入 flutter.jar即可。 //获取local.properties配置文件 def localProperties = new Properties() def localPropertiesFile = rootProject.file('local.properties') if (localPropertiesFile.exists()) { localPropertiesFile.withReader('UTF-8') { reader -> localProperties.load(reader) } } //获取flutter的sdk路径 def flutterRoot = localProperties.getProperty('flutter.sdk') if (flutterRoot == null) { throw new GradleException(\"Flutter SDK not found. Define location with flutter.sdk in the local.properties file.\") } dependencies { compileOnly files(\"$flutterRoot/bin/cache/artifacts/engine/android-arm/flutter.jar\") } flutter BloC 模式 业务逻辑组件 （Business Logic Component ），实际上BloC设计模式，似乎和MVP没有什么本质区别， 两种设计模式的最终目的就是为了把和UI糅合在一起的业务逻辑代码剥离开来，单独的抽取到一层中。 项目类型 Flutter Application Flutter Application 表示一个Flutter项目，主体是Flutter， 当然它也可以接入Android Module 或者 iOS Framework， 其内部包含 Android 和 iOS 项目。以后可能会支持其他平台。 Flutter Plugin Flutter Plugin 表示 Flutter 插件，包含 Android 和 iOS 项目， 如果你要开发一个 Plugin 且此 Plugin 涉及到原生支持，比如蓝牙功能、网络功能等， 这些功能纯 Flutter 是无法实现的。 Flutter Plugin 开发完成后可以发布到 pub 上。 Flutter Package Flutter Package 和 Flutter Plugin 基本一样，唯一的区别是Flutter Package表示纯 Flutter 模块， 不需要原生开发，没有Android 和 iOS 项目，比如开发一个纯 UI 的插件。 Flutter Module Flutter Module 用于原生项目中插入 Flutter 模块，原生为主体，与 Flutter 进行混合开发。 json // 举例使用 // json.decode(modelStr) // Parses the string and returns the resulting Json object // json obj 转对象 WeatherModelEntity weatherModelEntity = WeatherModelEntity().fromJson(json.decode(modelStr)); ------------------ json部分的代码使用 FlutterJsonBeanFactory 插件生成的 。 https://plugins.jetbrains.com/plugin/11415-flutterjsonbeanfactory 如果改变了结构，需要在变动过的文件上 alt+ j 重新生成 json_convert_content.dart ------------------ 1、将 json 字符串转为 map 格式的json 对象 import 'dart:convert'; //系统自带 2、将 json 对象转为 实体类对象 借助第三方工具 FlutterJsonBeanFactory 简化人工代码 国际化 翻译支持 系统自带的控件 国际化 Flutter给我们提供的Widget默认情况下就是支持国际化。例如时间日期选择控件。 1、 pubspec.yaml中新增配置 flutter_localizations:# 国际化支持 包 sdk: flutter 2、 对 MaterialApp 进行配置 return MaterialApp( title: 'Flutter Demo', // localizationsDelegates 指定哪些Widget需要进行国际化 localizationsDelegates: [ GlobalMaterialLocalizations.delegate, // Material GlobalCupertinoLocalizations.delegate, // Cupertino GlobalWidgetsLocalizations.delegate // Widgets ], // supportedLocales 支持哪些 语言 supportedLocales: [ Locale(\"en\"), Locale(\"zh\") ], 自定义控件、文本、信息展示 国际化 大部分情况，是需要对自定义的控件或信息等进行国际化。 为了方便快速，一般使用第三方插件 Flutter intl 进行配置。 1、安装插件，重启 Androidstudio 2、 pubspec.yaml中新增配置 flutter_localizations:# 国际化支持 包 sdk: flutter 3、在Tools栏目下找到 Flutter Intl 进行初始化。 初始化后 ， pubspec.yaml 中会新增配置 flutter_intl: enabled: true lib 目录下 会新增 generated 、l10n文件夹 4、在Tools栏目下找到 Flutter Intl 添加语言支持 ，例如 en_IN, zh_CN, de_DE 5、在 l10n 目录下 找到对应的文件，进行语言配置 ，例如 { \"string_title\": \"测试标题\" , \"string_Name\": \"测试名字\" } 6、 在 MaterialApp 中进行多语言支持配置 。 return MaterialApp( title: \"123123\", // 快照上显示的APP名字 // title: S.of(context).string_title, // 这里使用会报错， localizationsDelegates: const [ S.delegate, GlobalMaterialLocalizations.delegate, GlobalCupertinoLocalizations.delegate, GlobalWidgetsLocalizations.delegate ], supportedLocales: S.delegate.supportedLocales, localeListResolutionCallback: (locales, supportedLocales) { // 设备支持的语言 print(\"---------$locales\"); return; }, 7、使用 Text( S.of(context).string_title ) // S是自定生成的代码定义的类名 Text( S.current.string_title ) 屏幕适配 final mediaQueryData = MediaQuery.of(context); // 逻辑宽高 final screenWidth = mediaQueryData.size.width; final screenHeight = mediaQueryData.size.height; // 物理宽高、分辨率 final physicalWidth = window.physicalSize.width; // import 'dart:ui'; final physicalHeight = window.physicalSize.height; // 密度 final dpr = window.devicePixelRatio; // 状态栏高度 final statusBarHeight = mediaQueryData.padding.top; // 底部高度 final bottomHeight = mediaQueryData.padding.bottom; flutter的长度单位是 dp ，而不是px ,适配方案参考Android的适配经验即可。 无论设计稿的单位是px,或者是dp,我们都能够转换成px。 1、先将设计稿换成 dp为单位的设计稿 例如 1920 * 1080 ( px ) 2、转换原理(比例一样)如图. flutter 运行模式 release //发布模式 profile // 性能模式 debug // 调试模式 flutter run --release flutter run --debug // It's likely that this file was generated under xxx \\build, but the tool couldn't find it. 这个问题 我这边导致的原因是 签名信息配置错了 ， 不能改成 wk2017之类的 ， 要用 release 或者debug ， 或者干脆不要签名。 Androidstudio 菜单下的 Flutter fun xxx.dart in release/profile mode 。 状态管理 1、添加支持 provider: ^4.3.2+2 https://pub.flutter-io.cn/packages/provider/install 2、定义共享数据类 xxx extends ChangeNotifier notifyListeners(); // 通知刷新 3、ChangeNotifierProvider 将数据共享类 和 widget 关联起来 Widget someWidget = ChangeNotifierProvider( create: (context) => GlobalModel(), // ChangeNotifier child: child, // Widget ); 4、更新数据 var shareBean = Provider.of(context); // 如果 Widget 和 ChangeNotifier 没有关联过，是不是就是null？ shareBean.xxx = \"abc\" // 更新数据 引入本地第三方库 1、在工程目录下新建一个文件夹存放插件，比如plugin 2、打开工程的pubspec.yaml，在dependence里添加plugin下的插件 //本地插件引用 注意缩进格式 webview_flutter: path: plugin/webview_flutter flutter 插件开发 1、新建插件工程 2、调用者中 引入插件地址 wk_flutter_plugin: path: wk_flutter_plugin # 本地flutter插件库 msg_plugin flutter 与 Android 数据 交互 有些功能，flutter暂时不支持(例如蓝牙)，所以需要用Android开发获得数据，然后传递给蓝牙。 flutter和Android通信的方式目前主要可以采用 MethodChannel // flutter调用方法，方法返回，一问一答模式 EventChannel // Android端不断往flutter发送数据 ，单向? BasicMessageChannel // 双向通信 注意：新建通道对象时 ，flutter 和 Android 端，name 参数是对应的， public class MainActivity extends FlutterActivity implements MethodChannel.MethodCallHandler { int count = 0; @Override protected void onCreate(@Nullable Bundle savedInstanceState) { super.onCreate(savedInstanceState); Activity activity = this ; new Thread(new Runnable() { @Override public void run() { while(true){ try { Thread.sleep(500); } catch (InterruptedException e) { e.printStackTrace(); } if(eventSink==null){ WkLog.showLog(\"myEvent ==null\"); }else{ count ++ ; activity.runOnUiThread(new Runnable() { @Override public void run() { if(count%2==0){ eventSink.success(\"hello android...\"+count); }else{ eventSink.error(\"500\" ,\"发生异常\" ,null); } } }); } if(basicMessageChannel!=null){ activity.runOnUiThread(new Runnable() { @Override public void run() { basicMessageChannel.send(\"Android主动发送消息 \" + count); } }); }else{ WkLog.showLog(\"basicMessageChannel ==null\"); } } } }).start(); } private final String KEY_METHODCHANNEL =\"KEY_METHODCHANNEL_20201124\" ; private final String KEY_EventChannel =\"KEY_EventChannel_20201124\" ; private final String KEY_BasicMessageChannel =\"BasicMessageChannel_20201124\" ; private MethodChannel methodChannel; private EventChannel.EventSink eventSink = null ; private BasicMessageChannel basicMessageChannel; // configureFlutterEngine 函数 在 onCreate 之前执行 @Override public void configureFlutterEngine(@NonNull FlutterEngine flutterEngine) { super.configureFlutterEngine(flutterEngine); initEngineConfig(flutterEngine); } private void initEngineConfig(FlutterEngine flutterEngine){ // MethodChannel methodChannel = new MethodChannel(flutterEngine.getDartExecutor(), KEY_METHODCHANNEL); methodChannel.setMethodCallHandler(this); // EventChannel EventChannel eventChannel =new EventChannel( flutterEngine.getDartExecutor() ,KEY_EventChannel); eventChannel.setStreamHandler( new EventChannel.StreamHandler() { @Override public void onListen(Object arguments, EventChannel.EventSink events) { // events 传出去，用来主动发送数据 eventSink =events ; } @Override public void onCancel(Object arguments) { } }); // basicMessageChannel = new BasicMessageChannel ( flutterEngine.getDartExecutor() , KEY_BasicMessageChannel, StringCodec.INSTANCE); // StandardMessageCodec.INSTANCE basicMessageChannel.setMessageHandler( new BasicMessageChannel.MessageHandler() { @Override public void onMessage(Object message, BasicMessageChannel.Reply reply){ String str = (String) message; WkLog.showLog(\"收到来自flutter=\"+ str); } }); } @Override public void onMethodCall(MethodCall call, MethodChannel.Result result) { if (call.method.equals(\"userLogin\")) { String hostIp = call.argument(\"hostIp\"); String hostPort = call.argument(\"hostPort\"); result.success(hostIp+ \" \"+hostPort + \"登录成功...\" + System.currentTimeMillis()) ; }else { result.notImplemented(); } } } class MsgTransmissionTool { static String KEY_METHODCHANNEL =\"KEY_METHODCHANNEL_20201124\" ; static String KEY_EventChannel =\"KEY_EventChannel_20201124\" ; static String KEY_BasicMessageChannel =\"BasicMessageChannel_20201124\" ; static MsgTransmissionTool _instance ; static MsgTransmissionTool getinstance() { if(_instance ==null){ _instance = MsgTransmissionTool() ; } return _instance ; } MethodChannel methodChannel ; EventChannel eventChannel ; BasicMessageChannel basicMessageChannel ; MsgTransmissionTool(){ // todo 重要注释： 要先在 flutter端新建初始化这些对象，否则Android端的那些对象是空的。 methodChannel = MethodChannel(KEY_METHODCHANNEL); eventChannel = EventChannel(KEY_EventChannel ); basicMessageChannel = BasicMessageChannel( KEY_BasicMessageChannel, StringCodec()); // StandardMessageCodec } setMessageHandler( Future Function( dynamic message) handler ){ if(basicMessageChannel!=null){ basicMessageChannel.setMessageHandler(handler) ; } } setEnventChannelListener( void onData(dynamic event) ,void _onError(dynamic event) ){ if(eventChannel!=null){ eventChannel.receiveBroadcastStream().listen( onData, onError: _onError); } } void sendMsgByBasicMessageChannel(String msg) async { if(basicMessageChannel!=null){ await basicMessageChannel.send(msg ); } } Future sendMsgByMethodChannel( String hostIp ,String hostPort) async { if(methodChannel!=null){ final String version = // 参数以键值对的方式传递过去 await methodChannel.invokeMethod('userLogin' , {\"hostIp\":hostIp , \"hostPort\":hostPort}); return version; }else{ print(\"methodChannel ==null\"); } return null ; } } // 使用 // 设置监听函数 _initTool() async{ await MsgTransmissionTool.getinstance().setMessageHandler( ongetMsgFromMessageChannerl); await MsgTransmissionTool.getinstance().setEnventChannelListener( _onEvent , _onError); } void _onEvent(Object event) { setState(() { msg2 = event ; }); print(\"收到数据==_onEvent==$event\"); } void _onError(Object error) { PlatformException exception = error ; setState(() { msg2 = \" ${ exception.message} , ${exception.code} \"; }); print(\"收到数据==_onError\"); } Future ongetMsgFromMessageChannerl( dynamic message) { setState(() { msg3= message ; }); } // 往Android发送数据 Future testSend() async { String result = await MsgTransmissionTool.getinstance().sendMsgByMethodChannel(\"192.168.1.1\" ,\"8080\"); setState(() { loginResult=result ; }); MsgTransmissionTool.getinstance().sendMsgByBasicMessageChannel(\"BasicMessageChannel 给Android 发送消息\") ; } flutter 调用Android控件 // Android 端 新建 View 和工厂类 class MyView implements PlatformView { private TextView textView; MyView(Context context ) { // configureFlutterEngine 函数 在 onCreate 之前执行 ，所以不能通过 findViewById 方式获得控件 //View rootView = inflater.inflate(R.layout.testlayout, null); //rootView.findViewById() TextView myNativeView = new TextView(context); myNativeView.setTextColor(Color.RED); myNativeView.setClickable(true); myNativeView.setOnClickListener(new View.OnClickListener() { @Override public void onClick(View view) { textView.setTextColor(Color.BLUE); Toast.makeText(context ,\"hello android\" ,Toast.LENGTH_SHORT).show(); } }); this.textView = myNativeView; } public void updateValue(String value){ textView.setTextColor(Color.RED); textView.setText(\"----> \"+value); } @Override public View getView() { return textView; } @Override public void dispose() { } } public class MyViewFactory extends PlatformViewFactory { private MyView myView ; public MyViewFactory( ) { super(StandardMessageCodec.INSTANCE); } @Override public PlatformView create(Context context, int id, Object args) { myView = new MyView(context) ; // 新建时 传递过来的参数 Map params = (Map) args; String value = params.get(\"key123456\") ; myView.updateValue(value); return myView; } } // 在XXActivity中 注册这个控件 @Override public void configureFlutterEngine(@NonNull FlutterEngine flutterEngine) { super.configureFlutterEngine(flutterEngine); PlatformViewRegistry registry = flutterEngine.getPlatformViewsController().getRegistry() ; myViewFactory = new MyViewFactory() ; // platform_text_view12345678 是全局唯一的，要与flutter端对应使用 registry.registerViewFactory(\"platform_text_view12345678\",myViewFactory) ; } // flutter端 通过 AndroidView 来包裹调用 var androidView = AndroidView( viewType: \"platform_text_view12345678\", creationParams: {\"key123456\": \"我来自flutter\"}, creationParamsCodec: const StandardMessageCodec()); Container( // width: 80, height: 80, child: androidView, ) , flutter第三方库 package_info 获取版本号等 版本号在 pubspec.yaml version 中配置 https://pub.flutter-io.cn/packages/package_info PackageInfo.fromPlatform().then((PackageInfo packageInfo) { String appName = packageInfo.appName; String packageName = packageInfo.packageName; String version = packageInfo.version; String buildNumber = packageInfo.buildNumber; }); url_launcher 通过 url 打开第三方应用 ，例如网址打开浏览器 ， 拨打电话，调用第三方APP等。 https://pub.flutter-io.cn/packages/url_launcher/install _launchURL() async { const url = 'tel:13457980678'; // 唤起电话界面 // const url = 'weixin://'; 唤起微信 //const url = 'http://typhoon.zjwater.gov.cn/wap.htm'; // 打开浏览器 if (await canLaunch(url)) { await launch(url); } } flutter_bloc https://pub.flutter-io.cn/packages/flutter_bloc // Bloc 业务逻辑组件 (Business Logic Component) 。 Bloc 将 Event 事件转换为 States 状态. 每个 Bloc 都有一个 add 方法，用来添加新的 Event 到 mapEventToState 中； // BlocBuilder extends StatefulWidget ... 构造器，主要用于构建 Widget 。 // BlocProvider extends Widget ... BlocProvider 为 Bloc 的供应者； // MultiBlocProvider extends Widget ... 是一个用于将多个BlocProvider合并为一个BlocProvider的组件。 // BlocListener t extends Widget ... 用于监听状态变更，可在此做出相应的业务处理； shared_preferences key-value 存储插件， 跟android SharedPreferences 的类似。 https://pub.flutter-io.cn/packages/shared_preferences SharedPreferences prefs = await SharedPreferences.getInstance(); prefs.setString(KEY_CITY_MODELS, encodeStr); // 保存 var parseValue = prefs.getString(KEY_CITY_MODELS); // 获取 prefs.remove(key); prefs.clear(); dio http 网络访问框架。 Dart Http请求库，支持Restful API、FormData、拦截器、请求取消、Cookie管理、文件上传/下载、超时。 int timeout = 15 *1000 ; BaseOptions options = BaseOptions( baseUrl: \"https://www.baidu.com/\", connectTimeout:timeout , receiveTimeout:timeout , sendTimeout:timeout ); Dio dia = Dio(options) ; Interceptor dInter = InterceptorsWrapper( onRequest: (RequestOptions options) { return options; // 拦截请求 }, onResponse: (Response response) { return response; // 拦截响应 }, onError: (DioError error) { // 拦截异常 print(\"拦截了错误\"); return error; } ); dia.interceptors.add( dInter); // 添加拦截器 String url=\"https://www.baidu.com/\" ; Map param= Map() ; Response response = await dia.get(url, queryParameters: param); // get 请求 var result = response.data ; print(\"请求结果=\"+ result); event_bus 消息传递框架 https://pub.flutter-io.cn/packages/event_bus https://github.com/marcojakob/dart-event-bus EventBus eventBus = EventBus(); eventBus.fire(\"helloflutter\"); // 发送 StreamSubscription streamSubscription =eventBus.on().listen((event){ // 接收 }); streamSubscription.cancel() ; // 取消监听 streamSubscription.pause() ;// streamSubscription.resume() ;// flutter_screenutil flutter 屏幕适配方案，让你的UI在不同尺寸的屏幕上都能显示合理的布局。 https://pub.flutter-io.cn/packages/flutter_screenutil https://github.com/OpenFlutter/flutter_ScreenUtil //设置适配尺寸 (填入设计稿中设备的屏幕尺寸) 此处假如设计稿是按iPhone6的尺寸设计的(iPhone6 750*1334) // 设置字体大小是否根据系统的“字体大小”辅助选项来进行缩放 // ScreenUtil.init(context); //默认 width : 1080px , height:1920px , allowFontScaling:false ScreenUtil.init(context,designSize: Size(750, 1334), allowFontScaling: false); // var width = 1.wp ; var width = 1.sw ; // screen height var width2 = 0.2.sw ; // screen height 屏幕宽度的0.2倍 ScreenUtil().pixelRatio ; //设备的像素密度 ScreenUtil().screenWidth ; // (sdk>=2.6 : 1.sw) //设备宽度 ScreenUtil().screenHeight ; //(sdk>=2.6 : 1.sh) //设备高度 ScreenUtil().bottomBarHeight ; //底部安全区距离，适用于全面屏下面有按键的 ScreenUtil().statusBarHeight; //状态栏高度 刘海屏会更高 单位dp ScreenUtil().textScaleFactor; //系统字体缩放比例 ScreenUtil().scaleWidth ; // 实际宽度的dp与设计稿px的比例 ScreenUtil().scaleHeight; // 实际高度的dp与设计稿px的比例 modal_bottom_sheet 底部弹窗控件 https://pub.flutter-io.cn/packages/modal_bottom_sheet https://github.com/jamesblasco/modal_bottom_sheet 可以直接用系统控件，没必要用这个。 path_drawing 绘制虚线的工具 https://pub.flutter-io.cn/packages/path_drawing Path _path = Path(); Canvas canvas ; Paint _paint = Paint(); canvas.drawPath( dashPath(_path, dashArray: CircularIntervalList([10, 5])), // 每个线段长度、间隔长度 _paint); toast https://pub.flutter-io.cn/packages/toast Toast.show(\"Toast plugin app\", context, duration: Toast.LENGTH_SHORT, gravity: Toast.BOTTOM); Toast.show(msg, context, duration: duration, backgroundColor: backgroundColor, textColor: textColor, backgroundRadius: backgroundRadius, border: border); flutter_tts 语音播报 https://pub.flutter-io.cn/packages/flutter_tts ota_update 升级、 下载apk https://pub.flutter-io.cn/packages/ota_update cupertino_icons 一个icon图标库，具体怎么用 不知道。 https://pub.flutter-io.cn/packages/cupertino_icons equatable 用来简化 对象比较的一个库。 这个库内部做了一些处理，让我们简单地用 == 即可判断对象是否相等，不用重写hashcode。 https://pub.flutter-io.cn/packages/equatable dart 语法 dart 文件名和类名 可以不一样。这点跟Java不一样。 在变量中可以放置的所有东西都是对象，而每个对象都是类的实例。无论数字、函数和null都是对象。 如果要明确说明不需要任何类型，请使用[特殊类型dynamic]。 胖箭头语法 = >expr 语法是{return expr;}的简写写法。“=>”符号有时被称为胖箭头语法。 => expr 等同于{ return expr; } 可见性 // 可见性 ，public private 跟Java不一样 Dart没有公开、保护和私有的关键字。 如果标识符以下划线(_)开头，则该标识符对其库是私有的。 final 、const final和const区别 ： const可以使用其他const常量的值来初始化其值。 final dt = DateTime.now();//正确，运行时有确定的值 const dt = const DateTime.now();//错误，需要编译时有确定的值 // 初始化后不能再赋值 final a = 'aaa'; a = 'abc'; //错误 const b = 'bbb'; b = 'abc'; //错误 //不能和var同时使用 final var d = 'abc';//错误 const var e = 'abc';//错误 数字类型 // 数字类型 只有 int 和 double var one = int.parse('1'); var msg = 3.156.toString() ; var msg2 = 3.156.toStringAsFixed(2); 变量 的初始值 未初始化的变量的初始值为null。 甚至具有数字类型的变量最初也是null，因为数字，就像dart中的其他东西一样也是对象。 在Dart2中new关键字是可选的。 即 new 关键字可写可不写。 Dart是一种真正的面向对象语言，所以即使函数也是对象。 b ??= value; // 仅仅在b为空的情况下b被赋值value ，否则b的值不变 print(person ?.name) // person 为空 就直接返回null ，不为空 就返回 name的值 类型 判断 、转换 if (emp is Person) // 类型判断 is (emp as Person) // 类型转换 as 字符串 // 用r前缀创建一个原始字符串 (即 转义字符没有被转义) var msg1 = r'In a raw string, not even \\n gets special treatment.'; // 多行字符串 ，用 + 连接 ，或者是 带有单引号或双引号的三重引号 var msg1 = '''1111 222222 33333 '''; 字符串用 等号 == 来判断对象是否相等，跟Java不太一样。 var msg1 =\"abc1\" ; var msg2 =\"abc\"+\"1\" ; print(msg1==msg2) ; // true 函数 // 命名函数 ，可以带有默认值 void enableFlags( { int age =18, String myName } ) { print( \"age=$age ,name=$myName\") ; // age=20 ,name=aivin } // age 和 myName 在函数中已经定义了，相当于直接初始化，此处 age 不能写成其他 age1等 enableFlags( age: 20, myName: \"aivin\"); // 位置参数 void say(String from, String msg, [ int time]) { var result = '$from says $msg $time'; // aivin says 现在时间是: null print(result) ; } say('aivin' ,'现在时间是:' ) ; // 级联操作符 ，跟Java的链式调用差不多 Address address = Address(); address ..street = '北京市' ..number = '12' ..name = '西城区' 所有函数都返回一个值。如果没有指定返回值，则语句返回null;隐式附加到函数体。 // 匿名函数 Function showMsg = (int x, String y) { print(\"$x \"); }; 列表、数组 var list = [1, 2, 3]; // 可变列表、数组 var list2 = const [1, 2, 3]; // 常量列表 构造函数 // 构造函数 class Point { num x, y; Point(num x, num y) { this.x = x; this.y = y; } } 可以简写成 ---> class Point { num x, y; Point(this.x, this.y); // 语法糖，构造函数的简写 } --------------------------------------------------- class Point { num x, y; // 类名构造函数 Point(this.x, this.y); // 命名构造函数 Point.order(this.x,this.y); // 重定向构造函数， origin构造函数将外界的传值，指向给了order构造函数。 Point.origin(num a,num b):this.order(a,b); } --------------------------------------------------- class Person { String firstName; Person.fromJson(Map data) { print('in Person'); } } class Employee extends Person { // 调用父类构造函数， 语法与Java不一样。 // 先打印 in Person ， 后打印 in Employee Employee.fromJson(Map data) : super.fromJson(data) { print('in Employee'); } } main() { var emp = new Employee.fromJson({}); } 闭包 // java 闭包 ，用接口 和匿名函数 实现。-- 所谓闭包从表面看就是返回一个 函数 interface AaddFunc{ int addBy(int value); } public static AaddFunc createNewFunction(final int value){ return new AaddFunc() { @Override public int addBy(int addBy) { return value + addBy; } } ; } AaddFunc func = createNewFunction(1) ; int result =func.addBy(10) ; // dart 闭包 Function makeAdder( int addBy) { return (int value) { return addBy + value; } ; } var func1 = makeAdder(10); var result =func1(1); //11 三目运算符 dart 支持三目运算符。 参考Java mixin 特性 mixin 并不是一个关键字，只是一个普通的单词，意思是混合 Dart中，每个类（除了Object类）都只有一个超类。 但是我们有时需要多个父类的特性，可以用 with 来实现 minxin 特性。 class Walker { void walk() { print(\"I'm walking\"); } } class Fish { void swim() { print(\"I'm swimming\"); } } /** Person person = Person() ; person.walk() ; person.swim() ; */ class Person with Walker , Fish { } 异步函数 async await // 异步函数 async await Dart是单线程的语言， 在Dart1.9中加入了async和await关键字，有了这两个关键字， 我们可以更简洁的编写异步代码，而不需要调用Future相关的API（这种方法相对繁琐）。 用async标记，表示函数内部包含有需要延迟执行的代码。 有await标记的运算，其结果值都是一个Future对象 （马上返回）。 // 举个例子 就会明白 func(String callType) async { print('$callType = 方法内部 await 语句之前 '); await print('$callType = await 执行的语句 '); print('$callType = 方法内部 await 语句之后 '); } /* 1 方法 通过 awiat 调用 = 方法内部 await 语句之前 1 方法 通过 awiat 调用 = await 执行的语句 1 方法 通过 awiat 调用 = 方法内部 await 语句之后 1 --------------------------- 2 方法直接调用 = 方法内部 await 语句之前 2 方法直接调用 = await 执行的语句 2 ---------------------------- 2 方法直接调用 = 方法内部 await 语句之后 */ main( ) async { // await 方式调用异步方法 , 则会等异步方法执行完成后再执行后续的代码 await func('1 方法 通过 awiat 调用'); print('1 ---------------------------'); // 没有使用 await 方式调用异步方法，则异步方法执行到 await 处后等待 ( await所在的语句会调用，是在等待返回结果)，程序继续执行异步方法外的后续代码 func('2 方法直接调用'); print('2 ----------------------------'); } 生成器 // 同步生成器 Iterable 、 sync* 、yield Iterable getSyncGenerator(int n ) sync* { int k = n; while (k > 0) { yield k--; } } //异步生成器： Stream 、 async* 、 yield Stream getAsyncGenerator(int n) async* { int k = 0; while (k call 函数 类的 特殊函数 call () 。 实现call()方法可以让你的Dart类像函数一样被调用。 不习惯这样。暂仅做了解。 class Person { call(String a, String b ) { return '$a $b ' ; } } main() { var person = new Person(); var out = person(\"Hi\", \"aivin\" ); print('$out'); } “多进程”机制 Isolate // “多进程”机制 Isolate isolate是Dart平台对线程的实现方案，但和普通Thread不同的是，isolate拥有独立的内存，isolate由线程和独立内存构成。 由于isolate线程之间的内存不共享，所以isolate线程之间并不存在资源抢夺的问题，所以也不需要锁。 isolate线程之间的通信主要通过port来进行，这个port消息传递的过程是异步的。 isolate看起来其实和进程比较相似，之前请教阿里架构师宗心问题时， 宗心也说过“isolate的整体模型我自己的理解其实更像进程，而async、await更像是线程”。 如果对比一下isolate和进程的定义，会发现确实isolate很像是进程。 （这段话来自网络，我暂时没有用到过 Isolate ） 注解 // immutable 被 @immutable 注解标明的类或者子类都必须是不可变的 . 随机数 // 随机数 weatherType = WeatherType.values[Random().nextInt(WeatherType.values.length)]; 无版权 可以无限制使用！ all right reserved，powered by Gitbook该文件更新时间： 2020-12-24 10:19:45 "},"chinese/server/服务器部分.html":{"url":"chinese/server/服务器部分.html","title":"服务器部分","keywords":"","body":"服务器部分 tomcat 1、外网访问 tomcat，需要防火墙对 8080 端口放行。 2、tomcat 需要 jdk 的支持才能启动 tomcat 配置 https 用了腾讯云的免费证书 + tomcat9 。 https://cloud.tencent.com/document/product/400/4143 按照提示修改就行了。 并没有手动修改过tomcat的8080端口为80. 也没有手动对443端口放行 。 配置完之后可以检测一下443端口是否可用。 https://cloud.tencent.com/product/ssl linux 部署 多个 tomcat 修改server.xml配置文件, 三个地方 1 、port=\"18005\" port=\"18006\" 2、port=\"18080\" port=\"18081\" 3、port=\"18009\" port=\"18008\" 指定的服务未安装 unable to open the service tomcat7 进入Tomcat安装目录下的bin目录 输入 service.bat install 即可 在MyEclipse上点击部署按钮没反应 找到MyEclipse的工作路径，去“\\.metadata\\.plugins\\org.eclipse.core.runtime\\.settings” 找一个含有deploy的.prefs文件。 删除即可 (com.genuitec.eclipse.ast.deploy.core.prefs)。 重新启动MyEclipse。 springBoot 可以用 springBoot 快速搭建一个服务api 。 直接使用 IntelliJ 的 spring Initializr 引导新建项目。 1、IntelliJ IDEA 2、Tomcat 3、springBoot 4、mysql 5、mybatis // 项目发布war 本地调试jar https://blog.csdn.net/mimica247706624/article/details/60765730 因为我外网的tomcat配置了https，而且项目不大，所以所有的项目部署在同一个tomcat中。 但是本地仍然用内置的tomcat进行运行调试。 // 集成mybatis https://blog.csdn.net/gebitan505/article/details/54929287 springBoot 项目xml 配置 更加详细的配置可以参考托管在码云上的项目 4.0.0 com.aivin AivinInfo 1.0.0 war AivinInfo AivinInfo project for Spring Boot org.springframework.boot spring-boot-starter-parent 2.0.2.RELEASE UTF-8 UTF-8 1.8 org.springframework.boot spring-boot-starter-web org.mybatis.spring.boot mybatis-spring-boot-starter 1.3.2 mysql mysql-connector-java runtime org.springframework.boot spring-boot-starter-test test org.springframework.boot spring-boot-starter-tomcat provided--> javax.servlet javax.servlet-api com.github.pagehelper pagehelper 4.1.0 org.springframework.boot spring-boot-maven-plugin // 设置访问的端口 server.port=80 // mysql配置信息 spring.datasource.url=jdbc:mysql://xxxxx:3306/xxx?useUnicode=true&characterEncoding=UTF-8&useSSL=true spring.datasource.username=aivin spring.datasource.password=xxxxx spring.datasource.driver-class-name=com.mysql.jdbc.Driver // 拦截404 ，500等错误 spring.mvc.throw-exception-if-no-handler-found=true spring.resources.add-mappings=false redis redis 是一种数据库。 将常用数据存储在内存中(也支持持久化存储),提高查询速度 。 // Linux 安装 redis https://redis.io/download 下载安装包 tar -zxvf xxx cd 文件夹 make make install cd src redis-server // 用默认配置启动redis redis-server ./xxxx // 用指定的配置启动redis 验证是否启动成功 用另一个终端输入 redis-cli ，如果成功进入redis客户端 ，就说明启动正常 nginx nginx 的主要作用是反向代理 和负载均衡 。 ubuntu 下可以用 apt-get 的方式进行安装。 也可以去官网下载自己想要版本的源码，自己编译安装。 在linux上需要安装一些依赖库才能正确安装nginx。 安装依赖 apt-get update // 安装gcc g++的依赖库 apt-get install build-essential apt-get install libtool //安装pcre依赖库 apt-get install libpcre3 libpcre3-dev //安装zlib依赖库 apt-get install zlib1g-dev ///安装SSL依赖库 apt-get install openssl 安装 Nginx // 去官网找到最版本的下载链接 下载并解压 wget http://nginx.org/download/nginx-xxx.tar.gz tar -zxvf nginx-xxx.gz //进入解压目录 并配置配置 cd nginx-xxx ./configure --prefix=/usr/local/nginx make //编译 sudo make install //安装 //配置软链接 sudo ln -s /usr/local/nginx/sbin/nginx /usr/bin/nginx // 启动 nginx nginx -c /usr/local/nginx/conf/nginx.conf (注意：-c 指定配置文件的路径，不加的话，nginx会自动加载默认路径的配置文件) nginx -s stop //停止nginx ps -ef | grep nginx // 查看nginx进程 , 验证nginx是否启动成功了。 nginx的默认端口是80 ，可以用浏览器访问服务器地址 ， 如果有welcome信息 说明启动成功。 nginx 配置 指向 tomcat http{}节点之间添加upstream配置。 myServerHost 这个随便写，后面要用到。 upstream myServerHost { server 127.0.0.1:18080; server 127.0.0.1:18081; } 然后在 location 节点中配置 proxy_pass location / { root html; index index.html index.htm; proxy_pass http://myServerHost; } 然后重启 nginx 即可。 jenkins jenkins官网 https://jenkins.io/index.html //启动时指定端口 java -jar jenkins.war --httpPort=8082 //停止jenkins net stop jenkins 持续集成（Continuous integration，CI） 指的是频繁地（一天多次）将代码集成到主干。 它的好处主要有两 1、快速发现错误。 每完成一点更新，就集成到主干，可以快速发现错误，定位错误也比较容易。 \"持续集成并不能消除Bug，而是让它们非常容易发现和改正。\" 2、防止分支大幅偏离主干。 如果不是经常集成，主干又在不断更新，会导致以后集成的难度变大，甚至难以集成。 持续交付（Continuous delivery） 可以看作持续集成的下一步。 不管怎么更新，软件是随时随地可以交付的。 持续部署的目标是，代码在任何时刻都是可部署的，可以进入生产阶段。 mysql 复制表数据到新表 sql INSERT INTO 新表(字段1,字段2,…….) SELECT 字段1,字段2,…… FROM 旧表 CREATE TABLE 新表 LIKE 旧表 INSERT INTO recommendpicvdebug SELECT * FROM recommendpicv3 多表合并去重 sql InnoDB 和 MyISAM。选择为MyISAM。 INSERT INTO userall SELECT t.uid, t.userName FROM starbeaninfo4 t WHERE t.uid NOT IN ( SELECT uid FROM userall ) 让id从1开始自动增长 sql truncate table test 分页查询 sql SELECT * FROM newsentity_table WHERE (usertype = 'base' OR usertype = 'salse') AND logindate IS NOT NULL ORDER BY logindate DESC LIMIT 起始行, 每页多少行 增加记录 public class DBUtil{ public static void closeConection(Connection conn, ResultSet rs, PreparedStatement pstm) throws SQLException{ if (rs != null) { rs.close(); } if (pstm != null) { pstm.close(); } if ((conn != null) && (!conn.isClosed())) try { conn.close(); } catch (Exception e) { e.printStackTrace(); } } public static Connection getConnection() { Connection conn = null; String URL = \"jdbc:mysql://114.67.234.65:3306/aivininfo?useUnicode=true&characterEncoding=UTF-8&useSSL=true\"; try{ Class.forName(\"org.gjt.mm.mysql.Driver\"); conn = DriverManager.getConnection(URL, \"aivin\", \"Hnyer88888888\"); } catch (Exception e) { e.printStackTrace(); } return conn; } } public class MyDbHelper { Connection conn; PreparedStatement pstm = null; ResultSet rs = null; String sqlStr; public int addRecommendPicRecord(String title, String content) { boolean addUserSuccess = true; long addedRecodeId = -1L; this.conn = DBUtil.getConnection(); this.sqlStr = \"insert into aivinblog ( blogTitle , blogContent ,updateTime) values ( ? ,? ,?)\"; try { this.pstm = this.conn.prepareStatement(this.sqlStr, Statement.RETURN_GENERATED_KEYS); this.pstm.setString(1, title); this.pstm.setString(2, content); this.pstm.setString(3, getCurrentDataStr()); addUserSuccess = this.pstm.executeUpdate() > 0; ResultSet rs = this.pstm.getGeneratedKeys(); if (rs.next()) addedRecodeId = rs.getLong(1); } catch (SQLException e) { e.printStackTrace(); } finally { } try { DBUtil.closeConection(this.conn, this.rs, this.pstm); } catch (SQLException e) { e.printStackTrace(); } return (int) addedRecodeId; } public String getCurrentDataStr() { DateFormat dateFormat = new SimpleDateFormat(\"yyyy-MM-dd\", Locale.getDefault()); String reslut = dateFormat.format(new Date()); return reslut; }// } 无版权 可以无限制使用！ all right reserved，powered by Gitbook该文件更新时间： 2020-12-24 08:42:30 "},"chinese/webDev/web部分.html":{"url":"chinese/webDev/web部分.html","title":"web部分","keywords":"","body":"html5 标签元素 名字 说明 abbr 用来指明这是简称或缩写，比如 \"WWW\" 。 标记后能够为浏览器、搜索引擎提供有用的信息。 acronym 标签定义首字母缩写。标记后能够为浏览器、搜索引擎提供有用的信息。 address 定义文档或文章的作者/拥有者的联系信息 applet 一个嵌入的 Java applet 。 HTML5 中不支持 applet 标签。请使用 object 元素 标签代替。 area 标签定义图像映射中的区域 article 标签规定独立的自包含内容。一篇文章应有其自身的意义，应该有可能独立于站点的其余部分对其进行分发。 aside 定义其所处内容之外的内容。 aside 的内容应该与附近的内容相关 audio 定义声音 b 粗体文本 base 为页面上的所有链接规定默认地址或默认目标。 basefont 标签定义基准字体。该标签可以为文档中的所有文本定义默认字体颜色、字体大小和字体系列。 bdi 允许设置一段文本，使其脱离其父元素的文本方向设置 bdo 定义文字的方向 big 大号字体效果 blockquote 定义块引用 body 定义文档的主体 br 换行 button 按钮 canvas 画布 ，可以在这上面绘制内容 caption 定义表格标题 center 对其所包括的文本进行水平居中 cite 定义引用 code 定义计算机代码文本 col 用在表格中，设置每一列的样式 ,一个表格里面只写一次 colgroup 用于对表格中的列进行组合，以便对其进行格式化 command 表示用户能够调用的命令 datalist 定义选项列表。 与 input 元素配合使用该元素，来定义 input 可能的值。 dd 在定义列表中定义条目的定义部分 del 定义文档中已被删除的文本 dfn 定义一个定义项目 dialog 定义对话框或窗口 dir 定义目录列表 。 不赞成使用这个标签 div 层 。把文档分割为独立的、不同的部分。它可以用作严格的组织工具，并且不使用任何格式与其关联。 dl 定义了定义列表 dt 定义了定义列表中的项目 em 把文本定义为强调的内容 embed 定义嵌入的内容，比如插件 fieldset 将表单内的相关元素分组 figcaption 定义 figure 元素的标题 figure 规定独立的流内容（图像、图表、照片、代码等等）。 figure 元素的内容应该与主内容相关，但如果被删除，则不应对文档流产生影响。 font 规定文本的字体、字体尺寸、字体颜色 footer 定义文档或节的页脚 form 表单 frame 定义 frameset 中的一个特定的窗口（框架） frameset 用来包含 frame h1 ... h6 不同级别的 标题 head 文档的头部 header 定义文档的页眉（介绍信息） hr 创建一条水平线 html 告知浏览器其自身是一个 HTML 文档 i 斜体文本效果 iframe 创建包含另外一个文档的内联框架（即行内框架） img 嵌入一幅图像 input 标签用于搜集用户信息。 根据不同的 type 属性值，输入字段拥有很多种形式。 文本字段、复选框 、单选按钮、按钮等 ins 大多数浏览器会改写为删除文本和下划线文本。 一些老式的浏览器会把删除文本和下划线文本显示为普通文本。 kbd 定义键盘文本 keygen 用于表单的密钥对生成器字段 label label 不会向用户呈现任何特殊效果。不过，它为鼠标用户改进了可用性。如果你在 label 元素内点击文本，就会触发此控件。 legend 为 fieldset 元素定义标题 li 定义列表项目 ， 可用在有序列表 ol 和无序列表 ul 中 link 导入外部资源 ，css等 main 规定文档的主要内容 map 带有可点击区域的图像映射 。例如指定图片的哪些区域可以点击就跳转 mark 定义带有记号的文本 menu 用于上下文菜单、工具栏以及用于列出表单控件和命令 menuitem 定义用户可以从弹出菜单调用的命令/菜单项目 meta 可提供有关页面的元信息 ，比如针对搜索引擎和更新频度的描述和关键词。 meter 进度条 nav 定义导航链接的部分 noframes 为那些不支持框架的浏览器显示文本 noscript 用来定义在脚本未被执行时的替代内容 object 定义一个嵌入的对象 ol 有序列表 optgroup 定义选项组 option 定义下拉列表中的一个选项 output 定义不同类型的输出 p 定义段落 param 为object标签提供嵌入内容的运行时参数的name与value对 pre 定义预格式化的文本 progress 有动画的进度条 q 定义短的引用 rp 在 ruby 注释中使用，以定义不支持 ruby 元素的浏览器所显示的内容。 rt 定义字符（中文注音或字符）的解释或发音。 ruby 定义 ruby 注释（中文注音或字符） samp 定义样本文本 script 插入一段 JavaScript section HTML 5 中的新标签。 定义文档中的节（section、区段）。比如章节、页眉、页脚或文档中的其他部分。 select 单选或多选菜单 small 小号字体效果 source 音频播放器 span span随内容而占用高宽空间（紧贴内容），而一对div标签却占用一行。 strike 加删除线文本 s 是 strike 标签的缩写版本 ， 定义加删除线文本定义 strong 定义为语气更强的强调的内容 style 定义样式 details 当与标记配合使用时，在单击标记后才会显示元素中设置的内容。 summary 当与标记配合使用时，在单击标记后才会显示元素中设置的内容。 textarea 多行的文本输入控件 sub 上标 sup 下标 table 表格 tbody 表格主体 thead 定义表格的表头 tfoot 定义表格的页脚（脚注或表注） tr 定义简单的表格，行 th 定义简单的表格， 表头的列 td 定义简单的表格， 普通行的列 time 不会在任何浏览器中呈现任何特殊效果。为搜索引擎提供有用信息 title 文档的标题 track 播放带有字幕的视频 tt 呈现类似打字机或者等宽的文本效果 u 为文本添加下划线 ul 无序列表 var 定义变量 video 定义视频 wbr br 表示必须换行。 而 wbr 表示在浏览器宽度足够的情况下，不换行；在宽度不足的情况下，在加了wbr 处主动换行。 HTML 全局属性 属性名字 说明 accesskey 规定激活元素的快捷键。 class 规定元素的一个或多个类名（引用样式表中的类）。 contenteditable 规定元素内容是否可编辑。 contextmenu 规定元素的上下文菜单。上下文菜单在用户点击元素时显示。 data-* 用于存储页面或应用程序的私有定制数据。 dir 规定元素中内容的文本方向。 draggable 规定元素是否可拖动。 dropzone 规定在拖动被拖动数据时是否进行复制、移动或链接。 hidden 规定元素仍未或不再相关。 id 规定元素的唯一 id。 lang 规定元素内容的语言。 spellcheck 规定是否对元素进行拼写和语法检查。 style 规定元素的行内 CSS 样式。 tabindex 规定元素的 tab 键次序。 title 规定有关元素的额外信息。 translate 规定是否应该翻译元素内容。 HTML 事件属性 Window 事件属性 名字 说明 onafterprint 文档打印之后运行的脚本。 onbeforeprint 文档打印之前运行的脚本。 onbeforeunload 文档卸载之前运行的脚本。 onerror 在错误发生时运行的脚本。 onhaschange 当文档已改变时运行的脚本。 onload 页面结束加载之后触发。 onmessage 在消息被触发时运行的脚本。 onoffline 当文档离线时运行的脚本。 ononline 当文档上线时运行的脚本。 onpagehide 当窗口隐藏时运行的脚本。 onpageshow 当窗口成为可见时运行的脚本。 onpopstate 当窗口历史记录改变时运行的脚本。 onredo 当文档执行撤销（redo）时运行的脚本。 onresize 当浏览器窗口被调整大小时触发。 onstorage 在 Web Storage 区域更新后运行的脚本。 onundo 在文档执行 undo 时运行的脚本。 onunload 一旦页面已下载时触发（或者浏览器窗口已被关闭）。 Form 事件 名字 说明 onblur 元素失去焦点时运行的脚本。 onchange 在元素值被改变时运行的脚本。 oncontextmenu 当上下文菜单被触发时运行的脚本。 onfocus 当元素获得焦点时运行的脚本。 onformchange 在表单改变时运行的脚本。 onforminput 当表单获得用户输入时运行的脚本。 oninput 当元素获得用户输入时运行的脚本。 oninvalid 当元素无效时运行的脚本。 onreset 当表单中的重置按钮被点击时触发。HTML5 中不支持。 onselect 在元素中文本被选中后触发。 onsubmit 在提交表单时触发。 Keyboard 事件 名字 说明 onkeydown 在用户按下按键时触发。 onkeypress 在用户敲击按钮时触发。 onkeyup 当用户释放按键时触发。 Mouse 事件 名字 说明 onclick 元素上发生鼠标点击时触发。 ondblclick 元素上发生鼠标双击时触发。 ondrag 元素被拖动时运行的脚本。 ondragend 在拖动操作末端运行的脚本。 ondragenter 当元素元素已被拖动到有效拖放区域时运行的脚本。 ondragleave 当元素离开有效拖放目标时运行的脚本。 ondragover 当元素在有效拖放目标上正在被拖动时运行的脚本。 ondragstart 在拖动操作开端运行的脚本。 ondrop 当被拖元素正在被拖放时运行的脚本。 onmousedown 当元素上按下鼠标按钮时触发。 onmousemove 当鼠标指针移动到元素上时触发。 onmouseout 当鼠标指针移出元素时触发。 onmouseover 当鼠标指针移动到元素上时触发。 onmouseup 当在元素上释放鼠标按钮时触发。 onmousewheel 当鼠标滚轮正在被滚动时运行的脚本。 onscroll 当元素滚动条被滚动时运行的脚本。 Media 事件 名字 说明 onabort 在退出时运行的脚本。 oncanplay 当文件就绪可以开始播放时运行的脚本（缓冲已足够开始时）。 oncanplaythrough 当媒介能够无需因缓冲而停止即可播放至结尾时运行的脚本。 ondurationchange 当媒介长度改变时运行的脚本。 onemptied 当发生故障并且文件突然不可用时运行的脚本（比如连接意外断开时）。 onended 当媒介已到达结尾时运行的脚本（可发送类似“感谢观看”之类的消息）。 onerror 当在文件加载期间发生错误时运行的脚本。 onloadeddata 当媒介数据已加载时运行的脚本。 onloadedmetadata 当元数据（比如分辨率和时长）被加载时运行的脚本。 onloadstart 在文件开始加载且未实际加载任何数据前运行的脚本。 onpause 当媒介被用户或程序暂停时运行的脚本。 onplay 当媒介已就绪可以开始播放时运行的脚本。 onplaying 当媒介已开始播放时运行的脚本。 onprogress 当浏览器正在获取媒介数据时运行的脚本。 onratechange 每当回放速率改变时运行的脚本（比如当用户切换到慢动作或快进模式）。 onreadystatechange 每当就绪状态改变时运行的脚本（就绪状态监测媒介数据的状态）。 onseeked 当 seeking 属性设置为 false（指示定位已结束）时运行的脚本。 onseeking 当 seeking 属性设置为 true（指示定位是活动的）时运行的脚本。 onstalled 在浏览器不论何种原因未能取回媒介数据时运行的脚本。 onsuspend 在媒介数据完全加载之前不论何种原因终止取回媒介数据时运行的脚本。 ontimeupdate 当播放位置改变时（比如当用户快进到媒介中一个不同的位置时）运行的脚本。 onvolumechange 每当音量改变时（包括将音量设置为静音）时运行的脚本。 onwaiting 当媒介已停止播放但打算继续播放时（比如当媒介暂停已缓冲更多数据）运行脚本 HTML 5 视频/音频 API HTML5 DOM 为 和 元素提供了方法、属性和事件。 这些方法、属性和事件允许你使用 JavaScript 来操作 和 元素。 HTML5 Audio/Video 属性 名字 说明 audioTracks 返回表示可用音轨的 AudioTrackList 对象 autoplay 设置或返回是否在加载完成后随即播放音频/视频 buffered 返回表示音频/视频已缓冲部分的 TimeRanges 对象 controller 返回表示音频/视频当前媒体控制器的 MediaController 对象 controls 设置或返回音频/视频是否显示控件（比如播放/暂停等） crossOrigin 设置或返回音频/视频的 CORS 设置 currentSrc 返回当前音频/视频的 URL currentTime 设置或返回音频/视频中的当前播放位置（以秒计） defaultMuted 设置或返回音频/视频默认是否静音 defaultPlaybackRate 设置或返回音频/视频的默认播放速度 duration 返回当前音频/视频的长度（以秒计） ended 返回音频/视频的播放是否已结束 error 返回表示音频/视频错误状态的 MediaError 对象 loop 设置或返回音频/视频是否应在结束时重新播放 mediaGroup 设置或返回音频/视频所属的组合（用于连接多个音频/视频元素） muted 设置或返回音频/视频是否静音 networkState 返回音频/视频的当前网络状态 paused 设置或返回音频/视频是否暂停 playbackRate 设置或返回音频/视频播放的速度 played 返回表示音频/视频已播放部分的 TimeRanges 对象 preload 设置或返回音频/视频是否应该在页面加载后进行加载 readyState 返回音频/视频当前的就绪状态 seekable 返回表示音频/视频可寻址部分的 TimeRanges 对象 seeking 返回用户是否正在音频/视频中进行查找 src 设置或返回音频/视频元素的当前来源 startDate 返回表示当前时间偏移的 Date 对象 textTracks 返回表示可用文本轨道的 TextTrackList 对象 videoTracks 返回表示可用视频轨道的 VideoTrackList 对象 volume 设置或返回音频/视频的音量 HTML5 Audio/Video 方法 名字 说明 addTextTrack() 向音频/视频添加新的文本轨道 canPlayType() 检测浏览器是否能播放指定的音频/视频类型 load() 重新加载音频/视频元素 play() 开始播放音频/视频 pause() 暂停当前播放的音频/视频 HTML5 Audio/Video 事件 名字 | 说明 -|- abort | 当音频/视频的加载已放弃时 canplay | 当浏览器可以播放音频/视频时 canplaythrough | 当浏览器可在不因缓冲而停顿的情况下进行播放时 durationchange | 当音频/视频的时长已更改时 emptied | 当目前的播放列表为空时 ended| 当目前的播放列表已结束时 error | 当在音频/视频加载期间发生错误时 loadeddata| 当浏览器已加载音频/视频的当前帧时 loadedmetadata | 当浏览器已加载音频/视频的元数据时 loadstart | 当浏览器开始查找音频/视频时 pause | 当音频/视频已暂停时 play | 当音频/视频已开始或不再暂停时 playing | 当音频/视频在已因缓冲而暂停或停止后已就绪时 progress| 当浏览器正在下载音频/视频时 ratechange| 当音频/视频的播放速度已更改时 seeked | 当用户已移动/跳跃到音频/视频中的新位置时 seeking | 当用户开始移动/跳跃到音频/视频中的新位置时 stalled | 当浏览器尝试获取媒体数据，但数据不可用时 suspend | 当浏览器刻意不获取媒体数据时 timeupdate| 当目前的播放位置已更改时 volumechange | 当音量已更改时 waiting | 当视频由于需要缓冲下一帧而停止 HTML 5 Canvas API HTML5 标签用于绘制图像 ，用JavaScript等脚本 。 canvas仅仅是图形的容器 ，你必须使用脚本来完成实际的绘图任务。 Internet Explorer 8 以及更早的版本不支持 元素。 颜色、样式和阴影 名字 说明 fillStyle 设置或返回用于填充绘画的颜色、渐变或模式 strokeStyle 设置或返回用于笔触的颜色、渐变或模式 shadowColor 设置或返回用于阴影的颜色 shadowBlur 设置或返回用于阴影的模糊级别 shadowOffsetX 设置或返回阴影距形状的水平距离 shadowOffsetY 设置或返回阴影距形状的垂直距离 createLinearGradient() 创建线性渐变（用在画布内容上） createPattern() 在指定的方向上重复指定的元素 createRadialGradient() 创建放射状/环形的渐变（用在画布内容上） addColorStop() 规定渐变对象中的颜色和停止位置 线条样式 名字 说明 lineCap 设置或返回线条的结束端点样式 lineJoin 设置或返回两条线相交时，所创建的拐角类型 lineWidth 设置或返回当前的线条宽度 miterLimit 设置或返回最大斜接长度 矩形 名字 说明 rect() 创建矩形 fillRect() 绘制“被填充”的矩形 strokeRect() 绘制矩形（无填充） clearRect() 在给定的矩形内清除指定的像素 路径 名字 说明 fill() 填充当前绘图（路径） stroke() 绘制已定义的路径 beginPath() 起始一条路径，或重置当前路径 moveTo() 把路径移动到画布中的指定点，不创建线条 closePath() 创建从当前点回到起始点的路径 lineTo() 添加一个新点，然后在画布中创建从该点到最后指定点的线条 clip() 从原始画布剪切任意形状和尺寸的区域 quadraticCurveTo() 创建二次贝塞尔曲线 bezierCurveTo() 创建三次方贝塞尔曲线 arc() 创建弧/曲线（用于创建圆形或部分圆） arcTo() 创建两切线之间的弧/曲线 isPointInPath() 如果指定的点位于当前路径中，则返回 true，否则返回 false 转换 名字 说明 scale() 缩放当前绘图至更大或更小 rotate() 旋转当前绘图 translate() 重新映射画布上的 (0,0) 位置 transform() 替换绘图的当前转换矩阵 setTransform() 将当前转换重置为单位矩阵。然后运行 transform() 文本 名字 说明 font 设置或返回文本内容的当前字体属性 textAlign 设置或返回文本内容的当前对齐方式 textBaseline 设置或返回在绘制文本时使用的当前文本基线 fillText() 在画布上绘制“被填充的”文本 strokeText() 在画布上绘制文本（无填充） measureText() 返回包含指定文本宽度的对象 图像绘制 名字 说明 drawImage() 向画布上绘制图像、画布或视频 像素操作 名字 说明 width 返回 ImageData 对象的宽度 height 返回 ImageData 对象的高度 data 返回一个对象，其包含指定的 ImageData 对象的图像数据 createImageData() 创建新的、空白的 ImageData 对象 getImageData() 返回 ImageData 对象，该对象为画布上指定的矩形复制像素数据 putImageData() 把图像数据（从指定的 ImageData 对象）放回画布上 合成 名字 说明 globalAlpha 设置或返回绘图的当前 alpha 或透明值 globalCompositeOperation 设置或返回新图像如何绘制到已有的图像上 其他 名字 说明 save() 保存当前环境的状态 restore() 返回之前保存过的路径状态和属性 createEvent() getContext() toDataURL() js 是一种动态类型语言，变量没有类型限制。 变量的类型没法在编译阶段就知道，必须等到运行时才能知道。 各种运算符对数据类型是有要求的。 如果运算符发现，运算子的类型与预期不符，就会自动转换类型。 js严格模式 ECMAscript 5添加了“严格模式”。 这种模式使得JavaScript在更合理，更安全、更严禁的条件下执行。 //f1.js 'use strice'; //指明使用 严格模式运行 数据类型 // 数值 整数和小数（比如1和3.14） // 字符串 比如Hello World // 布尔值 true、false // undefined 表示“未定义”或不存在，即由于目前没有定义，所以此处暂时没有任何值 // null 表示空值，即此处的值为空。 // 对象 可以分成三个子类型。狭义的对象、数组、函数 。 类型转换 自动转换具有不确定性，而且不易除错，建议在预期为布尔值、数值、字符串的地方， 使用Boolean、Number和String函数进行显式转换。 //Number函数强制转换 Number(324) // 324 Number('324') // 324 Number('324abc') // NaN Number('') // 0 Number(true) // 1 Number(false) // 0 Number(undefined) // NaN Number(null) // 0 Number({a: 1}) // NaN Number([1, 2, 3]) // NaN Number([5]) // 5 Number({}) // NaN //String 函数强制转换 String(123) // \"123\" String('abc') // \"abc\" String(true) // \"true\" String(undefined) // \"undefined\" String(null) // \"null\" String({a: 1}) // \"[object Object]\" String([1, 2, 3]) // \"1,2,3\" //Boolean 函数强制转换 Boolean(undefined) // false Boolean(null) // false Boolean(0) // false Boolean(NaN) // false Boolean('') // false Boolean({}) // true Boolean([]) // true Boolean(new Boolean(false)) // true 变量提升 js 中，函数及变量的声明都会被系统提升到函数的最顶部。 也就是说变量可以先使用再声明。 x = 5; // 先使用 var x; // 再声明 区块 使用大括号，将多个相关的语句组合在一起，称为“区块” 。 对于var命令来说，JavaScript 的区块不构成单独的作用域 。 { var a = 1; } 表达式、语句 JavaScript中的表达式和语句是有区别的。 一个表达式会产生一个值 。 语句可以理解成一个行为，循环语句和if语句就是典型的语句。 运算符 指数运算符 ** 2 ** 4 // 16 比较 // == 两边值类型不同的时候，先进行类型转换，再比较； // === 严格比较运算符，不做类型转换，类型不同就是不等； // Object.is('a', 'a') 行为与===基本一致。 除了： +0不等于-0 ， NaN等于自身。 if else 条件语句 if (m === 3) { } else { } switch 语句 var x = 1; switch (x) { case 1: break ; default: break ; } for 循环 for (var i = 0; i while 循环 var i = 0; while (i do ... while 循环 do { ... } while (条件); break 、continue break语句用于跳出代码块或循环。 continue语句用于立即终止本轮循环，返回循环结构的头部，开始下一轮循环。 三元运算符 var myVar; console.log( myVar ? 'myVar has a value' : 'myVar does not have a value' ) label标签 标签通常与break语句和continue语句配合使用，跳出特定的循环。 top: for (var i = 0; i 异常捕捉 var txt=\"\"; function message() { try { adddlert(\"Welcome guest!\"); } catch(err) { txt+=\"错误 \" + err.message ; } } 表单验证 onsubmit=\"return validateForm()\" method=\"post\" function validateForm() { var x = document.forms[\"myForm\"][\"fname\"].value; if (x == null || x == \"\") { alert(\"需要输入名字。\"); return false; } } typeof 用来确定一个值的类型 typeof 123 // \"number\" typeof '123' // \"string\" typeof false // \"boolean\" function f() {} typeof f // \"function\" typeof undefined // \"undefined\" v // 没有被声明过 typeof v // \"undefined\" typeof window // \"object\" typeof {} // \"object\" typeof [] // \"object\" 对象 对象就是一组“键值对”的集合， 是一种无序的复合数据集合。 对象 和代码块 都采用大括号表示。 为了避免这种歧义，V8 引擎规定， 如果行首是大括号，一律解释为对象。 不过，为了避免歧义，最好在大括号前加上圆括号。 ({ foo: 123}) var obj = { foo: 'Hello', bar: 'World' }; //with 语句 操作同一个对象的多个属性时，简化代码 with (document.links[0]){ console.log(href); console.log(title); console.log(style); } 函数 如果同一个函数被多次声明，后面的声明就会覆盖前面的声明。 注意： 定义函数时，是不需要指定参数的类型的 js有三种声明函数的方法。 1、 function 命令 function print(s) { } 2、函数表达式（采用变量赋值的写法） var print = function(s) { }; 或 var print = function x(){ // 这种写法的用处有两个，一是可以在函数体内部调用自身， //二是方便除错（除错工具显示函数调用栈时，将显示函数名， //而不再显示这里是一个匿名函数 }; 3、 利用关键字 Function 构造函数 不建议使用这种方式 var add = new Function( 'x', 'y', 'return x + y' ); function f1() {} // name属性返回函数名字 f1.name // length属性 返回 函数定义时的参数个数。 f.length // 函数参数不是必需的， js 允许省略参数。 function f(a, b) { return a; } f(1, 2, 3) // 1 f(1) // 1 f() // undefined f(undefined, 1) // undefined f( , 1) // 报错 // 在函数内部可以使用 arguments对象来获得所有的参数 var f = function(a, b) { console.log(arguments[0]); console.log(arguments[1]); console.log(arguments[2]); return a + b; } IIFE 立即执行函数 Immediately-Invoked Function Expression 在 js 中， ()是一种运算符，跟在函数名之后，表示调用该函数。 最外层加一个小括号是为了保护变量的作用域 (function(a, b){ console.log(a + b); })(1, 2) // 最后的小括号是表示立即执行这个函数，并传入参数 函数闭包 函数内部可以访问外部变量，函数外部不能访问函数内的变量 。 为了实现 外部代码可以访问函数内部的局部变量，我们设计了闭包机制。 function f1(){ var n=100 ; function f2(){ // 拿着f1的局部变量n做一些事情... } // 将内部函数返回 return f2 ; } // 使用闭包 var f3 = f1() ; // 注意，不是 f3= f1 f3() ; // 相当于执行了 f2() 题外话： 个人感觉闭包这个东西设计的有点反人类。 eval 命令 eval命令接受一个字符串作为参数，并将这个字符串当作语句执行。 eval没有自己的作用域，都在当前作用域内执行 。 //eval 的别 var m = eval; m('var x = 1'); 为了保证eval的别名不影响代码优化 , js 的标准规定，凡是使用别名执行eval，eval内部一律是全局作用域。 Object 对象 JavaScript 的所有其他对象都继承自Object对象 。 //返回空对象 var obj = Object();// undefined / null 如果Object方法的参数是一个对象，它总是返回该对象，即不用转换。 // 返回对象的所有属性名 Object.keys(obj) ; Object.getOwnPropertyNames(obj) // 获取某个属性的描述对象 Object.getOwnPropertyDescriptor(obj, 'p') //属性描述对象 attributes object js 提供了一个内部数据结构，用来描述对象的属性 。每个属性都有自己对应的属性描述对象。 { value: 123, // 该属性的属性值，默认为undefined。 writable: false, // value 是否可改变 ，默认 true。 enumerable: true, // 是否可遍历，默认 true。如果 为false，会使for循环操作等跳过该属性。 configurable: false, // 控制了属性描述对象的可写性 get: undefined, // 该属性的取值函数 set: undefined // 该属性的存值函数 } Array 数组 Array构造函数有一个很大的缺陷: 就是不同的参数，会导致它的行为不一致。 因此，不建议使用构造函数生成新数组。 var arr = new Array(1, 2);// bad var arr = [1, 2];// good Array.isArray(arr); // 判断是否是数组类型 var arr = []; arr.push(1) // 添加元素 arr.pop() // 删除最后一个元素，并返回该元素。 arr.shift() // 删除数组的第一个元素，并返回该元素 arr.shift() // 遍历并清空一个数组 arr.unshift('x'); // 在数组的第一个位置添加元素 arr.join(' | ') // 指定参数作为分隔符，将所有数组成员连接为一个字符串返回。 ['hello'].concat(['world']) // 用于多个数组的合并 arr.reverse() // 颠倒排列数组元素 arr.slice(start, end); // 提取目标数组的一部分，返回一个新数组 arr.splice(start, count, addElement1, addElement2, ...); // 删除原数组的一部分成员，并可以在删除的位置添加新的数组成员 [11, 101].sort() ;// 按照字典顺序排序 // 将数组的所有成员依次传入指定函数，然后把每一次的执行结果组成一个新数组返回。 arr.map(function (n) { return n + 1; }); 字符串 String // 是否匹配某个子字符串，返回一个数组 'cat, bat, sat, fat'.match('at') // [\"at\"] // 小于0: 一个字符串 第二个字符串。 'apple'.localeCompare('banana') // -1 JSON 转换 // 将一个值转为 JSON 字符串 JSON.stringify({ name: \"张三\" }) // 将 json 字符串转换成对应的值 var o = JSON.parse('{\"name\": \"张三\"}'); o.name // 张三 其他 表示url的内容通过js执行。void(0)表示不作任何操作，这样会防止链接跳转到其他页面。 这么做往往是为了保留链接的样式，但不让链接执行实际操作， 点击 点击后会回到网面顶部 //刷新 location.reload() ; window.location.reload() ; 事件监听 // 添加 监听函数 button.addEventListener('click', hello, false); // 移除监听函数 button.removeEventListener('click', listener, false); // 在当前节点上触发指定事件，从而触发监听函数的执行 xx.dispatchEvent(event); 鼠标事件 名称 说明 click 单击 dblclick 双击 mousedown 按下鼠标键时触发。 mouseup 释放按下的鼠标键 mousemove 当鼠标在一个节点内部移动时触发 mouseenter 进入一个节点时触发 ，进入子节点不会触发这个事件 mouseover 进入一个节点时触发 ， 进入子节点会再一次触发这个事件 mouseout 离开一个节点时触发，离开父节点也会触发这个事件 mouseleave 离开一个节点时触发 ，离开父节点不会触发这个事件 contextmenu 按下鼠标右键时 wheel 滚动鼠标的滚轮时触发 键盘事件 名称 说明 keydown 按下键盘 keypress 按下有值的键时触发， 即按下 Ctrl、Alt、Shift、Meta 这样无值的键，这个事件不会触发。 keyup 松开键盘时触发该事件 表单事件 名称 说明 input 只要值发生变化，也会触发 select Change invalid reset submit 触摸事件 Touch ：一个触摸点 . TouchList：多个触摸点的集合 TouchEvent：触摸引发的事件实例 其他事件 名称 说明 beforeunload 在窗口、文档、各种资源将要卸载前触发 unload 在窗口关闭或者document对象将要卸载时触发 load 在页面或某个资源加载成功时触发 error 在页面或资源加载失败时触发 pageshow 在页面加载时触发 pagehide 当用户通过“前进/后退”按钮，离开当前页面时触发 popstate hashchange readystatechange scroll 在文档或文档元素滚动时触发 resize 在改变浏览器窗口大小时触发 fullscreenchange 进入或退出全屏状态时触发 fullscreenerror 在浏览器无法切换到全屏状态时触发 cut 将选中的内容从文档中移除，加入剪贴板时触发。 copy 进行复制动作时触发。 paste 剪贴板内容粘贴到文档后触发 focus 元素节点获得焦点后触发，该事件不会冒泡。 blur 元素节点失去焦点后触发，该事件不会冒泡。 focusin 元素节点将要获得焦点时触发，发生在focus事件之前。该事件会冒泡。 focusout 元素节点将要失去焦点时触发，发生在blur事件之前。该事件会冒泡。 拖拉事件 拖拉指的是，用户在某个对象上按下鼠标键不放， 拖动它到另一个位置，然后释放鼠标键，将该对象放在那里。 draggable属性可用于任何元素节点 。图片和链接默认可以拖拉。 一旦某个元素节点 draggable=true，就无法再用鼠标选中该节点内部的文字或子节点了。 css cssref css 引入 // 外部样式表 // 内部样式表 hr {color: sienna;} ... // 内联样式 内联样式会损失掉样式表的许多优势。请慎用。 This is a paragraph css 优先级 同一元素同时使用Style,ID,Class来指定样式. style > id > class 如果是不同元素,还需要看元素父层级的样式: 1.子元素自身有样式,以自身的为准. 2.子元素未设定样式,此时如果父元素有定义的话套用父元素的样式否则以默认显示 css 选择器 // 单个元素选择器 body { // 颜色声明 color: #000; // 背景声明 background: #fff; } // 元素分组 选择器 h1,h2,h3,h4,h5,h6 { color: green; } // 派生选择器 常与id选择器、类选择器一起使用，可以更方便地定义局部的css. 重新定义id为sidebar下的 strong属性 sidebar strong { font-style: italic; font-weight: normal; } // id 选择器 ,用 # 来定义 ..... #sidebar p { font-style: italic; text-align: right; margin-top: 0.5em; } // 类选择器 , 用 . 来定义 .center { text-align: center ; } // 属性选择器 [title] { color:red; } [属性] //用于选取带有指定属性的元素。 [属性=value] //用于选取带有指定属性和值的元素。 [属性~=value] //用于选取属性值中包含指定词汇的元素。 [属性|=value] //用于选取带有以指定值开头的属性值的元素，该值必须是整个单词。 [属性^=value] //匹配属性值以指定值开头的每个元素。 [属性$=value] //匹配属性值以指定值结尾的每个元素。 [属性*=value] //匹配属性值中包含指定值的每个元素。 // css 其他常用选择器 选择所有元素，并设置它们的背景色： * { background-color:yellow; } 选择未被访问的链接，并设置其样式： a:link { background-color:yellow; } 选择已访问的链接，并设置其样式： a:visited { background-color:yellow; } 选择活动链接，并设置其样式： a:active { background-color:yellow; } 选择鼠标指针浮动在其上的元素，并设置其样式： a:hover { background-color:yellow; } 选择获得焦点的输入字段，并设置其样式： input:focus { background-color:yellow; } 为所有 type=\"text\" 的已启用的 input 元素设置背景色： input[type=\"text\"]:enabled { background-color: #ff0000; } 为所有 type=\"text\" 的被禁用的 input 元素设置背景色： input[type=\"text\"]:disabled { background-color: #dddddd; } 为所有被选中的 input 元素设置背景色： input:checked { background-color: #ff0000; } css 定位 关键字 说明 position //元素框正常生成。块级元素生成一个矩形框，作为文档流的一部分，行内元素则会创建一个或多个行框，置于其父元素中。 static //元素框偏移某个距离。元素仍保持其未定位前的形状，它原本所占的空间仍保留。 relative //元素框从文档流完全删除，并相对于其包含块定位。包含块可能是文档中的另一个元素或者是初始包含块。元素原先在正常文档流中所占的空间会关闭，就好像元素原来不存在一样。元素定位后生成一个块级框，而不论原来它在正常流中生成何种类型的框。 absolute //元素框的表现类似于将 position 设置为 absolute，不过其包含块是视窗本身。 fixed top 定义了一个定位元素的上外边距边界与其包含块上边界之间的偏移。 right 定义了定位元素右外边距边界与其包含块右边界之间的偏移。 bottom 定义了定位元素下外边距边界与其包含块下边界之间的偏移。 left 定义了定位元素左外边距边界与其包含块左边界之间的偏移。 overflow 设置当元素的内容溢出其区域时发生的事情。 clip 设置元素的形状。元素被剪入这个形状之中，然后显示出来。 vertical-align 设置元素的垂直对齐方式。 z-index 设置元素的堆叠顺序 clear 规定元素的哪一侧不允许其他浮动元素。 cursor 规定要显示的光标的类型（形状）。 display 规定元素应该生成的框的类型。 float 规定框是否应该浮动。 visibility 规定元素是否可见 css 尺寸 关键字 说明 height 设置元素的高度。 width 设置元素的宽度。 min-height 设置元素的最小高度。 min-width 设置元素的最小宽度。 max-height 设置元素的最大高度。 max-width 设置元素的最大宽度。 line-height 设置行高 css border 边距 关键字 说明 border 简写属性，用于把针对四个边的属性设置在一个声明。 border-style 用于设置元素所有边框的样式，或者单独地为各边设置边框样式。 border-width 简写属性，用于为元素的所有边框设置宽度，或者单独地为各边边框设置宽度。 border-color 简写属性，设置元素的所有边框中可见部分的颜色，或为 4 个边分别设置颜色。 border-bottom 简写属性，用于把下边框的所有属性设置到一个声明中。 border-bottom-color 设置元素的下边框的颜色。 border-bottom-style 设置元素的下边框的样式。 border-bottom-width 设置元素的下边框的宽度。 border-left 简写属性，用于把左边框的所有属性设置到一个声明中。 border-left-color 设置元素的左边框的颜色。 border-left-style 设置元素的左边框的样式。 border-left-width 设置元素的左边框的宽度。 border-right 简写属性，用于把右边框的所有属性设置到一个声明中。 border-right-color 设置元素的右边框的颜色。 border-right-style 设置元素的右边框的样式。 border-right-width 设置元素的右边框的宽度。 border-top 简写属性，用于把上边框的所有属性设置到一个声明中。 border-top-color 设置元素的上边框的颜色。 border-top-style 设置元素的上边框的样式。 border-top-width 设置元素的上边框的宽度。 css 内边距属性 关键字 说明 padding 简写属性。作用是在一个声明中设置元素的所内边距属性。上、右、下、左 padding-bottom 设置元素的下内边距。 padding-left 设置元素的左内边距。 padding-right 设置元素的右内边距。 padding-top 设置元素的上内边距。 css 外边距属性 关键字 说明 margin 简写属性。在一个声明中设置所有外边距属性。 margin-bottom 设置元素的下外边距。 margin-left 设置元素的左外边距。 margin-right 设置元素的右外边距。 margin-top 设置元素的上外边距。 css 边框 关键字 说明 border 在一个声明中设置所有的边框属性。 border-bottom 在一个声明中设置所有的下边框属性。 border-bottom-color 设置下边框的颜色。 border-bottom-style 设置下边框的样式。 border-bottom-width 设置下边框的宽度。 border-color 设置四条边框的颜色。 border-left 在一个声明中设置所有的左边框属性。 border-left-color 设置左边框的颜色。 border-left-style 设置左边框的样式。 border-left-width 设置左边框的宽度。 border-right 在一个声明中设置所有的右边框属性。 border-right-color 设置右边框的颜色。 border-right-style 设置右边框的样式。 border-right-width 设置右边框的宽度。 border-style 设置四条边框的样式。 border-top 在一个声明中设置所有的上边框属性。 border-top-color 设置上边框的颜色。 border-top-style 设置上边框的样式。 border-top-width 设置上边框的宽度。 border-width 设置四条边框的宽度。 outline 在一个声明中设置所有的轮廓属性。 outline-color 设置轮廓的颜色。 outline-style 设置轮廓的样式。 outline-width 设置轮廓的宽度。 border-bottom-left-radius 定义边框左下角的形状。 border-bottom-right-radius 定义边框右下角的形状。 border-image 简写属性，设置所有 border-image-* 属性。 border-image-outset 规定边框图像区域超出边框的量。 border-image-repeat 图像边框是否应平铺(repeated)、铺满(rounded)或拉伸(stretched)。 border-image-slice 规定图像边框的向内偏移。 border-image-source 规定用作边框的图片。 border-image-width 规定图片边框的宽度。 border-radius 简写属性，设置所有四个 border-*-radius 属性。 border-top-left-radius 定义边框左上角的形状。 border-top-right-radius 定义边框右下角的形状。 box-decoration-break box-shadow 向方框添加一个或多个阴影。 css 背景 关键字 说明 background 在一个声明中设置所有的背景属性 background-attachment 设置背景图像是否固定或者随着页面的其余部分滚动。scroll、fixed、inherit background-color 可以为所有元素设置背景 background-image 背景图像 ， url(/i/eg_bg_03.gif) background-position 设置背景图像的开始位。center,top,bottom,right,left、百分比、具体的px background-repeat 背景重复 ， repeat 、 repeat-x 、 repeat-y、 no-repeat 、inherit background-clip 规定背景的绘制区域。 background-origin 规定背景图片的定位区域。 background-size 规定背景图片的尺寸。 css 动画 关键字 说明 @keyframes 规定动画。 animation 所有动画属性的简写属性，除了 animation-play-state 属性。 animation-name 规定 @keyframes 动画的名称。 animation-duration 规定动画完成一个周期所花费的秒或毫秒。 animation-timing-function 规定动画的速度曲线。 animation-delay 规定动画何时开始。 animation-iteration-count 规定动画被播放的次数。 animation-direction 规定动画是否在下一周期逆向地播放。 animation-play-state 规定动画是否正在运行或暂停。 animation-fill-mode 规定对象动画时间之外的状态。 css Box 属性 关键字 说明 overflow-x 如果内容溢出了元素内容区域，是否对内容的左/右边缘进行裁剪。 overflow-y 如果内容溢出了元素内容区域，是否对内容的上/下边缘进行裁剪。 overflow-style 规定溢出元素的首选滚动方法。 rotation 围绕由 rotation-point 属性定义的点对元素进行旋转。 rotation-point 定义距离上左边框边缘的偏移点。 css 颜色 属性 关键字 说明 color-profile 允许使用源的颜色配置文件的默认以外的规范。 opacity 规定元素的不透明级别。 rendering-intent 允许使用颜色配置文件渲染意图的默认以外的规范。 css Content for Paged Media 属性 关键字 说明 bookmark-label 规定书签的标记。 bookmark-level 规定书签的级别。 bookmark-target 规定书签链接的目标。 float-offset 将元素放在 float 属性通常放置的位置的相反方向。 hyphenate-after 规定连字单词中连字符之后的最小字符数。 hyphenate-before 规定连字单词中连字符之前的最小字符数。 hyphenate-character 规定当发生断字时显示的字符串。 hyphenate-lines 指示元素中连续断字连线的最大数。 hyphenate-resource 规定帮助浏览器确定断字点的外部资源（逗号分隔的列表）。 hyphens 设置如何对单词进行拆分，以改善段落的布局。 image-resolution 规定图像的正确分辨率。 marks 向文档添加裁切标记或十字标记。 string-set css 可伸缩框属性（Flexible Box） 关键字 说明 box-align 规定如何对齐框的子元素。 box-direction 规定框的子元素的显示方向。 box-flex 规定框的子元素是否可伸缩。 box-flex-group 将可伸缩元素分配到柔性分组。 box-lines 规定当超出父元素框的空间时，是否换行显示。 box-ordinal-group 规定框的子元素的显示次序。 box-orient 规定框的子元素是否应水平或垂直排列。 box-pack 规定水平框中的水平位置或者垂直框中的垂直位置。 css 字体属性 关键字 说明 font 在一个声明中设置所有字体属性。 font-family 文本的字体 font-size 规定文本的字体尺寸 font-size-adjust 为元素规定 aspect 值。 font-stretch 收缩或拉伸当前的字体系列。 font-style 规定文本的字体样式。 font-variant 规定是否以小型大写字母的字体显示文本。 font-weight 规定字体的粗细。 css 内容生成 相关属性 关键字 说明 content 与 :before 以及 :after 伪元素配合使用，来插入生成内容。 counter-increment 递增或递减一个或多个计数器。 counter-reset 创建或重置一个或多个计数器。 quotes 设置嵌套引用的引号类型。 crop 允许被替换元素仅仅是对象的矩形区域，而不是整个对象。 move-to 从流中删除元素，然后在文档中后面的点上重新插入。 page-policy 确定元素基于页面的 occurrence 应用于计数器还是字符串值。 css 表格属性 关键字 说明 grid-columns 规定网格中每个列的宽度。 grid-rows 规定网格中每个列的高度。 css 超链接属性 关键字 说明 target 简写属性，设置target-name、target-new以及target-position属性。 target-name 规定在何处打开链接（链接的目标）。 target-new 规定目标链接在新窗口还是在已有窗口的新标签页中打开。 target-position 规定在何处放置新的目标链接。 css 列表属性 关键字 说明 list-style 简写属性。用于把所有用于列表的属性设置于一个声明中 list-style-image 将图象设置为列表项标志 list-style-position 设置列表中列表项标志的位置 list-style-type 设置列表项标志的类型 marker-offset 设置或检索标记容器和主容器之间水平补白。即两个容器靠近的一边的间距 css 走马灯属性 关键字 说明 marquee-direction 设置移动内容的方向。 marquee-play-count 设置内容移动多少次。 marquee-speed 设置内容滚动得多快。 marquee-style 设置移动内容的样式。 css 多列属性 关键字 说明 column-count 规定元素应该被分隔的列数。 column-fill 规定如何填充列。 column-gap 规定列之间的间隔。 column-rule 设置所有 column-rule-* 属性的简写属性。 column-rule-color 规定列之间规则的颜色。 column-rule-style 规定列之间规则的样式。 column-rule-width 规定列之间规则的宽度。 column-span 规定元素应该横跨的列数。 column-width 规定列的宽度。 columns 规定设置 column-width 和 column-count 的简写属性。 css Paged Media 属性 关键字 说明 fit 示意如何对width和height属性均不是auto的被替换元素进行缩放。 fit-position 定义盒内对象的对齐方式。 image-orientation 规定用户代理应用于图像的顺时针方向旋转。 page 规定元素应该被显示的页面特定类型。 size 规定页面内容包含框的尺寸和方向。 css 打印属性 关键字 说明 orphans 设置当元素内部发生分页时必须在页面底部保留的最少行数。 page-break-after 设置元素后的分页行为。 page-break-before 设置元素前的分页行为。 page-break-inside 设置元素内部的分页行为。 widows 设置当元素内部发生分页时必须在页面顶部保留的最少行数。 css 表格属性 关键字 说明 border-collapse 设置是否把表格边框合并为单一的边框 border-spacing 设置分隔单元格边框的距离 caption-side 设置表格标题的位置 empty-cells 设置是否显示表格中的空单元格 table-layout 设置显示单元、行和列的算法 css 文本属性 关键字 说明 color 文本颜色 direction 文本方向 unicode-bidi 对于行内元素，只有当 unicode-bidi 属性设置为 embed 或 bidi-override 时才会应用 direction 属性 line-height 文本行高 letter-spacing 与 word-spacing 的区别在于，字母间隔修改的是字符或字母之间的间隔 word-spacing 字（单词）之间的标准间隔 text-align 对齐元素中的文本 text-decoration 向文本添加下划线、删除线等 text-indent 文本缩进 text-shadow 设置文本阴影 text-transform 处理文本的大小写 white-space 处理空白符 hanging-punctuation 规定标点字符是否位于线框之外 punctuation-trim 规定是否对标点字符进行修剪。 text-align-last 设置如何对齐最后一行或紧挨着强制换行符之前的行。 text-emphasis 向元素的文本应用重点标记以及重点标记的前景色。 text-justify 规定当 text-align 设置为 \"justify\" 时所使用的对齐方法。 text-outline 规定文本的轮廓。 text-overflow 规定当文本溢出包含元素时发生的事情。 text-wrap 规定文本的换行规则。 word-break 规定非中日韩文本的换行规则。 word-wrap 允许对长的不可分割的单词进行分割并换行到下一行。 css 2D/3D 转换属性 关键字 说明 transform 向元素应用 2D 或 3D 转换。 transform-origin 允许你改变被转换元素的位置。 transform-style 规定被嵌套元素如何在 3D 空间中显示。 perspective 规定 3D 元素的透视效果。 perspective-origin 规定 3D 元素的底部位置。 backface-visibility 定义元素在不面对屏幕时是否可见。 css 过渡属性 关键字 说明 transition 简写属性，用于在一个属性中设置四个过渡属性。 transition-property 规定应用过渡的 CSS 属性的名称。 transition-duration 定义过渡效果花费的时间。 transition-timing-function 规定过渡效果的时间曲线。 transition-delay 规定过渡效果何时开始。 css 用户界面属性 关键字 说明 appearance 允许您将元素设置为标准用户界面元素的外观 box-sizing 允许您以确切的方式定义适应某个区域的具体内容。 icon 为创作者提供使用图标化等价物来设置元素样式的能力。 nav-down 规定在使用 arrow-down 导航键时向何处导航。 nav-index 设置元素的 tab 键控制次序。 nav-left 规定在使用 arrow-left 导航键时向何处导航。 nav-right 规定在使用 arrow-right 导航键时向何处导航。 nav-up 规定在使用 arrow-up 导航键时向何处导航。 outline-offset 对轮廓进行偏移，并在超出边框边缘的位置绘制轮廓。 resize 规定是否可由用户对元素的尺寸进行调整。 css 非标准属性 以下内容是非标准的一些属性，各家的浏览器支持效果可能会不一样。 有些是比较新的内容。笔记比较零星和凌乱。 -moz- 代表FireFox浏览器私有属性 -ms- 代表IE浏览器私有属性 -webkit- 代表safari、chrome浏览器私有属性 -o- 代表opera浏览器私有属性 // 对字体的锯齿进行调整 。 inherit、grayscale、antialiased -moz-osx-font-smoothing: grayscale; -webkit-font-smoothing: antialiased; // 告诉渲染引擎工作时如何优化显示文本 , auto | optimizeSpeed | optimizeLegibility | geometricPrecision | inherit text-rendering: optimizeLegibility; 腾讯小程序 小程序官方文档 我的小程序客户端示范代码 我的小程序服务器API代码 其他用过的一些 主业不是搞这个的，看了忘记了，这里只记录常用的基础。 http://hnyer.gitee.io/webdev/chinese/web/vueJS.html 无版权 可以无限制使用！ all right reserved，powered by Gitbook该文件更新时间： 2020-12-24 09:41:58 "},"chinese/人工智能/人工智能相关概念.html":{"url":"chinese/人工智能/人工智能相关概念.html","title":"人工智能","keywords":"","body":"基础概念 熵 就是对信息的不确定性，如果我们对一个信息掌握得好，对应的熵就会低，反之就高。信息熵是表示随机变不确定性的度量。熵越大，信息量越大，也就是越不确定。 拟合 形象的说，拟合就是把平面上一系列的点，用一条光滑的曲线连接起来。 因为这条曲线有无数种可能，从而有各种拟合方法。拟合的曲线一般可以用函数表示. 它是对我们数据点的一个近似表达。在开始阶段, 红线的表达能力不强, 误差很大。 不过通过不断的学习, 预测误差将会被降低. 所以学习到后来. 红线也能近似表达出数据的样子. 张量（Tensor) 零阶张量为 纯量或标量 (scalar) 也就是一个数值. 比如 [1] 一阶张量为 向量 (vector), 比如 一维的 [1, 2, 3] 二阶张量为 矩阵 (matrix), 比如 二维的 [[1, 2, 3],[4, 5, 6],[7, 8, 9]] 以此类推, 还有 三阶 三维的 … TensorFlow 通过 Anaconda 来安装 tensorFlow 和其他依赖的库。 然后用 pycharm 来进行编写代码。 pycharm里面的 python.exe 要指定为 Anaconda 里面的那个 python.exe 。（否则 无法 import tensorflow） 无版权 可以无限制使用！ all right reserved，powered by Gitbook该文件更新时间： 2020-12-23 16:52:42 "}}