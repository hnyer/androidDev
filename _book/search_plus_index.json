{"./":{"url":"./","title":"首页","keywords":"","body":"﻿本博客不保证完整性和正确性,请自行甄别。 善用左上角的搜索功能。 托管地址 https://gitee.com/hnyer/androidDev 博客链接 email：aivin666@qq.com 、wechat: Aivin666666 https://blog.csdn.net/dengpanwen //CSDN https://hnyer.gitee.io //红尘之声 Java基础 [x] JVM 架构 [x] Java 内存模型、内存结构、Java的内存分区 [x] JVM 垃圾回收机制、老年代有什么算法 [x] 说一下 Android 用的是哪几种 垃圾回收算法 [x] 方法区有什么东西 [x] 说说你对类加载机制的了解？类什么时候会被加载？ 类加载的过程具体生命周期是怎样的？ [x] DexClassLoader 与 PathClassLoader 的区别 [x] 类加载的过程，属性先加载还是方法先加载 [ ] 对象创建过程 [x] 讲下Java的 双亲委派 [x] 拉圾回收的 GCRoot 是什么 [x] GCRoot 的类型 ,举例说明。比如说Activity和它的匿名内部类Handler，分析下引用链，对应的 gcroot 是哪个 [x] 讲下 equals 和 hashcode ，他们为何必须一起重写 [ ] 成员变量和局部变量的区别。为何成员变量需要jvm在对象初始话过程中赋默认值？ [ ] class文件的组成？常量池里面有什么内容？ [x] java 和 字节码 有什么区别 [x] 编译期注解处理的是字节码还是java文件 [x] 字节码注入 、字节码插桩 、字节码注入 [ ] 自动装箱发生在什么时候？编译期还是运行期 [ ] 内部类访问外部类 [x] java有什么特性，继承有什么用处，多态有什么用处 [x] java 里带$的函数 是什么意思 [x] 硬件加速 是什么原理 [x] 进程优先级 [x] 静态方法，静态对象为什么不能继承 （此问题错误，可以被继承，不能被重写） [x] JMM 可见性 、原子性 、有序性 、synchronized 可以保证什么 [ ] 线程间同步的方法 [x] 重入锁 ReentrantLock 、synchronized 和 读写锁 ReadWriteLock 的区别 [x] Lock 接口 的实现，以及与 synchronized 的区别 [ ] 平常有用到什么锁，锁之间的区别 ,synchronized 底层原理是什么 [x] synchronized 是公平锁还是非公平锁 , ReteranLock 是公平锁吗？ 是怎么实现的 [x] synchronized 跟 ReentranLock 有什么区别？ 发生异常的场景 [ ] synchronized 和 volatile 的区别？为何不用 volatile 替代 synchronized？ [ ] 说说你对 volatile 字段有什么用途？ [ ] Synchronize 关键字后面跟类或者对象有什么不同 [x] 类锁和对象锁互斥么 [x] CAS 原理 [x] AQS 了解吗 [x] 泛型是什么、泛型有什么优点 [x] 泛型通配符 [x] 泛型擦除 是什么，为何会有擦除 、擦除的时机 [ ] 泛型是怎么解析的，比如在 retrofit 中的泛型是怎么解析的 [x] 泛型 为何会有 协变 和 逆变，PECS 规则 [x] string 比较 equals 和 == 有什么区别 [x] 函数式编程 如何理解 [x] 说说你对 注解 的了解，是怎么解析的 [ ] 编译时注解 与 运行时注解，为什么retrofit要使用运行时注解？什么时候用运行时注解？ [x] 反射 是什么，在哪里用到，怎么利用反射创建一个对象 [x] 反射可以反射final修饰的字段吗？ 框架源码 [x] 有看过哪些框架的源码 (leakCanary / RecyclerView) [x] 讲下 leakCanary 原理 [x] leakCanary 为什么不用 虚引用？ 引用队列里面存的是什么？ android 基础 [x] Android APP的 入口函数 在哪里 [x] activity 启动模式 [x] APP主页一般用哪种 启动模式 ，原因是什么 [x] Activity 生命周期有哪些，知道 onRestart 么； A启动B ，A的 onStop 一定会执行吗；按 Home 按键后的生命周期 [x] activity 启动另外一个activity的时候横屏切换再点击返回，过程中发生的生命周期 [x] Activity 与 AppCompatActivity 区别 [x] Fragment#onHiddenChanged 是生命周期方法么？如何触发？ [ ] Fragment hide show生命周期变化 [ ] Fragment replace生命周期变化 [ ] ViewPager切换Fragment什么最耗时？ [ ] fragment 的 replace 和end？ 的区别 [ ] Activity和Fragment的通信方式；系统为何会设计Fragment#setArgument方法。 [x] Service的生命周期，两种启动方法，有什么区别 [ ] 如何在 Service 中打开一个 Activity [x] 有什么工具可以看到 Activity栈信息么？多个栈话，有方法分别得到各个栈的Activity列表么 [x] ANR 是怎么回事？怎么查？Service会引起 ANR 么 [x] 为什么 Activity.finish() 之后 10s 才 onDestroy [x] SQLite 的数据库升级 [x] SharedPreferences 原理 ，读取xml是在哪个线程 [x] SharedPreferences 的 apply 和 commit 有什么区别 [x] SharedPreferences 可以跨进程通信吗？ 如何改造成可以跨进程通信的? [ ] ContentProvider具体实现。 [ ] binderService方法中的回调具体运行在哪个线程？binder线程池最大线程数是多少？自定义的Callback远程调用，运行在哪个线程？为何不是主线程，如果运行在主线程会有哪些问题？ [x] 悬浮窗如何实现 [ ] ANR的log中关键字是什么 [ ] Activity的onSaveInstance方法何时调用？它跟onPause、onStop的调用顺序如何？ [ ] 方法内部的匿名内部类，比如说给View设置的OnClickListener，它里面相关调用外部方法的形参，必须使用final修饰这个形参，为何？ [ ] Android里面进程间通信方式，ContentProvider可以用file实现么？ [ ] Activity启动模式，以及各启动模式生命周期问题 [x] Activity怎么启动 Service 、Activity 与 Service 交互，Service 与 Thread 的区别 [x] ANR 了解过吗？有没有实际的ANR定位问题的经历 [x] AndroidManifest.xml 中 application 中配置 largeHeap ，真的能分配到大内存吗？ [ ] ThreadLocal 实现 [ ] 通知的类别 [x] 全局广播与局部广播区别 [x] 本地广播 LocalBroadcastManager 实现 ,为何效率高 ? [ ] 广播与 RxBus 的区别 [ ] Rxjava 是怎么实现线程切换的 [ ] Rxjava 自定义操作符 [ ] RXJava 怎么切换线程 [ ] Bugly 日志收集的原理是什么？ [x] 做过一些 SDK 的操作吗？ [x] 为什么会有 R文件映射表 ？直接使用资源的路径不好么？ [x] dex 文件结构了解过么？为何会有 65535 的限制 [ ] mutildex 技术了解么？这项技术的目的是什么？ [x] Parcelable 和 Serializable 本质区别 。说原理 ,不要说用法 [ ] Bundle 是什么数据结构 ? 利用什么传递数据 [x] 两个 getDrawable 取得的对象，有什么区别 ？ [x] onSaveInstanceState() 、onRestoreInstanceState() 平时是怎么用的 , 什么时候有值，什么时候为空 [ ] Scroller 有什么方法，怎么使用的 [ ] canvas lock的缓冲区是怎么回事 Android 动画 [x] 介绍一下 Android 动画 [x] 补间动画与属性动画的区别，哪个效率更高 [x] 动画里面用到了什么设计模式 [x] 属性动画更新时会回调 onDraw 吗 [x] 动画连续调用 的原理是什么 线程 、进程 、跨平台 [x] 多线程如何实现 ,有哪些方式 、四种线程池原理 ,线程池的类型 [x] 线程池如何配置，核心线程数你一般给多少 、线程池的参数 ,最大线程数和核心线程数的关系 [x] 线程池 task 的优先级如何实现？（优先级队列 PriorityBlockingQueue ） [x] 线程池 拒绝策略有几种 [x] 如何禁止 手动创建线程 。使用 自定义 lint [x] 阿里编程规范 不建议使用 Executors 来创建线程池，为什么 [x] IdleHandler 调用时机 [x] IdleHandler用过吗 ？IdleHandler 应用场景 [ ] Handler休眠是怎样的？epoll 的原理是什么？如何实现延时消息，如果移除一个延时消息会解除休眠吗？ [x] Handler内存泄漏 的GCRoot是什么 ？ [x] 说说你对Handler机制的了解，同步消息，异步消息等 [x] Handler机制了解吗？一个线程有几个Looper？为什么？ [x] 简单描述下Handler,Handler是怎么切换线程的 [x] Handler 同步屏障 [ ] Launcher启动App的流程，中间有几种跨进程通信(socket) [ ] 源码中有哪里用到了 AtomicInteger [x] 跨进程通信了解多少？管道了解吗？ [x] 描述一次跨进程通讯 [x] 说说 binder 机制的原理 [x] binder 的 mmap() [x] android 跨进程通信了解吗？ 共享内存用过吗？binder驱动了解吗？ [ ] binder 怎么验证 pid ? [ ] binder 进程间通信可以调用原进程方法吗 ？ [ ] 生命周期都是通过什么调用的？有用过AIDL吗？ [x] AIDL in out oneWay 代表什么意思 [x] 你们用的什么消息通信机制 [x] 多进程 怎么实现？如果启动一个多进程APP，会有几个进程运行？ [x] 怎么终止一个线程，thread.interrupt() 一定有效吗 启动流程 、加载流程 [ ] 从桌面点击icon图标开始，整个启动activity的启动过程 [ ] ContentProvider启动流程 [ ] Application 启动流程 [ ] Application 中持有 静态的信息，有何缺点 ？如何改进 [x] Application 中可以显示Dialog么 ？为什么？ [x] 使用 ActivityLifecycleCallbacks 做了哪些事情？ [ ] 说说App的启动过程 , 在ActivityThread的main方法里面做了什么事，什么时候启动第一个Activity？ [ ] AMS 交互调用生命周期是顺序的吗 [x] Activity、Window 、PhoneWindow、DecorView、View、ViewRootImpl 的关系 [x] activity 有几个 Window [x] 除了 Activity 还有别的方式显示 Window 出来么 [x] DecorView 的布局是什么样的 [x] DecorView 的创建时机 [x] ViewRootImpl 创建的时机 [x] PhoneWindow 是在哪里初始化的 [x] setContentView 是如何把xml文件 化成View并显示到 Activity中的 [x] LayoutInflater 是如何把xml布局文件转换成View对象的（反射）？View树如何生成的？怎么优化？ [x] RecyclerView 的缓存结构是怎样的？缓存的是什么？cachedView 会执行 onBindView 吗? [x] RecyclerView 嵌套 RecyclerView，NestScrollView 嵌套 ScrollView 滑动冲突 [x] 讲一下 RecyclerView 的缓存机制,滑动10个，再滑回去，会有几个执行 onBindView [x] 如何实现 RecyclerView 的局部更新，用过 payload 吗, notifyItemChange 方法中的参数？ [x] RecyclerView 和 ListView 区别、特点、缓存 、懒加载、局部刷新 ,多种type场景下怎么避免滑动卡顿 ,怎么优化滑动 [x] RecyclerView 缓存结构，RecyclerView预取，RecyclerView局部刷新 [x] RecyclerView 里面那个 changedSrape, attachedScrape 之类的到底是在做什么 ? [x] RecyclerView 的 LayoutManager 有哪几种 [x] 想改变 ListView 的高度，怎么做 [ ] Launcher 启动图标，有几个进程？ [ ] Jetpack 组件用过哪些？ [ ] LifeCycle 的原理是什么？如果在onStart里面订阅，会回调onCreate吗？ [ ] Activity内 LinearLayout 红色 wrap_content ,包含View绿色 wrap_content ,求界面颜色 [ ] ViewPager 切换掉帧 有什么处理经验？ [ ] ViewPager2 原理 [ ] setFactory 和 setFactory2 有什么区别？ [ ] 如何自定义实现一个 FlexLayout [ ] A Activity打开B Activity的生命周期变化，会有什么方法打断吗？ [ ] 登陆功能，登陆成功然后跳转到一个新Activity，中间涉及什么？从事件传递，网络请求,AMS交互角度分析 UI 绘制 [x] View 绘制流程 [x] onMeasure 、onLayout 、onDraw关系 [x] 自定义 View 的几种方式。onMeasure、onLayout、onDraw 方法都何时需要重写 [x] MeasureSpec 讲一下 [x] 讲下 onMeasure方法 , 如何测量 ，测量模式 ，入参为什么是int类型 [ ] 为什么会多次调用 onMeasure 和 onLayout 方法 [x] 怎么获取view的宽高，如何确定值是准确的 ,有遇到是0的情况吗 [x] 为什么 view.post 可以获得宽高，有看过view.post的源码吗 [x] 自定义 LinearLayout ，怎么测量子 View宽高 [ ] 在 View 绘制中 ，一个View的宽高由哪些因素决定？ 在 activit 中要拿到 View 准确的宽高有哪些方式 [x] onCreate 、onResume 、onStart里面，什么地方可以获得宽高 [x] 如何触发重新绘制 [x] invalidate 每次都会触发 onDraw 么？invalidate 每次会触发 View#onLayout 么？ [ ] requestLayout 和 invalidate 的流程 [ ] requestLayout 和 invalidate 的区别 [ ] ACTION_CANCEL 什么时候触发，触摸button然后滑动到外部抬起会触发点击事件吗，在+ + 滑动回去抬起会么 [ ] 获取TextView的行数时，StaticLayout原理。 [ ] 绘制的数据是如何提交到远端的SurfaceFlinger [ ] requestLayout调用后，都会调用哪些方法？ [ ] 手势操作 ActionCancel 后怎么取消 [ ] 说说你对屏幕刷新机制的了解，双重缓冲，三重缓冲，黄油模型 [x] onAttachedToWindow 什么时候调用？ 事件分发 [ ] 伪代码实现一个长按事件 [ ] 首次 View 的绘制流程是在什么时候触发的 [ ] MotionEvent#offsetLocation事件转发 [ ] 滑动冲突如何解决？有几种方式？具体从哪个事件开始拦截？在哪里拦截？比如双层ViewPager嵌套的滑动冲突如何解决。 [ ] 讲下事件传递 ，总体流程，DOWN事件拦截后，后续事件如何处理？，dispatchTouchEvent方法返回true后事件如何处理？ [ ] setOnTouchListener,onClickeListener 和 onTouchEvent 的关系 [ ] dispatchTouchEvent , onInterceptEvent , onTouchEvent 顺序，关系 [ ] 说说 事件分发机制，怎么写一个不能滑动的 ViewPager [ ] RecyclerView 是怎么处理内部ViewClick冲突的 [ ] ViewGroup在Action_Move时onIntercept返回true，事件怎么传递 [ ] ViewPager中嵌套ViewPager怎么处理滑动冲突 [ ] 怎么处理嵌套View的滑动冲突问题 [ ] View的分发机制，滑动冲突 [ ] 说一下 touch 触摸时间的传递流程图 [ ] 如果onInterceptTouchEvent返回true，但是onTouchEvent返回了false，是什么效果？如果还想让其他View接收事件，该怎么做？ 自定义控件 [x] 自定义圆角图片 [x] 自定义实现一个九宫格 如何实现 插件化 、热修复 (已过时，已废弃) [ ] 说说插件化的原理，资源的插件化id重复如何解决？ [ ] 插件化 的原理是怎样的？ [ ] 插件化的原理是什么？有没有什么非运行时插件化的解决方案？ [ ] 插件化换肤方案 [ ] 插件化的原理，startActivity hook了哪个方法 [ ] 插件化的主要优点和缺点是什么？ [ ] 插件化的原理，以及hook点，大概有两个 [ ] 说说热修复的原理？ [ ] 热修复的原理，资源的热修复的原理,会不会有资源冲突的问题 [ ] tinker的原理是什么,还用过什么热修复框架，robust的原理是什么？ [ ] 热修复，主要说了ClassLoader的方式和Rubost的插装方式，重点介绍了Rubost的原理。 组件化 模块化 [x] 多模块开发，不同的人可能会引入重复资源。相同的字符串，相同的icon等但是文件名并不一样，怎样去重 [x] 组件化有详细了解过吗？ [x] 组件化的实现方案 (参考 ARouter) [x] ARouter 路由原理？ [x] 注解处理器是处理 java 还是字节码 (java文件) [x] ARouter 怎么实现接口调用 (IProvider) [x] ARouter 怎么实现页面拦截 (IInterceptor) [x] 如果不用 ARouter ，你会怎么去解藕。接口？设计接口有什么需要注意的？ 网络相关 [x] TCP 和 UDP 区别，TCP为何是三次握手，为何是四次挥手 [x] 说一下 tcp 的建立连结和结束连结的通信过程 [x] MediaPlayer 能同时播放多个音频么？ 如果需要播放多个提示音，如何实现 [ ] 如何在网络框架里直接避免内存泄漏，不需要在 presenter 中释放订阅 [x] http 与 https 有什么区别 [x] http1.0 、http1.1 、http1.2 、 HTTP3.0 有什么区别 [ ] OkHttp 里面用到了什么设计模式？ [ ] OkHttp连接池是怎么实现的？里面怎么处理SSL？ [ ] OkHttp网络拦截器，应用拦截器 ? OKHttp有哪些拦截器，分别起什么作用 [ ] OkHttp怎么实现连接池 [ ] OkHttp 连接池的复用机制 [ ] 网络封装怎么实现？ [ ] 如何上传数据？请求头关键字段和请求体格式 [ ] 实现一个下载功能的接口 [x] 平常抓包用什么工具 [x] 在项目中有直接使用tcp 、socket 来发送消息吗 [x] get 、 post 有什么区别 NDK JNI [x] java 中 int 类型对应的本地类型是什么 [x] JNI 中静态注册和动态注册的区别 算法 [x] 了解哪些算法 [x] 手写生产者消息者模型 [x] 斐波那契台阶 [x] 如何让三个线程按照顺序依次打印 1-100 [x] 如何让两个线程循环交替打印 [x] 删除数组中的重复元素 [x] 反转数组 [x] 实现一个快速排序 [ ] 一个大致有序的数组如何排序，最快时间复杂度 [ ] 不同面值的几个硬币，怎么求满足条件的最小值 [ ] 实现一个双向链表 [ ] K个一组反转链表 [ ] 链表求和 [ ] 二叉树最长结点集合 [ ] 二叉树的最大深度 [ ] 二叉树的每一层最左边节点 [x] 有用过什么加密算法？AES , RAS什么原理？ [x] 非对称加密 、对称加密 [x] appkey 、 token 放在本地如何保存？ 如何加密比较好 [ ] HashMap 讲一下，数据结构、hash过程、扩容、加载因子为何是0.75等。 [ ] hashmap。hash冲突时给链表插入数据，1.7头插法，1.8尾插法。 [ ] SparseArray 和 ArrayMap 各自的数据结构，前者的查找是怎么实现的，与HashMap的区别 [ ] 说说HashMap的原理 HashMap查找的时间复杂度是多少？ [ ] 讲下arraylist、hashmap、linkedlist、linkedhashmap的实现。linkedhashmap为何会有这样的特性(lru)?它有个参数，表示命中率和使用次数。 [ ] lru是通过 linkedhashmap实现的么？ [ ] 讲讲 LinkedHashMap 的数据结构 [ ] ConcurrentHashMap 锁分段技术 [ ] ArrayMap 和 SparseArray 的区别，实现。 [ ] 如何求当前 Activity View 的深度 优化 、稳定性 、技术选型 [x] Android 中如何查看一个对象的回收情况 [x] 使用 Application. onTrimMemory( ) 优化 [ ] 启动优化做过什么工作？ 如果首页就要用到的初始化 [ ] 你的APP冷启动时间是多少，普通页面打开时间是多少，举例几个认为比较好的优化方法 [ ] WebView 性能优化做过什么工作 [ ] 有没有做过什么 WebView 秒开的一些优化 [x] 界面优化的一些方法，ConstraintLayout 实现三等分, ConstraintLayout 动画 [x] 包体积的极致优化 [x] 有什么实际解决UI卡顿优化的经历 [x] 有做过什么Bitmap优化的实际经验 [x] Apk的大小如何压缩 [ ] 看视频的时候网络请求很慢怎么优化 ？ [x] 自定义 lint [x] App上线后 用户使用时卡顿 ，怎么查看是什么原因 [x] 界面卡顿怎么排查和优化 ，何监测应用的 FPS [x] 网络优化 [x] 数据库优化 [ ] view的优化，减少层级，异步加载，x2c框架引入，优缺点，textview的优化。 [ ] 怎么优化xml inflate的时间，涉及IO与反射。了解 compose 吗？ [ ] 讲下你做过的 首页优化 [x] 如何提高线上代码质量 [x] 你们项目的稳定性如何？有做过什么稳定性优化的工作？ [x] 你做过什么 性能优化 的工作 [ ] 性能优化做过什么工作? 有用过什么工具？有没有精确测量的工具？ [x] 如何进行单元测试，如何保证App稳定 [x] 代码质量如何控制 [x] 技术选型是如何做 ，为什么这么考虑？从开发效率，产品性能，产品质量，产品体验等方面考虑 [x] 你们网络框架用的什么？为什么？ [ ] 如果 Android 和 iOS 调一个接口，一个通了一个没通 (或者响应速度一个块一个慢)，你会如何解决 [x] 冷启动、热启动 优化方案 [x] 有什么提高编译速度的方法 内存泄漏 、图片 、图片加载 [ ] Drawable 与 View 有什么区别, Drawable 有哪些子类 [x] 图片加载优化有什么经验吗 [ ] 说一个你熟悉的图片加载库的图片加载流程 [x] 图片内存的计算 [x] 大图加载 原理和优化，长图加载 [x] Bitmap高效加载 、Bitmap内存复用 inBitmap [x] inJustDecodeBounds 是什么？ [x] Bitmap 内存 和 drawable 目录的关系 [x] xhdpi 的图片放到 xxhdp 的手机上，内存会如何变化 [ ] hdpi 和xxhdpi的手机，分别加载xhdpi下的图片，会缩放图片么？如果会缩放，是如何缩放的，像素点是如何补全或者减少的？图片在内存中的大小会如何变化？ [x] Bitmap 不改变图片质量的情况下,如何减少内存 [x] 图片显示不全、变形怎么处理 [x] 一个 wrap_content 的 ImageView ，加载远程图片，传什么参数裁剪比较好? [x] Androidstudio drawable 下所以的格式都能转成 webp 么 ？哪些不能转 [x] 如何跨进程传递大图 [ ] 图片的三级缓存中,图片加载到内存中,如果内存快爆了,会发生什么 ？怎么处理 [x] glide 默认 Bitmap 的 Config 配置是 ARGB_8888 么 [ ] Glide 的缓存，有用过Glide的什么深入的API，自定义model是在Glide的什么阶段 [ ] 你碰到过什么 内存泄漏 ，怎么处理 [ ] 你认为为了避免内存泄漏，写代码时应该注意哪些事项 [x] AsyncTask 内存泄露 打包发布 [x] 项目搭建过程中有什么经验,有用到什么 gradle 脚本 [x] Gradle 熟悉吗 ？ 常用哪些配置和命令 [x] 如何通过 Gradle 配置多渠道包 [x] 有没有编写过 Gradle 插件 [x] 了解APK打包的过程吗 [x] Activity 会打包到包里面去吗 [x] 分包有做什么操作 适配 [x] 屏幕适配方案；头条适配方案核心原理。 [x] 屏幕适配做过什么工作 [ ] Android11 有没有适配 kotlin [ ] 有用 Anko DSL 写过布局吗 [ ] kotlin空安全的原理是什么？ [ ] kotlinc与javac编译字节码有什么区别？ [ ] kotlin lazy使用,lazy viewmodel [ ] kotlin 与Java互相调用有什么问题？ [ ] kotlin ?的原理 [x] 说说你对 协程 的理解， 可以完全取代 rxjava 吗 , 协程 可以在Java项目中使用吗 [x] 协程 怎么取消 [ ] 讲一个 协程 的 scope 与 context，协程的+号 代表什么 html5 [ ] .h5 与 native 交互做过什么工作 [ ] 项目中的 Webview 与 native 通信 [ ] h5 与 native 交互，webView.loadUrl 与 webView.evaluateUrl 区别 [ ] 项目中对 WebView 的功能进行了怎样的增强 [ ] native 如何对 h5 进行鉴权，让某些页面可以调，某些页面不能调 [ ] @JavaScriptInterface为什么不通过多个方法来实现 [ ] 为什么不利用同步方法来做 jsBridge交互？ 同步可以做异步，异步不能做同步 [ ] jsBridge 实现方式 [ ] CoordinatorLayout自定义behavior,可以拦截什么？ [ ] 视频播放,一个player怎么实现预加载，避免loading [ ] webView加载本地图片，如何从安全方面考虑 [ ] webwiew了解？怎么实现和javascript的通信？相互双方的通信。@JavascriptInterface在？版本有bug，除了这个还有其他调用android方法的方案吗 [ ] retrofit怎么做post请求 设计能力 [ ] 如果让你来实现一个网络框架，你会考虑什么 [ ] 你如何自己实现一个LRUCache？Android里面的LRUCache是如何实现的 [ ] 设计一个上传日志的大小，涉及到，性能、文件大小、怎样压缩、时机、TopK 问题等 [x] 如果产品要求你开发一个音频播放功能，你会怎么着手？预计会有什么坑？ [x] 你觉得 XX 目前的APP有什么问题？ [x] 如果叫你实现，你会怎样实现一个多主题的效果 [x] 换皮肤、切换主题、暗黑模式 [x] 如何封装一个字符串转数字的工具类 设计模式 [x] 你在项目中有用到什么设计模式吗 [x] 动态代理 的实现，动态代理有什么作用 [x] 手写一个静态代理，一个动态代理 [x] 代理模式 与装饰模式 的区别 [x] 单例模式 有什么缺点 [x] 单例的几种实现方式 [x] DCL 双锁单例，为什么要价 volatile [x] 单例的 DCL 方式下，那个单例的私有变量要不要加volatile关键字，这个关键字有什么用 [x] 手写 DCL 双检查单例模式，各个步骤有什么区别 [x] Android中常用的设计模式，说三个比较高级的 [x] android源码中有哪些设计模式 [x] MVC 、MVP 、MVVM 理解 [ ] 讲讲 MVC 、MVP ，presenter 内存泄漏的问题 [ ] MVP 怎么处理内存泄漏 [x] MVVM 双向数据绑定的原理是怎样的 [x] MVVM 怎么更新UI, databinding 用得多吗, databinding的原理 [ ] ViewModel 是怎么实现双向数据绑定的 [ ] ViewModel 怎么实现自动处理生命周期 [ ] ViewModel 为什么在旋转屏幕后不会丢失状态 [ ] ViewModel 的原理，为什么可以在Activity销毁后保存数据 [ ] ViewModel 的使用中有什么坑 [ ] 有没有看一下Google官方的 ViewModel demo [ ] ViewModel 在 Activity 初始化与在 Fragment中初始化，有什么区别 [x] 如果用了一些解耦的策略，怎么管理生命周期的 其他问题 [x] 介绍一下你们项目的架构 [x] 介绍一下你自已和项目 ，项目有什么难点 [x] 你们的项目中做过什么比较难的工作 [x] 这些年有做一些什么比较难的工作 [x] 说说为什么考虑离职 ,为什么考虑换工作 ，说说对你们原来公司的印象 [x] 为什么考虑换一份工作 ，在你们公司这几年感觉怎么样 [x] 你在团队中是怎样一个角色 ，有没有做什么推进项目的工作 [x] 你们的产品为什么被砍掉，从哪方面考虑 [x] 在这几年里，你有做过什么觉得最有价值的工作 [x] 平常是怎么了解一些新知识与业界动态的，最近有什么印象深刻的文章 [x] 你还有什么要问我的吗？目前有几个offer，倾向性是怎样的 ( no Copyright，enjoy youself ! ) all right reserved，powered by GitbookThe file was updated at : 2021-07-26 11:58:41 "},"chinese/doc/常用网站.html":{"url":"chinese/doc/常用网站.html","title":"常用网站","keywords":"","body":"VPN 佛跳墙 蓝灯 lantern 付费的 麒麟加速器 只有安卓端，每月300M免费 android 相关 android官方英文版 android官方中文版 民间组织-安卓中文组 android developer Java8 官方文档 谷歌开发者社区 maven 仓库 maven、central、gradle-plugin 阿里云镜像 wanandroid 一键反编译apk 谷歌应用网页下载 google app sotre 谷歌应用下载地址 谷歌应用网页下载 谷歌应用网页下载 谷歌应用网页下载 文件存储/托管 bmob 后端云 需要绑定自定义域名，否则会不稳定 leancloud leancloud 后端云，国际版暂时不用绑定域名 fir app 托管 阿里云盘网盘 全平台文件代下载 githubd github 代下载 项目管理 pingcode pingcode 的研发管理工具 ，目前在用 tracup 蒲公英的 Bug 追踪，轻量、便捷的项目管理 音视频 抖音视屏去水印1 抖音视屏去水印2 抖音视屏去水印3 抖音视屏去水印4 歌词下载 歌词制作 音乐下载 音效下载 音频、视频、图片测试文件下载 B站视屏下载 视屏剪切 ，无水印 musictools 无损音乐下载 、Vip 音乐 VIP视频解析 m3u8 下载插件 图床插件 PicGo 第三方博客 v2ex 掘金 干货集中营 王垠的博客 代码家的博客 伯乐在线 猎云网 太平洋手机 人人都是产品经理 pmcaff python3基础语法 廖雪峰python3基础教程 崔庆才-静觅python博客 大鱼python博客 在线工具 git标签生成工具 shields.io 在线流程图工具 ProcessOn 代码高亮工具 tool oschina Rar暴力破解 文本差异比较 在线图片压缩 文字对比 二维码在线解析 草料二维码 屏幕帧速率比较 编辑器 UEditor 百度 UEditor 富文本 在线Markdown typora Markdown markdown 在线转换 GLSL在线编辑 json格式化 csv 转json excel 转json,csv 转json 正则表达式测试 汉字手写输入 数学公式 \\frac{ h_{x} } { H_{当前设备高度} } = \\frac{600} {1920_{设计稿高度}} 信息查询 国家企业信用信息公示系统 中国版权保护中心 行政区划分 磁力搜索 opendrive 小白网盘搜索 历史价格对比1 历史价格对比2 备案信息查询 备案信息查询2 备案信息查询3 MD5 反查 MD5 编码 网页快照查询 站点网络测试 多地点 ping 知网 知网镜像 Data 字幕搜索 照片回执网站 在线获取照片回执,免去照相馆的麻烦 pc 软件 福昕pdf 在阿里云盘 Everything 电脑全局搜索 Snipaste 截图、贴图 ConEmu 比cmd好用的命令行工具 cports 端口查看工具 EVCapture录屏工具 GifCam_v6.5 gif录制 ，在阿里云盘 AdvancedRenamer文件名批量相关 SnapTimer 计时器 电脑壁纸 油猴脚本 解除网站不允许复制的限制 知乎免登录脚本 百度网盘下载助手 浏览器插件 Tampermonkey 油猴 用户脚本管理器 彩云小译 -网页翻译插件 Postman Website Blocker 网页黑名单 猫抓 网页媒体嗅探 Adblock Plus 广告拦截 AdBlock 广告拦截 智力开发 力扣算法 文学/国学 鸠摩搜书 诗词文学地图 寻古诗词网 kindleer 电子书分享 Koodo pc epub 阅读器 百度阅读器 在阿里云盘 文字倒叙 英文日文 彩云翻译插件 slashdot 英文新闻 可可英语 中国日报双语频道 文档模板 mydocuments 项目代码 在线简历 代码块Share 无人车APP WalkeraDrone1100 WK420_6K Version2017All-ReadOnly 农服App AppsUrl 航线规划Demo 微信点赞助手 史海沉钩阅读器 天气APP 俄罗斯方块 android_ftp_server android_http_server SmartHomeApp 智能家居APP万物互联 简易博客前端 简易博客后台 基于 springBoot 的 api服务器 服务器demo BusinessExternal xiaoyi DataShareDev hexo 红尘之声 第一个小程序 ( no Copyright，enjoy youself ! ) all right reserved，powered by GitbookThe file was updated at : 2021-08-26 16:41:48 "},"chinese/常用软件/常用软件和框架.html":{"url":"chinese/常用软件/常用软件和框架.html","title":"常用软件和框架","keywords":"","body":"IntelliJ IDEA IntelliJ IDEA 下载地址为 https://www.jetbrains.com/idea/download/#section=windows IntelliJ IDEA 商业版 License 免费申请。 申请地址为 https://www.jetbrains.com/shop/eform/opensource?product=ALL 一般是一周左右就可以通过。 申请条件是自己的开源项目， github 和gitee上的都可以。 我用的就是托管在 gitee上的开源项目。 许可证的有效周期为一年 They are valid for one year. You will receive an automatic email reminder shortly before the license expiration date. 根据收到的邮件进入授权页面，点击 Assign 授权给你指定的账号。 然后打开 IntelliJ IDEA 就行使用即可。 Androidstudio 安装或更新后插件后都需要重启 Androidstudio 。 Androidstudio下载 Androidstudio 自动代码补全配置 通过输入快捷键，自动补全模板代码， 例如 输入 \"todo\" , 就可以自动生成 \"// TODO: 2021/2/4 \" ctrl + J 快速查看 Live Templates 打开 \"设置 -> Editor -> Live Templates\"， 可以看到默认已经有很多\"Live Templates\" ，可以进行修改。 导入原有的模板： 将文件替换即可 （C:\\Users\\kaifa4k\\.AndroidStudio2.2 是你自己的安装路径） C:\\Users\\kaifa4k\\.AndroidStudio2.2\\config\\templates CodeGlance 代码快速定位 插件 Android-Resource-Usage-Count 显示 Android 资源使用的次数。 翻译插件ECTranslation 原理是调用了有道词典的API 。可以自定义 快捷方式，我目前设置的是 alt + m 快捷键设置 Preferences -> Keymap -> 搜索Translate - > 右键 add Keyboard Shortcut. 输入你想要的快捷键。 Android Parcelable code generator 自动生成 Parcelable接口相关的代码。 public class FtpThumDownListInfo implements Parcelable{ /**当前这个指针 指向的文件需要下载*/ private int gotoDownFileIndex = 0; /**需要下载的文件列表- 这个列表会分批次增加 */ private List ftpNeddLoadList =null ; /**下载好的文件的byte[]*/ private List ftpDowndBytesList =null ; //以下代码是 用插件自动生成的 start protected FtpThumDownListInfo(Parcel in){ this.gotoDownFileIndex = in.readInt(); this.ftpNeddLoadList = new ArrayList(); in.readList(this.ftpNeddLoadList, FTPFile.class.getClassLoader()); this.ftpDowndBytesList = new ArrayList(); in.readList(this.ftpDowndBytesList, FTPFile.class.getClassLoader()); } /** * 内容接口描述，默认返回0就可以了 */ @Override public int describeContents(){ return 0; } @Override public void writeToParcel(Parcel dest, int flags){ dest.writeInt(this.gotoDownFileIndex); dest.writeList(this.ftpNeddLoadList); dest.writeList(this.ftpDowndBytesList); } /** 实例化静态内部对象 * 接口对象名必须为CREATOR. * 必须按成员变量声明的顺序读取数据 */ public static final Parcelable.Creator CREATOR = new Parcelable.Creator() { @Override public FtpThumDownListInfo createFromParcel(Parcel source) { return new FtpThumDownListInfo(source); } @Override public FtpThumDownListInfo[] newArray(int size) { return new FtpThumDownListInfo[size]; } }; // 以下代码是 用插件自动生成的 end } //赋值 Bundle mBundle = new Bundle(); mBundle.putParcelable(\"picBean\",picBean); intentToMatch.putExtras(mBundle); //获取： RecommendPicBean picBean = (RecommendPicBean)getIntent().getParcelableExtra(\"picBean\"); 无线调试 ADB WIFI 华为M2 ，无Root 1、 确保电脑和手机在同一个局域网 2、插上USB线 连上adb 3、adb tcpip 5555 ( 5555为端口号，可自由指定） 4、adb connect 192.168.x.x:5555 // 如果是想同时连接多个设备 > adb devices // 找到设备号 adb -s 设备号 指令 // 使用 -s 参数指定设备号 布局查看器 可以用 Androidstudio 自带工具查看 DecorView的布局。 Tools -> Layout Inspector 生成文档 JavaDoc 找到工具栏上的 Tools，选择 Generate JavaDoc 如果出现编码错误提示，则在 Other command line arguments 中添加 -encoding utf-8 -charset utf-8 多行注释快捷键 Ctrl+Shift+/ // idea将单行注释替换为多行注释 匹配正则 // +(.*$) ----------> /**\\n * $1\\n */ 代码折叠 可以把相关的代码放在一组 region 中， 这样这组代码就可以收起和展开。 // region 布局测试 ...... 这是代码... // endregion 布局测试 git操作 配置全局信息 git config --global user.name \"aivin666@qq.com\" git config --global user.email \"aivin666@qq.com\" git config --list //查看当前用户信息 拉取指定分支 git clone -b 分支名称 https://xxxx.git 拉取指定历史版本 1、找到历史版本，获取对应的版本编号 2、git checkout xxxxx 添加个人私钥到网站 这种情况下无需配置密码 - window10下测试 1、生成对应的文件 ssh-keygen -t rsa -C 'aivin666@qq.com' 2、将 id_rsa.pub 里面的内容填写到网站上。 3、测试是否成功 。 ssh -T git@gitee.com 配置密码方式 Ubuntu下测试 https模式，每次提交都需要输入密码。 1、在一个新目录 初始化 git init 2、将远程代码拉倒本地 git pull https://gitee.com/hnyer/java_android.git 3、关联远程端仓库 master 是远程端的一个支路。 git remote add master https://gitee.com/hnyer/java_android.git // git remote rm master , 删除关联 4、 将本地指定的版本推送到远程端指定的版本 的一个maser是远程的 ，第二个是本地的 git push -u master master 5、以后不用每次都用参数 u ,直接 git push 即可 Ubuntu下 SSH 配置 码云 1、进入 /home/用户名/.ssh 目录下 生成公钥 ssh-keygen -t rsa -C \"your_email@example.com\" 2、将 id_rsa.pub 文件中的内容填入码云网站中 。 3、即可正常拉取 、提交 gitignore 文件 1、如果不清楚添加规则，可以借用插件 .gitignore 进行鼠标添加 2、有时会遇到修改了忽略文件后，规则并没有生效的现象。 原因是.gitignore只能忽略那些原来没有被追踪的文件，如果某些文件已经被纳入了版本管理中， 则修改.gitignore是无效的。那么解决方法就是先把本地缓存删除（改变成未被追踪状态），然后再提交。 git rm -r --cached ./ (注意那个小数点) gitbook windows 安装gitbook 安装gitbook过程中请优先连接VPN，如果没有请考虑更换淘宝源等方式。 npm uninstall -g gitbook // 卸载 gitbook npm uninstall -g gitbook-cli npm cache clean --force //清除npm缓存 npm install gitbook -g // 安装gitbook npm install -g gitbook-cli gitbook -V // 查看版本 gitbook ls // 列出本地所有的gitbook版本 在国内为了加速访问速度，一般会更换成淘宝的下载源 // 设置 淘宝镜像源 npm config set registry https://registry.npm.taobao.org npm config get registry // 查看 使用的 镜像源 npm install -g cnpm --registry=https://registry.npm.taobao.org gitbook常用的使用命令 gitbook install // 安装依赖包 gitbook init //新建定义好的文件 gitbook serve // 本地服务器测试 gitbook build // 编译成html格式 安装错误 如果遇到 “ Error: ENOENT: no such file or directory ... ” 这个错误 ， 把.gitbook\\versions\\3.2.2\\lib\\output\\website\\copyPluginAssets.js 修改成 confirm：false 如果遇到 fs\\polyfills.js:287 if (cb) cb.apply(this, arguments) ... 根据报错信息，找到 polyfills.js ，注释 62-64 行即可 Node.js：v14.15.4. CLI version: 2.3.2 GitBook version: 3.2.3 gitbook 热更新 (Windows) https://github.com/GitbookIO/gitbook-cli/issues/67 暂时没找到优雅的办法。给出粗暴的方案，检测到奔溃后又重启。 将下面的命令做成一个 xx.bat ，通过这个文件启动即可。 @echo off :start call gitbook serve @goto start gitbook 留言评论 使用 Valine 插件可以实现 (20210204)。 Valine 是一款无后端评论系统。 https://valine.js.org/ Valine 是基于 leancloud 实现的(Valine的评论数据保存在这里) 需要申请 leancloud 的账号，因为国内监管问题， 如果你不想实名认证和域名备案，请使用国际版 (20210204)。。 https://console.leancloud.app/apps 虚拟机 VMware Workstation 12序列号 5A02H-AU243-TZJ49-GTC7K-3C61N //安装完VmTools重启之后仍不能全屏显示 检查VmTools是否安装成功: 将主机的一个文件拖到虚拟机，如果可以托进去说明已经安装成功，否则没有。 如果还没有全屏显示，就设置成\"自动适应窗口\"。 windows 系统 如果用的是正版的win10系统，会经常提示更新，但是如果你不想强制你更新， 可以 使用 Windows Update Blocker将更新模块禁止掉。 电脑浏览器模拟手机浏览器 pc端谷歌浏览器模拟微信浏览器，然后利用音频抓取插件抓取音频。 因为有些网页做了限制“请在微信客户端打开链接” 。 1、电脑端谷歌浏览器安装插件 \" user agent switcher \" 2、在插件中模拟微信浏览器的 UA ( userAgent ) mozilla/5.0 (linux; android 5.1.1; mi note pro build/lmy47v) applewebkit/537.36 (khtml, like gecko) version/4.0 chrome/37.0.0.0 mobile mqqbrowser/6.2 tbs/036215 safari/537.36 micromessage/6.3.16.49_r03ae324.780 nettype/wifi language/zh_cn 3、然后浏览器安装插件“猫抓”，进行视屏抓取。 ps 常用快捷键： 移动工具 V 裁剪工具 C shift+ctrl+alt+s 保存切片 放大视图 Ctrl+【+】 缩小视图 【Ctrl】+【-】 切图： ctrl + alt + shift + a 制作圆角矩形图片 参考资料 图片渐变、透明度渐变 参考资料 PS里怎么样将白色背景去掉，变成透明的背景？ 参考资料 要先解压图层锁定 打开图片，单纯白色背景的话则只需使用工具栏中的魔棒工具在白色部位点一下，跟着delete键删除，此时就是透明的背景图片了，但关键的是要选择合适的保存方式。点文件-存储为web和设备所用格式，在弹窗选择附图红框处的PNG格式就可以了。 方法一:用擦除工具组中的魔棒擦除,点选白色 方法二: 1、用选择工具中的魔棒工具选白色(勾选连续的). 2、然后反选,复制 3、再粘贴成新层 4、册掉背景层 5、完 xUtils https://github.com/wyouflf/xUtils3 compile 'org.xutils:xutils:3.5.0' // 1、在Application 初始化 // import org.xutils.x; x.Ext.init(this); x.Ext.setDebug(false); // get请求 private void loadData( ) { String API = Ipconfig.KEY_WORKNEWS_DetailItem; API = API.replace(\"{pageSize}\" ,\"10\") ; RequestParams params = new RequestParams(API); Callback.Cancelable cancelable = x.http().get(params, new Callback.CommonCallback() { @Override public void onSuccess(String result) { } @Override public void onError(Throwable ex, boolean isOnCallback) { } @Override public void onCancelled(CancelledException cex) { } @Override public void onFinished() { } }); } // post 请求 private void requestHost(String name, String pwd1 ) { String API = Ipconfig.KEY_userRegister; RequestParams params = new RequestParams(API); params.addBodyParameter(\"userName\",name); params.addParameter(\"password\",pwd1); x.http().post(params, new Callback.CommonCallback() { public void onSuccess(String result) { } }); // 文件上传 String api =\"http://xxx\" ; RequestParams params = new RequestParams(api) ; params.setMultipart(true); params.addBodyParameter(\"userId\", MyApplication.getUserId(activity)); params.addBodyParameter(\"file\", new File( filePath)); Callback.Cancelable cancelable = x.http().post(params, new Callback.CommonCallback() { @Override public void onSuccess(String result) { } }); // 文件下载 RequestParams requestParams = new RequestParams(); requestParams.setSaveFilePath(filePath); requestParams.setUri(url);// 文件url x.http().get( requestParams, new Callback.ProgressCallback() { @Override public void onSuccess(File result) { } @Override public void onLoading(long total, long current, boolean isDownloading) { float percent = 100f* current / total ; } butterknife butterknife 常用的功能就是 findview 绑定 和 click 绑定。 https://github.com/JakeWharton/butterknife butterknife 添加依赖 Butterknife requires Java 8, compileOptions { sourceCompatibility JavaVersion.VERSION_1_8 targetCompatibility JavaVersion.VERSION_1_8 } dependencies { // 在 基础库中添加 implementation 'com.jakewharton:butterknife:10.2.3' } dependencies { // 在项目根目录的 build.gradle 中添加插件依赖 classpath 'com.jakewharton:butterknife-gradle-plugin:10.2.3' } // 在需要使用的 module 中添加 apply plugin: 'com.jakewharton.butterknife' // 哪个 module 使用，就在哪个 module 中添加，而不是添加在在基础module中，否则注解是无效的。 annotationProcessor 'com.jakewharton:butterknife-compiler:10.2.3' butterknife 使用示范 @BindView(R2.id.wkExpandOhterFunc) public WkExpandLayout wkExpandLayout ; setContentView(R.layout.lib_login_activity_login); ButterKnife.bind(this); @OnClick({R2.id.changeStateBtn }) public void onViewClicked(View view){ int id = view.getId(); if (id == R.id.changeStateBtn) { // todo } } EventBus、 缺点： 不容易跟踪调试代码。逻辑不是很连贯。 https://github.com/greenrobot/EventBus compile 'org.greenrobot:eventbus:3.1.1' // 绑定 @Override public void onStart() { super.onStart(); EventBus.getDefault().register(this); } // 解绑 @Override public void onStop() { super.onStop(); EventBus.getDefault().unregister(this); } // 发送 EventBus.getDefault().post(new MessageEvent()); // 接收 @Subscribe(threadMode = ThreadMode.MAIN) public void onEventBusMsgCome(WkEventBean bean) { switch (bean.getCode()){ case WkEventBean.CODE_1: String msg = (String) bean.getData() ; WkLog.d(\"UI received = \"+msg); break; default: break; } public class WkEventBean { public static final int CODE_1 = 1; public static final int CODE_2 = 2; public WkEventBean(int code , Object data){ this.code = code ; this.data =data ; } private int code ; private Object data ; public int getCode() { return code; } } RxJava 2.x 要在Android中使用RxJava2, 需要依赖 Rxjava2.x 、 RxAndroid 异步事件处理框架。 continued support for Java 6+ & Android 2.3+ 基于观察者设计模式。 RxJava1.x 跟 RxJava2.x 不能共存 ，会冲突。 RxJava组成元素 RxJava基本组成元素 说明 被观察者 数据源 发送数据 观察者 接收到（处理后的数据） 建立订阅关系 操作符 可以对数据进行过滤、转换等处理 线程切换 指定发送和接收的线程 RxJava 常用类 常用类 作用 Observable 被观察者 ObservableEmitter 用来发出事件的，它可以发出三种类型的事件 x.onNext() x.onComplete() x.onError() 发射规则如下： 1、上游可以发送无限个onNext ，下游也可以接收无限个onNext 2、当上游发送了一个onComplete后（只能发一次）, 上游onComplete之后的事件将会继续发送, 而下游收到onComplete事件之后将不再继续接收事件 3、当上游发送了一个onError后（只能发一次）, 上游onError之后的事件将继续发送, 而下游收到onError事件之后将不再继续接收事件 4、上游可以不发送onComplete或onError. 5、onComplete 和 onError 只能发送一个 , 不能都发送 ObservableOnSubscribe Observer 观察者 Disposable x.dispose() 切断订阅关系。 调用dispose()后 ，观察者接收不到数据，但是数据源还可以继续发送 CompositeDisposable Disposable 容器 x.add(...) x.clear() Flowable Rxjava2 新增的 。数据发送 。我们可以用Flowable + Subscriber 来解决 收发速度不一致问题 Subscriber 与Flowable搭配， 数据接收。 Subscription 切断订阅关系 Subscription.cancel() 观察者请求数据源发送多少个数据 subscription.request(Long.MAX_VALUE) FlowableEmitter 返回 观察者 能处理多少个数据 flowableEmitter.requested() Action BiConsumer BiFunction Predicate BiPredicate BooleanSupplier Cancellable Consumer Function Function3 Function4 Function5 Function6 Function7 Function8 Function9 IntFunction LongConsumer Schedulers 调度器。 当数据源和观察者在同一个线程时，这是一个同步的订阅关系 。 数据源每发送一个事件后必须等到观察者接收处理完了以后才能接着发送下一个。 当处于不同线程时 ,就是异步的订阅关系, 这个时候数据源可以自由发送数据。 //CPU计算密集型线程 默认线程数等于处理器的数量 Schedulers.computation() // 使用指定的Executor作为调度器 Schedulers.from() // io操作的线程 Schedulers.io() // 常规新线程 Schedulers.newThread() // Android主线程 AndroidSchedulers.mainThread() // 在当前线程执行 ，不过需要等队列中的其他任务完成后才执行 Schedulers.trampoline() BackpressureStrategy 背压策略 抗压力策略 背压是指在异步场景中，数据源发送事件速度远快于观察者的处理速度的情况下， 一种告诉 数据源 需要降低发送速度的策略 。 // 缓存区大小128，超过大小继续发就会报错 BackpressureStrategy.ERROR // 默认128，超过大小继续发就会 提示缓冲满了 BackpressureStrategy.MISSING // 默认大小128 ，大于128时就会修改为无限大。直到OOM BackpressureStrategy.BUFFER // 默认128 ，超过128后来的数据会被丢掉 BackpressureStrategy.DROP // 默认128 ，超过128就会只会保留最后的一个数据。 最后总个数 是 129 BackpressureStrategy.LATEST SingleEmitter 用来发射一条单一的数据，且一次订阅只能调用一次 singleEmitter.onSuccess() // onSuccess与onError只可调用一个 ，否则会报异常 singleEmitter.onError() Subject 主题 , 不支持背压控制 一种特殊的存在 ，同时是 数据接收者 和 发送者 AsyncSubject 无论输入多少参数，永远只输出最后一个参数 , 如果因为发生了错误而终止，AsyncSubject将不会发射任何数据 BehaviorSubject 会发送离订阅最近的上一个值，没有上一个值的时候会发送默认值。 如果遇到错误会直接中断 PublishSubject 一旦一个观察者订阅了该Subject，它会发送所有数据给订阅者。 如果接收者只关系自己订阅的信息 ，可以用ofType来过滤 订阅者只会接受订阅之后的来自PublishSubject发射的数据。 ReplaySubject 无论何时订阅，都会将所有历史订阅内容全部发出 Processor rxjava2.x新增的 ，作用与Subject一样 。 支持背压控制 AsyncProcessor BehaviorProcessor PublishProcessor ReplayProcessor Transformer 转换器 ， 实际上就是Func1， 换句话说就是提供给他一个Observable它会返回给你另一个Observable ObservableTransformer SingleTransformer CompletableTransformer FlowableTransformer MaybeTransformer RxJava2.0中的观察者模式 RxJava2.0中的观察者模式 说明 Observable / Observer 不支持背压，及无法处理发送数据速度不协调的问题。 Flowable/ Subscriber Single/ SingleObserver 只发射一条单一的数据，或者一条异常通知， 不能发射完成通知，其中数据与通知只能发射一个。 // 可以指定Schedulers实现异步处理 ，如果不被订阅是不会被调用的 Single.create // 接收传入的参数 ，是一种特殊的create() ，只会在当前线程里执行 , 不管是否被 订阅均会被调用 Single.just // 仅仅用来连接Single顺序执行的，比如顺序执行检查网络，检查内存 ，注意：如果某个Single调用了onError()会导致被中断 Single.concat // 将多个Single整合为一个 Single.zip // Observable.just().zipWith() //创建一个自定义的操作符，用来处理数据发送者 。 就是对当前Observable进行操作，然后再返回它 Single.compose // Single.subscribe // 返回一个错误， 一般用于调试 Single.error // 用于一对0~多的返回 Single.just( ... ).flatMap() // 一般map()是用于一对一的返回 Single.just( ).map() // 它支持将Single转化为Observable对象，可以返回多个值 Single.just( ).flatMapObservable() // 类似于concat ，如果有中断 ，后面都会中断 Single.merge() // Single.just().mergeWith() // 用于指定异步任务的线程 Single.just().subscribeOn() // 相当于try catch中的return，具体意思就是当函数抛出错误的时候给出一个返回值 Single.just().onErrorReturn() // 指定回调所在线程 Single.just().observeOn() // 超时设置 Single.just().timeout() // Single.just( ).toString() Completable/ CompletableObserver 只发射一条完成通知，或者一条异常通知， 不能发射数据，其中完成通知与异常通知只能发射一个 Maybe/ MaybeObserver 可发射一条单一的数据，以及发射一条完成通知， 或者一条异常通知，其中完成通知和异常通知只能发射一个， 发射数据只能在发射完成通知或者异常通知之前，否则发射数据无效。 RXjava2操作符 所谓的操作符就是一些被Rxjava封装好的方法或API ，使用这些操作符就可以完成线程调度，数据过滤等功能 。 操作符类型 说明 create() 创建被观察者对象 just() 快速的创建被观察者对象 fromArray() 将数组中的数据转换为Observable对象 fromIterable() 将List中的数据转换为Observable对象 empty() 用于测试 ，仅发送Complete事件 error() 用于测试 ，仅发送Error事件 never() 不发射数据，也永远不会结束 defer() 直到有观察者订阅时，才创建被观察者对象&发送事件 每次订阅后，都会得到一个刚创建的最新的Observable对象 timer() 延迟指定时间后，发送1个数值0 interval() 每隔指定时间就加n并发送出去 range() 连续发送一个事件序列，可指定范围 rangeLong() 跟 range()类似，支持数据类型为Long intervalRange() 每隔指定时间 就发送 事件，可指定发送的数据的数量 map() 将传入数据处理后返回 。 输入和输出是一对一 flatMap() 输入和输出可以是 一对多 不能保证 输出的顺序和输入的顺序一致 concatMap 输入和输出可以是一对对 输出和输入顺序 严格一致 buffer() 每次取n个事件放到缓存区中，n可配置 filter() 将符合自定义条件的事件过滤出来 ofType() 过滤 特定数据类型的数据 skip() 跳过正序的前 n 项 skipLast() 跳过正序的后 n 项 distinct() 去掉序列中重复的事件 distinctUntilChanged() 去掉序列中连续重复的事件 take() 指定观察者最多能接收到的事件数量 takeLast() 指定观察者只能接收到被观察者发送的最后几个事件 throttleFirst() 在某段时间内，只发送该段时间内第1次事件 throttleLast() 在某段时间内，只发送该段时间内 最后1次事件 sample() 指定时间内 取一次数据 ，其他的数据就会被丢掉 throttleWithTimeout() 在输出了一个数据后的一段时间内，没有再次输出新的数据， 则把这个数据真正的发送出去； 假如在这段时间内有新的数据输出，则以这个数据作为将要发送的数据项， 并且重置这个时间段，重新计时 debounce () 跟 throttleWithTimeout() 一样 firstElement() 仅选取第1个元素 lastElement() 仅选取最后一个元素 elementAt() 接收指定索引的某个元素 ， 索引越界也不会报异常 elementAtOrError() 接收指定索引的某个元素 ， 索引越界 会报异常 all() 判断发送的所有数据是否都满足自定义的条件 , true false takeWhile() 判断发送的每项数据是否满足 自定义条件 若满足条件则发送 ,不满足不发送 skipWhile() 一直跳过，直到满足自定义条件 skipUntil() - takeUntil() 一直发送 ，直到某个条件 sequenceEqual() 两个数据源的数据是否相同 isEmpty() 数据源的数据是否为空 contains() 数据源中是否包含指定数据 defaultIfEmpty( obj) 在不发送任何有效事件（ Next事件）、仅发送了 Complete 事件的前提下，发送个默认值obj amb() 当有多个数据源需要发送数据时 ， 只发送 先发送数据的Observable的数据，而其余 Observable被丢弃。 concat() 组合多个被观察者一起发送数据，合并后 按发送顺序串行执行 concatArray() 跟concat()类似 merge() 组合多个被观察者一起发送数据，合并后 按时间线并行执行 被观察者数量≤4 mergeArray() 被观察者数量 > 4 mergeWith() delay() 使被观察者延迟一段时间再发送事件 concatDelayError() 使用concat()，一旦某个被观察者发出onError事件，其他被观察者就会终止发送。 为了让其他被观察者继续发送，可以使用这个操作符 concatArrayDelayError() mergeDelayError() combineLatestDelayError() reduce() 把被观察者需要发送的事件聚合成1个事件、发送 collect() 将被观察者发送的数据事件收集到一个数据结构里 startWith() 在被观察者发送事件前，追加发送一些数据 startWithArray() count() 统计被观察者发送事件的数量 subscribe() 订阅， 连接观察者 和 被观察者 zip() 多个数据源Observable 发送数据，经过自定义组合处理后，观察者再收到 。 1、组合数据时严格按照顺序从多个数据源中拿数据。 2、最后观察者收到的数据个数 跟发送最少数据的数据源的数据个数相同。 x.zipWith() combineLatest() 如果子流1在等待其他流发射数据期间又发射了新数据， 则使用子流最新发射的数据进行合并 x.concatMap() x.scan() x.window() subscribeOn() 指定发送事件的线程 只有第一次指定有效，其余的指定线程无效 unsubscribeOn() 取消订阅 observeOn() 指定接收事件的线程 每次指定均有效 doOnEach() 每发送一次就会调用一次 doOnNext () 执行 next之前调用 doAfterNext() 执行 next之后调用 doOnError() doOnComplete() doOnTerminate() doFinally() doOnSubscribe() 观察者订阅时调用 onErrorReturn() 遇到错误时，发送1个特殊事件 & 正常终止 onErrorResumeNext() 拦截的错误 是Throwable 类型 onExceptionResumeNext() 拦截的错误 是 Exception类型 retry() 当捕捉到错误时，被观察者会重新发射数据 retryUntil() 遇到错误，重新发射，直到... retryWhen() repeat() 无条件地、重复发送事件 repeatWhen() repeatUntil() publish() share() connect() 补充知识点 链式调用 MsgInfo msgInfo = new MsgInfo(); // 链式调用 msgInfo.setOwnerId(\"100011002\") .setStatus(MsgInfo.Status.SENDING) .setTime(System.currentTimeMillis()); // 普通调用 msgInfo.setOwnerId(\"100011002\"); msgInfo .setStatus(MsgInfo.Status.SENDING) ; msgInfo .setTime(System.currentTimeMillis()); // 链式调用的关键在于方法的返回值！ public MsgInfo setStatus(int status) { this.status = status; // 注意返回的是 this return this; } Retrofit 2.x 一个支持 RxJava方式调用的网络请求框架 A type-safe HTTP client for Android and Java by Square, Inc. requires at minimum Java 7 or Android 2.3. Retrofit 提供2种风格的网络请求方式： 1、传统风格 (略过不看) 采用Callback 接口 2、RxJava 风格 (流行) 采用Observable接口 Retrofit2 + Rxjava2 依赖 // rxjava核心库 compile 'io.reactivex.rxjava2:rxjava:2.0.1' // Android 支持 Rxjava compile 'io.reactivex.rxjava2:rxandroid:2.0.1' // Android 支持 Retrofit compile 'com.squareup.retrofit2:retrofit:2.1.0' // 衔接 Retrofit & RxJava compile 'com.jakewharton.retrofit:retrofit2-rxjava2-adapter:1.0.0' // 支持Gson解析 compile 'com.squareup.retrofit2:converter-gson:2.1.0' 注解 作用 @GET get请求 @POST post请求 @DELETE delete请求 @HEAD head请求 @OPTIONS options请求 @PATCH patch请求 @Headers 添加请求头 @Path get请求 ，user/{password} 格式 @Query get请求 ， user/password?password=xxx 格式 @FormUrlEncoded 用表单数据提交 @Field post需要 post请求需要 ， 替换参数 //定义请求接口 public interface BlogService { // get 方式 @GET(\"getAllMusicInfoGson\") Call getBlogByGet(@Query(\"pageNum\") int pageNum); // post 方式 @FormUrlEncoded @POST(\"getAllMusicInfoGson\") Call getBlogByPost(@Field(\"pageNum\") int pageNum); } //简单使用 Retrofit retrofit = new Retrofit.Builder() .baseUrl(\"https://www.aivin666.cn/AivinInfo/\")// url根目录 .build(); BlogService service = retrofit.create(BlogService.class); //Call call = service.getBlogByGet(2);//get方式 Call call = service.getBlogByPost(2);//post方式 call.enqueue(new Callback() { @Override public void onResponse(Call call, Response response) { try { String reslut = response.body().string(); tvHttpResult.setText(reslut); Log.i(TAG , reslut) ; } catch (Exception e) { } } @Override public void onFailure(Call call, Throwable t) { } }); Retrofit_RxJava_OkHttp Retrofit + RxJava + OkHttp Retrofit 负责请求的数据和请求的结果 RxJava 负责异步，各种线程之间的切换 OkHttp 负责请求的过程 // rxjava 核心库 compile 'io.reactivex.rxjava2:rxjava:2.1.14' // Android 支持 Rxjava compile 'io.reactivex.rxjava2:rxandroid:2.0.1' // retrofit 核心库 compile 'com.squareup.retrofit2:retrofit:2.4.0' // retrofit json 转换器 compile 'com.squareup.retrofit2:converter-gson:2.3.0' // 衔接 Retrofit & RxJava compile 'com.squareup.retrofit2:adapter-rxjava2:2.3.0' // okhttp 核心库 compile 'com.squareup.okhttp3:okhttp:3.10.0' // okhttp log 拦截器 compile 'com.squareup.okhttp3:logging-interceptor:3.8.1' RxJava 订阅者 public class HttpSubscriber implements Observer { private PicInfoSubscriberListener subscriberOnListener; private Context context; private Disposable disposable; public HttpSubscriber( PicInfoSubscriberListener subscriberOnListener, Context context) { this.subscriberOnListener = subscriberOnListener; this.context = context; } @Override public void onSubscribe(@NonNull Disposable d) { disposable = d; } @Override public void onComplete() { if( (subscriberOnListener == null) || (context == null)) { if(disposable != null && !disposable.isDisposed()){ //切断订阅关系 disposable.dispose(); } } } @Override public void onError(Throwable e) { if(subscriberOnListener != null && context != null) { if (e instanceof SocketTimeoutException) { subscriberOnListener.onError(-1001, \"网络超时，请检查您的网络状态\"); } else if (e instanceof ConnectException) { subscriberOnListener.onError(-1002, \"网络链接中断，请检查您的网络状态\"); } else if(e instanceof MyException){ subscriberOnListener.onError(((MyException)e).getCode(), ((MyException)e).getMsg()); } else { subscriberOnListener.onError(-1003, \"未知错误:\" + e.getMessage()); } } else { if(disposable != null && !disposable.isDisposed()){ disposable.dispose(); } } } @SuppressWarnings(\"unchecked\") @Override public void onNext(T t) { if(subscriberOnListener != null && context != null) { // 收到想要的订阅信息 ，然后通过回到接口 发送到需要数据的地方 subscriberOnListener.onSucceed((List) t); } else { if(disposable != null && !disposable.isDisposed()){ disposable.dispose(); } } } } 定义 发布者 的能力接口 /** * 最终的访问地址是 主地址 + 尾地址 http://xxx/getAllPicInfoGson?pageNum=6 * 此处填写 尾地址 */ @GET(\"getAllPicInfoGson\") Observable> getPicListByGet(@Query(\"pageNum\") int pageNum ); @FormUrlEncoded @POST(\"getAllPicInfoGson\") Observable> getPicListByPost( @Field(\"pageNum\") int pageNum ); 封装发布者 /** * 封装 图片模块的http接口 */ public class PicInfoApi { private final String TAG=\"PicInfoApi\" ; private static PicInfoApi picInfoApi; private PicInfoService picInfoService; private PicInfoApi() { final String BASE_URL_PANDA = \"https://www.aivin666.cn/AivinInfo/\"; picInfoService = HttpClient.getInstance(BASE_URL_PANDA).createApi(PicInfoService.class); } public static PicInfoApi getInstance() { if(picInfoApi == null) { picInfoApi = new PicInfoApi(); } return picInfoApi; } public void getPicListByGet (Observer >subscriber , int pageNum) { // 通过操作符 map(...) 将接收的数据经过处理后再返回 Observable observable = picInfoService.getPicListByGet(pageNum) .flatMap( function ); toSubscribe(observable, subscriber); } public void getPicListByPost (Observer> subscriber , int pageNum) { // 通过操作符 map(...) 将接收的数据经过处理后再返回 Observable observable = picInfoService.getPicListByPost(pageNum) .flatMap( function ); toSubscribe(observable, subscriber); // 将观察者 和订阅者 关联起来 } private void toSubscribe( Observable> o, Observer> s){ o.subscribeOn(Schedulers.io()) // 运行在 io 线程中 .unsubscribeOn(Schedulers.io())// 取消订阅 .observeOn(AndroidSchedulers.mainThread())// 指定接收事件的线程 .subscribe(s);// 订阅 } /*** * 配合 操作符 map 使用 * Function, List> 第一个参数是输入数据类型 ， 第二个参数是输出类型 * List apply(List list) * 第一个 List 是返回数据类型 ， 第二个 List 是输入的数据类型 * */ private Function function = new Function, Observable > >() { @Override public Observable > apply(List list) throws Exception { // 可以在这个函数里面进行数据过滤等处理 if(list != null && list.size() > 0) { Log.i(TAG , \" 数据处理=\"+ list.size()) ; }else{ Log.i(TAG , \" 数据处理 没有获取到数据\") ; } return Observable.fromArray(list) ; } }; 进行http访问的相关配置 public class HttpClient { private static String token = \"\"; private static Retrofit retrofit; private static HashMap clients = new HashMap<>(); private HttpClient(String url) { retrofit = new Retrofit.Builder() .baseUrl(url) // 设置接口主地址 .client(getHttpRequestClient())// 配置 HTTP 请求客户端 .addConverterFactory(GsonConverterFactory.create())// 配置json 转换器 // 添加支持 - 返回值定义为Observable对象 .addCallAdapterFactory(RxJava2CallAdapterFactory.create()) .build(); } public T createApi(Class clazz) { return retrofit.create(clazz);// 获取接口实例 } public static HttpClient getInstance(String url){ if(!clients.containsKey(url)) { HttpClient httpClient = new HttpClient(url); clients.put(url, httpClient); } return clients.get(url); // 一个主地址 对应一个client } /** * 定制 http 访问访问器 */ private OkHttpClient getHttpRequestClient() { HttpLoggingInterceptor logging = new HttpLoggingInterceptor( new OkHttpLogTool()); // 打印获取到的信息。 （不设置不打印） logging.setLevel(HttpLoggingInterceptor.Level.BODY); //设置缓存路径 String cacheDir = MyApplication.getInstance().getExternalCacheDir().getAbsolutePath() ; File httpCacheDirectory = new File(cacheDir , \"OKHttpResponses\"); //设置缓存 大小 Cache cache = new Cache(httpCacheDirectory, 50 * 1024 * 1024); // 自定义拦截器 Interceptor interceptor = new Interceptor() { @Override public Response intercept(Chain chain) throws IOException { Request request = chain.request() .newBuilder() .addHeader(\"token\", token) .build(); // 无网络时 ，使用缓存 if (!NetUtil.isNetworkConnected(MyApplication.getInstance())) { request = request.newBuilder() .cacheControl(CacheControl.FORCE_CACHE) .build(); } Response response = chain.proceed(request); if (NetUtil.isNetworkConnected(MyApplication.getInstance())) { // 有网络时 设置缓存超时时间0个小时 int maxAge = 0 * 60; response.newBuilder() .addHeader(\"Cache-Control\", \"public, max-age=\" + maxAge) // 清除头信息，因为服务器如果不支持，会返回一些干扰信息，不清除下面无法生效 .removeHeader(\"Pragma\") .build(); } else { // 无网络时，设置超时为1周 int maxStale = 60 * 60 * 24 * 7; response.newBuilder() .addHeader(\"Cache-Control\", \"public, only-if-cached, max-stale=\" + maxStale) .removeHeader(\"Pragma\") .build(); } return response; } }; OkHttpClient httpClient = new OkHttpClient.Builder() .addInterceptor(logging) .cache(cache) .addInterceptor(interceptor) .build(); return httpClient; } } 如何使用 private int pageNum = 6 ; private void testUrlGet() { PicInfoApi.getInstance().getPicListByGet( new HttpSubscriber>(new PicInfoSubscriberListener () { @Override public void onSucceed(List data) { // 获取到数据 } @Override public void onError(int code, String msg) { } }, this) , pageNum); } private void testUrlPost( ){ PicInfoApi.getInstance().getPicListByPost( new HttpSubscriber>(new PicInfoSubscriberListener () { @Override public void onSucceed(List data) { } @Override public void onError(int code, String msg) { } }, this) , pageNum); } react-native 将 reate-native 的相关笔记删除。体验不如 Flutter ，跨平台请使用 flutter。 Hierarchyviewer 借助ViewServer 这个工具可以在任何手机上使用 hierarchyviewer。 注：在 android device monitor 可以找到 hierarchyviewer。 检验手机是否开启了View Server： adb shell service call window 3 //View Server处于关闭状态 返回：Result: Parcel(00000000 00000000 '........')\" //View Server处于开启状态 返回值：Result: Parcel(00000000 00000001 '........')\" 抓包工具 对于一般的公司和个人来说，抓包难度越来越大。 暂时没有深入研究。 1、高版本的Android系统，例如7.0以上会抓包更难。 2、APP做了证书合法性检验。例如检测到非法证书无法启动APP。 3、https 传输 并对传输内容进行了加密。抓到后并不是明文。 常用工具有 小茶壶 charles https://www.charlesproxy.com/download/ HttpCanary https://github.com/MegatronKing/HttpCanary Fiddler 反编译 keystore 、 // apktool http://ibotpeaches.github.io/Apktool/install/ 解压apk文件，获取其中的图片、布局文件 ，必须用apktool打开。 apktool.bat d -f test.apk test 直接用解压软件打开的会显示乱码。 // dex2jar https://sourceforge.net/projects/dex2jar/files/ 直接用解压软件解开,获得dex。 用 dex2jar 将classes.dex转变成jar包。 dex2jar.bat classes.dex //在当前文件夹里生成classes_dex2jar.jar // jd-gui http://java-decompiler.github.io/ 用 jd-gui打开jar包，查看class 文件。 Mac 系统 复制粘贴 command +c v xcode 全局查找 command + shift + f commit+shift+J 快速定位文件 // xcode shift+ option + 全屏按钮 --》 最大化 command + 🔼箭头 // 返回上一个目录 command + F3 //回到桌面 command + tab //程序切换 贴图工具 // 安装 snap 软件 图片浏览软件，用 kantu 看图 。 // Xcode打包 应用 https://www.yisu.com/zixun/80031.html 首先我们打开要打包的工程文件，comm＋shift＋K清空，再comm＋B编译一下， 1、product --> scheme --> editor scheme 把debaug改成release，点击close。 2、product --> archive ( no Copyright，enjoy youself ! ) all right reserved，powered by GitbookThe file was updated at : 2021-08-18 09:54:32 "},"chinese/doc/开发规范.html":{"url":"chinese/doc/开发规范.html","title":"开发规范","keywords":"","body":"开发规范 Android开发规范 阿里巴巴Android开发规范 1.0.0 类型 规范 示例 资源文件 需带模块前缀 layout文件 - Activity 的 layout以 module_activity开头Fragment 的 layout 以 module_fragment 开头Dialog 的 layout 以 module_dialog 开头include 的 layout 以 module_include 开头ListView 的 item layout 以 module_list_item 开头GridView 的 item layout 以 module_grid_item 开头RecyclerView 的 item layout 以 module_recycle_item 开头 drawable 资源 小写单词+下划线 module_tabs_icon_home_normal module_login_btn_pressed anim 资源 - module_fade_out module_push_down_in color 资源 module_colors.xml 《color name=\"module_btn_bg_color\">#33b5e5e5 dimen 资源 module_dimens.xml 《dimen name=\"module_horizontal_line_height\">1dp style 资源 module_styles.xml 《style name=\"ParentTheme.ThisActivityTheme\"》 string 资源 module_strings.xml moudule_login_tips module_homepage_notice_desc 控件Id 资源 驼峰法命名 View 的缩写作为前缀 LinearLayout  ll RelativeLayoutnbsp   rlConstraintLayout   clListView   lvScollView   svTextView   tvButton   btnImageView   ivCheckBox   cbRadioButton   rbEditText   et //其它控件ProgressBar    progress_bar DatePicker    date_picker Java 开发规范 阿里巴巴编码规范Java 1.3.1 类型 规范 示例 资源文件 需带模块前缀 不能以下划线或美元符号开始、结束 _name Object$ 严禁拼音与英文混合严禁直接使用中文 类名 使用UpperCamelCase风格 TcpUdpDeal DO 、 DTO 、VO 、 DAO等例外 方法名参数名成员变量局部变量 使用lowerCamelCase风格 getHttpMessage() 常量 全部大写、用下划线隔开、语义表达完整 不允许任何魔法值 按模块分开放在不同文件中 MAX_STOCK_COUNT CacheConsts.java ConfigConsts.java 抽象类命名 Abstract 或 Base 开头 异常类命名 用Exception结尾 测试类命名 以它要测试的类名开始，以Test结尾 包名 统小写、统一使用单数形式 com.alibaba.ai.util √ com.alibaba.ai.utils × 接口类 方法和属性不要加任何修饰符号（包括public） void f(); √ void f(); × 枚举 类名带Enum后缀、成员名全大写、用下划线隔开 若变量值仅在一个固定范围内变化，请用枚举 UNKNOWN_REASON 大括号 若大括号内为空，则写成{} 若非空，则左大括号前不换行(不要学c代码的风格) 小括号 小括号和字符之间不出现空格 if (空格a == b空格) × equals方法 \"test\".equals(object); √ object.equals(\"test\"); × 构造方法 禁止写任何业务逻辑 POJO类(没有业务逻辑的类) 必须写toString方法，为了方便排除异常 字符串拼接 使用 StringBuilder final 不允许被继承的类 不允许修改的方法、变量 并不会影响内存的回收 单例对象、工具类 需要保证线程安全 if else for while 必须使用大括号 if (condition) statements × if()...else 请勿超过3层 终止、退出 高并发场景，禁止使用 “==”作为终止条件 并发处理错误会导致数量瞬间变成负数 而无法终止 条件判断 禁止执行复杂语句 if ((...) != null) && (...) &&(...)) × TODO FIXME 代表 “错误，不能工作” 亚信 xx系统编写规范 long或者Long初始赋值时，必须使用大写的L， 不能是小写的l，小写容易跟数字1混淆，造成误解。 不能使用过时的类或方法。 例如 java.net.URLDecoder 中的方法 decode(String encodeStr) 这个方法已经过时， 应该使用双参数 decode(String source, String encode)。 接口提供方既然明确是过时接口，那么有义务同时提供新的接口； 作为调用方来说，有义务去考证过时方法的新实现是什么。 异常不要用来做流程控制，条件控制，因为异常的处理效率比条件分支低。 对大段代码进行 try-catch，这是不负责任的表现。 捕获异常是为了处理它，不要捕获了却什么都不处理而抛弃之，如果不想处理它，请将该异常抛给它的调用者。 异常信息应该包括两类信息：案发现场信息和异常堆栈信息。 如果不处理，那么往上抛。 向下兼容 、向后兼容 兼容老设备,旧系统版本。 在计算机中指在一个程序更新到较新的版本后， 用旧的版本程序创建的文档或系统仍能被正常操作或使用。 向下兼容可以使用户在进行软件或硬件升级时， 厂商不必为新设备或新平台从头开始编制应用程序，以前的程序在新的环境中任然有效。 ( no Copyright，enjoy youself ! ) all right reserved，powered by GitbookThe file was updated at : 2021-06-21 09:09:44 "},"chinese/源码阅读/源码阅读配置.html":{"url":"chinese/源码阅读/源码阅读配置.html","title":"源码阅读","keywords":"","body":"安卓历史版本 名称 版本名 API等级 发布时间 Android 11 11.0 30 2020年9月9日 Android 10 (Android Q) 10.0 29 2019年9月3日 Pie 馅饼 9.0 28 2018年8月7日 Oreo 奥利奥 8.0-8.1 26-27 2017年8月22日(8.0)2017年12月5日(8.1) Nougat 牛轧糖 7.0-7.1.2 24-25 2016年5月18日(7.0) Marshmallow 棉花糖 6.0-6.0.1 23 2015年5月28日(6.0) Lollipop 棒棒糖 5.0-5.1.1 21-22 2014年6月25日(5.5) KitKat 奇巧 4.4-4.4.4 19-20 2013年9月3日(4.4) Jelly Bean 果冻豆 4.1-4.3 16-18 2012年6月28日(4.1) Ice Cream Sandwich 冰淇淋三明治 4.0.1-4.0.4 14-15 2011年10月19日(4.0.1) Honeycomb 蜂巢 3.0-3.2 11-13 2011年2月24日(3.0) Gingerbread 姜饼 2.3-2.3.7 9-10 2010年12月6日(2.3) Froyo 冻酸奶 2.2 8 2010年5月20日 Eclair 闪电泡芙 2.0-2.1 5-7 2009年12月3日 (2.0)2010年1月12日(2.1) Donut 甜甜圈 1.6 4 2009年9月15日 Cupcake 纸杯蛋糕 1.5 3 2009年4月17日 Bender 发条机器人 1.1 2 2009年2月2日 Astro 铁臂阿童木 1.0 1 2008年9月23日 系统源码阅读 Androidstudio 查看自带的sdk中的源码 1、在 Androidstudio中点击自己的代码想往下查看源码时， throw new RuntimeException(\"Stub!\" 这是因为没有匹配到对应版本的源码，此时按提示下载源码即可。 2、有一些源码被加了 @hide标签，从 Androidstudio中看不到， 可以从 https://github.com/anggrayudi/android-hidden-api 下载对应版本的 android.jar 替换掉。 3、替换掉 android.jar 后，Androidstudio 报错 ERROR: Execution failed for MockableJarTransform 这是 com.android.tools.build:gradle:x.x.x 版本的问题, 高版本的 gradle中加了一些校验机制， https://github.com/anggrayudi/android-hidden-api/issues/46 4、最终配置 compileSdkVersion 27 targetSdkVersion 27 classpath 'com.android.tools.build:gradle:3.1.4' Androidstudio 查看整个Android系统的源码 只能阅读，不能编译。 这里给出 android-8.1.0_r1 版本的源码。 源码地址 https://gitee.com/hnyer/android-8.1.0_r1_learning 1、下载好源码解压，此时导入Androidstudio 只能查看，不能点击跳转。 2、将 android.iml 、android.ipr 两个文件放到根目录。此时可能仍然不能跳转。 3、进入 project Structure --> Modules ，将所有文件都设置成 sources 选项。 4、如果查看源码的时候展示的是 xxx.class ，连接的是 android.jar ， 你将连接指向 F:\\sdk2\\sources\\android-29 即可(举例)。 其他 throw new RuntimeException(\"Stub!\"); 代表没找到对应的android。下载对应版本的源码就可查看。 android 内部API 有些类可以在源码中调用，但是在 Androidstudio 中找不到，是因为这是 内部API 不允许用户调用。 例如 com.android.internal.policy; 注意关键字“internal” 。 其中 PhoneWindow 就是一个私有API 。 ( no Copyright，enjoy youself ! ) all right reserved，powered by GitbookThe file was updated at : 2021-02-04 14:23:34 "},"chinese/源码阅读/其他框架源码.html":{"url":"chinese/源码阅读/其他框架源码.html","title":"其他框架源码","keywords":"","body":"LeakCanary 框架 https://square.github.io/leakcanary/ https://github.com/square/leakcanary https://gitee.com/hnyer/leakcanary-2.7 // 2.7版本 LeakCanary 目前最新的版本是 Version 2.7 (2021-03-26)， 相比之前的版本，2.0 之后的版本在使用上简洁了很多， 只需要在 dependencies 中加入 LeakCanary 的依赖即可。 而且 debugImplementation 只在 debug 模式下有效， 所以不用担心用户在正式环境下也会出现 LeakCanary 收集。 dependencies { debugImplementation 'com.squareup.leakcanary:leakcanary-android:2.7' } LeakCanary 的特点 1、不需要手动初始化 2、可自动检测内存泄漏并通过通知报警 3、不能用于线上 leakCanary 基本原理 和 基本流程 1、LeakCanary 的基础是 ObjectWatcher Android 库。 它 hook 了 Android 的生命周期， 当 activity/fragment 被销毁时触发检测。 2、这些被销毁的对象被传递给 ObjectWatcher ， ObjectWatcher 持有这些被销毁对象的弱引用 。 3、如果弱引用在等待几秒钟并执行 gc ,如果仍未被清除， 那么被观察的对象就被认为存在潜在的泄漏。进行下一步分析。 private void runGC() { Runtime.getRuntime().gc(); Thread.sleep(5000); System.runFinalization(); } 3、 dump heap 分析 hprof 文件， 构建可能泄漏的对象与 GCRoot 间的引用链, 如果存在则证明有泄漏。 4、将泄漏的消息通过 log 或 APP通知 提示用户。 那么 1、怎么判断在5秒之后还未被清除的呢？ 2、怎么检测 对象和 GCRoot的引用链 ？ 怎么判断在5秒之后还未被清除的呢？ 当一个对象仅仅被 weak reference指向, 而没有任何其他strong reference指向的时候, 如果GC运行, 那么这个对象就会被回收。 基本原理就是 利用弱引用 WeakReference 和 ReferenceQueue 的特点 public void onActivityDestroyed(Activity activity) { String key = UUID.randomUUID().toString(); // referenceQueue 队列保存的是弱引用对象 MyWeakReference myWeakReference = new MyWeakReference(activity, referenceQueue); myWeakReference.key = key; leakMap.put(key, myWeakReference); handler.postDelayed(() -> watchActivity(myWeakReference), 5000); } private void removeWeaklyReachableObjects() { MyWeakReference myWeakReference; do { // 通过 do ...while 将队列的数据全部取出 myWeakReference = (MyWeakReference) referenceQueue.poll(); // 如果 myWeakReference 不为空，说明它包装的对象，已经被系统回收了，然后通知到了这个队列 if (myWeakReference != null) { // myWeakReference.info 已经被回收 leakMap.remove(myWeakReference.key); } } while (myWeakReference != null); } boolean isRecycled = !leakMap.containsKey(myWeakReference.key); if (isRecycled) { // 通过 ReferenceQueue 判断，已经被回收 } 注：补充一下，我在Android平台下测试，但是 ReferenceQueue 中 取不到非空对象，在 Java平台下要新建大量的对象并不停地回收， 才能有一部分非空对象。 所以用 ReferenceQueue 来监控并不是很实时，不太靠谱， 最终的确定是否被回收还得靠分析 .hprof 文件。 LeakCanary 怎么检测 对象和 GCRoot的引用链 ？ (分析 hprof 文件 ) 如果用 ReferenceQueue 怀疑 对象没有被回收， 就需要 发起 heap dump，分析 dump 文件 最终确定。 旧版(2.0之前)是使用 haha 库去分析的，新版的重写的堆内存分析，就是 shark ，分析速度更快了。 https://square.github.io/leakcanary/shark/ // LeakCanary 如何分析 hprof文件 Leakcanary2.0 较之前的版本最大变化是改由 kotlin 实现以及开源了自己实现的 hprof 解析的代码， 总体的思路是根据 hprof 文件的二进制协议将文件的内容解析成一个图的数据结构， 然后广度遍历这个图找到最短路径， 路径的起始就是GCRoot对象，结束就是泄漏的对象。 具体的实现代码可以去看源码。 leakCanary为什么不用 ‘虚引用 ’而用 ‘弱引用’ 因为 弱引用 + 手动gc 会让 那些没有被引用的对象回收掉。 而虚引用的对象，不管你gc还是不gc，它都没啥反应的。 唯一的作用就是在对象被回收时，告诉你一下我被回收了。 所以此处用虚引用不合适。 LeakCanary 是如何初始化的 LeakCanary 不需要 在自己的代码中进行初始化， 是因为应用了 ContentProvider 的特性。 因为 ContentProvider.onCreate() 在 Application.onCreate() 之前执行， 然后 LeakCanary 在自己的库中配置了 ContentProvider 。 internal sealed class AppWatcherInstaller : ContentProvider() {... AppWatcherInstaller 有两个子类, MainProcess 、LeakCanaryProcess override fun onCreate(): Boolean { val application = context!!.applicationContext as Application AppWatcher.manualInstall(application) // 真正的初始化 return true } 当然，我们也可以关闭自动注册， 在合适的地方在自己的代码中手动注册 LeakCanary 为什么不能用于线上 1、每次内存泄漏以后，都会生成一个.hprof文件，然后解析， 会增加手机负担，引起手机卡顿等问题。 2、多次调用GC，会对 APP 性能产生影响 所以新版本的 LeakCanary 设计成 debugImplementation ， 只有在 debug 模式下才起作用 手写demo ，模拟 leankCanary https://gitee.com/hnyer/leak-canary-sample RecyclerView 控件 RecyclerView 是 Google 在2014年的IO大会首次提出来。 implementation 'com.android.support:recyclerview-v7:26.1.0' implementation 'com.android.support:recyclerview-v7:26.0.0' implementation 'androidx.recyclerview:recyclerview:1.0.0' 在添加依赖的时候，要用小写字母去搜索。 RecyclerView 可以替代 ListView 和 GridView 。 recyclerview 源码阅读 androidx.recyclerview:recyclerview:1.0.0 的源码拷贝出来 重新理解、注释一部分。 https://gitee.com/hnyer/AndroidxRecyclerviewSource RecyclerView 插拔式设计 RecyclerView 在设计方面上非常的灵活， 不同的部分承担着不同的职责。 每一个人都可以根据自身的需求来定义不同的部分。 Adapter 负责提供数据、创建ViewHolder、绑定数据， LayoutManager 负责 ItemView 的测量和布局， ItemAnimator 负责每个ItemView的动画， ItemDecoration 负责每个 ItemView 的间隙。 RecyclerView 的优点 RecyclerView 是一个展示大量数据的控件， 相比较 ListView ,RecyclerView 有非常出色的缓存机制， 在性能方面相比于 ListView 提升了不少。 同时由于 LayoutManager 的存在, 让 RecyclerView 不仅有 ListView 的特点， 同时兼有 GridView 的特点 ，还可以有瀑布流布局。 RecyclerView 与 listview 的区别 RecyclerView 是 listview 的升级版，具有更高灵活、扩展 。 1、RecyclerView 默认实现了 线性布局、网格布局、流式布局。 2、RecyclerView 取消了 setEmptyView() 、 addHeaderView() 、 addFooterView() 对应的 UI效果需要自己去实现。 3、RecyclerView 提供了 局部刷新的 接口 notifyItemChanged(position) 4、RecyclerView 提供了部分 动画效果。listview 完全靠自定义 。 5、RecyclerView 实现嵌套滚动机制 。 RecyclerView 自定义 LayoutManager 默认提供了 线性布局 LinearLayoutManager 、 网格布局 GridLayoutManager 、 瀑布流布局 StaggeredGridLayoutManager 。 ------------------ extends RecyclerView.LayoutManager 重写以下函数 onLayoutChildren() // getItemCount() canScrollVertically() scrollVerticallyBy() RecyclerView 自定义间隔线 、边界样式 、ItemDecoration recyclerView.addItemDecoration(xx); https://gitee.com/Aivin_CodeShare/android_tool_code/raw/master/RecyclerView/RecyclerViewMarginDecoration.java RecyclerView 使用自带动画 注意，使用 notifyDataSetChanged() 时无法触发动画的。 RecyclerView 自带一个动画 DefaultItemAnimator ，默认开启。 在增加、删除 、更新 item 时都会触发。 recyclerView.setItemAnimator(null); // 去掉默认动画 Adapterxxx 适配器中... public void addOneItem(int position ,String value){ if(datas==null){ return ; } datas.add(position,value) ; notifyItemInserted(position);// ! if (position == 0) { recyclerView.scrollToPosition(0); } } public void removeOnItem(int position){ if(datas==null){ return ; } if(datas.size() RecyclerView 自定义动画、添加动画 一般都是模仿自带的动画 DefaultItemAnimator 去实现。 可以参考 https://github.com/wasabeef/recyclerview-animators 的实现。 val recyclerView = findViewById(R.id.list) recyclerView.itemAnimator = SlideInUpAnimator(OvershootInterpolator(1f)) RecyclerView 自定义滑动效果 可以通过 自定义 RecyclerView 的 LayoutManager 去实现。 可以参考 https://gitee.com/hnyer/GalleryDemo RecyclerView 自定义回收策略 自定义 ViewCacheExtension 。用的较少。 RecyclerView 绘制流程 RecyclerView 就是一个 ViewGroup ， RecyclerView 局部刷新 DiffUtil 是 专门为RecyclerView更新item设计的。 可以精确到某个Item上某个具体的TextView，或者ImageView的刷新。 使我们的app每次刷新消耗的资源较小。 adapter.notifyDataSetChanged(); // 全部刷新 adapter.notifyItemChanged(position);//刷新某Item中的所有组件 adapter.notifyItemChanged(position, payloads); //刷新某Item中的部分组件。 配合 DiffUtil RecyclerView 滚动机制 RecyclerView 之所以能滚动，就是因为它在监听到手指滑动之后，反复 layout 子View，不断更 Item 的位置。 RecyclerView 缓存 、复用 机制 // 缓存匹配顺序 先从 1 级找，然后 2 级 ，然后3级 ，然后4 级，若找不到就走 onCreateViewHolder 。 缓存级别 关键对象 说明 1级 mAttachedScrap 和 mChangedScrap 屏幕上的 HolderView 从 RecyclerView 的布局中被 拿下来后，存放到 mAttachedScrap 中 ， 这些 holderView 并不参与回收复用， 单纯只是为了先从RecyclerView中拿下来，再重新布局上去。对于新布局中没有用到的HolderView，才会从 mAttachedScrap 移到 mCachedViews 中，让它参与复用。 mCachedViews 它的 size 默认是 DEFAULT_CACHE_SIZE= 2，只能保存两个HolderView。 这里保存的始终是最新鲜被移除的HolderView， 当 mCachedViews 满了以后，会利用先进先出原则，把老的 HolderView 存放在 mRecyclerPool 中。 它的作用是在需要新的 HolderView 时，精确匹配是不是刚移除的那个， 如果是，就直接返回给 RecyclerView 展示，如果不是它，那么即使这里有 HolderView 实例， 也不会返回给 RecyclerView，而是到 mRecyclerPool 中去找一个HolderView实例返回给 RecyclerView ，让它重新绑定数据使用。 3级 mViewCacheExtension 是一个帮助类，让开发者可以自己控制View 缓存。Recycler不会在这个类中做任何缓存View的操作，是否需要缓存View由开发者自己控制。我们一般不会用到，使用系统自带的回收池即可。 4级 mRecyclerPool mRecyclerPool 默认size是 DEFAULT_MAX_SCRAP =5。 在 mAttachedScrap 、mCachedViews 中的 holderView 都是精确匹配的， 真正被标识为废弃的是存放在 mRecyclerPool 中的 holderView ， 当我们向 RecyclerView 申请一个 HolderView 来使用的时， 如果在 mAttachedScrap 、 mCachedViews 精确匹配不到， 即使他们中有 HolderView 也不会返回给我们使用， 而是会到 mRecyclerPool 中去拿一个废弃的HolderView返回给我们。 如何判断 item 是否复用 如果是新创建的View， 则会先调用 onCreateViewHolder 来创建View，然后调用 onBindViewHolder 来绑定数据 ； 如果是复用的View，就只会调用 onBindViewHolder 而不会调用 onCreateViewHolder 。 如果数据有 100 个， 没有复用机制，会创建 100个 itemView + 绑定100次数据。 有复用机制，有可能只绑定 20个 itemView + 100次数据绑定， 并且是一次性创建并绑定完，容易导致 ANR 。 RecyclerView 嵌套滑动 机制 Android 5.0推出了嵌套滑动机制，在之前，一旦子View处理了触摸事件， 父View就没有机会再处理这次的触摸事件，而嵌套滑动机制解决了这个问题 为了支持嵌套滑动， 子View必须实现 NestedScrollingChild 接口， 父View必须实现 NestedScrollingParent 接口。 RecyclerView 滑动卡顿 1、嵌套布局滑动冲突 导致卡顿假象 内部的滑动控件消费了滑动操作, 外部的滑动控件就再也没机会响应这个滑动操作了。 2、嵌套布局层次太深。过多的测量，绘制布局可能会导致滑动卡顿。 3、在 onCreateViewHolder / onBindViewHolder 中做了耗时的操作导致卡顿。 类似 Bitmap 解码一类的耗时操作，不要在它们里面进行。 RecyclerView 万能适配器 实际使用中 可以使用 一些封装过的 第三方 适配器，提高开发速度。 https://github.com/CymChad/BaseRecyclerViewAdapterHelper RecyclerView 问答 RecyclerView 的缓存结构是怎样的？ 缓存的是什么？cachedView 会执行 onBindView 吗? RecyclerView 嵌套 RecyclerView，NestScrollView 嵌套 ScrollView 滑动冲突 讲一下 RecyclerView 的缓存机制,滑动10个，再滑回去，会有几个执行 onBindView 如何实现 RecyclerView 的局部更新，用过 payload 吗, notifyItemChange 方法中的参数？ RecyclerView 防止内存OOM的一道题，充分利用自身的缓存机制 RecyclerView 和 ListView 区别、特点、缓存 、懒加载、局部刷新 ,多种type场景下怎么避免滑动卡顿 ,怎么优化滑动 RecyclerView 缓存结构，RecyclerView 预取，RecyclerView 局部刷新 RecyclerView 里面那个 mChangedScrap, mAttachedScrap 之类的到底是在做什么 ? ( no Copyright，enjoy youself ! ) all right reserved，powered by GitbookThe file was updated at : 2021-08-26 16:43:39 "},"chinese/产品经理/产品经理.html":{"url":"chinese/产品经理/产品经理.html","title":"产品经理","keywords":"","body":"工具 Axure 软件安装 Axure 原型制作工具 1、安装包 测试版本为8.1.0.3377 安装包在我百度盘有备份 2、汉化 汉化包也在百度盘 将汉化包解压，将其中的 lang文件夹, 复制到Axure 安装目录下即可。 3、破解 于20180907测试可用，以后可能会失效。 zdfans.com gP5uuK2gH+iIVO3YFZwoKyxAdHpXRGNnZWN8Obntqv7++FF3pAz7dTu8B61ySxli 类型 保真度 用途 特点 费用 线框图 低 文档、快速交流、表达设计思路和大纲 手绘草图，不能交互 低 原型 中 模拟成品的交互流程 可以交互 高 视觉稿 高 给非专业人看的，视觉感受 静态视觉设计，不能交互 中 类图(Class Diagram) 对象图(Object Diagram) 包图(Package Diagram) 组件图(Component Diagram) 部署图(Deployment Diagram) 用例图(User Case Diagram) 顺序图/序列图/时序图(Sequence Diagram) ---> 交互图 状态机图、状态图(State Machine Diagram) 协作图、通信图(Communlcation Diagram) 活动图(Activity Diagram) PERT图 项目评估与评审技术 Project Evaluation and Review Technique 可以使用亿图图示绘制 pert图示例 UML流程图 绘制软件 推荐使用 Visio 、processon 流程图符号 类型 作用 图形 开始 / 结束 代表“开始”、“结束” 过程 一个步骤或操作 判断 if else 数据 输入/ 输出 输入、输出的数据 箭头、连接线 工作流方向 文档 输入、输出的文件 多文档 外部数据 表示数据来自外部 数据库 表示从数据库中获取数据信息 内部存储 指数据提交之后，需要写入数据库 队列数据 表示数据处理的一种方式 直接数据 人工输入 用户通过键盘等手动输入的数据 人工操作 表示需要用户手动操作调整的内容 比如修改、搜索、删除、提交等 手动操作 卡片 穿孔卡是早期计算机的信息输入设备 纸带、条带 参考卡片 展示内容 在设备上展示信息 循环限值 是指循环开始或结束的条件 子流程 并行模式 表示同时进行 （在并行模式的框内可以添加其它的部件） 预定义流程 人员 注释 批注 页面内引用 相当于一个页面内的跳转 跨页引用 相当于一个跨页的连接器 预备 进入流程前的准备状态 推迟、延期 UML状态图 State Machine Diagram 用于描述一个特定的对象的所有可能状态以及由于各种事件的发生而引起的状态之间的转换。 概念 意义 图示 状态 开始 、其他状态、结束 转移 两个状态之间的一种关系 表示对象将在第一个状态中执行一定的动作， 并在某个特定事件发生而某个特定的条件满足时进入第二个状态 UML用例图 User Case Diagram 用例图从用户角度描述系统的静态使用情况 类型 作用 图示 角色、参与者 在系统外部与系统直接交互的人或事物 用例 系统外部可见的一个系统功能单元 系统边界、容器 用来展示系统的一部分功能，这部分功能联系紧密 关系 有4种：关联、泛化、包含、扩展 关系 意义 图示 备注 关联 箭头指向消息接收方 泛化 继承关系 箭头指向父类 包含 用来体现一个用例功能的多个子功能 拓展 是指用例功能的延伸，相当于为基础用例提供一个附加功能 UML类图 Unified Modeling Language 统一建模语言 绘制UML类图的软件推荐 Enterprise Architect 或 processon 作用域类型 符号 public + private - protected # 元素类型 图示 包 类 接口 元素之间的关系 定义 举例 备注 泛化（Generalization） 继承 箭头指向父类 实现（Realization） 类实现接口 箭头指向接口 关联（Association) 拥有关系 箭头指向被拥有者 聚合（Aggregation） 整体与部分的关系。部分可以单独存在。 菱形指向整体 组合(Composition) 整体与部分的关系 部分不能单独存在。 图标有2种菱形指向整体 依赖(Dependency) A需要B的协助才能完成某项功能 箭头指向被使用者 甘特图 甘特图最早由Henry L.Gantt在1917年提出。 甘特图是一个二维平面图， 横纬度 显示了每项工作的开始时间和结束时间，横道线的长度表示了该项工作的持续时间。 纵维表示工作内容 绘制工具可以使用 雁阵 其他 五大过程组 、十大知识领域 项目管理常用缩写 缩写 解释 AC 实际成本 。 Actual Cost : 在一个给定的时间段内，为完成进度活动或工作分解结构组成部分的工作，而实际发生并记录在案的总成本。实际成本有时仅为直接工时或直接成本，有时也为包括间接成本在内的所有成本。实际成本也称“已完工作实际成本（ACWP）”。参见“挣值管理”和“挣值技术”。 ACWP 已完成工作实际成本- Actual Cost of Work Performed : 见“实际成本”。AC BAC 完工预算- Budget At Completion：项目工作、工作分解结构组成部分或进度活动的所有预算之和，即项目的总计划价值。即PV之和 BCWP 已完成工作预算成本- Budgeted Cost of Work Performed：见“挣值”。EV BCWS 计划工作预算成本- Budgeted Cost of Work Scheduled：见“计划价值”。PV CCB 变更控制委员会-Change Control Board：由干系人正式组成的团体，负责审议、评价、批准、推迟或否决项目变更，所有决定和建议均应记录在案。 COQ 质量成本-Cost Of Quality：确定为保证质量而付出的成本的一种方法。预防和评估成本（一致性成本）包括为确保符合要求而进行质量规划、质量控制和质量保证的成本（即培训、质量控制体系等）。缺陷成本（非一致性成本）包括对不合格产品、部件或过程的返工成本，保修工作和废品的成本，以及名誉的损失。 CPF 成本加费用-Cost Plus Fee: CPFF 成本加固定费用- Cost Plus Fixed Fee [Contract]：成本补偿合同的一种类型，买方为卖方报销可列支成本（可列支成本由合同确定），再加上一笔固定数额的利润（费用）。 CPAF 成本加奖励费用- Cost Plus Award Fee [Contract]：为卖方报销履行合同工作所发生的一切合法成本，但是只有在满足了合同中规定的某些笼统、主观的绩效标准的情况下，才能向卖方支付大部分费用。完全由买方根据自己对卖方绩效的主观判断来决定奖励费用，并且卖方通常无权申诉。 CPIF 成本加激励费用- Cost Plus Incentive Fee [Contract]：成本补偿合同的一种类型，买方为卖方报销可列支成本（可列支成本由合同确定），并且卖方在达到规定绩效标准时赚取利润。 CPI 成本绩效指数-Cost Performance Index：项目成本效率的一种指标，是挣值（EV）与实际成本（AC）之比。CPI=EV／AC。 CPM 关键路径法-Critical Path Methodology：一种进度网络分析技术，用来确定项目进度网络中各条逻辑路径的灵活性大小（浮动时间大小），进而确定整个项目的最短工期。从规定的开始日期开始，利用顺推计算法计算最早开始和完成日期。从规定的完成日期（可能是顺推计算所得到的项目最早完成日期）开始，利用逆推计算法计算最晚开始和完成日期。 CV 成本偏差-Cost Variance：项目成本绩效的一种指标，是挣值（EV）与实际成本（AC）之差。CV=EV−AC。 DU or DUR Duration (DU or DUR) 持续时间：完成某进度活动或工作分解结构组成部分所需的工作时段总数（不包括节假日或其他非工作时段）。通常用工作日或工作周表示。有时被错误地等同于“自然流逝时间”。与“人力投入”比较。 EAC 完工估算[输出／输入] -Estimate at Completion [Output/Input] ：为完成某进度活动、工作分解结构组成部分或整个项目所需的预期总成本。EAC 既可以根据迄今为止的实际绩效进行计算，也可以由项目团队根据其他因素做出估算，后者也常称“最新修订估算”。参见“挣值技术”和“完工尚需估算”。 ETC 完工尚需估算[输出／输入] -Estimate to Completion[Output/Input ]：为完成某进度活动、工作分解结构组成部分或整个项目的所有剩余工作而预计需要的成本。参见“挣值技术”和“完工估算”。 EV 挣值-Earned Value Management ：进度活动或工作分解结构组成部分的已完成工作的价 值，用分配给该工作的预算数来表示。也称“已完工作预算成本（BCWP）”。 ES 最早开始时间-Earliest Start Date：在关键路径法中，基于进度网络逻辑、数据日期和所有进度制约因素，某进度活动（或项目）的未完部分可能开始的最早时点。最早开始日期可随项目的进展和项目管理计划的变更而改变。 EF 最早结束时间-Earliest Finish Date：在关键路径法中，基于进度网络逻辑、数据日期和所有进度制约因素，某进度活动（或项目）的未完部分可能完成的最早时点。最早完成日期可随项目的进展和项目管理计划的变更而改变。 EMV 预期货币价值分析- Expected Monetary Value Analysis：当某些情况在未来可能发生、也可能不发生时，计算平均结果的一种统计技术。这种技术经常在决策树分析中使用。 FF 完成到完成- Finish to Finish：只有当紧前活动完成，紧后活动才能完成的逻辑关系。参见“逻辑关系”。 FFP 固定总价[合同]- Firm Fixed Price [Contract]：不考虑卖方实际成本，由买方向卖方支付事先确定的金额（由合同规定）的一种总价合同。 FPIF 总价加激励费用- Fixed Price Incentive Fee FP-EPA 总价加经济价格调整- Fixed Price with Economic Price Adjustment FMEA 失效模式与影响分析[技术]：-Failure Mode and Effect Analysis [Technique]：一种分析程序用来分析产品的每个部件的每种可能失效模式及其对该部件的可靠性的影响，并确定每种失效模式本身或与其他失效模式联合将对产品或系统的可靠性的影响，或对该部件的必备功能的影响；或者，用来检查产品（在整个系统和／或较低层次上）的所有可能失效模式。对于每一种可能的失效，都要估计对整个系统的影响。此外，还应该审查为降低失效的概率和影响而计划采取的行动。 FS 完成到开始- Finish to Start：紧后活动的开始依赖于紧前活动的完成的逻辑关系。参见“逻辑关系”。 IFB 投标邀请书- Invitation For Bid：通常本术语等同于建议邀请书。但在某些应用领域，其含义可能更狭窄或更具体。 LS 最晚开始日期-Late Start Date：在关键路径法中，基于进度网络逻辑、项目完成日期和任何施加于进度活动的制约因素，在不违反进度制约因素或延误项目完成日期的条件下，允许某进度活动最晚开始的时点。最晚开始日期在项目进度网络的逆推计算中确定。 LF 最晚完成日期- Late Finish Date：在关键路径法中，基于进度网络逻辑、项目完成日期和任何施加于进度活动的制约因素，在不违反进度制约因素或延误项目完成日期的条件下，允许某进度活动最晚完成的时点。最晚完成日期在项目进度网络的逆推计算中确定。 LOE 人力投入量- Level of Effort OBS 组织分解结构[工具]- Organizational Breakdown Structure [Tool]：对项目组织的一种层级描述，以便把工作包与相应的执行部门联系起来。 PDM 紧前关系绘图法-Precedence Diagramming Method: 一种用方框（或节点）表示计划活动的进度网络图绘制技术。进度活动在图形中按一种或多种逻辑关系连接起来，以显示活动的实施顺序。 PMBOK 项目管理知识体系-Project Management Body of Knowledge：说明项目管理专业范围内的知识总和的概括性术语。与法律、医学、会计等其他专业一样，该知识体系掌握在应用和推进它的实践者和学者手中。完整的项目管理知识体系既包括已被验证并广泛应用的传统做法，也包括本专业新近涌现的创新做法。该知识体系包括已发表和未发表的材料。该知识体系正处于不断演进中。PMI的PMBOK® 指南识别了作为项目管理知识体系一部分的、被普遍公认的良好做法。 PMIS 项目管理信息系统-Project Management Information System：由收集、整合和传播项目管理过程成果的工具和技术所组成的信息系统。它为项目从启动到收尾的所有方面提供支持，可以包括人工和自动系统。 PV 计划价值-Planned Value：为某进度活动或工作分解结构组成部分的预定工作进度而分配且经批准的预算。也称“计划工作预算成本”。 QA 质量保证-Quality Assurance: 审计质量要求和质量控制测量结果，确保采用合理的质量标准和操作性定义的过程 QC 质量控制-Quality Control: 监测并记录执行质量活动的结果，从而评估绩效并建议必要变更的过程。 RACI 执行、负责、咨询、知情-Responsible、Accountable、Consult、Inform RAM 责任分配矩阵- Responsibility Assignment Matrix：一种将项目组织分解结构与工作分解结构联系起来的结构，有助于确保项目工作范围的每个组成部分都被分配给了某个人或某个团队。 RBS 风险分解结构- Risk Breakdown Structure：按风险类别和子类别来排列已识别的项目风险的一种层级结构图，用来显示潜在风险的所属领域和产生原因。风险分解结构通常依具体项目类型定制。 RFI 信息邀请书-Request For Information：采购文件的一种，买方借此邀请潜在卖方就某种产品、服务或卖方能力提供相关信息。 RFP 建议邀请书- Request For Proposal：采购文件的一种，用来向潜在卖方征求对产品或服务的建议书。在某些应用领域，其含义可能更狭窄或更具体。 RFQ 报价邀请书- Request For Quotation：采购文件的一种，用来向潜在卖方征求对普通或标准产品或服务的报价。有时可用来代替建议邀请书。在某些应用领域，其含义可能更狭窄或更具体。 SF 开始到完成- Start to Finish：紧后进度活动的完成取决于紧前进度活动的启 动的逻辑关系。参见“逻辑关系”。 SS 开始到开始- Start to Start：紧后进度活动的启动取决于紧前进度活动的启动的逻辑关系。参见“逻辑关系”。 SV 进度偏差-Schedule Variance：项目进度绩效的一种指标，是挣值（EV）与计划价值（PV）之差。SV=EV-PV。 SPI 进度绩效指数-Schedule Performance Index：项目进度效率的一种指标，是挣值（EV）与计划价值（PV）之比。SPI=EV/PV。 SOW 工作说明书-Statement of Work：对需提供的产品、服务或成果的叙述性说明。 SWOT 优势、劣势、机会、威胁-Strength、Weaknesses、Opportunities、Threats：这种信息收集技术从项目的每一个优势、劣势、机会和威胁的出发，对项目进行考察，以便更全面地考虑风险。 T&M 工料合同-Time & Material Contract：兼具成本补偿和总价合同特征的一种混合合同安排。与成本补偿合同相似，工料合同没有封顶价，因为签订合同时并没有确定合同总价。工料合同的合同价可以像成本补偿合同那样增长。另外，工料合同又与总价合同相似。例如，当买卖双方就某类高级工程师的单价达成一致意见时，该单价就被事先确定了。 TQM 全面质量管理-Total Quality Management WBS 工作分解机构-Work Breakdown Structure：以可交付成果为导向的工作层级分解。其分解的对象是项目团队为实现项目目标、提交所需可交付成果而实施的工作。工作分解结构组织并定义了项目的全部范围。 PERT （Program/Project Evaluation and Review Technique）即计划评审技术 ITTO 是一种输入输出工具法，类似于思维导图。用于项目管理中各种工作内容的计划的过程梳理，能够帮助人们在工作中理清工作思路，做好项目中的优先级排序。 NPV ROI IRR EVM 挣值计算 AT 实际时间 PMB 绩效测量基准 VAC 完工偏差 TCPI 完工尚需绩效指数 141个工具和技术 序号 名称 定义 1 专家判断 对某方面擅长的人就是专家，找专家协助就是专家判断，专家可能是顾问、干系人、团队成员 2 引导技术 用来协调干系人之间的矛盾，以及项目其他要素之间的矛盾。头脑风暴，冲突处理，问题解决和会议管理等，都是引导者可以用来帮助团队和个人完成项目活动的关键技术 3 项目管理信息系统 作为事业环境因素的一部分，项目管理信息系统提供下列工具：进度计划工具，工作授权系统，配置管理系统，信息收集与发布系统，或进入其他在线自动化系统的网络界面。也可用于自动收集和报告关键绩效指标KPI 4 会议 通过会议来讨论和解决项目的相关问题。参会者可包括项目经理，项目团队成员，以及与所讨论问题相关或会受该问题影响的干系人。按照会议目的分为三类：交换信息，头脑风暴或方案评估，制定决策。注意不要把各种会议类型混合在一起。 5 变更控制工具 为了便于开展配置和变更管理，可用一些手工或自动化的工具。工具的选择应基于项目干系人的需要，并考虑组织和环境情况或制约因素。可使用工具来管理变更请求和后续决策，还要关注沟通，以帮助CCB成员履行职责，以及向相关干系人传达决定。例如，变更管理软件，版本控制软件都是软件开发项目常用的变更控制工具 6 变更控制会 CCB开的会，重要干系人组成负责评审、批准变更请求，但不是所有变更都要由CCB来批准。是另一个工具“会议”的一种形式 7 分析技术 用来研究变量之间的复杂关系的各种技术的总称。可用的项目分析技术包括：回归分析，分组方法，因果分析，根本原因分析，预测方法，FMEA，FTA，储备分析，趋势分析，挣值管理，差异分析 8 配置管理系统 整个项目管理系统的一个子系统。它由一系列正式的书面程序组成，用于对以下工作提供技术和管理方面的指导与监督：识别并记录产品、成果、服务或部件的功能特征和物理特征；控制对上述特征的任何变更；记录并报告每一项变更及其实施情况；支持对产品、成果或部件的审查，以确保其符合要求。该系统包括文件和跟踪系统，并明确了为核准和控制变更所需的批准层次，包括变更控制系统 9 工作授权系统 整个项目管理系统的一个子系统。它是一系列正式书面程序的集合，规定如何授权（委托）项目工作，以保证该工作由正确的组织、在正确的时间、以正确的顺序执行。工作授权系统包括发布工作授权所需的步骤、文件、跟踪系统以及审批层次 10 访谈 与干系人直接交流，通常是一对一 11 焦点小组会议 有主持人，分主题、分小组讨论 12 引导式讨论会 跨职能人员讨论：IT行业JAD（联合应用开发）；制造业QFD（质量功能部署,倾听客户的声音） 13 头脑风暴法 面对面，快，容易受别人影响；属于群体创新技术 14 名义小组法 头脑风暴后，对创意进行排序；属于群体创新技术 15 德尔斐法 背靠背，匿名，客观，慢；属于群体创新技术 16 思维导图 圆圈、创意、线连起来；属于群体创新技术 17 亲和图 大量创意，然后找关系，同类的放在一起；属于群体创新技术 18 多标准决策分析 做决策时需要考虑多重相互矛盾的标准，可以建立矩阵表格，基于多重标准作出决策；属于群体创新技术 19 群体决策技术 为达成某种期望结果而对多个未来行动方案进行评估 20 问卷调查 通过设计书面问题，向为数众多的受访者快速收集信息 21 观察 直接观察个人在各自的环境中如何开展工作和实施流程 22 原型法 先造出该产品的实用模型 23 系统交互图 把某个系统置于大背景中，用图形直观地展示该系统与其他系统之间的接口关系。例如，该系统从哪里获得输入，又会向哪里输出什么，该系统与周围环境是什么关系等等 24 文件分析 从各种文件中识别并收集干系人的需求。可供分析的文件包括：商业计划，营销文献，协议，建议邀请书，现行流程，逻辑数据模型，业务规则库，应用软件文档，业务流程或接口文档，其他需求文档，问题日志，政策程序和法规文件 25 产品分析 产品分解、系统分析、需求分析、系统工程、价值工程和价值分析 26 备选方案识别 头脑风暴、横向思维和配对比较，条条大路通罗马 27 分解 把项目可交付成果划分为更小的、更便于管理的组成部分 28 检查 开展测量、审查与核实等活动，来判断工作和可交付成果是否符合要求及产品验收标准 29 滚动式规划 近期详细、远期粗略，计划反复进行 30 模板 过去的经验总结 31 PDM紧前关系图 节点法AON，方框代表活动，箭线代表逻辑关系，ADM，CDM 32 确定依赖关系 硬逻辑（客观，无法改变）、软逻辑（考验项目经理创造力，最佳实践）、外部逻辑（依赖其他项目的活动，隐含着风险，可以包含硬逻辑或软逻辑） 33 提前&滞后 提前或推迟（如水泥抹平晾干）某个活动的开始日期，不改变本来的逻辑关系 34 网络模板 标准化网络，某部分可以称为子网络，适合项目中存在重复性的成果时 35 出版的估算数据 外部公司发布的生产率和资源单价 36 自下而上估算 对活动估算，然后汇总到工作包，再汇总到项目总资源，比较准，比较慢 37 项目管理软件 不等于项目管理信息系统 38 类比估算 以过去项目信息做基础来估算未来项目信息（历时、资源、成本） 39 参数估算 利用历史数据与其它变量的关系，生产率、成果数量，铺电缆200ft/小时 40 三点估算以及标准差 用最悲观、最乐观、最可能三个来估算 41 储备分析 考虑应急储备（如缓冲时间或储备金）和/或管理储备 42 进度网络分析 包括CPM、关键链、资源平衡、假设情景分析等 43 关键路径法 不考虑资源限制的情况下，找出完成项目的最短时间 44 关键链：帕金森定律 关键路径-时差概念+时间缓冲+资源缓冲，越早越好 45 资源平衡 确保资源使用量稳定均衡，往往会造成关键路径的变化 46 资源平滑 对进度模型中的活动进行调整，从而使项目资源需求不超过预定的资源限制的一种技术，相对于资源平衡，资源平滑不会改变关键路径，完工日期也不会延迟 47 资源优化技术 包括了资源平衡和资源平滑，通常先做资源平滑，再做资源平衡 48 假设情景分析 考虑各种可能的情形，预测对项目目标的影响，属于建模技术 49 模拟 基于多种不同的活动假设（通常使用三点估算的概率分布）计算出多种可能的项目工期，以应对不确定性，最常用的模拟技术为蒙特卡洛分析；属于建模技术 50 建模技术 包括假设情景分析和模拟 51 进度压缩 不改变范围情况下，缩短项目历时：赶工（那资源换时间，但逻辑关系不变）与快速跟进（调整逻辑关系，会增大风险） 52 进度计划编制工具 和项目管理软件一起使用，应该也是自动化的工具 53 绩效审查 测量与对比分析进度绩效，可使用各种技术包括趋势分析，关键路径法，关键链法，挣值管理，偏差分析 54 质量成本（COQ） 一致、非一致成本（失败或缺陷成本）；一致中又分预防（培训）和评估（过程控制） 55 卖方投标分析 让卖方先报价，预估项目大概花费成本 56 成本汇总 以WBS中工作包为单位汇总，得出总成本 57 历史关系 感觉就是参数估算或类比估算的基础 58 资金限制平衡 平衡资金支出，不要有很大起伏，财务部很喜欢 59 挣值管理（EVM） PV、EV、AC、CV、SV、CPI、SPI、EAC、ETC、TCPI，属于偏差分析的一种 60 绩效审查 包括偏差分析（看节点）、趋势分析（一个区间段）、挣值绩效分析 61 成本效益分析 对质量活动进行分析评估是否合适 62 控制图 看过程是否稳定，7点规则、失控 63 标杆对照（基准对照） 将项目与其它项目对比找差距、制定改进措施 64 实验设计（DOE） 统计学方法，分析每个因素对开发的流程和产品的特定变量的影响 65 统计抽样 从目标总体中选样本进行检查，在规划确定次数规模，在控制实施 66 流程图 显示某个过程中各步骤之间的关系 67 其它质量规划工具 头脑风暴、力场分析、名义小组、质量管理和控制工具 68 质量管理和控制工具 亲和图，过程决策程序图（PDPC），关联图，树形图，优先矩阵，活动网络图，矩阵图 69 质量审计 独立的结构化审查，由内外部审计师进行 70 过程改进（过程分析） 识别所需要改进的过程，包括根本原因分析 71 因果图 石川图、鱼骨图 72 直方图 显示特定情况的发生次数 73 帕累托图 特殊的直方图，按每个情况发生次数排序，28原理，如银行存款28法则 74 核查表（计数表） 用于收集数据的查对清单，合理排列各种事项，以便有效地收集关于潜在质量问题的有用数据 75 散点图 显示两个变量（因变量、自变量）的关系 76 组织机构图（OBS） 按组织部门排列下面列出工作包 77 责任分配矩阵图（RAM） 显示工作包（活动）和成员（资源）之间的关系，RACI 78 人际交往 正式、非正式的行业、职业环境下的人际互动，有助于认识人才 79 组织理论 个人、团队、组织的行为方式 80 多标准决策分析 在组建团队过程中，经常需要使用团队成员选择标准。通过多标准决策分析，制定出选择标准，并据此对候选团队成员进行定级或打分。根据各种因素对团队的不同重要性赋予不同的权重。包括可用性，成本，经验，能力，知识，技能，态度，国际因素等等 81 预分派 事先选定的，三种情况：竞标过程承诺、取决于特定技能、项目章程承诺 82 谈判 就某个事情双方达成共识的过程 83 招募 从外部招聘人员 84 虚拟团队 为共同目标而努力可几乎大家不见面，凝聚力低，沟通麻烦 85 人际关系技能 软技能：领导力，团队建设，激励，沟通，影响力，决策，政治和文化意识，谈判，建立信任，冲突管理，教练技术 86 培训 能够提高团队成员能力的活动 87 团队建设活动 有专门和非专门之分，非正式沟通非常重要，需要持续进行 88 基础规则 对成员可接受行为进行明确规定 89 集中办公 “紧密矩阵”，把许多或全部最活跃的项目团队成员安排在同一个物理地点（作战室）工作，以增强团队工作能力。 90 认可与奖励 对优秀成员的行为给予认可和奖励，要根据对方需求进行奖励 91 人事测评工具 能帮助项目经理和项目团队洞察成员的优劣势，了解成员的偏好和愿望，如何与人交际等。如态度调查，细节评估，结构化面谈，能力测试及焦点小组讨论等 92 观察与交谈 了解团队的工作表现和态度动态 93 项目绩效评估 对成员表现进行评估 94 冲突管理 解决项目冲突，合作/解决问题（综合考虑不同意见引导各方达成共识）、强制/命令（问题解决了，人际关系破坏了，通常在紧急情况下）、撤退/回避、缓和/包容（求同存异），妥协/调解（各让一步） 95 问题日志 书面的记录下来项目出现的问题 96 干系人分析 系统收集和分析各种信息了解干系人的利益、影响、期望 97 沟通需求分析 确定项目干系人的信息需求 98 沟通技术 要不要使用自动化工具，网络系统、视频会议等等 99 沟通模型 显示发送者和接受者 100 沟通方法 推式（发email)、拉式(在线课堂、网站）、交互式（开会） 101 信息管理系统 用来管理和分发项目信息的工具，包括电子的、纸的、项目管理电子工具（门户网站） 102 报告绩效 收集和发布绩效信息，包括状况报告，进展测量结果及预测结果，可以是简单的状态报告，也可以是详尽的报告 103 管理技能 指导与控制一群人协调他们行动实现目标 104 规划会议和分析 项目干系人、项目经理、团队成员、组织内负责风险的人一起开会 105 文档审查 对项目文档（合同、计划、项目档案等）进行评估审查 106 信息收集技术 头脑风暴、德尔斐、访谈、根本原因分析 107 核对表分析 根据编制的风险识别清单来进行风险识别，优点快，缺点不够全面 108 假设分析 检验之前的假设是否还成立，如果不成立就是风险 109 图解技术 因果图、流程图、影响图 110 SWOT分析 从内部优势、劣势；外部机会和威胁不同角度进行分析 111 概率与影响评估 分析风险发生可能性和后果 112 概率影响矩阵 用来对比把某个风险放入，深灰色代表严重；中度灰色代表较轻 113 风险数据质量评估 对风险识别分析所依据的数据进行评估开是否可信 114 风险分类 根据WBS、根据阶段、根据干系人、根据RBS（类别）对风险分类 115 风险紧迫性评估 评估哪些风险现在需要应对，哪些需要过一段时间应对 116 数据收集与表现 包括访谈、概率分布（贝塔分布、三角分布） 117 敏感性分析 确定哪些风险对项目具有最大影响，用龙卷风图来表现 118 预期货币价值（EMV） 把各种可能的后果和概率相乘，常和决策树一起使用 119 消极风险和威胁应对 回避、转移、减轻、主动或被动接受 120 积极风险和机会应对 开拓、提高、分享、接受 121 应急应对策略 制定应急计划，当风险发生时再执行 122 风险再评估 对现有评估、识别新风险、删除过去的风险，团队成员作的，内部人做的 123 风险审计 评估风险管理过程的有效性，通常外部人来做 124 技术绩效衡量 对技术成果和项目计划进行比较 125 状态审查会 定义开会，顺便看风险状况 126 自制外购分析 确定某个工作是团队自己完成还是外部采购 127 市场调研 包括考察行业情况和供应商能力 128 合同类型 固定价（范围明确时使用，买方风险小，卖方风险大，可以加激励、加经济调整考虑利率）、成本补偿类（买方参与最多，卖方风险小，有加成、有激励、有奖励-主观的·虚的）、时间材料合同（二者混合，谈判速度快） 129 投标人会议 买方向所有潜在卖方召开，要公平，让每个卖方对项目有清楚认识 130 建议书评价技术 就是评标的方法 131 独立估算 买方或找第三方编写，用作标杆来和投标人的报价进行对比 132 广告 在报纸或网站宣传招标活动 133 采购谈判 作为买方和卖方谈判，谈判技巧很重要，黑脸白脸，最终期限，有限授权，继承事实 134 合同变更控制系统 文书工作、跟踪系统、争议解决程序、审批层次 135 采购绩效审查 根据合同对卖方审查业绩，结构化审查 136 检查和审计 买方开展的，卖方需要支持 137 绩效报告 用来向高层汇报说明卖方合同执行情况 138 支付系统 说明如何给卖方付款，需要先确定卖方工作完成了 139 索赔管理 就是针对争议性的变更如何进行管理，先按合同谈判，然后考虑仲裁，最后上法院 140 记录管理系统 属于项目管理信息系统的一部分用来记录合同执行过程的文档 141 采购审计 对项目采购过程进行审查，找出经验和教训 PMP相关文档 https://hnyer.gitee.io/2020/06/08/pmp-xiang-guan-wen-dang/ 技术选型的 考虑纬度 //需求的满足度 是否满足当前的业务需求 // 成熟度、使用人数、社区活跃度、替换成本 更新速度稳定、社区气氛活跃的框架优先考虑。 // 学习成本 学习使用、引入当前技术框架带来的学习和改造成本。 // 开发速度、代码可维护性、可阅读性 、易调试性 当前技术是否会降低开发速度，和维护难度。 // 执行效率 、性能 是否对产品的性能有影响。 //安全性 数据安全性，是否容易被攻击； 开源协议约束，是否对自己的商业产品有版权威胁。 Scrum 在敏捷开发中，经常会看到Scrum一词。 作为敏捷开发的术语，Scrum 没有太贴切的中文翻译， 正确地读作[skrʌm]（中文读者常常发出错误读音为[skrum]）。 Scrum是一种敏捷软件开发的方法学。 Sutherland 读到了两位日本管理教授介绍制造业里出现的新的产品开发方法 Rugby 的文章。 他受到启发结合自己多年的经验，与 John Scumniotales 和 Jeff McKenna 一起开发了一套方法，取名为 Scrum 。 Scrum 是众多轻量级敏捷框架中应用最广泛的一种。 它用于开发、交付和持续支持复杂产品，是一个增量的、迭代的开发过程。 在标准的Scrum流程定义中， 有两个关键的产物： Product Backlog 、 Sprint Backlog 以及四个关键的会议： 计划会议、每日立会、评审会议 、 回顾会议。 Epic ：史诗，表示比较大的特性，开发周期一般是1-3月，用于产品路线图的规划。 Feature ：特性，表示相对小一些的特性，开发周期一般是1-3周，用于产品版本的规划 User Story：用户故事，表示最小的用户场景，开发周期一般是1-3天，用于迭代规划。 Product Backlog Sprint Backlog 作用 一个具有优先级的需求列表， 并对每个需求进行了粗略的估算。 任务列表 , WBS 估算单位 Story Points 小时 文档归属 Product Owner 开发团队 更新频率 一次/周 一次/工作日 持续长度 整个项目周期 一个Sprint 文档名 Product Backlog workbook Iteration Backlog workbook Scrum 每日站会 Daily Scrum / Daily Stand-up 执行频率为每24小时一次， 每次15分钟，每次都在同一时间、同一地点。 团队在每日站会上，进行上次每次站会以来的工作检视，并且计划接下来24小时的工作。 团队根据 每日 Scrum 站会的机会可以检视当前Sprint的目标进度， 并可以查看整个 Sprint Backlog的工作进度趋势， 让团队能够了解自身的进度情况，从而更好的进行协同工作来达成 Sprint 目标。 我们的发言可以遵循以下3条简易模板： 1、昨天，我做了什么？ 2、今天，我要做什么？ 3、我遇到了什么问题？ 如果一个成员好多天都没有交付，那么也就意味着可能他所负责的 Story 太大，或者是不合理的。 ------> 1、我昨天做的事情，对我们的项目产生了什么样的影响？ 今天谁可以来消费我昨天的工作成果？ 2、我今天打算做的事情，可能会使用谁的知识或者信息？ 3、我遇到的问题会不会是我们项目中潜在的一个风险 ？ ( no Copyright，enjoy youself ! ) all right reserved，powered by GitbookThe file was updated at : 2021-07-15 11:07:42 "},"chinese/设计模式/设计模式.html":{"url":"chinese/设计模式/设计模式.html","title":"设计模式","keywords":"","body":"设计模式 参考资料教材 目前设计模式： 23个GoF设计模式 + 简单工厂模式 学习设计模式的意义 过多地使用 if else 会造成代码臃肿 ，维护困难（容易产生bug ，需要大量修改代码）。此时你应该要考虑用某种设计模式来解决这个问题。 简单的设计意味着缺少灵活性，我们将其称之为“一次性代码”，不能方便地被应用在其他项目。 而合适的设计模式，可以让你的代码可以被反复使用。 设计模式分类 创建模型 创建型模式用来处理对象的创建过程 模式类型 学习进度 工厂方法模式（Factory Method Pattern） 抽象工厂模式（Abstract Factory Pattern） 建造者模式（Builder Pattern） 原型模式（Prototype Pattern） 单例模式（Singleton Pattern） 附：简单工厂模式：又叫做静态工厂方法（StaticFactory Method）模式，是属于创建型模式，但不属于23种GOF设计模式之一。 结构型模式 用来处理类或者对象的组合 模式类型 学习进度 适配器模式（Adapter Pattern） 桥接模式（Bridge Pattern） 组合模式（Composite Pattern） 装饰者模式（Decorator Pattern） 外观模式（Facade Pattern） 享元模式（Flyweight Pattern） 代理模式（Proxy Pattern） 行为型模式 用来对类或对象怎样交互和怎样分配职责进行描述 模式类型 学习进度 责任链模式（Chain of Responsibility Pattern） 命令模式（Command Pattern） 解释器模式（Interpreter Pattern） 迭代器模式（Iterator Pattern） 中介者模式（Mediator Pattern） 备忘录模式（Memento Pattern） 观察者模式（Observer Pattern） 状态模式（State Pattern） 策略模式（Strategy Pattern） 模板方法模式（Template Method Pattern） 访问者模式（Visitor Pattern） 面向对象设计原则 面向对象设计原则蕴含在很多设计模式中，它们是从许多设计方案中总结出的指导性原则。是我们用于评价一个设计模式的使用效果的重要指标之一。 [x] 1、单一职责原则(Single Responsibility Principle, SRP) [x] 2、开闭原则(Open-Closed Principle, OCP) [x] 3、接口隔离原则(Interface Segregation Principle, ISP) [x] 4、依赖倒转原则(Dependency Inversion Principle, DIP) [x] 5、里氏代换原则(Liskov Substitution Principle, LSP) [x] 6、迪米特法则(Law of Demeter, LoD) [x] 7、合成复用原则(Composite Reuse Principle, CRP) ( no Copyright，enjoy youself ! ) all right reserved，powered by GitbookThe file was updated at : 2020-08-19 17:20:00 "},"chinese/设计模式/模式详解.html":{"url":"chinese/设计模式/模式详解.html","title":"模式详解","keywords":"","body":"Android中 常用的设计模式 单例模式 // 建造者模式 Builder // AlertDialog.Builder 观察者模式 // Rxjava ， 适配器模式 // 解决接口不兼容的问题 ，两个系统的接口不一样，我继承旧接口,然后... 代理模式 // 源码中 有大量用到 ActivityManagerProxy , AMS // AsyncTask 应用 模板方法 @MainThread public final AsyncTask execute(Params... params){ return executeOnExecutor(sDefaultExecutor, params); } @MainThread public final AsyncTask executeOnExecutor( Executor exec, Params... params){ ... onPreExecute(); ... exec.execute(mFuture); return this; } 回调机制 回调的简单理解： A需要做一件事情(不需要立刻知道结果)，给B设置一个回调对象，然后B在条件合适的时候执行得到一个结果， 然后通过A传过来的回调对象告诉A。 // 1、回调普通使用 public interface IH264StoreFinishCallBack{ public void onStoreAndParseFinished( boolean result, String msgStr) ; } private IH264StoreFinishCallBack ih264StoreFinishCallBack = new IH264StoreFinishCallBack(){ @Override public void onStoreAndParseFinished(boolean result, String msgStr) { if(result) { disMissIosLoading(); } } } ; H264FileSotrPresenter h264FileSotrPresenter = new H264FileSotrPresenter(ih264StoreFinishCallBack); if(ih264StoreFinishCallBack!=null){ ih264StoreFinishCallBack.onStoreAndParseFinished(true ,\"切换到照片时自动触发结束录像命令\"); } // 2、全局回调的使用方法(结合单例模式) 这种模式可以实现在不同的activity之间传递参数。 1、定义回调函数管理类： /** * Created by Aivin on 2017/5/8. * 单例模式 管理一个回调对象， * 实现两个不同的activity实时通讯 *用户手动改变计量单位后，通知另外一个activity做出相应的改变 */ public class UnitsChangeCallBackManager{ private IUnitsModeChangeCallBack iUnitsModeChangeCallBack ; // 接受传入的回调实例 public void setiUnitsModeChangeCallBack(IUnitsModeChangeCallBack iUnitsModeChangeCallBack) { this.iUnitsModeChangeCallBack = iUnitsModeChangeCallBack; } public void sendUnitsChangedByUser(int type , int value , String msgStr) { if(iUnitsModeChangeCallBack !=null) { iUnitsModeChangeCallBack.onUnitsModeChange(type , value , msgStr); } }// /**私有化构造函数，防止被其他类实例化*/ private UnitsChangeCallBackManager() { //初始化操作 }// /**使用一个内部类来维护单例 *单例模式使用内部类来维护单例的实现。 *利用jvm提供的机制，加载类的线程互斥的，用来解决多线程访问的时候可能会遇到null的问题。 **/ private static class SingletonFactory { private static UnitsChangeCallBackManager instance = new UnitsChangeCallBackManager(); } /**获取实例,对外提供的接口 */ public static UnitsChangeCallBackManager getInstance() { return SingletonFactory.instance; } /**为了能在序列化过程仍能保持单例的特性，需要添加一个readResolve()方法 */ private Object readResolve() { return getInstance(); } } UnitsChangeCallBackManager.getInstance().setiUnitsModeChangeCallBack(this); // 设置回调： public void onUnitsModeChange(int type, int value, String msgStr){ switch (type) { case 1: break; } } UnitsChangeCallBackManager.getInstance().sendUnitsChangedByUser(1,1 ,\"英尺\"); // 触发回调 面向对象设计原则 单一职责 一个类只负责一个功能领域中的相应职责。 在软件系统中，一个类承担的职责越多，它被复用的可能性就越小。 一个类承担的职责过多，就相当于将这些职责耦合在一起，当其中一个职责变化时，可能会影响其他职责的运作。 因此，要将这些职责进行分离，将不同的职责封装在不同的类中。 单一职责原则是实现高内聚、低耦合的指导方针，它是最简单但又最难运用的原则。 高内聚、低耦合 高内聚 是指一个模块是由相关性很强的代码组成，只负责一项任务。 低耦合 是指模块与模块之间，尽可能的使其独立存在。 开闭原则 一个 软件实体 应当对扩展开放，对修改关闭。应尽量在不修改原有代码的情况下进行扩展。 //软件实体： 可以指一个软件模块、一个由多个类组成的局部结构或一个独立的类。 当软件系统需要面对新的需求时，我们应该尽量保证系统的设计框架是稳定的。 如果一个软件设计符合开闭原则，那么可以非常方便地对系统进行扩展，而且在扩展时无须修改现有代码， 使得软件系统在拥有适应性和灵活性的同时具备较好的稳定性和延续性。 在Java中，可以为系统定义一个相对稳定的抽象层(抽象类或者接口)，而将不同的实现行为移至具体的实现层中完成。 增加新的具体类来实现新的业务功能，在不修改已有代码的基础上扩展系统的功能。 //注意： 因为xml和properties等格式的配置文件是纯文本文件，编辑后无须编译， 因此在软件开发中，一般不把对配置文件的修改认为是对系统源代码的修改。 如果一个系统在扩展时只涉及到修改配置文件，而原有的Java代码没有做任何修改， 则可认为该系统是一个符合开闭原则的系统。 接口隔离原则 (Interface Segregation Principle, ISP) 使用多个专门的接口，而不使用单一的总接口。 因为在面向对象编程语言中，实现一个接口就需要实现该接口中定义的所有方法，所以大的总接口使用起来不一定很方便。 //注意： 在使用接口隔离原则时，我们需要注意控制接口的粒度。 1、接口不能太小。接口太小会导致系统中接口泛滥，不利于维护； 2、接口也不能太大。太大的接口将违背接口隔离原则，灵活性较差，使用起来很不方便。 一般而言，接口中仅包含为某一类用户定制的方法即可。 //“接口”往往有两种不同的含义： 对于不同的含义，ISP的表达方式以及含义都有所不同。 1、把接口理解成角色，一个接口只能代表一个角色，每个角色都有它特定的一个接口， 此时，这个原也可以叫做“角色隔离原则”。 2、如果把“接口”理解成狭义的特定语言的接口， 那么ISP表达的意思是指接口仅仅提供客户端需要的行为。 依赖倒转原则 Dependency Inversion Principle, DIP 抽象不应该依赖于细节，细节应当依赖于抽象。换言之，要针对接口编程，而不是针对实现编程。 DIP要求传递参数时或在关联关系中，尽量引用层次高的抽象层类，而不要用具体类。 我们需要针对抽象层编程。将具体类的对象通过依赖注入的方式注入到其他对象中。 依赖注入(DependencyInjection, DI): 当一个对象要与其他对象发生依赖关系时，通过抽象来注入所依赖的对象。 常用的注入方式有三种： 1、构造注入。通过构造函数来传入具体类的对象； 2、设值注入。通过Setter方法来传入具体类的对象； 3、接口注入。通过在接口中声明的业务方法来传入具体类的对象。 依赖倒置和里氏替换的区别 在大多数情况下，这三个设计原则会同时出现，开闭原则是目标，里氏代换原则是基础，依赖倒转原则是手段， 它们相辅相成，相互补充，目标一致，只是分析问题时所站角度不同而已。 1、定义的角度不同。里氏替换原则是关于子类和父类的原则;依赖倒置原则是关于抽象与细节的原则。 2、应用范围不同。依赖倒置原则使用范围更广。 在大多数情况下，OCP、LSP、DIP会同时出现。开闭原则是目标，里氏代换原则是基础， 依赖倒转原则是手段，它们相辅相成，相互补充，目标一致，只是分析问题时所站角度不同而已。 里氏代换原则 Liskov Substitution Principle, LSP **LSP** 是由麻省理工学院计算机科学实验室的**Liskov**女士提出来的。所以以她的名字命名。 里氏代换原则要求，在软件中将一个基类对象替换成它的子类对象，程序将不会产生任何错误和异常，反过来则不成立。 例如：我喜欢动物，那我一定喜欢狗，因为狗是动物的子类；但是我喜欢狗，不能据此断定我喜欢所有动物。 里氏代换原则是实现开闭原则的重要方式之一，因此在程序中尽量使用基类类型来对对象进行定义， 而在运行时再确定其子类类型，用子类对象来替换父类对象。 //在使用LSP时需要注意如下问题： 1、子类的所有方法必须在父类中声明，或子类必须实现父类中声明的所有方法。 因为如果一个方法只存在子类中，在父类中不提供相应的声明，则无法在以父类定义的对象中使用该方法。 2、在运用LSP时，尽量把父类设计为抽象类或者接口，让子类继承父类或实现父接口，并实现在父类中声明的方法， 运行时，子类实例替换父类实例，我们可以很方便地扩展系统的功能，同时无须修改原有子类的代码。 附： 类似 List tempList= new ArrayList() ; ? //申明时用基类List ， 具体实现时用子类ArrayList 。 迪米特法则 、得墨忒耳法则 (Law of Demeter, LoD) ,有些书也译作 “得墨忒耳法则” 。 一个软件实体应当尽可能少地与其他实体发生相互作用。 迪米特法则可降低系统的耦合度，当其中某一个模块发生修改时，就会尽量少地影响其他模块。 //所以在类的结构设计上： 1、每一个类都应当尽量降低其成员变量和成员函数的访问权限； 2、在类的设计上，只要有可能，一个类型应当设计成不变类； 3、在对其他类的引用上，一个对象对其他对象的引用应当降到最低。 迪米特法则还有几种定义形式，包括：不要和“陌生人”说话、只与你的直接朋友通信等 其朋友包括以下几类： 1、当前对象本身(this)； 2、以参数形式传入到当前对象方法中的对象； 3、当前对象的成员对象； 4、 如果当前对象的成员对象是一个集合，那么集合中的元素也都是朋友； 5、当前对象所创建的对象。 任何一个对象，如果满足上面的条件之一，就是当前对象的“朋友”，否则就是“陌生人”。 迪米特法则要求我们在设计系统时，应该尽量减少对象之间的交互， 如果两个对象之间不必彼此直接通信，那么这两个对象就不应当发生任何直接的相互作用， 如果其中的一个对象需要调用另一个对象的某一个方法的话，可以通过第三者转发这个调用。 简言之，就是通过引入一个合理的第三者来降低现有对象之间的耦合度。 合成复用原则 (Composite Reuse Principle, CRP), 有一些书上没有列上CRP，只说“六大设计原则” 。 组合复用原则、聚合复用原则 尽量使用对象组合，而不是继承来达到复用的目的。 在面向对象设计中，可以通过两种方法在不同的环境中复用已有的设计和实现: 1、通过 组合/聚合 实现 组合/聚合可以使系统更加灵活，降低类与类之间的耦合度。请优先考虑。 2、通过 继承 实现 继承复用会破坏系统的封装性，因为继承会将基类的实现细节暴露给子类。 由于基类的内部细节通常对子类来说是可见的，所以这种复用又称“白箱”复用。 一般而言，如果两个类之间是“Has-A”的关系应使用组合或聚合； 如果是“Is-A”关系可使用继承。 中介者模式 Mediator Pattern ,“中介者模式” 是 “迪米特法则” 的一个典型应用。（不要与陌生人说话）。 同事类之间没有直接显示交流 ，而是通过中介类（定义了行为接口）进行通信。 应用场景 1、在有些软件中，某些类/对象之间的相互调用关系错综复杂，类似QQ用户之间的关系， 此时，我们特别需要一个类似“QQ群”一样的中间类来协调这些类/对象之间的复杂关系 。 2、 请结合现实生活中的 “中介”进行理解。 房产中介... 优缺点 // 优点 1、 简化了对象之间的交互，将原本难以理解的网状结构转换成相对简单的星型结构。 2、 增加新的中介者和新的同事类都比较方便，更好地符合“开闭原则”。 // 缺点 1、 中介者类中包含了大量同事类之间的交互细节，可能会导致中介者类非常复杂 享元模式 Flyweight Pattern 当系统中存在大量相似或相同的对象时，将会导致运行代价过高、OOM 等问题，享元模式正为解决之一类问题而诞生。 1、享元模式在使用时存在线程安全问题，需要考虑线程安全。 2、通常用一个 工厂类 类维护享元对象。 // 内部状态 Internal State 存储在享元对象内部并且不会随环境改变而改变的状态，内部状态可以共享。 // 外部状态 External State 随环境改变而改变的、不可以共享的状态。外部状态由客户端保存。 外部状态不可以影响享元对象的内部状态，它们是相互独立的。 缺点 1、对象 需要分离出 内部状态 和 外部状态，这使得程序的逻辑复杂化。 2、读取外部状态使得运行时间变长。 示例 围棋棋盘中包含大量的黑子和白子，它们的形状、大小都一模一样，只是出现的位置不同而已。 如果将每一个棋子都作为一个独立的对象存储在内存中，将导致该围棋软件在运行时所需内存空间较大。 class Chessman { private String color; // 内部状态 private Point location;// 外部状态 public Chessman(String color) { ...} public String getColor() { ... } public String getLocation() { ...} /**更新外部状态 需要主要线程安全*/ public synchronized void updateLocation( Point loation) { ... } } public class ChessmanFactory { /**享元池*/ private static Map map=new HashMap<>(); public static ChessFlyWeight getChess(String color) { if(map.get(color)!=null){ return map.get(color); }else{ Chessman chessman=new Chessman(color); map.put(color, chessman); return chessman; } } } //多次调用 也只创建了一个 Chessman 对象 Chessman chessman=ChessmanFactory.getChess(\"黑色\"); 代理模式 Proxy Pattern, 当无法直接访问某个对象或访问某个对象存在困难时可以通过一个代理对象来间接访问。 关键点：代理对象控制对原对象的引用 。 静态代理 代理类与委托类有同样的接口。通过代理对象访问目标对象。 1、可以在目标对象实现的基础上,增强额外的功能操作 。(这一点跟装饰者模式一样) 实现自定义的控制策略。 // 委托类 实现的接口 public interface IUser{ public String getUserInfo(); } // 委托类。对外提供 查询用户信息的功能。 public class UserTools implements IUser{ public String getUserInfo(){ return \"he is tom\"; } } /** * 代理类。 实现的接口与委托类一模一样。 * 用户通过代理作为中间人去使用原对象拥有的功能。 * 但是真正执行的还是原来的对象。 */ public class UserToolsProxy implements IUser{ private UserTools userTools ; public String getUserInfo() { //做授权判断 boolean isTheRightTime = true of false...; if(isTheRightTime){ return userTools.getUserInfo(); }else{ return \"wrong time\"; } } 动态代理 因为静态代理的方案是需要编写好代码的， 代理类与委托类有同样的接口，如果 委托类 方法数量较多，采用静态代理方案， 代理类的代码就比较冗余，工作量比较大。 动态代理 可以在不改变源码的情况下，直接在方法中插入自定义逻辑。 这种编程模型有一个专业名称叫 AOP (Aspect Oriented Programming 面向切面编程) 。 JDK的动态代理机制只能代理实现了接口的类。 JDK 动态代理是基于接口设计实现的，如果 委托类没有实现接口，会抛异常。 Exception in thread \"main\" java.lang.ClassCastException // 功能接口 public interface UserService { public void select(); public void update(); } // 委托类 public class UserServiceImpl implements UserService { @Override public void select() { System.out.println(\"委托类原始选择功能\"); } @Override public void update() { System.out.println(\"委托类原始更新功能\"); } } // 动态代理 新功能处理类 public class LogHandler implements InvocationHandler { private Object target; // target 是委托类 LogHandler(Object target){ this.target = target; } @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable { System.out.print(\"--- \"+ method.getName()); // 方法名 before(); Object result = method.invoke(target, args); after(); return result; } private void before() { System.out.println(\"\\r\\n\"); System.out.println(String.format(\"动态代理添加的日志记录功能 ，日志开始记录于 [%s] \", new Date())); } private void after() { System.out.println(String.format(\"动态代理添加的日志记录功能 ，日志记录结束于 [%s] \", new Date())); } } // 测试 UserServiceImpl userServiceImpl = new UserServiceImpl(); // 委托类的 类加载器 ClassLoader classLoader = userServiceImpl.getClass().getClassLoader(); // 委托类实现的接口 Class[] interfaces = userServiceImpl.getClass().getInterfaces(); // 需要 切入添加的 事件处理器 InvocationHandler logHandler = new LogHandler(userServiceImpl); // JDK 生成动态代理 UserService proxy = (UserService) Proxy.newProxyInstance(classLoader, interfaces, logHandler); // 动态代理的 方法 proxy.select(); proxy.update(); cglib 动态代理 JDK的动态代理用起来非常简单，但是它有一个限制， 就是使用动态代理的对象必须实现一个或多个接口。 如果想代理没有实现接口的继承类，我们可以使用 CGLIB 包。 CGLIB 包使用字节码处理框架 ASM (Java字节码操控框架), 通过字节码技术为一个类创建子类，并在子类中采用方法拦截的技术拦截所有父类方法的调用， 顺势织入横切逻辑，来完成动态代理的实现。 代理模式和接口回调的区别 跟做iOS的同事曾经讨论过，对方说代理模式和接口回调理解起来差不多。 ( 可能是iOS的代理的定义不一样?) 我个人认为这两者相差还是比较大的，出发点和定义都不一样。 单例模式 Singleton Pattern 通过单例模式可以保证系统中，应用该模式的一个类只有一个实例 。 1、单例类只能有一个实例 2、单例类必须自己自己创建自己的唯一实例。 (不考虑反射机制)外部只能通过 getInstance() 访问。 4、构造方法限定为 private ，防止外部实例化该类的对象 使用场景 1、某些大型的类创建频繁时会导致很大的系统开销。 2、软件系统中有些地方只能有一个实例，否则会出现各种问题。 例如打印机为了避免状态不一致而采用单例模式。 缺点 单例实例的生命周期和软件的生命周期一样长。 如果它持有某些对象的引用 ，会导致该对象无法释放。 饿汉式 单例模式 实例在类加载的时候即被实例化(jvm的机制，加载类的线程互斥)，因此线程安全。 没有延迟加载，如果长时间没用到这个实例，则会造成内存的浪费。 如果实例初始化时间长而需要延迟初始化 就要考虑用懒汉模式了。 public class SingletonBean { private SingletonBean(){ } // 在类加载的时候即被实例化 private static final SingletonBean singleton=new SingletonBean(); public SingletonBean getIncetance(){ return singleton; } } 简单 懒汉式单例模式 (不推荐) 单线程下没有安全问题， 多线程下，可能会有多个线程同时拿到 if (null == instance) ， 所以可能会产生多个实例。 可以加 synchronized 解决安全问题，让线程串行执行。 绝大部分的耗时都用在synchronized修饰符的同步准备上，因此从性能上来说很不划算。 public class SingletonBean { private SingletonBean(){ } private static SingletonBean singleton = null; public synchronized static SingletonBean getIncetance() { if (singleton == null) { singleton = new SingletonBean(); } return singleton; } } DCL + Volatile 懒汉模式 (推荐) DCL (Double-Check-Locking ) 双重检查锁定 public class SingletonBean{ private static volatile SingletonBean instance = null; public static SingletonBean getInstance() { if(null == instance) { // 第一次检查 synchronized (SingletonBean.class) { if(null == instance) { // 第二次检查 + volatile 配合避免了创建多个实例 instance = new SingletonBean(); } } } return instance; } } instance = new SingletonBean() 这句代码被编译成多条指令，大致做了下面三件事 1、给instance实例分配内存 2、初始化instance的构造器 (真正初始化) 3、将instance对象指向分配的内存空间（到这步时instance就非null了） volatile 禁止指令重排，确保 步骤3在步骤2之后执行 。 Holder 懒汉模式 (推荐) 将懒加载和线程安全(无锁)完美结合的一种方式 。 public class SingletonBean{ private static SingletonBean instance = null ; private SingletonBean() { } public static SingletonBean getInstance() { return SingletonFactory.instance; } /** * 静态的成员式内部类，该内部类的实例与外部类的实例没有绑定关系， * 而且只有被调用到才会装载，从而实现了延迟加载 */ private static class SingletonFactory { // 由 JVM 来保证线程安全 private static SingletonBean instance = new SingletonBean(); } } 枚举 懒汉模式 Java规范中规定，每一个枚举类型极其定义的枚举变量在JVM中都是唯一的 。 利用枚举的特性，让JVM来帮我们保证线程安全和单一实例的问题。 public class SingletonBean { private SingletonBean() { } public static SingletonBean getInstance() { return EnumHolder.INSTANCE.getInstance(); } private enum EnumHolder { INSTANCE; private SingletonBean instance = null; private EnumHolder() { // JVM保证这个方法只调用一次 instance = new SingletonBean(); } private SingletonBean getInstance() { return instance; } } } 类的静态方法也可以实现单例模式的效果，有什么区别 单例模式可以延迟初始化，有助于优化性能 。 单例模式 反序列化 的问题 一般来说，一个类实现了Serializable接口，我们就可以将它写入内存然后再从内存中读取组装成一个跟原来一样的对象。 此时，内存中存在N（N>=2）个相同的对象。 而单例模式要求JVM中只能有一个类的对象。如果不做特殊处理反序列就会违反单例模式的规则。 /** * 实现readResolve方法，一个class可以直接控制反序化返回的类型和对象引用。 * ObjectInputStream 会检查对象的class是否定义了readResolve方法。 * Method readResolveMethod = getInheritableMethod( cl, \"readResolve\", null, Object.class); */ private Object readResolve() throws ObjectStreamException { return INSTANCE; //直接返回已经存在单例对象，不再组装新的对象。确保唯一性。 } 原型模式 Prototype Pattern ,原型模式特点 在于通过 克隆 一个已经存在的实例来返回新的实例，而不是新建实例。 被复制的实例就是我们所称的“原型”。 模型需要对外暴露自己实现的克隆接口。 当创建新的对象实例较为复杂、成本较大时，使用原型模式可以简化对象的创建过程、节约资源。 // 创建原型对象 WeeklyLog log_previous = new WeeklyLog(); log_previous.setDate(\"第12周\"); //调用克隆方法创建克隆对象 WeeklyLog log_new = log_previous.clone(); log_new.setDate(\"第13周\"); 缺点 1、需要为每一个类配备一个克隆方法 ，当对已有的类进行改造时，需要修改源代码，违背了“开闭原则”。 2、如果对象复杂，实现深克隆的时候较麻烦。（每一层对象对应的类都必须支持深克隆） 命令模式 Command Pattern 类型 特点 命令 Command 有N种。包含具体的接收者。 接收者 Receiver 有N种 。执行具体逻辑的地方 。 请求者 Invoker 1种 。 只负责 接收命令并调用命令的执行方法。 示例 /**调用者 */ public class Invoker{ /**接收具体命令 并执行*/ public void executeCmd(Command command){ command.execute(); } } /**具体的命令,例如打开连接 */ public class CommandOpenConnection implements Command{ 　　private Receiver receiver; /**命令 和 接收者 绑定*/ 　　public CommandOpenConnection(Receiver receiver) { ...} /**执行命令*/ 　　public void execute() { 　　 receiver.doSomeThing(...); 　　} } /**具体的接收者*/ public class ReceiverOpenConnection implements Receiver{ public void doSomeThing(...) { 具体的逻辑.... } } //使用场景 Receiver receiver=... ; Invoker invoker = ...; Command cmd1 = ... ; //Command cmd2 = ... ; // 调用者 更新命令 并发起执行 invoker.executeCmd(cmd1); 优缺点 //优点 1、请求者（Invoker） 和执行者（Receiver） 完全解耦。 2、添加新的命令 符合 “开闭原则” 。 // 缺点 1、一种命令 对应 一个命令类(xxx.java)。导致 类个数过多 。 命令模式 和 策略模式 的区别 1、命令模式 只是强调解耦合，调用者只是负责发起调用。不同的命令得到不同的处理结果 。 2、策略模式 强调 一个问题可以用多种策略方法来 获得相同的处理结果 。 备忘录模式 Memento Pattern 、快照模式 在不破坏封闭的前提下，保存对象当前状态，并且在需要的时候可以再次恢复到此状态。 数据库的 回滚操作、编辑器的 Ctrl+Z恢复 都有用到 备忘录模式。 // 如何理解“不破坏封闭的前提” 发起者只提供有限的接口（保存、恢复数据）。不暴露其他不该暴露的信息。 // 缺点 消耗资源 /**发起者*/ public class Game{ private int time; //游戏开始时间 private int killPeople; //游戏人头数 /** 将信息保存到备忘录*/ public GameInfo saveGameInfo() { GameInfo gameInfo= new GameInfo(time, killPeople); return gameInfo; } // 根据备忘录 恢复 信息 。 public void loadGame(GameInfo gameInfo) { time = gameInfo.getTime(); killPeople = gameInfo.getKillPeople(); } } /**备忘录角色 ,保存指定的状态信息*/ public class GameInfo{ private int time; private int killPeople; public GameInfo(int time, int killPeople) { ... } } //使用 Game dota = new Game(); // 将状态保存到备忘录中 GameInfo info = dota.saveGameInfo(); // 根据备忘录 恢复数据 dota.loadGame(info); 外观模式 Facade Pattern 、门面模式 有一个系统 很大、很复杂，以至于一般的人不会用。即使会用也很麻烦。 这时，我们可以对这个系统做封装 ，让大家通过封装后的接口很方便地使用原来的系统 。 开启电脑 需要经过多个步骤，接通电源、启动BIOS、加载系统等等。 显然，用户不需要去操作这么繁琐复杂的流程 。 所以我们给用户暴露了一个简单的接口，只要一按开机键 就可以启动电脑了 。 大大减小了系统使用的复杂度。 缺点 1、如果子系统做了修改 ， 外观类可能需要做相应修改。违背了开闭原则。 代理模式 、外观模式 的区别 1、侧重点不同， 代理强调 不直接访问原系统（因为权限等） 。 外观模式 强调 复杂系统的简化。 建造者模式 Builder Pattern 适用于 构建流程非常复杂的 对象。 将一个复杂对象的构造与它的表示分离，使同样的构建过程可以创建不同的表示。 1、对象的构建：对象的组装生成过程。 2、对象的表示：产品本身。产品的特性。 3、同样的创建过程：指挥者中定义的创建的相同流程。 4、创建不同的表示：不同的创建细节区分在构建者当中，调用不同的构建者会有不同的结果。 具有指挥者的建造者模式 （完整模式） // 具体的构建者 只负责 最后的构建细节。 // 不负责这些细节如何组装 class DevilBuilder extends ActorBuilder{ public void buildType() { ...} public void buildSex() { ... } public void buildFace() { ... } public void buildCostume() {...} public void buildHairstyle() {...} } // 指挥者 只负责构建顺序 class ActorController{ public Product getProduct(ActorBuilder ab) { ab.buildType(); ... ab.buildCostume(); // Product在ActorBuilder的构造函数中创建好 return ab.createAProduct(); } } //测试 // 构建顺序定义在 ActorController 中 ActorController controller = ...; // 产品不同部位的构建能力 定义在 builer 中 ActorBuilder builer=...; //根据构建者不同返回产品不同 Product product = controller.getProduct(builer); 没有指挥者的建造者模式（简略模式） 构建顺序 和构建能力 全部定义在 ActorBuilder 中 class DevilBuilder extends ActorBuilder{ public void buildType() { ...} public void buildSex() { ... } public void buildFace() { ... } public void buildCostume() {...} public void buildHairstyle() {...} public Product getProduct() { buildType(); ... buildCostume(); return createAProduct(); } } 建造者模式 和 工厂模式 的区别 工厂模式与 建造者模式的完整模式相比，就多了一个 指挥者。 不同的构建者的 构建流程 抽象出来放在一起了。 与简略模式相比，我感觉没啥区别。 建造者模式 和 策略模式 的区别 个人感觉只是定义的出发点不同。 从形式上看，都是根据传入不同的策略，获得不同的结果。（一种构建者可以看做一种策略） 桥接模式 Bridge Pattern 如果一个类有多个变化维度。此时可以使用继承的方法进行组合 ，但是这样会产生大量的派生类 才能满足要求。 此时我们的桥接模式，采用聚合而非继承的方式 也可以实现同样的效果。但是需要的派生类就大大减少了。 抽象部分 、实现部分 概念参考自刘伟 。 假如一个类有两个独立的纬度，我们将与这个类关系最密切、最本质的那个纬度 称之为 “抽象部分”。 而另外的一个纬度称之为“实现部分” 。 例如 一支毛笔，有“大小型号” 和\"能绘制的颜色\" 两个纬度 。 因为毛笔一旦生产它的大小型号就已经被固定了，而能绘制的颜色可以根据沾染的涂料不同而变化。 所以， “型号”这个纬度划分为 “抽象部分” ，“颜色”划分为 “实现部分” 。 示意图 采用继承的方式去实现效果。需要较多的派生类。 采用桥接的方式去实现效果。型号和颜色互相组合即可实现。 demo //实现部分 public class Color{ String color=\"\"; public Color(String color) {...} } // 抽象部分 public class Size { Color color; String size =\"大号\" ; public Size(Color color){...} public void disPlay() { System.out.println(size+\" \"+ color.color+ \" 笔\"); } } //组合 Color white =new Color(\"白色 \"); Size size = new Size(white); size.disPlay(); //获得 大号白色笔 模板模式 、模板方法模式 、Template Method Pattern 模板方法使得子类可以在不改变算法结构的情况下，重新定义算法中的某些步骤。 为防止恶意操作，一般模板方法都加上 final 防篡改。 demo /**抽象类*/ public abstract class AbstractComputer{ /**开机*/ protected void powerOn() { ... } /**常规硬件检查*/ protected void checkHardware() { ...} /**加载 操作系统*/ protected void loadOS() { ...} /**默认无密码验证，直接进入系统*/ protected void login() { ... } // 模板方法，用 final修饰，防止被篡改 算法流程。 public final void startUp() { //公共方法 powerOn(); //有差异性的方法 checkHardware(); //公共方法 loadOS(); //有差异性的方法 login(); } } // 程序员的电脑 CoderComputer extends AbstractComputer... @Override protected void login() { // 验证用户名和密码 } //军用计算机 class MilitaryComputer extends AbstractComputer... @Override protected void checkHardware(){ //进行 硬件防火墙 等安全设备是否正常 ... } @Override protected void login(){ //验证 指纹 、 用户名、密码等 } 状态模式 State Pattern 某种业务情况下，确实可以用 if else 来完成 ， 但是由于 不同状态下的处理方法不一样。会导致大量的 if else 代码。 会造成代码复杂，不易维护等问题。 此时可以考虑用 状态模式 解决。 demo 一个订单的状态： 未支付、正在支付、已支付、申请退款，退款中，退款完成 //直接采用简单的 if else 方式 public void 支付（）{ if(未支付){ //处理 支付操作 } else if(正在支付){ //提示 不符合操作条件。 } else if(退款完成){ //提示 不符合操作条件。 } } public void 退款（）{ if(未支付){ //提示 不符合操作条件。 }else if(正在支付){ //提示 不符合操作条件。 } else if(退款完成){ //提示 不符合操作条件。 }else if(已支付){ // 处理退款操作.. } } //如果要新增 一个 \"退款审核\"状态 。 //此时需要去修改以上所有的 if else ,严重破坏 开闭原则 。 //采用状态模式 /**未支付状态*/ public class NoPayStatus { public NoPayStatus(Order order,String name){ //初始化订单信息 } public OrderStatus processOrder(Order order) { //处理当前状态下的订单， ... //根据处理结果，设置订单新的状态 OrderStatus state=new PayStatus(order,\"已支付\"); order.setStatus(state); return state; } } /**申请退款*/ public class ApplyDrawbackStatus { private Order order; private String name; public ApplyDrawbackStatus(Order order, String name) { //初始化订单信息 } @Override public OrderStatus processOrder(Order order) { //处理当前状态下的订单， ... //根据处理结果，设置订单新的状态 return new DrawbackStatus(order, \"订单回款中\"); } } //使用场景 //某个时刻根据情况根据具体情况给订单设置状态 Order order=new Order(); order.setStatus( 某个状态); .... //在另一个时刻，处理订单。 OrderStatus status=order.getStatus(); status.processOrder(order); 缺点 并没有完全符合 开闭原则 @Override public OrderStatus processOrder(Order order){ //如果要新增 一个 \"退款审核\"状态 。 //也需要修改相关代码 //return new DrawbackStatus(order, \"订单回款中\"); return new CheckDrawbackStatus(order, \"退款审核中\"); } 策略模式 和 状态模式 的区别 1、策略模式只是一个解决方案的封装 。重在外部对策略的选择或动态的切换。策略模式每个算法是相对独立的。 2、状态模式是初始化一个状态，之后的每个状态的变化都会指定下一个状态。状态模式中每个状态是存在相互转化的， 策略模式 Strategy Pattern demo /**抽象接口，定义共同操作*/ public interface Strategy{ public double getValue(double paramA, double paramB); } // 加法策略 public class AddStrategy implements Strategy{ @Override public double getValue(double paramA, double paramB){ return paramA + paramB; } }// // 减法策略 public class SubStrategy implements Strategy{ @Override public double getValue(double paramA, double paramB){ return paramA - paramB; } }// // 辅助类。根据传入的策略类型返回计算结果。 public class CalcClient{ private Strategy strategy; public void setStrategy(Strategy strategy){ this.strategy = strategy; } public double calc(double paramA, double paramB){ return this.strategy.getValue(paramA, paramB); } } public static void main(String[] args){ double paramA = 5; double paramB = 21; //用if-else实现 （ 普通形式） System.out.println(\"普通方法-加法结果是：\" + calc(\"+\", paramA, paramB)); System.out.println(\"普通方法-减法结果是：\" + calc(\"-\", paramA, paramB)); //System.out.println(\"乘法结果是：\" + calc(\"*\", paramA, paramB)); //System.out.println(\"除法结果是：\" + calc(\"/\", paramA, paramB)); //策略模式 System.out.println(\"策略模式-加法结果是：\" + calc(new AddStrategy(), paramA, paramB)); System.out.println(\"策略模式-减法结果是：\" + calc(new SubStrategy(), paramA, paramB)); //System.out.println(\"乘法结果是：\" + calc(new MultiStrategy(), paramA, paramB)); //System.out.println(\"除法结果是：\" + calc(new DivStrategy(), paramA, paramB)); } // 用if-else实现 （ 普通形式） public static double calc(String op, double paramA, double paramB){ if (\"+\".equals(op)) { return paramA + paramB; } else if (\"-\".equals(op)) { return paramA - paramB; } else if (\"*\".equals(op)) { return paramA * paramB; } else if (\"/\".equals(op)) { return paramA / paramB; } else { throw new IllegalArgumentException(\"未找到计算方法!\"); } } // 策略模式 实现 public static double calc(Strategy strategy, double paramA, double paramB) { CalcClient calc = new CalcClient(); calc.setStrategy(strategy); return calc.calc(paramA, paramB); } 前者通过简单的if-else来解决问题，在解决简单问题事会更简单、方便; 后者则是通过给予不同的具体策略来获取不同的结果，对于较为复杂的业务逻辑显得更为直观，扩展也更为方便。 优缺点 // 优点 1、结构清晰明了、使用简单直观。 2、耦合度相对而言较低，扩展方便。 3、操作封装也更为彻底，数据更为安全。 // 缺点 1、随着策略的增加，子类也会变得繁多。 简单工厂模式（Simple Factory Pattern） 又叫做静态工厂方法（StaticFactory Method）模式。 注：简单工厂模式实际上不属于23个GOF模式。 工厂类根据传入的参量,动态的决定应该创建出哪一个产品类的实例的设计模式。一个工厂可以生产多种产品。 优缺点 //优点 使用者不需要去负责具体的创建过程，只需要向工厂传递参数信息就可以获得自己想要的产品。 // 缺点 因为工厂类集中了所有实例的创建逻辑， 如果需要增加新的产品，就需要修改工厂类，不利于代码的维护。违背了“开闭原则” 。所以**不推荐**使用这种设计模式。 客户很爽，工厂很被动。 demo // 产品抽象类，定义产品共同的特效 public interface Product{ public void getProductInfo() ; } // 具体的产品 public class Car implements Product{ @Override public void getProductInfo(){ System.out.println(\"汽车产品\"); }// }// public class Bicycle implements Product{ @Override public void getProductInfo(){ System.out.println(\"自行车产品\"); }// }// // 简单工厂 public class SimpleFactory{ /** * 根据不同的参数进行判断，返回不同的结果。 * 如果增加了产品类，需要修改判断代码。 * 静态工厂方法 的“静态”体现在这个 static方法上 */ public static Product getProductInfo(String productType ){ Product product = null ; if(\"car\".equals(productType)){ product = new Car() ; }else{ product = new Bicycle() ; } return product; }// } // 测试 public static void main(String[] args){ //直接调用工厂类的 静态方法或的产品。 Product product =SimpleFactory.getProductInfo(\"car\") ; product.getProductInfo() ; }// 抽象工厂模式（Abstract Factory Pattern） 工厂方法模式是一个具体工厂生产一种具体产品，抽象工厂模式是一个具体工厂生产一个品牌下的多种产品。 工厂方法模式解决了简单工厂模式中工厂类职责太重的问题。 但由于工厂方法模式中的每个工厂只生产一类产品，可能会导致系统中存在大量的工厂类，势必会增加系统的开销。 此时，我们可以考虑将一些相关的产品组成一个“产品族”，由同一个工厂来统一生产，这就是抽象工厂模式的基本思想。 产品等级结构 、产品族 // 产品等级结构 类似手机与androdi手机、mac手机的关系。手机和Android手机、mac手机具体手机产品之间构成了一个产品等级结构。 // 产品族 同一个品牌下的各种产品，比如android手机和Android电视属于同一个产品族。 优缺点 // 优点 - 1、隔离了具体类的生成，更换一个具体工厂就变得相对容易。 - 2、增加新的产品族很方便，无须修改已有系统，符合“开闭原则”。 //缺点 - 1、增加新的产品等级结构麻烦，违背了“开闭原则”。 增加新的产品族很方便，但是增加新的产品等级结构很麻烦，抽象工厂模式的这种性质称为“开闭原则”的倾斜性。 demo // 抽象产品 public interface Iphone{ public void getInfo(); } // 抽象产品 public interface TV{ public void getInfo(); } // 具体产品 public class AndroidIphone implements Iphone{ @Override public void getInfo(){ System.out.println(\"mac 手机\"); } } public class MacIphone implements Iphone{ @Override public void getInfo(){ System.out.println(\"android 手机\"); } } public class AndroidTv implements TV{ @Override public void getInfo(){ System.out.println(\" Android 电视\"); } } public class MACTv implements TV{ @Override public void getInfo() { System.out.println(\" MAC 电视\"); } } // 抽象工厂 public interface IFactory{ public Iphone createPhone() ; public TV createTV() ; } // 具体工厂。 public class AndroidFactory implements IFactory{ @Override public Iphone createPhone(){ return new MacIphone(); } @Override public TV createTV(){ return new MACTv(); } } // 具体工厂 public class MacFactory implements IFactory{ @Override public Iphone createPhone(){ return new AndroidIphone(); } @Override public TV createTV(){ return new AndroidTv(); } } // 测试场景 public static void main(String[] args){ IFactory factory = new AndroidFactory() ; //根据配置文件或者网络参数，动态决定采用哪一个工厂。 //IFactory factory = new MacFactory() ; //批量得到属于同一品牌下的产品。 Iphone phone = factory.createPhone() ; TV tv = factory.createTV() ; tv.getInfo(); }// 工厂方法模式（Factory Method Pattern） 又被称为多态工厂模式。 通常我们所说的工厂模式是指工厂方法模式。 工厂方法是针对每一种产品提供一个工厂类。通过不同的工厂实例来创建不同的产品实例。 反射生成对象只能适用一些最简单的情况，简单的创建一个对象。 如果对象的创建过程比较复杂，例如要调用有参构造函数、创建之前要配置环境等等，需要将这些代码封装到工厂中。 // 定义工厂的公共行为。 可以用接口或抽象类。 public interface Factory{ public Product produceProduct() ; } // 具体的产品 car public class Car implements Product{ @Override public void getProductInfo(){ System.out.println(\"汽车产品\"); } } // 具体的产品 bicycle public class Bicycle implements Product{ @Override public void getProductInfo(){ System.out.println(\"自行车产品\"); } } // 定义工厂的公共行为。可以用接口或抽象类。 public interface Factory{ public Product produceProduct() ; } // 具体的工厂类。BicycleFactory public class BicycleFactory implements Factory{ @Override public Product produceProduct(){ //做一些复杂的操作。比如连接数据库等 //调用有参构造等 Bicycle bicycle = new Bicycle(); return bicycle; } }// // 具体的工厂类。CarFactory public class CarFactory implements Factory{ @Override public Product produceProduct(){ //做一些复杂的操作。比如连接数据库等 // ... //调用有参构造等 Car car = new Car(); return car; } }// /**使用场景*/ public static void main(String[] args){ //根据相关参数 生成具体的工厂对象。例如根据配置文件或者网络参数来决定 Factory factory ; factory= new CarFactory() ; //factory= new BicycleFactory() ; Product product = factory.produceProduct() ; product.getProductInfo(); }// 优缺点 // 优点 1、它能够让工厂可以自主确定创建何种产品对象，而如何创建这个对象的细节则完全封装在不同的具体工厂内部。 2、加入新产品时，无须修改抽象工厂和抽象产品提供的接口，也无须修改其他的具体工厂和具体产品， 而只要添加一个具体工厂和具体产品就可以了。 // 缺点 1、在添加新产品时，需要新加新的具体产品类和与之对应的具体工厂类，在一定程度上增加了系统的复杂度， 有更多的类需要编译和运行，会给系统带来一些额外的开销。 策略模式和工厂模式有什么区别 1、侧重点不一样 。 工厂模式侧重构建过程，使用者拿到最终的“生产物”即可。 策略模式侧重 事件的行为，使用可互换的规则创建成功业务。 策略模式是开放的，大多数事情要你自己亲力亲为。 而工厂模式作是封闭的，很多事情都帮组你做好了，你直接“点”就可以了。 工厂相当于黑盒子，策略相当于白盒子? [参考资料](http://blog.csdn.net/tengzhaorong/article/details/6827093) 组合模式 Composite Pattern 、 整体-部分模式 组合模式将一批有共同特征的对象组合成 “树形结构”。 关键点是定义了一个抽象构件类，它既可以代表叶子，又可以代表容器， 而客户端针对该抽象构件类进行编程，无须知道它到底表示的是叶子还是容器，可以对其进行统一处理。 透明组合模式 （推荐使用） 强调透明性一致性。 因为叶子节点不存在子节点，所以一些方法是无效的。可以用过 “提供异常处理或相关提示”来解决 。 安全组合模式 优点 1、将对象们进行树形分层，方便对整个某个层次的所有对象进行处理。 2、使用透明组合模式时， 新增节点(容器节点、子节点) 符合 “开闭原则” 。 demo /**抽象节点 */ abstract class AbstractFile{ public abstract void add(AbstractFile file); public abstract AbstractFile getChild(int i); public abstract void killVirus(); } /**叶子节点*/ class ImageFile extends AbstractFile{ private String name; public ImageFile(String name) { ...} public void add(AbstractFile file) { // 子节点 不支持 当前方法 的相关提示 } public AbstractFile getChild(int i) { // 子节点 不支持 当前方法 的相关提示 return null; } public void killVirus() { //模拟杀毒 ... } } /**容器节点*/ class Folder extends AbstractFile { private ArrayList fileList=new ArrayList<>(); private String name; public Folder(String name) {...} public void add(AbstractFile file) { fileList.add(file); } public AbstractFile getChild(int i) { return (AbstractFile)fileList.get(i); } public void killVirus() { //递归调用 for(AbstractFile obj : fileList) { obj .killVirus(); } } } //使用 。针对抽象构件编程 // 子节点 AbstractFile folder2 = new Folder(\"图像文件夹\"); folder2.add(new ImageFile(\"xxx.jpg\")); folder2.add(new ImageFile(\"xxxx.gif\")); // 容器节点 AbstractFile file1 = new Folder(); folder1.add(folder2); folder1.killVirus(); 装饰者模式 、Decorator Pattern 、包装模式 、Wrapper Pattern 装饰模式是一种用于替代继承的技术。 在不改变一个对象原有结构和功能的前提下，给它新加一些额外的功能。 public class ConcreteComponent extends MyComponent{ /**原有功能*/ @Override public void operation() { ... } } 透明装饰模式 (尽量使用这种方式) 要求完全针对抽象编程。可以透明地使用装饰之前的对象和装饰之后的对象。 为了达到这种效果， 必须在构件对象的方法中调用 增强方法。 但是缺点是用户不能单独地调用那些增强的方法 。 /**具体装饰器*/ public class ConcreteDecoratorA extends MyComponent{ MyComponent component ; /**持有被装饰的对象*/ public ConcreteDecoratorA(MyComponent component) { ... } public int operationA(){ ... 增强方法 ... } @Override public void operation() { // 区别点！！里面调用了 operationA（） operationA(); component.operation(); } } MyComponent myComponet1= new ConcreteComponent(...); // 针对MyComponent抽象编程 MyComponent myComponet2 = new ConcreteDecoratorA(myComponet1); myComponet1.operation(); //不能在外面调用额外功能 。- 编译 出错 myComponet2.operationA(); myComponet2.operation(); 半透明装饰模式 /**具体装饰器*/ public class ConcreteDecoratorA extends MyComponent { MyComponent component ; /**持有被装饰的对象*/ public ConcreteDecoratorA(MyComponent component) { ... } public int operationA(){ ... 增强方法 ... } @Override public void operation() { // 区别点！！ 在里面并没有调用 operationA() component.operation(); } } MyComponent myComponet1= new ConcreteComponent(...); ConcreteDecoratorA myComponet2 = new ConcreteDecoratorA(myComponet1); //透明装饰者模式 myComponet1.operation(); // 可以在外 调用增强方法 - 编译ok myComponet2.operationA(); myComponet2.operation(); 如何理解 “半透明装饰模式不能实现对同一个对象的多次装饰” 首先明确一点：半透明装饰模式 是将 增强方法 和原有方法 独立开来的。在装饰器中 原有方法并没有调用过增强方法。 因为装饰类持有的是 MyComponent 类型的引用，而 MyComponent 并不能调用增强方法。 所以导致如下结果： 多次装饰的情况下，无法使用那些增强方法。 代理模式 与 装饰者模式 区别 代理模式 强调对 委托对象的访问 ( 例如情况下 委托类不能或者不想对外暴露)。 装饰模式 强调 给原对象增加额外功能。 二者看起来类似，但是解决问题的出发点不一样。 观察者模式 Observer Pattern 1、Observer Pattern用于建立一种对象与对象之间的依赖关系。 一个对象发生改变时将自动通知其他对象，其他对象将相应作出反应。 2、Observer Pattern包含1个观察目标和n(n>=1)观察者两类对象。一旦观察目标的状态发生改变，所有的观察者都将得到通知。 3、这种交互也称为发布-订阅(Publish-Subscribe)。 发布者发出通知时并不需要知道谁是它的观察者，可以有任意数目的观察者订阅它并接收通知。 - 4、凡是涉及到一对一或者一对多的对象交互场景都可以使用观察者模式。 // 举例 1、交通信号灯是汽车（驾驶员）的观察目标，而汽车是观察者。 随着交通信号灯的变化，汽车的行为也将随之而变化，一盏交通信号灯可以指挥多辆汽车。 2、在当前流行的MVC架构中也应用了观察者模式，它包含三个角色：模型(Model)，视图(View)和控制器(Controller)。 其中模型可对应于观察者模式中的观察目标，而视图对应于观察者，控制器可充当两者之间的中介者。 当模型层的数据发生改变时，视图层将自动改变其显示内容。 3、邮件订阅和RSS订阅，当我们浏览一些博客或wiki时，当你订阅了该文章，如果后续有更新，会及时通知你。 观察目标 Observer Pattern中，发生改变的对象称为观察目标。 观察者 而被通知的对象称为观察者。 1、一个观察目标可以对应多个观察者。 2、这些观察者之间可以没有任何相互联系。 3、可以根据需要增加和删除观察者，使得系统更易于扩展。 优缺点 // 优点 1、观察者模式可以实现表示层和数据逻辑层的分离，定义了稳定的消息更新传递机制，并抽象了更新接口， 使得可以有各种各样不同的表示层充当具体观察者角色。 2、观察者模式在观察目标和观察者之间建立一个抽象的耦合。 观察目标只需要维持一个抽象观察者的集合，无须了解其具体观察者。 3、观察者模式支持广播通信，观察目标会向所有已注册的观察者对象发送通知，简化了一对多系统设计的难度。 4、观察者模式满足“开闭原则”的要求，增加新的具体观察者无须修改原有系统代码， 而且观察目标和观察者没有紧密地耦合在一起，因此它们可以属于不同的抽象化层次。 在具体观察者与观察目标之间不存在关联关系的情况下，增加新的观察目标也很方便。 // 缺点 1、若一个观察目标对象有很多直接和间接观察者，将所有的观察者都通知到会耗时过多。 2、若观察者和观察目标之间存在循环依赖，观察目标会触发它们之间进行循环调用，可能导致系统崩溃。 3、Observer Pattern没有相应的机制让观察者知道所观察的目标对象是怎么发生变化的，而仅仅只是知道观察目标发生了变化。 demo: // 观察者抽象类，定义共同的行为 public interface Observer{ public void update(); } // 具体的观察者 1 public class Observer1 implements Observer{ @Override public void update(){ System.out.println(\"观察者 1收到通知\"); } }// // 具体的观察者 2 public class Observer2 implements Observer{ @Override public void update(){ System.out.println(\"观察者 2收到通知\"); } }// // 被观察者接口。定义一些 方法用来管理 观察者集合。 public interface Subject{ /**添加观察者*/ public void addObserver(Observer observer) ; /**删除观察者*/ public void delObserver(Observer observer) ; /**通知观察者*/ public void notifyAllObservers(); }// // 具体的 被观察者 public class MySubject implements Subject{ /**线程安全的集合*/ private Vector myObservers ; /**构造函数*/ public MySubject () { myObservers = new Vector(); } @Override public void addObserver(Observer observer) { myObservers.add(observer) ; } @Override public void delObserver(Observer observer) { myObservers.remove(observer) ; } @Override public void notifyAllObservers() { //使用迭代器获取所有观察者 并通知 Iterator iterator = myObservers.iterator() ; while (iterator.hasNext()) { Observer observer = iterator.next(); observer.update(); }// }// } /**实际场景应用*/ public static void main(String[] args) { Observer1 ob1 = new Observer1() ; Observer2 ob2 = new Observer2() ; MySubject mySubject = new MySubject() ; mySubject.addObserver(ob1); mySubject.addObserver(ob2); mySubject.notifyAllObservers() ; }// 解释器模式 Interpreter Pattern 还未完全理解。 等过段时间再来更新.... 解释器模式为自定义语言的设计和实现提供了一种解决方案，它用于定义一组文法规则并通过这组文法规则来解释自定义语言中的句子。 #### 应用场景 1、正则表达式解释器 2、SQL语法的解释器 相关概念 特点 举例 终结符（表达式） 不可拆分的最小元素。 一个语法的规则不能改变终结符。 x -> xa a是终结符 非终结符（表达式） 可拆分元素。 非终结符是可以被取代的元素。运算符也是非终结符 x -> xa x 是非终结符 语言的文法规则 即语法规则。拥有自己的表达式和结构。 抽象语法树(Abstract Syntax Tree, AST) 用来直观地表示语言的构成。 每一棵抽象语法树对应一个语言实例。 终结符表达式类的实例作为树的叶子节点，非终结符表达式类的实例作为非叶子节点。 通过对抽象语法树的分析，可以识别出语言中的终结符类和非终结符类。 环境角色 存放文法中各个终结符所对应的具体值 #### 示例 Java无法直接解释类似“1+ 2 + 3 – 4 + 1”这样的字符串。 我们可以自己定义 一个解释器来解释这个语句 。 一些重复发生的问题，比如加减乘除四则运算，但是公式每次都不同，有时是a+b-cd，有时是ab+c-d，等等等等个，公式千变万化，但是都是由加减乘除四个非终结符来连接的，这时我们就可以使用解释器模式。 #### 缺点 1、 执行效率低。 2、 维护困难。 访问者模式 Visitor Pattern 访问者模式把 数据结构 和 作用于结构上的操作 解耦合 。 适用于数据结构相对稳定算法又易变化的场景。 demo 以公司员工和部门的关系为场景。 /**全职员工*/ public class FulltimeEmployee implements Employee { public FulltimeEmployee(String name, int workTime) {...} /**每个对象都会实现这个方法*/ @Override public void accept(Department handler) { //每个访问者都会有这个方法 handler.visit(this); } } /**人力资源部类：具体访问者类*/ public class HRDepartment implements Department { /**所有访问者都会重载 所有 visit方法*/ @Override public void visit(FulltimeEmployee employee) { ... } /***所有访问者都会重载 所有 visit方法 */ @Override public void visit(ParttimeEmployee employee) { ... } } //使用。访问者不同，会做出不同的处理结果 Employee employee = new FulltimeEmployee(...); Department dep = new HRDepartment(....) ; //Department dep = new FADepartment (....) ; employee.accept(dep); 优缺点 // 优点 1、方便定义 新的访问者，实现新的数据操作。 //Department dep = new HRDepartment(....) ; //定义新的访问者 Department dep = new FADepartment (....) ; // 缺点 1、违背了\"依赖倒置原则\" 。访问者依赖的是具体元素，而不是抽象元素。 public void visit(FulltimeEmployee employee) { ... } 2、增加新的元素类比较困难。 每增加一个元素类 , 访问者就要多加一个visit()。 // 有 n个元素类 就有 n 个visit 方法 @Override public void visit(FulltimeEmployee employee) { ... } .... @Override public void visit(ParttimeEmployee employee) { ... } 访问者模式 和 策略模式 的区别 我个人感觉这两个模式差不多。 个人体会到的区别： 1、策略模式是通过构造方法将策略传进去的 。 访问者模式 是通过普通的方法 accept() 将访问者（策略）传进的。 2、 体现在定义架构上 public class HRDepartment implements Department { @Override public void visit(FulltimeEmployee employee) { ... } ... @Override public void visit(ParttimeEmployee employee) { ... } } 责任链模式 Chain of Responsibility Pattern 其实 ，swith 、if-else 体现了最简单的责任链思想 。只是这种写法 比较臃肿、耦合度高。 优缺点 // 优点 1、一个请求沿着一条“链”传递，申请者不需要知道是谁来批准这个请求。 批阅者也不需要这个请求来自谁。 这样将 申请者和批阅者优雅地解耦了。 2、容易拓展责任链 // 缺点 1、需要对链中责任人的遍历，如果责任人太多那么遍历必定会影响性能。 2、请求不一定会被处理掉。 demo /**责任人的处理方法*/ public void handleRequest(ProgramApe ape){ if ( 有处理权限) { // 自己处理掉... } else { if (null != mSuperiorLeader) { //如果自己没有权限处理， 就交给上级处理 } else { //如果自己没有权限处理， 也没有其他领导。就抛出错误，提示该 //请求没有被处理掉 } } } //应用场景 //先来一个程序猿 这里给他一个三万以内的随机值表示需要申请的差旅费 ProgramApe ape = new ProgramApe((int) (Math.random() * 30000)); //再来四个领导 Leader leader = new GroupLeader(); Leader director = new Director(); Leader manager = new Manager(); Leader boss = new Boss(); //事先设置好 责任链之间的连接关系 leader.setLeader(director); director.setLeader(manager); manager.setLeader(boss); // 提交申请（不用写 if else 繁琐代码） leader.handleRequest(ape); 迭代器模式 Iterator Pattern 、游标模式 迭代器模式 提供一种机制 遍历一个聚合对象中的各个元素，而又不暴露其他细节。 由于java已经为我们对容器对象（Collection，List、Set、Map等）做了很好的封装， 我们平时其实很少会自己实现迭代器模式。 demo // 具体迭代器 class ConcreteIterator implements MyIterator{ private List list = new ArrayList (); private int cursor =0; public ConcreteIterator(List list){ this.list = list; } public boolean hasNext(){ return !(cursor == list.size()); } public Object next(){ if(hasNext()){ return list.get(cursor++); } return null; } } /**具体的聚合类*/ class ConcreteAggregate { private List list = new ArrayList(); public MyIterator iterator(){ return new ConcreteIterator(list); } // 聚合类中的其他方法 ，处理其他逻辑 fun1 、saveObj 、removeObj public void saveObj(Object obj) { ... } ... 其他逻辑... } //使用 // 聚合类 ConcreteAggregate ag = new ConcreteAggregate(); ag.saveObj(\"obj1\"); ag.saveObj(\"obj2\"); // 获取迭代器 MyIterator it = ag.iterator(); //根据迭代器 遍历 while(it.hasNext()){ ... } 优缺点 // 优点 1、将聚合类 的 “数据存储” 和 \"数据遍历\" 分离 。 2、自定义的迭代器可以实现一些自己想要的遍历效果（逆序遍历、只遍历符合自己指定条件的对象等）。 // 缺点 1、一个具体的聚合类 对应一个 迭代器 ，略显繁琐。 适配器模式 Adapter Pattern 解决接口不兼容的问题。 A 需要 C接口， 但是系统只提供了B接口。 同时, A 和B 都不想改或者不能改。 如果，我们将B封装一下，改成C接口的规范。就解决了问题。 被适配者 ：即源接口 。 一、类适配器 （不推荐） 采用继承方案。 // 旧接口 提供220V电压 public class Voltage220 { public int output220V() { return 220; } } // 用户需要 5V的电压 public interface Voltage5{ int output5V(); } //新建适配器 public class VoltageAdapter extends Voltage220 implements Voltage5 { @Override public int output5V() { //获得旧接口的数据， 转换成用户需要的数据 int src = output220V(); return src / 44; } } 二、对象适配器 （推荐） 采用持有方案。 // 新建适配器 public class VoltageAdapter2 implements Voltage5 { private Voltage220 mVoltage220; public VoltageAdapter2(Voltage220 voltage220) {...} @Override public int output5V() { int src = mVoltage220.output220V(); return src / 44; } } 三、缺省适配器 、接口适配器模式（推荐） 原接口是 interface 。 // 原接口 public interface AnimatorPauseListener{ void onAnimationStart(Animator animation); void onAnimationEnd(Animator animation); ... void onAnimationResume(Animator animation) ; } // 新建适配器 public abstract class AnimatorListenerAdapter implements AnimatorListener { @Override public void onAnimationEnd(Animator animation){...} @Override public void onAnimationStart(Animator animation){...} @Override public void onAnimationResume(Animator animation) {...} } // 使用 XXX.addListener(new AnimatorListenerAdapter() { @Override public void onAnimationStart(Animator animation) { // 重新 需要的那个方法就行。 // 而不必 要实现 interface 中所有的方法，从而简化代码 } }); 四、双向适配器 （不推荐） 同时持有原接口和旧接口的对象。 class Adapter implements DesInterface,SrcInterface { private Des des; private Src src; public Adapter(Des des) {... } public Adapter(Src src) {...} public void() func1(){ src.xxx(); }; public void() func2(){ des.xxx(); }; } ( no Copyright，enjoy youself ! ) all right reserved，powered by GitbookThe file was updated at : 2021-03-04 14:58:32 "},"chinese/设计模式/mvc等.html":{"url":"chinese/设计模式/mvc等.html","title":"mvc等","keywords":"","body":"常用架构 MVC 架构 1979年，Trygve Reenskaug 在Smalltalk-80系统上首次提出了MVC的概念， 最初的时候叫做Model-View-Controller-Editor。 MVC并不是一种设计模式，不在23种经典设计模式中。 可以理解为 MVC是一种架构模式，一种架构可能 运用到了多种设计模式。 Model 模型 适合做一些业务逻辑处理，比如数据库存取操作，网络操作，复杂的算法，耗时的任务等都在model层处理。 View 视图 处理数据显示的部分，XML布局可以视为V层，显示Model层的数据结果。 Controllor 控制器 处理用户交互问题。 mvc 优点 、缺点 // 优点 1、实现了分层开发 ,降低了代码的耦合 // 缺点 1、增加了代码编写的复杂性 2、MVC中 允许 M 层 和 V 层进行交互 ，解耦合不够彻底 MVP 架构 Model 业务逻辑和实体模型层 View 视图展示层。 V层没有任何的逻辑部分又不用主动监听数据，被称之为“被动视图”。 Presenter 负责view和model层的交互。 mvp 特点 于mvc相比，mvp有以下特点 1、 M 层和 V 层只能通过 P 层进行交互 2、V 层和 P 层通过接口进行交互 3、一个复杂的 V 层可以对应多个 P mvp 优点 、缺点 // 优点 1、相对mvc解耦更彻底 // 缺点 1、多了很多接口文件。 繁多的接口，繁琐的接口通信 , 在实际的开发过程中，很难严格遵循。 MVVM 、 MV-VM 架构 MVVM架构在一定程度上减少了MVP存在的以下缺点。 1、P 层与 V 层是通过接口进行交互的，接口粒度不好控制。 粒度太小，就会存在大量接口的情况，使代码太过碎版化; 粒度太大，解耦效果不好。 2、V 层与 P 层还是有一定的耦合度。 一旦 V 层某个UI元素更改，那么对应的接口就必须得改， 数据如何映射到UI上、事件监听接口这些都需要转变，牵一发而动全身。 3、复杂的业务同时也可能会导致 P 层太大。虽然可以 一个 V 对应 多个 P 。 MVVM模块 模块 说明 M Model 数据提供 V View 视图展示 VM ViewModel M 和 V 绑定 ， 监听数据变化，一旦有改变，就响应到另一方 mvvm的缺点 2、引入新框架，增加学习成本。 3、通过 数据绑定的方式 ，出现问题 ，不容易调试。 MVVM 数据双向绑定、完全解耦的原理 在安卓中，DataBinding 是 谷歌提供的一个工具， 可以将 V 和 M 进行数据绑定 。 能实现数据绑定的原因，我猜测是框架采用了 观察者模式 实现数据驱动， DataBinding 具体源码我暂时还未看过，只能是猜测 。 其他方向，例如前端也有类似的框架，例如 Vue.js 完全解耦的方案中 ，如何管理生命周期 可以使用 谷歌的 LiveData 。 总结 1、MVC中 允许 M 层 和 V 层进行交互 ，耦合太高，不合理。 2、MVP 中 ， P 层与 V 层还是有一定的耦合度。还不够完美。 3、MVVM ，通过数据绑定的方式，实现数据监听 ，完全解耦。 Jetpack 由于Gradle默认支持依赖传递，添加这一句代码就依赖了很多库。 implementation \"android.arch.lifecycle:extensions:1.1.1\" 一直以来，Android开发都充斥了大量的不规范的操作和重复代码， 比如生命周期的管理，开发过程的重复，项目架构的选择等等。 所以 2018年谷歌I/O 发布了一系列辅助android开发者的实用工具， 合称 Jetpack ，以帮助开发者在从基础，架构，行为以及界面 4 大方面体系化地为我们提供组件级别的支持。 Jetpack 包含4个部分的组件：Architecture、Foundation、Behavior 以及 UI 。 Architecture 全称 Android Architecture Component (AAC) 。 AAC 包含 ViewModel 、LiveData、Room、 Lifecycles、DataBinding、Navigation、 Paging、WorkManager 、DataStore Navigation https://developer.android.google.cn/guide/navigation/navigation-getting-started Navigation的主要目的就是方便在一个 Activity中对多个Fragment进行管理。 让Fragment能够轻松的实现跳转与传递参数。 类似于ios开发中的storyboard 。 我试用了一下，感觉不太喜欢这种方式。 只做一下基本笔记。 // 在 APP 模块下的 gradle 配置 apply plugin: 'androidx.navigation.safeargs' def nav_version = \"2.1.0\" implementation \"androidx.navigation:navigation-fragment:$nav_version\" implementation \"androidx.navigation:navigation-ui:$nav_version\" // 在项目 gradle 配置 def nav_version = \"2.1.0\" classpath \"androidx.navigation:navigation-safe-args-gradle-plugin:$nav_version\" -- 这个是为了使用 Safe Args Gradle -- 指定导航容器 -- 指定开始页是 fragmentOne ... 注意 ，如果修改了 navigation 地图， 需要在 配置了 apply plugin: 'androidx.navigation.safeargs' 并且修改了就要重新 rebuild ，以便 系统帮你生成中间代码。 很多操作都是用鼠标可视化操作。 // 启用 Safe Args 后，该插件会生成代码 FragmentOneDirections ，规则是 你的fragment名字+ Directions NavDirections navDirections = FragmentOneDirections.actionFragmentOneToFragmentTwo(\"Tom\" ,\"标题2\") ; 其他的内容很容易理解，参考官网就行了。 Lifecycles Lifecyces 是一个生命可感知的组件。 LiveData 、 ViewModel 也依赖于 Lifecycle 框架。 如果不用 Lifecycles , 我们以前需要在 activity 的每个生命周期函数中进行监听。 使用了 Lifecycles ，可以在 activity 中注册一次， 即可监听到所有生命周期的回调，简化了代码。 def lifecycle_version = \"2.2.0\" implementation \"android.arch.lifecycle:runtime:$lifecycle_version\" implementation \"androidx.lifecycle:lifecycle-process:$lifecycle_version\" // 监听器 class MyLifecycleObserver implements LifecycleObserver { @OnLifecycleEvent(Lifecycle.Event.ON_CREATE ) // 还有其他 void onCreate() { // onCreate生命周期回调 } // Activity 注册监听 class MainActivity extends FragmentActivity implements LifecycleOwner { // Activity 好像监听不到，我测试失败。用 FragmentActivity AppCompatActivity 可以 LifecycleRegistry registry; registry = new LifecycleRegistry(this); // 注册 } // Application 注册监听 ProcessLifecycleOwner.get().getLifecycle().addObserver(new MyLifecycleObserver()); LiveData LiveData如同它的名字一样，是一个可观察的数据持有者， 和常规的observable不同，LiveData是具有生命周期感知的， 它能够在Activity、Fragment、Service中正确的处理生命周期。 当数据更新后，LiveData 就会通知它的所有观察者，比如Activiy。 但是 LiveData并不是通知所有观察者，它只会通知处于Active状态的观察者， 如果一个观察者处于Paused或Destroyed状态，它将不会收到通知。 所以我们可以安全地观察LiveData对象而不用担心内存泄漏的问题。 LiveData 代表 MVVM 模式最重要的思想，即数据驱动视图（也叫观察者模式、响应式等）。 LiveData 本质是 观察者模式 的体现 。 class MyLiveDataData extends LiveData ... class MyViewModel extends ViewModel { ... // 获得 ViewModel MyViewModel mMyViewModel = new ViewModelProvider.AndroidViewModelFactory( getApplication() ).create( MyViewModel.class); // LiveData 注册观察者 mMyViewModel.getDemoData().observe(this, new Observer() { @Override public void onChanged(MyLiveDataData myLiveDataData) { // 收到数据更新 } }); // 数据被更新 mMyViewModel.getDemoData().setTag1(123); // 或者直接使用 LiveData 的子类 MutableLiveData MutableLiveData mutableLiveData = new MutableLiveData<>(); mutableLiveData.observe(this, new Observer() { @Override public void onChanged(@Nullable final String s) { // 收到更新 } }); mutableLiveData.postValue(\"发送新数据\"); ViewModel ViewModel 的定义最早起源于前端，代表着 数据驱动视图 的思想。 在实际开发中我们通过观察数据的状态，来维护UI的自动更新，这就是 数据驱动视图（观察者模式）。 因为 MVVM 有截然不同的实现方式，这种百花齐放的代码风格、难以严格统一的 开发流派 导致代码质量的参差不齐，代码的可读性更是天差地别。 不同的项目、不同的依赖库加上不同的开发者， 最终代码中对于 状态管理 的实现方式都有很大的不同。 ViewModel 以注重生命周期的方式管理界面相关的数据。通常和DataBinding配合使用 。 基于以上不足，谷歌推出了 ViewModel ，它具有以下优点 1、 ViewMode l组件直接对 ViewModel 层进行了标准化的规范 2、更便于保存数据 当组件被销毁并重建后，原来组件相关的数据也会丢失(例如屏幕的旋转)，如果数据类型比较简单，同时数据量也不大， 可以通过onSaveInstanceState()存储数据，组件重建之后通过onCreate()，从中读取Bundle恢复数据。 但如果是大量数据， 则上述方法将不适用。 ViewModel 的扩展类则会在这种情况下自动保留其数据 3、更方便UI组件之间的通信 如果 ViewModel 的实例化作用域为Activity的生命周期， 则两个Fragment可以持有同一个ViewModel的实例，这意味着数据状态的共享。 那些 “重新获取的代价比较大” 的状态（例如通过网络请求到的 List 等数据，抛开 “费流量” 不说， https 请求本身涉及大量的加解密运算，耗费 CPU 资源，耗电显著）。 ViewModel 对象可以处理配置更改，因此无需担心旋转时或其他情况下的状态。 但是，如果需要处理系统发起的进程终止，则可以使用 onSaveInstanceState() 作为备用方式。 状态必须是简单的轻量级状态。对于复杂或大型数据，您应该使用本地持久性存储。 mMyViewModel = new ViewModelProvider.AndroidViewModelFactory( getApplication() ).create( MyViewModel.class); int oldValue = mMyViewModel.age; // ViewModel 会自动将数值存储，屏幕翻转之后数据不会丢失 // 注意 activity 标签需要配置这个 才会生效 android:configChanges=\"keyboardHidden|orientation|screenSize\" DataBinding (单向、双向数据绑定) DataBinding 顾名思义即为数据绑定，可以绑定数据和UI，还可以绑定事件 是 MVVM 模式在 Android 上的一种实现 。 Google在2015年IO大会上提出的 ，它的发布极大地促进了MVVM在Android领域的应用。 dataBinding { enabled = true // 开启dataBinding } // 代码中加载布局 binding = DataBindingUtil.setContentView(this, R.layout.activity_main); // ActivityMainBinding // 更新数据后，UI的数据会自动更新 binding.setUserName(\"tom\"+ (++age) ); ViewModel 是怎么实现双向数据绑定的 ViewModel 怎么实现自动处理生命周期 ViewModel 为什么在旋转屏幕后不会丢失状态 / 为什么可以在Activity销毁后保存数据 屏幕旋转时，activity被销毁重建了，存放在activity的数据也没有了。 ViewModel在配置更改期间能自动保留其对象，以便它们所持有的数据可立即用于下一个 Activity 或片段 Fragment Activity的生命周期不断变化，经历了被销毁重新创建，而ViewModel的生命周期没有发生变化。 ViewModel 的使用中有什么坑 ViewModel 在 Activity 初始化与在 Fragment中初始化，有什么区别 LiveData 是如何避免内存泄漏的 RxJava在使用过程中，避免内存泄漏是一个不可忽视的问题， 因此我们一般需要借助三方库比如RxLifecycle、AutoDispose来解决这个问题。 而反观LiveData，当它被我们的Activity订阅观察，这之后Activity如果finish()掉， LiveData 本身会自动“清理”以避免内存泄漏。 它的实现原理非常简单，其本质就是利用了Jetpack 架构组件中的另外一个成员 ,Lifecycle。 LiveData会绑定到 Lifecycle 对象，并在其关联的生命周期遭到销毁后进行自我清理。 ( no Copyright，enjoy youself ! ) all right reserved，powered by GitbookThe file was updated at : 2021-03-19 16:52:23 "},"chinese/数据结构/常用数据结构.html":{"url":"chinese/数据结构/常用数据结构.html","title":"基本算法","keywords":"","body":"Hash / Hash 碰撞 // Hash 是一种信息摘要算法，一般用于验证完整性， 它还叫做哈希、散列。 我们平时使用的 MD5 、SHA1 、SSL 中的公私钥验证都属于Hash算法。 // Hash碰撞 好的 Hash 算法可以出计算几乎出独一无二的 HashCode ， 如果出现了重复的 hashCode ，就称作碰撞; 不过就算是 MD5 这样优秀的算法也会发生碰撞。 Hashtable 哈希表 HashMap Hashtable 和 HashMap 的内部数据结构相似. HashMap 由数组+链表组成的，数组是 HashMap 的主体，链表则是主要为了解决哈希冲突而存在的。 HashMap 中的链表出现越少，性能才会越好。当链表较长时，又会引入红黑树来解决性能问题。 // HashMap存储的步骤put（K,V） 传入key和value，计算key的hash值，根据hash值搜索在哈希表table中的索引位置， 若当前索引位置不为null，则对该位置的Entry链表进行遍历， 如果链中存在该key，则用传入的value覆盖掉旧的value，同时把旧的value返回。 入股链中不存在该key，就用key-value创建一个新的节点，并把该节点插入到该索引对应的链表的头部 // HashMap 如何解决 Hash碰撞问题的 根据不同的key 计算得到 hash值，如果有碰撞，就进入当前hash值索引对应的 链表中， 在同一条链表中 根据 不同的 key 来存储不同的 value值。 // HashMap 的读取实现 get（key，value） 读取的步骤比较简单，调用 hash（key）求得key的hash值， 然后调用 indexFor（hash）求得hash值对应的 table 的索引位置， 然后遍历索引位置的链表， 如果存在 key ，则把 key 对应的 Entry 返回，否则返回 null . // HashMap键的遍历，keySet() HashMap遍历时，按哈希表的每一个索引的链表从上往下遍历。 // 缺点 1、在移动设备端内存资源很珍贵，HashMap 为实现快速查询带来了很大内存浪费。 2、HashMap 没有提供同步机制，是线程不安全的，需要自己写同步代码 。 HashMap / Hashtable 的区别 Hashtable 和 HashMap 的内部数据结构相似。 Hashtable 已经被淘汰了,不用关注太多细节。 知道以下几个区别就好了。 1、HashMap 可以允许 key 为 null，value 为 null，Hashtable 都不允许为null 。 2、HashMap 没有提供同步机制，是线程不安全的，需要自己在外面写同步代码， Hashtable 部分方法上有自己的 synchronize 同步，是线程安全的。 3、父类不一样，各自拥有的方法不完全一样，扩充机制不一样 。 ConcurrentHashMap ConcurrentHashMap 使用了分段锁。 访问 Hashtable 的所有线程都竞争同一把锁，所以效率低下。 而 ConcurrentHashMap 是容器里有多把锁， 每把锁用于锁容器中的一部分数据， 当多线程访问不同数据段时， 线程间就不会存在竞争， 从而提高并发访问效率。 ArrayMap ( 对HashMap 的优化 - 更省内存) ArrayMap 是 Android api 提供的 ， Android 里的 Bundle 内部就是 ArrayMap 。 ArrayMap 有两个数组 。 第一个数组存放存放 item 的 hash 值， 第二数组是把 key 和 value 连续的存放在数组里， 通过先算 hash 在第一个数组里找到它的 hash index， 然后 根据这个index在去第二个数组里找到这个 key 和 value 。 // ArrayMap 如何解决哈希碰撞问题的。（以下结论是我猜测的） 1、存储 如果产生了相同的哈希值了，如果他的key是相同的，就把key对应的value修改。 如果 key 不同，就会把当前哈希值也保存在哈希数组中 (此时数组中有相同的哈希值)。 2、读取 由于存在 hash 碰撞的情况，而二分法查找到下标可能是多个连续相同hash值中的任意一个， 所以此时需要用equals比对对命中的Key对象是否相符， 不相符时，从当前index先向后再向前遍历所有相同hash。 3、注意比较 与 HashMap解决哈希冲突方法的区别。 // 比 HashMap 更省内存。 ArrayMap 相对于 HashMap ， 无需为每个键值对创建 Node对象， 这就是为什么ArrayMap相对HashMap要节省空间。 // 缺点 1、ArrayMap 查找时间复杂度O(logN)；HashMap查找、修改的时间复杂度为O(1)； 2、ArrayMap 增加、删除操作需要移动成员，速度相比较慢 。 3、ArrayMap 也没有提供同步机制，是线程不安全的，需要自己在外面写同步代码 。 SparseArray ( 对 HashMap 的优化 - 更省内存) 在 Android 中，IDE 会提醒我们应该使用 SparseArray 替换掉 HashMap， 其根本原因就在于 SparseArray 相比较 HashMap 会更省内存。 // 更省内存 1、SparseArray 对应的key只能是int类型， 它不会对key进行装箱操作。 所以比 HashMap 更省内存。 2、SparseArray 不需要保存key所对应的哈希值，所以比 ArrayMap 更省内存。 // SparseArray 的 延迟回收 机制 当执行delete()或者removeAt()删除数据的操作， 只是将相应位置的数据标记为DELETE，并设置mGarbage=true， 而不会直接执行数据拷贝移动的操作。 比如删除某个数据后被标记删除，接着又需要在相同位置插入数据， 则不需要任何数组元素的来回移动操作。 所以SparseArray适合频繁删除和插入来回执行的场景。 栈 结构 手写代码实现一个栈。 1、用数组实现 通过移动下标来模拟。 2、使用系统的 LinkedList 来实现。 Deque queue = new LinkedList(); queue.addFirst(e); queue.removeFirst(); 3、自己模拟单链表 实现栈 。 sample没有考虑线程安全等细节，只是简洁地展示关键思想 // 栈节点 public class Node{ public Object data;/**数据*/ public Node next ;/**下一个节点*/ public Node(Object data ,Node next) { this.data=data ; this.next =next; } } public class MyStack{ /**栈顶节点*/ private Node topNode ; /**栈大小*/ public int stackSize; // 入栈 public void push(Object data){ Node newNode = new Node(data, topNode);//新节点 topNode= newNode ; //对外公布 新栈顶元素 stackSize++ ; } // 出栈 public void pop() { Node temp= topNode ;//需要出栈的节点 topNode = temp.next ;//对外公布 新的栈顶元素 stackSize-- ; } /**打印该栈所有元素*/ public void showStackInfo() { Node temp =topNode ; if(temp==null) { System.out.println(\"空栈\"); return ; } while(temp !=null ) { System.out.println(\"栈节点值=\"+ temp.data); temp = temp.next; } } } // 测试 public static void main(String[] args){ MyStack myStack = new MyStack(); myStack.showStackInfo(); myStack.push(1) ; myStack.push(2) ; myStack.showStackInfo(); myStack.pop(); myStack.showStackInfo(); } 队列 结构 队列的特点是“先进先出”。 阻塞队列 阻塞队列与普通队列的区别在于： 当阻塞队列为空时，从队列中获取元素的操作将会被阻塞， 或者当队列是满时，往队列里添加元素会被阻塞。 阻塞双端队列 指允许两端都可以进行入队和出队操作的阻塞队列。 常用队列 特点 常用方法 安全性 LinkedBlockingQueue 基于链表的单向队列 线程安全 LinkedBlockingDeque 基于链表的双端队列 interface BlockingQueue extends Queue ... interface BlockingDeque extends BlockingQueue , Deque {... class LinkedBlockingDeque ... implements BlockingDeque {... class LinkedBlockingQueue implements BlockingQueue... ( no Copyright，enjoy youself ! ) all right reserved，powered by GitbookThe file was updated at : 2021-07-21 17:01:27 "},"chinese/常用算法/算法术语.html":{"url":"chinese/常用算法/算法术语.html","title":"算法术语","keywords":"","body":"算法术语 时间复杂度 在数据结构中,每个算法有他的时间复杂度 , 用O（）表示。括号里面是通过算法求出来的时间复杂度 , n*n 是n的平方，如果求出来是n*n+n 这时它的时间复杂度还是 0（n*n）, 因为规定时间复杂度是取它的最高次幂 递归 相同的结构层级嵌套，自我调用的过程。 迭代 迭代就像是操场永不回头的跑圈，不断利用相同的优化过程将输出作为新的输入，使问题推进到一个个里程碑，直到符合答案的要求。 计算1+2+3+…+n, sum1是递归, sum2是迭代. function sum1(n){ if (n == 0) { return 0; } else { return n + sum1(n - 1); } } function sum2(n){ var result = 0; for (var i = 1; i ( no Copyright，enjoy youself ! ) all right reserved，powered by GitbookThe file was updated at : 2020-08-19 17:20:00 "},"chinese/常用算法/排序算法.html":{"url":"chinese/常用算法/排序算法.html","title":"排序算法","keywords":"","body":"排序算法 冒泡排序 核心思想是\"冒泡\"。 最后的效果是第一个最小，最后一个最大，沉在最下。 一次比较 可以让数值中最小的那个值冒出来。 然后依次比较，直到完成。 /** * int[] array = { 7, 3, 10, 0, 6 , 0 ,-56 }; * 冒泡排序 */ public static int[] sortBubble(int[] array){ //外层for 确定 排序趟次 for ( int i = 0 ; i i ; j--) { int temp; //将小的值往前移动 if(array[j] 归并排序 、合并排序 合并排序体现了分治思想 递归“分” 递归“分”的终止条件是“只剩下一个元素” 。 因为一个元素认为它有序 。 有序元素的“合” 先比一下 A指针 和 B指针 指向的两个元素谁比较小一点，然后把比较小的元素（此时假设A指针指向的元素小）放到C指针指的位置上。 A往前挪，C 往前挪 。然后继续比较A指针和B指针的两个元素。 合并排序缺点 需要额外的空间辅助。 /** * 归并 排序。 升序 */ public static void mergeSort(int[]array , int start , int end){ if(start>=end){ //递归终止条件 return ; }else{ int mid = (start + end )/2 ; //递归处理左边 mergeSort(array , start ,mid); //递归处理右边 mergeSort(array ,mid+1 ,end); //合并 排序好的左右 mergeAction(array ,start ,mid ,end); } } public static void mergeAction(int[]arr ,int start ,int mid , int end ){ //辅助数组空间 并不是 int[] tempArr = new int[arr.lengh] int[] tempArr = new int[end - start + 1]; //左数组的下标 int ptrA = start; //右数组的下标 int ptrB = mid +1; //辅助数组的下标 int ptrC=0; //循环比较，直至有一个区间被取完 while (ptrA 快速排序 之所以说它是快速的原因，不是因为它比其他的排序算法都要快。 而是从实践中证明了快速排序在平均性能上的确是比其他算法要快一些 。 找一个基准元素，对数组进行调整， 调整的标准是，这个基准元素的左边存放的都是比这个元素小的，右边都是比这个元素大的。 然后分而治之，对左右两边的子数组利用同样的规则调整，调整到每一个子数组中都只有一个元素时结束。 （快排体现了分而治之的思想，一步步地把问题变小，最终解决。） 快排的理解 快排有多种理解角度，个人觉得从“挖坑填坑”的角度比较容易理解。 /**最基础的 快速排序*/ public void quickSort(int[] array, int left , int right){ if(left = base){ right-- ; } //找到坑值，填坑 array[left] = array[right] ; //从左边开始寻找坑值 while (left 选择排序 选择排序的思想：就是不断地从未排序的元素中选择最大（或最小）的元素放入已排好序的元素集合中，直到未排序中仅剩一个元素为止 。 选择排序 和冒泡排序有点类似，都是在一次排序后把最大(最小)的元素放到最前面。但是过程不同，冒泡排序是通过相邻的比较和交换。而选择排序是通过对整体的选择。 选择排序 可以看成 冒泡排序 的优化，只有在确定了最小数的前提下才进行交换，大大减少了交换的次数。 选择排序关键点 1、有序区间 、 无序区间 2、如何选出最大（/最小）元素 /** * 选择排序 升序 */ public static int [] sortSelect(int [] array){ int length = array.length; for(int i=0 ;i array[k]){ minPos=k ; } } //将当前趟次的结果放到 有序区间 if(array[minPos] ( no Copyright，enjoy youself ! ) all right reserved，powered by GitbookThe file was updated at : 2021-06-09 11:28:53 "},"chinese/常用算法/查找算法.html":{"url":"chinese/常用算法/查找算法.html","title":"查找算法","keywords":"","body":"查找算法 二分查找 、折半查找 前提：数组是 排好序的。 （升序、降序都可以） 越界异常 int middle = (low+high)/2 // 错误写法 int middle = low + (high - low) / 2; // 正确写法 low 和 high 都是整形，当你的low和high很大的时候， low+high 就会产生溢出，low+high 的结果就会变为负数，数组越界了。 /** * @param array 升序 数组 * @param key 需要查找的值 */ public static int binarySearch(int[] array, int key) { int low = 0; int high = array.length - 1; while (low key) { high = middle - 1; } else if (array[middle] 顺序查找 优点： 算法简单 、 对线性链表也适用 缺点： 慢 public static int SequenceSearch(int[] array, int key){ int length = array.length ; for (int i=0 ;i ( no Copyright，enjoy youself ! ) all right reserved，powered by GitbookThe file was updated at : 2020-08-19 17:20:00 "},"chinese/常用算法/大数相加.html":{"url":"chinese/常用算法/大数相加.html","title":"大数相加","keywords":"","body":"大数相加 如果利用java的 API ，就非常简单。 BigInteger value1= new BigInteger(\"-11\") ; BigInteger value2= new BigInteger(\"-11\"); BigInteger reslut = value1.subtract(value2) ; ( no Copyright，enjoy youself ! ) all right reserved，powered by GitbookThe file was updated at : 2020-09-15 16:00:11 "},"chinese/常用算法/集合的所有子集.html":{"url":"chinese/常用算法/集合的所有子集.html","title":"获得集合的所有子集","keywords":"","body":"获得集合的所有子集 思想比较巧妙。 集合A={a,b,c}中的元素在每个子集中，要么存在，要么不存在。 映射关系： (1,1,1)->(a,b,c) --> 7 (1,1,0)->(a,b) --> 6 (1,0,1)->(a,c) --> 5 (1,0,0)->(a) --> 4 (0,1,1)->(b,c) --> 3 (0,1,0)->(b) --> 2 (0,0,1)->(c) --> 1 (0,0,0)->(空集) --> 0 public static void GetPowerSet(int nArray[] ) { // 一共多少种组合 0 ,1, 2 ... n-1 int end = 1 ( no Copyright，enjoy youself ! ) all right reserved，powered by GitbookThe file was updated at : 2020-08-19 17:20:00 "},"chinese/常用算法/扫描线种子填充算法.html":{"url":"chinese/常用算法/扫描线种子填充算法.html","title":"扫描线种子填充算法","keywords":"","body":"扫描线种子填充算法 一般用来 填充不规则多边形 该算法并不完美，对图片有要求，识别的也不是很精准 ，而且有锯齿。 ColourImageView.java public class ColourImageView extends ImageView { private Bitmap mBitmap; private Paint mPaint ; /** * 边界的颜色 */ private int mBorderColor = -1; private boolean hasBorderColor = false; private ImageTool imageTool; public ColourImageView(Context context, AttributeSet attrs) { super(context, attrs); imageTool = new ImageTool(mBorderColor, hasBorderColor ); mPaint = new Paint(); mPaint.setColor(Color.RED); } @Override protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) { super.onMeasure(widthMeasureSpec, heightMeasureSpec); // 规定让图片按比例显示 int viewWidth = getMeasuredWidth(); setMeasuredDimension(viewWidth, getDrawable().getIntrinsicHeight() * viewWidth / getDrawable().getIntrinsicWidth()); if (mBitmap == null) { Bitmap bm = ((BitmapDrawable) getDrawable()).getBitmap(); mBitmap = Bitmap.createScaledBitmap(bm, getMeasuredWidth(), getMeasuredHeight(), false); } } private int touchX ; private int touchY ; @Override public boolean onTouchEvent(MotionEvent event) { touchX = (int) event.getX(); touchY = (int) event.getY(); if (event.getAction() == MotionEvent.ACTION_DOWN) { fillColorToSameArea( ); } return super.onTouchEvent(event); } /** * 以触摸点为种子点 进行填充 */ private void fillColorToSameArea( ) { int bitmapWidth ; int bitmapHeight ; int[] pixels ; int currentTouchPixel ; currentTouchPixel = mBitmap.getPixel(touchX, touchY); if (currentTouchPixel == Color.TRANSPARENT || (hasBorderColor && mBorderColor == currentTouchPixel)) { return; } bitmapWidth = mBitmap.getWidth(); bitmapHeight = mBitmap.getHeight(); pixels = new int[bitmapWidth * bitmapHeight]; mBitmap.getPixels(pixels, 0, bitmapWidth, 0, 0, bitmapWidth, bitmapHeight); int newColor = randomColor(); //填色 imageTool.fillColor(pixels, bitmapWidth, bitmapHeight, currentTouchPixel, newColor,touchX, touchY); //重新设置bitmap mBitmap.setPixels(pixels, 0, bitmapWidth, 0, 0, bitmapWidth, bitmapHeight); setImageBitmap(mBitmap); invalidate(); } @Override protected void onDraw(Canvas canvas) { super.onDraw(canvas); canvas.drawCircle(touchX ,touchY ,10 ,mPaint); } /** * 返回一个随机颜色 */ private int randomColor() { Random random = new Random(); int color = Color.argb(255, random.nextInt(256), random.nextInt(256), random.nextInt(256)); return color; } } ImageTool.java public class ImageTool { private Stack mStacks = new Stack<>(); private int mBorderColor = -1; private boolean hasBorderColor = false; public ImageTool( int mBorderColor ,boolean hasBorderColor ){ this.mBorderColor = mBorderColor ; this.hasBorderColor= hasBorderColor ; } /** * @param pixels 像素数组 * @param currentTouchPixel 当前触摸点的 颜色 * @param newColor 填充色 */ public void fillColor(int[] pixels, int bitmapWidth, int bitmapHeight, int currentTouchPixel, int newColor, int x, int y) { //步骤1：将种子点(x, y)入栈； mStacks.push(new Point(x, y)); //步骤2：判断栈是否为空， // 如果栈为空则结束算法，否则取出栈顶元素作为当前扫描线的种子点(x, y)， // y是当前的扫描线； while (!mStacks.isEmpty()) { /* * 步骤3：从种子点(x, y)出发，沿当前扫描线向左、右两个方向填充，直到边界。 * 分别标记区段的左、右端点坐标为xLeft和xRight */ Point seed = mStacks.pop(); int count = fillLineLeft(pixels, currentTouchPixel, bitmapWidth, newColor, seed.x, seed.y); int left = seed.x - count + 1; count = fillLineRight(pixels, currentTouchPixel, bitmapWidth, newColor, seed.x + 1, seed.y); int right = seed.x + count; //从y-1找种子 if (seed.y - 1 >= 0){ findSeedInNewLine(pixels, currentTouchPixel, bitmapWidth, seed.y - 1, left, right); } //从y+1找种子 if (seed.y + 1 = 0) { int index = y * bitmapWidth + x; if (needFillPixel(pixels, pixel, index)) { pixels[index] = newColor; count++; x--; } else { break; } } return count; } /** * 往右填色，返回填充的个数 */ private int fillLineRight(int[] pixels, int currentTouchPixel, int bitmapWidth, int newColor, int x, int y) { int count = 0; while (x 0xFFBBBBBB ; // 直接跟当前pixel比较，有较明显的锯齿，原因不明 //return pixels[index] > pixel ; } } /** * 在新行找种子节点 */ private void findSeedInNewLine(int[] pixels, int currentTouchPixel, int bitmapWidth, int indexY, int left, int right) { // 获得该行的开始索引 int begin = indexY * bitmapWidth + left; // 获得该行的结束索引 int end = indexY * bitmapWidth + right; boolean hasSeed = false; int newSeedIndexX ; while (end >= begin) { if (pixels[end] == currentTouchPixel) { if (!hasSeed) { newSeedIndexX = end % bitmapWidth; mStacks.push(new Point(newSeedIndexX, indexY)); hasSeed = true; } } else { hasSeed = false; } end--; } } } ( no Copyright，enjoy youself ! ) all right reserved，powered by GitbookThe file was updated at : 2020-08-19 17:20:00 "},"chinese/常用算法/其他算法.html":{"url":"chinese/常用算法/其他算法.html","title":"其他算法","keywords":"","body":"让三个线程按照顺序依次打印 1-100 ， 几个线程轮流打印。 如何让n个线程循环交替打印 思路1 synchronized + wait + notifyAll 思路就是通过锁机制 private static final Object lockObj = new Object(); private static volatile int printInt = 1; public static void main(String[] args) { Thread threadFirst = new Thread(new Runnable() { @Override public void run() { synchronized (lockObj) { while (printInt 思路2 休眠+ 条件判断 public class PrintRunnable implements Runnable{ private static int printValut =1; /** * 下一个将要打印的线程序号, * 用来确保线程 是按照 0 ，1 ，2 顺序来执行的 */ private static volatile int nextPrintSeq =0; private static Lock lock=new ReentrantLock(); /** * 当前线程序号 */ private int seq; /** * 线程总数 */ private int nThread; PrintRunnable(int seq, int nThread) { this.seq = seq; this.nThread=nThread; } @Override public void run() { final int MAXVALUE =100 ; while(printValut 删除数组中的重复元素 数组去重 给定 nums = [0,0,1,1,1,2,2,3,3,4], 函数应该返回新的长度 5, 并且原数组 nums 的前五个元素被修改为 0, 1, 2, 3, 4。 你不需要考虑数组中超出新长度后面的元素。 思路：定义两个指针，将数组看做两个部分，将前面部分与后面部分进行比较， 如果发现不同，就将后面的不同项拷贝到前面。 根据示意图和打印过程，很容易理解 public static void main(String[] args) { int[] values = {0, 0, 0, 0, 0, 2, 2 ,3}; int size = removeDuplicates1(values); System.out.print(\"\\r\\n有效数字长度=\"+size +\" -->\"); for(int value : values){ System.out.print( \" \"+value); } } private static int removeDuplicates1(int[] nums) { if(nums.length == 0) { return 0; } int indexA = 0; for(int indexB = 1; indexB \"+indexA+\" \"+indexB ); if(nums[indexA] != nums[indexB]){ System.out.print(\"值不同-->\"+nums[indexA]+\" \"+nums[indexB] +\" 需要修改\"); indexA++; nums[indexA] = nums[indexB]; }else{ System.out.print(\"值相同-->\"+nums[indexA]+\" \"+nums[indexB] +\" 忽略本轮\"); } showArray(nums); } //循环结束之后，indexA是索引，数组的长度要+1 return indexA + 1; } private static void showArray(int[] values ){ System.out.println(); for(int value : values){ System.out.print(value+\" \"); } System.out.println(); } 0 0 0 0 0 2 2 3 本轮索引-->0 1值相同-->0 0 忽略本轮 0 0 0 0 0 2 2 3 0 0 0 0 0 2 2 3 本轮索引-->0 2值相同-->0 0 忽略本轮 0 0 0 0 0 2 2 3 0 0 0 0 0 2 2 3 本轮索引-->0 3值相同-->0 0 忽略本轮 0 0 0 0 0 2 2 3 0 0 0 0 0 2 2 3 本轮索引-->0 4值相同-->0 0 忽略本轮 0 0 0 0 0 2 2 3 0 0 0 0 0 2 2 3 本轮索引-->0 5值不同-->0 2 需要修改 0 2 0 0 0 2 2 3 0 2 0 0 0 2 2 3 本轮索引-->1 6值相同-->2 2 忽略本轮 0 2 0 0 0 2 2 3 0 2 0 0 0 2 2 3 本轮索引-->1 7值不同-->2 3 需要修改 0 2 3 0 0 2 2 3 有效数字长度=3 --> 0 2 3 0 0 2 2 3 反转数组 例如原数组为：{\"a\",\"b\",\"c\",\"d\"},那么翻转后的数组为 {\"d\",\"c\",\"b\",\"a\"}。 void reverseArray(int[] array){ for (int i = 0, max = array.length - 1; i 生产者消息者模型 生产者和消费者问题是线程模型中的经典问题： 生产者和消费者在同一时间段内共用同一个存储空间， 生产者往存储空间中添加产品，消费者从存储空间中取走产品， 当存储空间为空时，消费者阻塞，当存储空间满时，生产者阻塞。 方式1 synchronized + object.wait() + object.notifyAll() - 原理 public static void main(String[] args) { // 所有的生产者+消费者线程都争抢这一把锁 Object lock =new Object(); // 存放产品的缓冲区 List linkedList = new ArrayList<>(); for (int i = 0; i list; private int maxLength; private final Object lock ; private static boolean isRunning = true ; Productor(List list, int maxLength , Object lock) { this.list = list; this.maxLength = maxLength; this.lock = lock; } @Override public void run() { while (isRunning) { synchronized (lock) { try { while (list.size() >= maxLength) { System.out.println(Thread.currentThread().getName() + \" 队列已满，进行wait。\"+list.size()); lock.wait(); System.out.println(Thread.currentThread().getName() + \" 退出wait\"); } int i = getRadomInt(0 ,100); System.out.println( Thread.currentThread().getName() + \" 生产了数据: \" + i); list.add(i); lock.notifyAll(); Thread.sleep(500); } catch (InterruptedException e) { e.printStackTrace(); } } } } private int getRadomInt(int startNum, int endNum){ return new Random().nextInt(endNum - startNum + 1) + startNum; } } public class Consumer implements Runnable { private final Object lock ; private static boolean isRunning = true ; private List list; Consumer(List list ,Object lock) { this.list = list; this.lock = lock; } @Override public void run() { while (isRunning) { synchronized (lock) { try { while (list.isEmpty()) { System.out.println(Thread.currentThread().getName() + \" 数据不足，进行wait\"); lock.wait(); System.out.println(Thread.currentThread().getName() + \" 数据充足,退出wait\"); } Integer element = list.remove(0); System.out.println(Thread.currentThread().getName() + \" 消费了数据：\" + element+\" 数据剩余个数=\"+list.size()); lock.notifyAll(); Thread.sleep(500); } catch (InterruptedException e) { e.printStackTrace(); } } } } } 方式2 封装工具 BlockingQueue -生产环境 BlockingQueue 内部提供了线程安全的队列访问方式， 使我们不需要手动去操作 wait 和 notifyAll 等细节。 BlockingQueue queue = new LinkedBlockingQueue<>(); while (true) { Random random = new Random(); int i = random.nextInt(); System.out.println(\"生产者\" + Thread.currentThread().getName() + \"生产数据\" + i); queue.put(i); // Thread.sleep(1000); } while (true) { Integer element = (Integer) queue.take(); System.out.println(\"消费者\" + Thread.currentThread().getName() + \"正在消费数据\" + element); Thread.sleep(1000); } 斐波那契数列、青蛙跳台阶 斐波那契数列 斐波那契数列指的是这样一个数列：1、1、2、3、5、8、13、21 ... F(1)=1，F(2)=1, F(n)=F(n-1)+F(n-2)（n>=3，n∈N*） 从第3项开始，每一项都等于前两项之和。 简单青蛙跳台阶 一只青蛙一次可以跳上1级台阶，也可以跳上2级。 求该青蛙跳上一个n级的台阶总共有多少种跳法。 可以发现这个相当于变相的斐波那契数列。 思路：假如有5级台阶，青蛙要么直接从4级上跳一格上来，要么从3级上跳两格上来，没有别的方式了， 因此青蛙只要关心跳到4级的总方法数和跳到三级的总方法数。 // 递归方式(效率不如非递归) private static long jumpFloor(int n) { if (n 变态青蛙跳台阶 一只青蛙一次可以跳1阶，2阶…n阶。 求该青蛙跳上一个n 级的台阶总共有多少种跳法 数学分析过程： 将 n 级台阶的跳法记为 f(n)。 n = 1 时， 跳法只有 1 种，记为 f(1)； n = 2 时， 可以先跳 1 级，然后有 f(1) 种跳法； 或者直接跳 2 级，这是 1 种跳法； 共计 f(2) = f(1)+1； n = 3 时， 可以先跳 1 级， 然后有 f(3-1) 种跳法，即 f(2) 种； 或者先跳 2 级，然后有 f(3-2) 种跳法，即 f(1) 种； 或者直接跳 3 级，这是 1 种跳法；； 共计 f(3) = f(2) + f(1) + 1 种； n 级台阶，共有 f(n) = f(n-1) + f(n-2) + … + f(1) + 1 种； n-1 级台阶，共有 f(n-1) = f(n-2) + … + f(1) + 1 种； 两个等式相减，得到： f(n) - f(n-1) = f(n-1) 即 f(n) = 2*f(n-1) // 递归方式(效率不如非递归) public static int jumpFloorBT(int n) { if (n ( no Copyright，enjoy youself ! ) all right reserved，powered by GitbookThe file was updated at : 2021-06-09 11:19:06 "},"chinese/java基础/原码补码反码.html":{"url":"chinese/java基础/原码补码反码.html","title":"Java部分","keywords":"","body":"原码补码反码 类型 正数规则 负数规则 原码 0表示正号，1表示负号，后面是数值部分 跟正数一样 反码 与原码相同 原码的符号位不变，其它位取反 补码 与原码相同 反码+1 加法运算 只能通过 补码来运算，因为通过原码不能保证所有的计算都是正确的。 例如 ： 6+（-3） 补码存在的意义 因为采用原码或反码 进行 减法运算 ，并不能保证结果正确。 为了保证计算正确， 因此设计了补码的规则 。 至于为什么采用这样的设计就能保证结果正确。请查阅其他资料。 ( no Copyright，enjoy youself ! ) all right reserved，powered by GitbookThe file was updated at : 2021-01-19 10:23:57 "},"chinese/java基础/java常用代码.html":{"url":"chinese/java基础/java常用代码.html","title":"java常用代码","keywords":"","body":"java常用代码 java get 访问 用来简单获取一下数据，测试一下服务器代码。 public static String get(String url) throws Exception { String content = null; URLConnection urlConnection = new URL(url).openConnection(); HttpURLConnection connection = (HttpURLConnection) urlConnection; connection.setRequestMethod(\"GET\"); connection.connect(); int responseCode = connection.getResponseCode(); if (responseCode == HttpURLConnection.HTTP_OK) { BufferedReader bufferedReader = new BufferedReader(new InputStreamReader (connection.getInputStream(), StandardCharsets.UTF_8)); StringBuilder bs = new StringBuilder(); String l; while ((l = bufferedReader.readLine()) != null) { bs.append(l).append(\"\\n\"); } content = bs.toString(); } return content; } ( no Copyright，enjoy youself ! ) all right reserved，powered by GitbookThe file was updated at : 2021-08-18 14:52:58 "},"chinese/java基础/JVM详解.html":{"url":"chinese/java基础/JVM详解.html","title":"JVM详解","keywords":"","body":"JVM JVM 是 Java Virtual Machine (Java 虚拟机 ) 的缩写， 是指负责将字节码解释成为特定的机器码进行运行。 Java源程序需要通过编译器编译为 .class 文件，才能被 JVM 识别。 JRE 字节码将由 JRE (Java运行时环境) 执行。 JRE是Java虚拟机(JVM)的一个实现，它可以分析字节码、解释代码并执行它。 Java 字节码 通俗来讲，字节码就是经过 javac 命令编译之后生成的 class 文件。 class文件包含了 Java 虚拟机指令集和符号表以及若干其他的辅助信息。 字节码结构 cafe babe 0000 0034 001d 0a00 0600 0f09 0010 0011 0800 120a 0013 0014 0700 1507 0016 0100 063c 696e 6974 3e01 0003 2829 5601 0004 436f 6465 0100 0f4c 696e 654e 756d 6265 7254 6162 6c65 0100 046d 6169 6e01 0016 285b 4c6a 6176 612f 6c61 6e67 2f53 7472 696e 673b 2956 0100 0a53 6f75 7263 6546 696c 6501 0009 4465 6d6f 2e6a 整个字节码文件本质上就是一张表，它由下面几个部分组成 。 便于理解，可以将一个完整的表划分为以下七个部分， 这七个部分组成了一个完整的 Class 字节码文件： 魔数与Class文件版本 常量池 访问标志 类索引、父类索引、接口索引 字段表集合 方法表集合 属性表集合 可以用 javap 命令反编译字节码，查看相关信息 例如 javap -verbose Hello.class -help --help -? 输出此用法消息 -version 版本信息 -v -verbose 输出附加信息 -l 输出行号和本地变量表 -public 仅显示公共类和成员 -protected 显示受保护的/公共类和成员 -package 显示程序包/受保护的/公共类 和成员 (默认) -p -private 显示所有类和成员 -c 对代码进行反汇编 -s 输出内部类型签名 -sysinfo 显示正在处理的类的 系统信息 (路径, 大小, 日期, MD5 散列) -constants 显示最终常量 -classpath 指定查找用户类文件的位置 -cp 指定查找用户类文件的位置 -bootclasspath 覆盖引导类文件的位置 字节码查看工具 1、jol-cli ClassLayout 第三方工具 2、 javap -v xxx // xxx 是 class 文件 （貌似是信息最全面的） 3、jclasslib ( Androidstudio 插件 ) https://github.com/ingokegel/jclasslib ASM Bytecode Outline ，ASM 字节码查看工具 在使用 ASM 插入字节码代码时、如果不熟悉字节码相关语法和规则 , 可能对于插入 字节码代码 就束手无策了、 ASM官方开发了一款IDE插件，可以将 Java代码 转换成 ASM 字节码类型代码， 这样再使用 ASM 插入字节码时就比较方便了。 JVM 架构 JVM 分为三个主要子系统 ：类加载子系统 、运行时数据区 、执行引擎 类加载子系统 Java的动态类加载功能由 类加载子系统 处理。 加载、链接、初始化。并在运行时(而不是编译时)首次引用类时初始化类文件。 加载 ClassLoader 在加载类文件时将遵循委托层次算法。 BootStrap ClassLoader 负责从引导类路径中加载类，仅用于rt.jar。最高优先级将给予此加载程序。 Extension ClassLoader 负责加载ext文件夹（jre \\ lib）内的类。 Application ClassLoader 负责加载应用程序级别的类路径，提到的环境变量路径等。 链接 // 验证 字节码验证程序将验证生成的字节码是否正确，如果验证失败，我们将收到验证错误。 // 准备 将为所有静态变量分配内存并为其分配默认值。 // 解决 将所有符号内存引用替换为“方法区域”中的原始引用。 初始化 所有静态变量将被分配原始值，并且将执行静态块。 运行时数据区 运行时数据区域主要分为五个区域。 程序计数器、Java 虚拟机栈 、本地方法栈 是线程私有的 ， 堆、方法区 是线程共享的。 程序计数器 PC寄存器 (程序计数器) 每个线程将具有单独的PC寄存器，以在执行指令后保存当前执行指令的地址， PC寄存器将用下一条指令进行更新。 方法区 每个JVM只有一个方法区域，它是共享资源。 方法区用于存储已被虚拟机加载的 类级别信息、常量、静态变量、即时编译器编译后的代码缓存等数据。 在 JDK 6 的 时候 HotSpot 开发团队就有放弃永久代，逐步改为采用 本地内存 来实现方法区的计划了， 到了JDK 7 的 HotSpot，已经把原本放在永久代的字符串常量池、静态变量等移出， 而到了 JDK 8，终于完全废弃了永久代的概念，改用与 JRockit、J9 一样在本地内存中实现的元空间(Metaspace)来代替， 把JDK 7中永久代还剩余的内容(主要是类型信息)全部移到元空间中。 不要将方法区和永久代混为一谈，从JDK 8 以后已经没有永久代的概念了。 运行时常量池 是方法区的一部分。 Class 文件中除了有类的版本、字段、方法、接口等描述信息外， 还有一项信息是常量池表 (Constant Pool Table)， 用于存放编译期生成的各种字面量与符号引用， 这部分内容将在类加载后存放到方法区的运行时常量池中。 常量池是为了避免频繁的创建和销毁对象而影响系统性能，其实现了对象的共享。 堆区 所有对象及其对应的实例变量和数组将存储在此处。 由于“方法”和“堆”区域共享多个线程的内存， 因此存储的数据不是线程安全的。 Java虚拟机栈 Java虚拟机栈 是线程私有的，它的生命周期与线程相同。 虚拟机栈描述的是 Java 方法执行的线程内存模型。 每个方法被执行的时候，Java 虚拟机都 会同步创建一个 栈帧 用于存储局部变量表、操作数栈、动态连接、方法出口等信息。 每一个方法被调用直至执行完毕的过程，就对应着一个栈帧在虚拟机栈中从入栈到出栈的过程。 // 局部变量表 存放了编译期可知的各种Java虚拟机基本数据类型、对象引用、和 returnAddress 类型(指向了一条字节码指令的地址)。 // 操作数栈 如果需要执行任何中间操作，则操作数堆栈充当执行该操作的运行时工作区。 // 动态连接 每个栈帧中包含一个在常量池中对当前方法的引用， 目的是支持方法调用过程的动态连接。 // 方法出口 无论何种退出情况，都将返回至方法当前被调用的位置。方法退出的过程相当于弹出当前栈帧。 本机方法堆栈 本机方法堆栈保存本机方法信息。对于每个线程，将创建一个单独的本机方法堆栈。 执行引擎 分配给运行时数据区的字节码将由执行引擎执行。 执行引擎读取字节码并逐段执行。 解释器 Interpreter 计算机只认识0和1，任何编程语言的代码最终都要转化成 机器码(二进制代码) 才能执行， 解释器的工作是将编译得到的字节码再转化成机器码，然后才能执行。 Java 正是因为边解释边执行的特点， 在执行时才会慢于 C++ 之类的编译型语言。 即时编译器 、JIT Compiler，just-in-time compiler 为了弥补解释执行带来的速度劣势，JVM 引入了即时编译器， 它的作用就是把热点代码，比如重复调用的方法和循环代码等， 编译成机器码并存放在 code cache 中， 这样之后再用到这些代码就不用重新解释执行了，可以提高程序运行效率。 // 中间代码生成器 产生中间代码。 // 代码优化器 负责优化上面生成的中间代码。 // 目标代码生成器 负责生成机器代码或本机代码。 Profiler 个特殊的组件，负责查找热点，即是否多次调用该方法。 垃圾收集器 程序员可以不用手动释放内存，全是垃圾收集器的功劳。 当然可以通过调用System.gc() 来触发垃圾回收，但是不能保证马上被回收。 Java本地接口库 、JNI JNI将与本机方法库进行交互，并提供执行引擎所需的本机库。 本机方法库 这是本机库的集合，这是执行引擎所需的。 一般是计算机本地的 C 或 C++ 库。 ( no Copyright，enjoy youself ! ) all right reserved，powered by GitbookThe file was updated at : 2021-05-28 10:52:42 "},"chinese/java基础/类加载机制.html":{"url":"chinese/java基础/类加载机制.html","title":"类加载机制","keywords":"","body":"类的生命周期 java类加载器分类 从虚拟机层面角度分类 从虚拟机层面角度讲,分为两大类型的类加载器。 一是 Bootstrap Classloader ，即启动类加载器（C++实现），它是虚拟机的一部分， 二是其他类型类加载器（JAVA实现），在虚拟机外部，并全部继承 ClassLoader 类。 从加载顺序角度来分类 Bootstrap ClassLoader 主要负责加载JVM自身工作所需要的类。 是由C/C++编写的，它本身是虚拟机的一部分，它并不是一个JAVA类，无法在java代码中获取它的引用。 所以getClass().getName()返回null。 System.out.println(System.getProperty(\"sun.boot.class.path\")); xxx\\jre\\lib\\resources.jar; xxx\\jre\\lib\\rt.jar; xxx\\jre\\lib\\sunrsasign.jar; xxx\\jre\\lib\\jsse.jar; xxx\\jre\\lib\\jce.jar; xxx\\jre\\lib\\charsets.jar; xxx\\jre\\lib\\jfr.jar; xxx\\jre\\classes ExtClassLoader 负责装载JRE扩展目录ext下的jar类包。一般为JVM平台扩展工具。 System.out.println(System.getProperty(\"java.ext.dirs\")); xxx\\jre\\lib\\ext; C:\\Windows\\Sun\\Java\\lib\\ext AppClassLoader(SystemAppClass) 如果应用程序中没有自定义过自己的类加载器，一般情况下这个就是程序中默认的类加载器。 System.out.println(System.getProperty(\"java.class.path\")); //这个路径其实就是当前java工程目录bin，里面存放的是编译生成的class文件。 F:\\aivin_space\\myEclipseSpace\\MySample\\bin 类加载之间的父子关系是怎样的 子类加载器和父类加载器的关系，是委派关系并不是继承关系。 双亲委派 模型 （parent delegation） 在加载类别时，每个类别加载器会先将加载类别的任务交由其parent， 如果parent找不到，才由自己负责加载， 如果自己也找不到，就会丢出 NoClassDefFoundError。 为什么要用“双亲委派模型” 防止内存中出现多份同样的字节码 。 比如两个类A和类B都要加载System类： 如果不用委托而是自己加载自己的， 那么类A就会加载一份System字节码， 然后类B又会加载一份System字节码， 这样内存中就出现了两份System字节码。 自定义类加载器的意义和使用场景 1、为了实现jdk的类加载器没有的某些功能。 例如Tomcat使用自定义的类加载器实现了热部署功能。 2、将java写的核心代码编译成.clas文件，然后将lass文件就加密。只有使用在自己的类加载器才能正确使用这些核心代码。 (因为只要获得了这个加载器，核心代码就可以轻易被获取。 所以要保护好自己的加载器。) 触发类加载的情况 / 类什么时候会被加载 1、调用静态成员时，会加载静态成员真正所在的类及其父类。 例如通过子类调用父类的静态成员时，只会加载父类而不会加载子类。 2、第一次 new 对象的时候加载(第二次再 new 同一个类时，不需再加载)。 3、加载子类会先加载父类。 注意：如果静态属性被 final 修饰时，则不会加载，当成常量使用。 例：public static final int a =123; 但是如果上面的等式右值改成表达式(且该表达式在编译时不能确定其值)时则会加载类。 例：public static final int a = math.PI 类/对象 属性和方法 的加载顺序 1、父类静态对象和静态代码块 类中静态块按照声明顺序执行。 2、子类静态对象和静态代码块 3、父类非静态对象和非静态代码块 4、父类构造函数 5、子类非静态对象和非静态代码块 6、子类构造函数 静态的代码块、属性、方法都会在类加载时加载，它们的加载顺序 跟程序编写顺序相同。 实例化一个类时，会先加载普通属性 > 普通代码块 > 构造方法 > 普通方法。 Android 的 类加载器 BaseDexClassLoader 、DexClassLoader 、PathClassLoader PathClassLoader 主要是用来加载系统类和主Dex中的类， DexClassLoader 主要是用来加载其他Dex文件的类。 ( no Copyright，enjoy youself ! ) all right reserved，powered by GitbookThe file was updated at : 2021-03-02 14:33:43 "},"chinese/java基础/内存模型.html":{"url":"chinese/java基础/内存模型.html","title":"内存模型","keywords":"","body":"Java内存模型 其他语言，例如c/c++直接使用了物理硬件或操作系统的内存模型 ， 由于不同平台上内存模型的差异性，需要开发者针对不同的平台做相应的兼容处理。 Java内存模型是为了屏蔽各种硬件和系统的访问差异，达到一致的并发效果。 进一步解决多线程编程中的线程安全等问题。 运行时数据区域 (绿色部分是每个线程私有的，白色部分是线程共享的) 分为5块内存空间。 附：栈是运行的单位，而堆是存储的单元。 // 1、程序计数器 当前线程所执行的字节码的行号指示器。用来记录程序运行到哪里了，下一步又该执行哪一步操作。 // 2、本地方法栈 存储本地方法执行过程中的栈数据。 // 3、JVM栈（Java栈） 存放一个Java线程的运行状态。 // 4、堆 存放运行时产生的对象的。Java只能在堆中存放对象 // 5、方法区 方法区主要是用来存类型数据的，与类型相关的东西，比如常量，静态变量。 注：运行时常量池是方法区的一部分，用来存放编译器生成的各种字面量和符号引用。 基本概念 主内存 进程内存。 所有线程共享主内存。 工作内存 线程内存。 每个线程都有自己的执行空间(即工作内存)，线程执行的时候用到某变量， 首先要将变量从主内存拷贝的自己的工作内存空间， 然后对变量进行操作：读取，修改，赋值等，这些均在工作内存完成， 操作完成后再将变量写回主内存； 可见性 指当一个线程修改了共享变量的值，其他线程能够立即得知这个修改。 各个线程都从主内存中获取数据，线程之间数据是不可见的； 例如，主内存 变量A 原始值为1，线程1从主内存取出 变量A，修改A的值为2， 在线程1未将变量A写回主内存的时候，线程2拿到变量A的值仍然为1； 我们可以使用 volatile 或 synchronized 等机制 保证可见性。 有序性 如果在本线程内观察，所有的操作都是有序的； 指\"线程内表现为串行的语义\" 如果在一个线程中观察另一个线程，所有的操作都是无序的。 指\"指令重排序\"现象和\"工作内存与主内存同步延迟\"现象。 Java提供了 volatile 和 synchronized 来保证有序性 ， volatile 本身包含禁止指令重排序的语义， synchronized 则是由\"一个变量在同一个时刻只允许一条线程对其进行lock操作\"的规则来获得。 原子操作 、原子性 是指不会被线程调度机制打断的操作机制。 这种操作一旦开始，就一直运行到结束，中间不会有任何 context switch （切换到另一个线程）。 根据java 定义，原子操作是不会被打断地的操作，因此被认为是线程安全的。 java中可以通过锁和循环CAS的方式来实现原子操作。 指令重排序 即生成的机器指令与字节码指令顺序不一致。 为什么会有重排序? 为了提高执行效率，目前大多数现代微处理器都会采用将指令乱序执行。 在条件允许的情况下，直接运行当前有能力立即执行的后续指令，避开获取下一条指令所需数据时造成的等待。 int a = 1; int b = 2; int c = a + b; 将上面的代码编译成Java字节码或生成机器指令，大致可视为展开成了以下几步动作： 对a赋值1 --1 对b赋值2 --2 取a的值 --3 取b的值 --4 将取到两个值相加后存入c --5 在上面5个动作中，动作1可能会和动作2、4重排序， 动作2可能会和动作1、3重排序，动作3可能会和动作2、4重排序， 动作4可能会和1、3重排序。但动作1和动作3、5不能重排序。 动作2和动作4、5不能重排序。因为它们之间存在数据依赖关系， 一旦重排，as-if-serial语义便无法保证。 as-if-serial 语义 所有的动作都可以为了优化而被重排序， 但是必须保证它们重排序后的结果和程序代码本身的应有结果是一致。 所以，重排序不会发生在有数据依赖的操作之中。 8大原子操作 为了解决主内存和工作线程的一致性问题，Java定义了如下原子操作. 1、 lock 锁定 作用于主内存，把变量标记为一条线程独占状态。 2、unlock 解锁。 作用于主内存，释放后的变量才能被其他线程锁定。 3、 read 读取 作用于主内存。 将变量的值从主内存传输到工作内存中。 4、load 载入 作用于工作内存。将从主内存中得到的变量值放入工作内存的变量副本中。 5、 use 使用。 作用于工作内存。 将工作内存中的变量的值传递给执行引擎。 6、assign 赋值 作用于工作内存。将执行引擎传递过来的值赋值给工作内存中的变量副本。 7、store 存储 作用于工作内存。 将工作内存中的变量值传递到主内存。 8、write 写入 作用于主内存。将从工作内存中传递过来的值 赋值给主内存的变量。 ( no Copyright，enjoy youself ! ) all right reserved，powered by GitbookThe file was updated at : 2021-01-06 16:10:38 "},"chinese/java基础/GC机制.html":{"url":"chinese/java基础/GC机制.html","title":"GC机制","keywords":"","body":"gc机制 GC机制的诞生时间大于Java。在早期的一些语言也曾使用过GC机制。 经过多年的发展，GC机制已经已经进入了“自动化”时代了，我们为什么还要去了解GC机制呢？ 因为深入了解GC机制能更好地排查内存溢出泄露问题。 当GC机制成为高并发的瓶颈时，我们可以通过监控和调节GC过程，采取合适的优化方案。 普通的程序员也可以从GC机制中学习到它们优秀的策略。 判断对象是否存活的方法 引用计数算法 (Reference Counting) 给对象中添加一个引用计数器,每当有一个地方引用它时,计数器值就加1; 当引用失效时,计数器值就减1;任何时刻计数器为0的对象就是不可能再被使用的。 ava已经摈弃了这种方案。因为很难解决对象之间的互相循环引用的问题。j 例如有两个对象互相引用，这个时候两个对象都不能被访问，但是互相引用导致引用计数不为0。 可达性分析算法( Reachability Analysis) / 根搜索算法( GC Root Tracing) 目前主流编程语言(java,C#等)中,都是称通过可达性分析来判定对象是否存活的。 该算法的基本思路就是通过一系列的“GC Roots”对象作为起始点, 从这些节点开始向下搜索(搜索所走过的路径称为引用链), 当一个对象到 GC Roots 没有任何引用链相连(用图论的话来说,就是从GC Roots到这个对象不可达)时,则证明此对象是不可用的。 如下图所示，对象object 5、object 6、object 7虽然互相有关联, 但是它们到GC Roots是不可达的,所以它们将会被判定为是可回收的对象。 GCRoot 的类型 、Java中可作为 GC Root 的对象 1、虚拟机栈中 引用的对象 每个方法执行的时候，jvm都会创建一个相应的栈帧， 栈帧中包含这个方法内部使用的所有对象的引用 (这就是虚拟机栈中的引用对象) 一旦该方法执行完后 ，该栈 帧就会从虚拟机栈中弹出。 这样一来，没有任何 GCRoot 指向这些临时对象,所以这些对象在下次gc时就会披回收掉。 public static void testGC(){ BeanXX bean = new BeanXX(\"localParameter\"); // 局部变量 bean = null; } 2、持久代(方法区)中 类静态属性引用的对象 Class Dog { private static Object obj; // static } 3、持久代(方法区)中 常量引用的对象 Class Dog { private final Object obj; // final } 4、本地方法栈中JNI(即一般说的Native方法)引用的对象 垃圾收集算法 以下是常用的 垃圾回收算法 引用计数回收法（ Reference Counting GC ） 引用计数法的原理很简单，即记录每个对象被引用的次数。 每当创建一个新的对象，或者将其它指针指向该对象时，引用计数都会累加一次； 而每当将指向对象的指针移除时，引用计数都会递减一次， 当引用次数降为0时，删除对象并回收内存。 标记-清除 算法 ( Mark and Sweep GC ) 首先标记出所有需要回收的对象，标记完成后统一回收被标记过的对象。 缺点： 1、效率不高。标记和清除过程效率都不高。 2、空间问题。标记清除后会产生大量不连续的内存碎片。 标记整理 算法 标记过程与 “标记-清除”算法一样。 然后让所有存活的对象向一端移动，最后直接清理掉端边界以外的内存。 拷贝回收 算法 ( Copying GC ) 将内存均分为两块，每次只用其中一块。 当着一块的内存用完了，就将还存活的对象复制到另一块内存上。 然后将已经使用过的这块内存一次性清理掉。 优点： 实现简单，运行高效。 缺点： 浪费内存，可用内存较少。 分代收集 / 逐代回收 算法 ( Generational GC ) 该算法是目前大部分JVM的垃圾收集器采用的算法。 核心思想是根据对象存活的生命周期将内存划分为若干个不同的区域。 然后根据各个年代的特点采用适当的收集算法。 新生代的垃圾回收算法 拷贝回收 算法 ( Copying GC ) 为什么新生代使用标记复制算法，而老年代使用标记清除/标记整理 ？ 因为新生代gc非常频繁，所以选择效率比较高的垃圾回收算法。 老年代的垃圾回收算法 标记-清除 算法 ( Mark and Sweep GC )、标记整理 Android采用的垃圾回收算法 Android系统采用的是 标注并删除( Mark and Sweep ) 或 拷贝GC ( Copying GC ) 。 如果在编译dalvik虚拟机的命令中指明了\"WITH_COPYING_GC\"选项， 则编译\"/dalvik/vm/alloc/Copying.cpp\"源码 ( 拷贝GC算法的实现 ) 否则编译\"/dalvik/vm/alloc/HeapSource.cpp\" ( 标注与清理GC算法 ) 内存划分类型 内存被分为下面三个区域 。 Enden、form survicor space、to survivor space。 新生代 绝大多数最新被创建的对象会被分配到这里。 对象从这个对象消失的过程称为”minor GC”。 主要是用来存放新生的对象，会频繁创建对象，所有垃圾收集会频繁进行回收。 在新生代中，每次垃圾收集时都发现有大批对象死去，只有少量存活 特征： （1）GC的发生相对比较频繁和迅速高效。 （2）包含了许多短周期对象。 老年代 老年代的对象存活率高，故垃圾收集不会频繁执行。 老年代中对象存活率高。 (1)、从新生代存活下来的对象会被拷贝到这里，它的空间比新生代要大 (2)、GC操作不是很频繁，但是耗时比新生代中的GC要长。 内存占用的增长比较缓慢。 对象从老年代消失的过程称为”major GC”或者”full GC”。 永久代 (方法区/持久代) 永久代指的是永久保存区域。主要存放Class和Meta（元数据）的信息。 (并不是用来存储那些从老年代存活下来的对象)。 在触发full gc的情况下，永久代也会被进行垃圾回收。 在Java8中，永久代已经被移除，被一个称为“元数据区”（元空间）的区域所取代。 元空间与永久代最大的区别在于，元空间不在虚拟机中，使用本地内存。 永久代的回收会随着full gc进行移动，消耗性能。每种类型的垃圾回收都需要特殊处理元数据。 将元数据剥离出来，简化了垃圾收集，提高了效率。 内存分配与回收机制 对象优先在Eden分配 对象一般在新生代Eden区中分配，当Eden区没有足够的空间进行分配时，虚拟机将发起一次Minor GC 。 大对象直接就进入老年代 大对象(类似很长的字符串或数组 需要大量连续内存空间的对象)。 长期存活的对象将进入老年代 虚拟机给每个对象定义了一个对象年龄计数器。对象再Survivor区中每熬过一次Minor GC,年龄就会增加1岁。当年龄增加到一定程度(默认配置15岁)，对象就会被移动到老年代中。 动态对象年龄判定 并不是一定要达到规定的年龄，对象才会被移动到老年代中。 如果Survivor空间中相同年龄 所有对象的大小的总和大于Survivor空间的一半，年龄>=该年龄的对象就会直接被移动到老年代中。 空间分配担保 在执行Minor GC之前，虚拟机先检查老年代最大可用的连续空间是否大于新生代所有对象总空间，如果ok，那么此次Minor GC可以安全进行。否则，虚拟机会查看HandlePromotionFailure设置值是否允许担保失败。如果允许，那么会继续检查老年代最大可用的连续空间是否大于历次晋升到老年代对象的平均大小，如果大于，将尝试着进行一次Minor GC，(尽管此次 Minor GC是有风险的)；如果小于，或者HandlePromotionFailure设置不允许冒险，就改为执行 Full GC（不执行 Minor Gc）。 Java中引用的类型 1、强引用 类似 Object obj= new Object(); 只要强引用还存在，GC永远不会回收掉被引用的对象。 2、软引用 可用 SoftReference 实现软引用。 一个软引用中的对象，不会很快被JVM回收，JVM会根据当前堆的使用情况来判断何时回收， 当堆的使用率超过阈值导致内存不足时，才会去回收软引用中的对象。 3、弱引用。 可用WeakReference实现。 当GC执行时，无论当前内存是否充足，都会尝试将弱引用关联的对象回收掉。 它对应的对象没有 被引用时 + GC 就会被回收。 4、虚引用 可用 PhantomReference 实现。 虚引用的唯一作用就是当其指向的对象被回收之后， 自己被加入到引用队列，用来告知该引用指向的对象已被销毁。 finalize() finalize() 的发明是为了向 c/c++ 程序员妥协。 在Java中使用finalize()方法反而会带来更多的不确定性。 所以在Java中不推荐使用这个方法，不建议对象进行自我拯救。 类似于“关闭外部资源”之类的工作可以交给try-finally或其他方式完成。 被GC判断为”垃圾”的对象一定会回收吗 在可达性分析算法中不可达的对象,也并非是“非死不可”的, 这时候它们暂时处于“缓刑”阶段,要真正宣告一个对象死亡,至少要经历 两次标记过程。 如果对象在进行可达性分析后发现没有与GC Roots相连接的引用链,那它将会被第一次标记并且进行一次筛选, 筛选的条件是此对象是否有必要执行finalize()方法。 当对象没有覆盖finalize()方法,或者finalize()方法已经被虚拟机调用过,虚拟机将这两种情况都视为“没有必要执行”。(即意味着直接回收)。 如果这个对象被判定为有必要执行finalize()方法,那么这个对象将会放置在一个叫做F-Queue的队列之中, 并在稍后由Finalizer线程(虚拟机建立的、低优先级)去触发finalize()方法。 finalize()方法是对象逃脱死亡命运的最后一次机会,稍后GC将对F-Queue中的对象进行第二次小规模的标记, 如果对象要在finalize()中成功拯救自己——只要重新与引用链上的任何一个对象建立关联即可, 譬如把自己(this关键字)赋值给某个类变量或者对象的成员变量,那在第二次标记时它将被移除出“即将回收”的集合; 如果对象这时候还没有逃脱,那基本上它就真的被回收了。 任何一个对象的finalize()方法只能被系统自动调用一次。所以对象自我拯救的次数有限。 ( no Copyright，enjoy youself ! ) all right reserved，powered by GitbookThe file was updated at : 2021-06-28 11:24:45 "},"chinese/java基础/对象内存布局.html":{"url":"chinese/java基础/对象内存布局.html","title":"对象内存布局","keywords":"","body":"对象内存布局 在HotSpot虚拟机中，对象在内存中存储的布局分为 对象头Header、实例数据Instance Data、对齐填充Padding。 // 对象头 object header , 包括了关于堆对象的布局、类型、GC状态、同步状态和标识哈希码的基本信息。 Java对象和vm内部对象都有一个共同的对象头格式。 // 实例数据 Instance Data ,主要是存放类的数据信息，父类的信息，对象字段属性信息。 // 对齐填充 Padding, 为了字节对齐，填充的数据，不是必须的。 对齐填充并不是必然存在的，无特别含义，起着占位符的作用， HotSpotVM的自动内存管理系统要求对象起始地址必须是8字节的整数倍，也就是对象的大小必须是8字节的整数倍， 对象头正好是8字节的倍数，所以当对象实例数据部分没有对齐，就需要通过对齐填充来补全。 对于Java和C、C++、C#这类高级语言，因为编译器的存在， 编译器或虚拟机会自动帮我们进行字节对齐补白。无需手动去处理。 为什么要进行内存对齐 // 平台原因 不是所有的硬件平台（例如某些嵌入式系统中使用的低端微处理器）都能访问任意地址上的任意数据， 某些硬件平台只能访问对齐的地址，否则会出现硬件异常。 // 性能原因 如果数据存放在未对齐的内存空间中，则处理器访问变量时需要做两次内存访问， 而对齐的内存访问仅需要一次访问。 显然，内存对齐在某些情况下可以减少读取内存的次数以及一些运算，性能更高。 另外，由于内存对齐保证了读取 b 变量是单次操作，在多核环境下，原子性更容易保证。 但是内存对齐提升性能的同时，也需要付出相应的代价。 由于变量与变量之间增加了填充，并没有存储真实有效的数据，所以占用的内存会更大。 这也是一个典型的空间换时间的应用场景。 如何解决 内存对齐 带来的内存浪费问题 有内存对齐就会有内存浪费的情况，所以为了减少内存浪费， 并达到内存对齐的目的，JVM就会将字段重新排列。 java -version // 查看虚拟机类型 java version \"1.8.0_151\" Java(TM) SE Runtime Environment (build 1.8.0_151-b12) Java HotSpot(TM) 64-Bit Server VM (build 25.151-b12, mixed mode) 由于HotSpot虚 拟机的自动内存管理系统要求对象的起始地址必须是8字节的整数倍， 因此当对象实例部分数据没有对齐时，就需要对剩余的部分进行填充。 补齐位的存在就是为了补齐8字节，每一个java对象的大小都是8的倍数。 // 字段重排规则 (Java HotSpot(TM) ) 1、总的规则是 (对象头 + 实例数据 + padding) %8 == 0 且 0 OFFSET SIZE TYPE DESCRIPTION 0 4 (object header) 4 4 (object header) 8 4 (object header) // header 下面属性顺序跟申明顺序可能不一致 12 2 char TestBean.charValue1 14 2 char TestBean.charValue2 16 8 long TestBean.longValue2 24 8 double TestBean.doubleValue1 32 8 double TestBean.doubleValue2 40 1 byte TestBean.byteValue1 41 1 boolean TestBean.booleanValue2 42 1 byte TestBean.byteValue2 43 5 (loss due to the next object alignment) Instance size: 48 bytes jol-cli 查看 对象内存布局信息 https://repo.maven.apache.org/maven2/org/openjdk/jol/jol-cli/ 下载一个 full 版本 //查看对象内部信息. String inInfo=ClassLayout.parseInstance(bean).toPrintable() ; //查看对象外部信息，包括引用的对象. String outInfo=GraphLayout.parseInstance(bean).toPrintable() ; //查看对象总大小. long allInfo=GraphLayout.parseInstance(bean).totalSize(); ( no Copyright，enjoy youself ! ) all right reserved，powered by GitbookThe file was updated at : 2021-05-28 09:09:37 "},"chinese/java基础/继承多态.html":{"url":"chinese/java基础/继承多态.html","title":"继承和多态","keywords":"","body":"继承 内部类 可以将一个类的定义放在另一个类的定义内部，这就是内部类。 使用内部类最大的优点就在于它能够非常好的解决多重继承的问题 。 内部类是个编译时的概念， 一旦编译成功后，它就与外围类属于两个完全不同的类( 当然他们之间还是有联系的 )。 内部类它可以无限制地访问外围类的元素。 Java中内部类主要分为成员内部类、局部内部类、匿名内部类、静态内部类。 匿名内部类 匿名内部类没有名字，创建格式如下。 new 父类构造器（参数列表）|实现接口 (){ //匿名内部类的类体部分 } 匿名内部类参数为何要为final 1、首先在内部类编译成功后，它会产生一个class文件， 该class文件与外部类并不是同一class文件，仅仅只保留对外部类的引用。 2、内部类并不是直接调用方法传递的参数，而是利用自身的构造器对传入的参数进行备份， 自己内部方法调用的实际上时自己的属性而不是外部方法传递进来的参数。 3、在内部类中的属性和外部方法的参数两者从外表上看是同一个东西，但实际上却不是， 也就是说在内部类中我对属性的改变并不会影响到外部的形参， 而然这从程序员的角度来看这是不可行的，毕竟站在程序的角度来看这两个根本就是同一个， 如果内部类该变了，而外部方法的形参却没有改变这是难以理解和不可接受的，所以为了保持参数的一致性， 就规定使用final来避免形参的不改变。（规定的） 内部类类名规则 , 带 $ 的函数 public class TestClass { // 内部类 private MyTestCallback myTestCallback = new MyTestCallback() { @Override public void showMsg(String msg) { } }; } // 编译成功后，发现有生成 TestClass$1.class class TestClass$1 implements MyTestCallback { TestClass$1(TestClass this$0) { this.this$0 = this$0; } public void showMsg(String msg) { } } 抽象类 、接口 区别 接口完全是抽象的，不存在任何方法的实现。 接口只是一种形式，接口自身不能做任何事情。 抽象类，除了不能实例化之外，它和普通的Java类没有任何区别。 接口 、抽象类 可以被new吗 ？ Java 语言规范规定了抽象类不能实例化 。 xx is abstract ,can not be instantiated .. 接口 是定义的一种规范和能力 也不能被new出来 。 但是我们平时有时会见到一些迷惑性的代码，其实那是创建了匿名内部类 。 // java编译器特有的写法？？给我们一种可以 new 出一个接口实例的假象 AbstractClassA test1= new AbstractClassA() { @Override public void func1() { System.out.println(\"func1...\"); } }; //错误写法，无法通过编译 AbstractClassA test2= new AbstractClassA(); 抽象类不能new，但抽象类里为什么还要有构造方法？ 抽象类可以有成员变量，他们的初始化怎么做呢？ 这么一样你就明白为什么抽象类可以有构造函数了。 实现多重继承的方案 1、接口, 无需多说。 2、内部类。 // 这种方式实现多重继承，我认为不太优雅。 public class Father { public void strong(){ } } public class Mother { public void kind(){ } } public class Son { // 通过 2个内部类，获得两个父类的能力。 class Father_1 extends Father{ } class Mother_1 extends Mother{ } } 父类的 静态方法 能否被子类 继承和重写 ？ 可以被继承、不能被重写。 因为重写的定义是： 根据运行时对象的类型来决定调用哪个方法，而不是根据编译时的类型。 public class Father { public static void showMsg(){ System.out.println(\"i am father\"); } } public class Son { public static void showMsg(){ System.out.println(\"i am son\"); } } 需要注意的是， 如果 子类和父类有相同的静态方法，那么父类的方法就会被覆盖(不是重写)、被隐藏。 如果没有同名静态方法，子类可以通过继承的方式调用父类的静态方法。 静态属性 是否可以被继承 ？ 静态属性可以被继承。 子类有同名静态属性 就使用子类的，没有同名的就是用继承得来的。 多态 从一定角度来看，封装和继承几乎都是为多态而准备的。 多态的定义： 指允许不同类的对象对同一消息做出响应。 即同一消息可以根据发送对象的不同而采用多种不同的行为方式。 以下是现实生活中多态的例子。 比方说按下 F1 键这个动作， 如果当前在 Word 下弹出的就是 Word 帮助， 在 Windows 下弹出的就是 Windows 帮助和支持。 同一个事件发生在不同的对象上会产生不同的结果。 Java中多态的实现方式 1、接口实现 2、继承父类进行方法重写 3、同一个类中进行方法重载 方法重载 为什么可以实现多态？？ 多态分为编译时多态和运行时多态。 其中编译时多态是静态的，主要是指方法的重载， 它是根据参数列表的不同来区分不同的函数， 通过编辑之后会变成两个不同的函数，在运行时谈不上多态。 Java实现多态的 必要条件 1、继承 （extends 、 implements） 2、重写 3、向上转型 Object cat = new Cat() ( no Copyright，enjoy youself ! ) all right reserved，powered by GitbookThe file was updated at : 2021-01-14 14:18:26 "},"chinese/java基础/相等判断.html":{"url":"chinese/java基础/相等判断.html","title":"相等判断","keywords":"","body":"相等判断 针对基本数据类型， == 比较的是它们的值是否相同。 针对 类、接口、数组 这样的引用数据类型 。 == 比较的是它们在内存 (在栈中) 的地址。 如果要比较引用对象的值是否相同，就需要重写 equals() 和 hashCode() , 根据自己定义的规则判断对象是否相同。 HashSet 是如何高效保证 元素不重复 java规定 Set中元素无序，元素不可重复。 如何高效地判断新加的元素是否与集合中的元素不一样，从而保证保证元素不重复 ？ 我们可以用 equals() 依次判断是否相等。 但是，每增加一个元素就检查一次，那么当元素很多时， 后添加到集合中的元素比较的次数就非常多了。 这显然会大大降低效率。 所以 Java采用了哈希表的原理， 当集合要添加新的元素时，先调用这个元素的 hashCode() ,定位到在hash表中的位置。 如果这个位置上没有元素，它就可以直接存储在这个位置上，不用再进行任何比较了； 如果这个位置上已经有元素了，但是有可能是 发生了 hash 碰撞 ， 所以还需调用它的 equals() 与新元素进行比较， 相同的话就不存，不相同就再次求 hashcode 散列其它的地址。 这样一来实际调用equals方法的次数就大大降低了，几乎只需要一两次。 equals () 和 hashcode () ， 为何必须一起重写 Object.java中有一句注释：equal objects must have equal hash codes 如果重写了 equals() ，但是不重写 hashCode() , 可能会出现 equals() 相等 ，但是 hashCode() 不相等 。 因为 equals() 的比较规则是你自定义的， hashCode() 规则还是系统默认， 肯定无法满足 equal objects must have equal hash codes 。 补充：其实如果只是简单地比较一下对象是否相等，我们不重写 hashCode 也没关系， 但是因为你不能保证 其他人用 HashMap 、HashMap 来使用你的对象， 因为 hashCode 不一样，即使 equals 相同，也被 HashXX 认为是两个不一样的对象。 在使用时可能会出现问题，例如： 如果两个 key A 对象 和B对象， 它们 equal 相同 但是 hashCode 不一样， 你用 A作为Key 添加了对象 ，但是用B去查 ，结果会为空。 如何重写 hashCode() @Override public int hashCode(){ int hashCode = 0; //自定义系数，随意写。只要不是特别大或特别小导致最后hash值查出int的范围即可 int k1=5 ; //最后的hash值生成原则：用到类里面的所有属性。 hashCode = k1 * age + name.hashCode(); return hashCode ; } @Override public boolean equals(Object obj){ //对象地址完全一样，对象肯定相等 if (obj == this){ return true; } //如果类型都不一样了，肯定不相等 if (!(obj instanceof Bean1)) { return false; } //根据自定义规则判断是否相等 Bean1 bean = (Bean1)obj; return bean.name.equals(name) && bean.age == age; } ( no Copyright，enjoy youself ! ) all right reserved，powered by GitbookThe file was updated at : 2021-01-19 10:20:29 "},"chinese/java基础/Java容器类.html":{"url":"chinese/java基础/Java容器类.html","title":"Java容器类","keywords":"","body":"容器类关系图 Array 、Arrays Array：就是数组。 java.lang.reflect.Array 是个反射工具包，全是静态方法。 Arrays：是Array的工具类，其静态方法定义了 对Array 的各种操作。 Collection 、Collections Collection 是接口，集合。 Collections 是工具类。提供静态方法 封装了一些对集合的操作。 ( no Copyright，enjoy youself ! ) all right reserved，powered by GitbookThe file was updated at : 2021-01-19 10:18:51 "},"chinese/java基础/Java枚举.html":{"url":"chinese/java基础/Java枚举.html","title":"Java枚举","keywords":"","body":"Java枚举 [JDK1.5 ,+∞ ) 支持枚举 为了唯一性，所以规定了构造函数不能为 public、protected 只能是private 或 不写 简单枚举 public enum CarType { BWO ,DZ ,AD } CarType type= CarType.DZ ; switch (type) { case BWO: System.out.println(\"宝马\"); break; case DZ: System.out.println(\"大众\"); break; case AD: System.out.println(\"奥迪\"); break; default: break; } 枚举类 public enum CarType { //初始化枚举实例 ，必须在构造函数前面 BWOINFO(1 ,\"宝马\" ,500.0), // 初始的值 对应构造函数的顺序 DZINFO( 2 ,\"大众\" ,600.0), ADOINFO(3 ,\"奥迪\" ,700.0) ; private int carId ; private String carName ; private double price ; private CarType(int id ,String name ,double price){ this.carId =id ; this.carName = name ; this.price = price ; } ... get set 方法 ... } // 单个实例 CarType car = CarType.BWOINFO; System.out.println(car.getCarName() + \" \" + car.getPrice()); // 修改枚举实例的值 car.setPrice(888.0); // 遍历枚举类中的所有实例 for (CarType temp : CarType.values()) { System.out.println(temp.getCarName() + \" \" + temp.getPrice()); } 枚举的缺点 每一个枚举值都是一个对象, 在使用它时会增加额外的内存消耗 ，同时也会增加 DEX文件的大小 。 所以 android官方文档建议尽量避免使用枚举。 Android 中枚举的替代方案 @IntDef 1、添加依赖 implementation 'com.android.support:support-annotations:28.0.0-rc02' 2、定义 public class MyDefBean { //先定义 常量 public static final int SUNDAY = 0; public static final int MONDAY = 1; public static final int TUESDAY = 2; //用 @IntDef \"包住\" 常量 声明构造器 @IntDef({SUNDAY, MONDAY,TUESDAY }) // @Retention 定义策略 @Retention(RetentionPolicy.SOURCE) // 定义‘接口’ public @interface WeekDays {} } 3、使用 @MyDefBean.WeekDays int currentDay = SUNDAY; void test(@MyDefBean.WeekDays int today) { switch (today) { case MyDefBean.MONDAY: break; case SUNDAY: break; case MyDefBean.TUESDAY: break; default: break; } } ( no Copyright，enjoy youself ! ) all right reserved，powered by GitbookThe file was updated at : 2021-01-19 10:05:13 "},"chinese/java基础/自定义异常.html":{"url":"chinese/java基础/自定义异常.html","title":"自定义异常","keywords":"","body":"自定义异常 自定义异常方式我用的较少，一般都习惯用回调的方式回调逻辑错误。 不过，自定义错误有一个优点，方便定位异常具体地点。(点击即可跳转) public class WkException extends Exception { private static final long serialVersionUID = 1L; private String errorInfo ; private int errorCode= -100 ; public WkException(String errorInfo){ this.errorInfo = errorInfo ; } public WkException(int errorCode ,String errorInfo){ this.errorCode = errorCode ; this.errorInfo = errorInfo ; } @Override public String toString() { return errorCode+\" \"+errorInfo; } } // 使用 public static void checkValue(int value ) throws WkException{ if(value>4){ throw new WkException(1001, \"数据错误\"); } } try { checkValue(10); } catch (WkException e) { e.printStackTrace(); } ( no Copyright，enjoy youself ! ) all right reserved，powered by GitbookThe file was updated at : 2021-01-14 13:30:16 "},"chinese/java基础/深度拷贝.html":{"url":"chinese/java基础/深度拷贝.html","title":"深度拷贝","keywords":"","body":"深度拷贝 public List deepCopy(List src) { ByteArrayOutputStream byteOut = new ByteArrayOutputStream(); ObjectOutputStream out = new ObjectOutputStream(byteOut); out.writeObject(src); ByteArrayInputStream byteIn = new ByteArrayInputStream(byteOut.toByteArray()); ObjectInputStream in = new ObjectInputStream(byteIn); List dest = (List) in.readObject(); return dest; } // 深度克隆ByteBuffer private ByteBuffer deepCloneByteBuffer(ByteBuffer original) { ByteBuffer clone = ByteBuffer.allocate(original.capacity()); original.rewind(); clone.put(original); // 用put接口，才会把byte数组的内容拷贝到ByteBuffer中 original.rewind(); clone.flip(); return clone; } ( no Copyright，enjoy youself ! ) all right reserved，powered by GitbookThe file was updated at : 2020-08-26 10:45:02 "},"chinese/java基础/泛型详解.html":{"url":"chinese/java基础/泛型详解.html","title":"泛型详解","keywords":"","body":"泛型是什么 在 Java5 以前，普通的类和方法只能使用特定的类型， 但是如果编写的代码需要应用于多种类型，这种严苛的限制对代码的束缚就会很大。 所以 Java5 引入泛型，泛型实现了参数化类型， 使得你编写的组件(通常是集合)可以适用于多种类型。 泛型将类型参数化,让编译器在编译期间帮忙检查类型错误。 在定义的时候你不知道这个地方需要什么类型的数据，只有实际使用的时候才会知道。 使用泛型 前 Object 是所有类的根类， 任何类的对象都可以设置给该Object引用变量，使用的时候可能需要类型强制转换 。 需要开发者手动做强制转换，但是如果开发者判断失误，程序运行会崩溃。 有很大的安全隐患。 使用泛型 后 这样设计的容器在使用时编译器就可以帮忙做很大一部分的类型安全检查工作了， 这就避免了很多运行时的ClassCastException异常， 程序员也无需记住各种对象的类型和担心类型匹配问题了。 (编译器在编译是就帮我们做检查，更容易发现错误。) List list = new ArrayList(); Bean bean = list.get(0) ; // 无需手动转换 泛型 通配符 原则上来讲，使用任何字母或字符串都是可以的， 但是为了代码的可读性，我们一般有如下约定。 E - Element //在集合中使用，因为集合中存放的是元素 T - Type // 类型 K - Key //键 V - Value // 值 N - Number // 数字 ? - //表示不确定的java类型、无界通配符 泛型的应用范围 泛型接口 、泛型类 、泛型方法 泛型类 public class Tool { private T value ; } 泛型接口 public interface Person { T getType(); }} 泛型方法 // 说明当前是一个泛型方法，并且将类型定义为T200 // 返回值 为 T200 public T200 showKeyName (List list) { return list.get(0) ; } public class Tool { // 静态方法不能使用类定义的泛型。 public static void show(T200 t){ // 这样使用编译器会报错 } } 泛型与可变参数 //printMsg(\"111\",222,\"aaaa\",\"2323.4\",55.55); public static void printMsg( T300... args){ for(T300 t : args){ System.out.println(\"t is \" + t); } } 泛型的 类型擦除 ( 泛型擦除 ) 因为 Java泛型 是从 JDK 1.5才开始加入的， 为了兼容之前的版本，java在语法上支持泛型，但是在编译阶段会进行所谓的“类型擦除”， 将所有的泛型表示（尖括号中的内容）都替换为具体的类型（其对应的原生态类型）， 就像完全没有泛型一样。 // 类型擦除验证 List list1 = new ArrayList<>(); List list2 = new ArrayList<>(); boolean result = list1.getClass() == list2.getClass() result 结果是true。 说明两个传入了不同泛型的List最终都编译成了ArrayList，成为了同一种类型， 原来的泛型参数String和Integer被擦除掉了。 协变 、逆变 、型变 、不变 定义 型变 分为 逆变 和 协变, 与不变对应。均用来描述类型转换后的继承关系; 其定义： A、B表示类型， f(⋅)表示某种类型转换，例如 f(A)=ArrayList ，f(A)=[]A ≤表示继承关系（A≤B表示A是由B派生出来的子类） 若 A≤B ，有f(A)≤f(B)成立； f(⋅) 是协变 的， 若 A≤B ，有f(B)≤f(A)成立；f(⋅) 是逆变 的 若 A≤B ，f(A) 与 f(B) 相互之间没有继承关系。 f(⋅) 是不变 的 数组的 协变 、泛型的 不变 BFruit[] BFruits = new Apple[3];// (通过) 说明 数组是 协变 的 ArrayList list = new ArrayList()//(报错)说明泛型 不是 协变 的 ArrayList list2 = new ArrayList()//(报错)说明泛型不是 逆变 的 泛型中 ? extends 和 ? super Java中泛型是不变的，可有时需要实现逆变与协变，怎么办呢？ 这时，通配符? 派上了用场。 上界通配符 实现了泛型的协变 ArrayList list3 = new ArrayList(); 下界通配符 实现了泛型的逆变 List list4 = new ArrayList(); 为什么 协变 只能读不能存 ？ BFruit[] fruits =new Banana[5] ; fruits[0] =new Apple(); System.out.println(fruits[0]);// 编译通过，但是运行报错 java.lang.ArrayStoreException ArrayList list3 = new ArrayList(); list3.add( new Apple()) ; // ( 编译报错) list3.add( new Banana()) ; // ( 编译报错) // 因为根据 里氏替换原则 ，list3 可能是 list3 = new ArrayList() // 也可能是 list3 = new ArrayList() // 如果不加限制地存进去，那么取出来的时候 ，类型转换就存在 转换异常 。 为什么 逆变 取出来的 只能放在 Object 中 ？ List list4 = new ArrayList(); list4.add( new Meat()) ; // (通过) list4.add( new Banana()) ; // (通过) Apple fruit1 =list4.get(0) ; // (编译报错) Banana fruit2 =list4.get(0) ; // (编译报错) BFruit fruit3 =list4.get(0) ; // (编译报错) Object object =list4.get(0) ; // (通过) // 因为 list4 限定的是下界是 BFruit 类型, // 编译器并不知道 里面存取的确切的类型是什么，没法找到一个合适的类型接受返回值。 // 所以只能放 Object 中 。 补充理解 ArrayList list // 定义一个list，存放 BFruit 和子类 是 BFruit的对象 。 List list ; // 定义一个list ，存放 BFruit 和 父类是 BFruit 的对象。 PECS 原则 究竟什么时候用extends什么时候用super呢？《Effective Java》给出了答案： PECS: producer-extends, consumer-super 如果它表示一个 T 生产者，就使用 如果它表示一个 T 消费者， 就使用 PECS 这个助记符突出了 通配符类型 的基本原则。 // java.util.Collections 的 copy() 方法(JDK1.7)完美地诠释了 PECS public static void copy( List dest, List src) { int srcSize = src.size(); if (srcSize di=dest.listIterator(); ListIterator si=src.listIterator(); for (int i=0; i ( no Copyright，enjoy youself ! ) all right reserved，powered by GitbookThe file was updated at : 2021-03-09 11:56:58 "},"chinese/java基础/线程详解.html":{"url":"chinese/java基础/线程详解.html","title":"线程详解","keywords":"","body":"锁 、同步 等 相关概念 原语 所谓原语，一般是指由若干条指令组成的程序段， 用来实现某个特定功能，在执行过程中不可被中断。 可重入 可重入函数保证了在多线程条件下，函数的状态不会出现错误。 以下分别是一个不可重入和可重入函数的示例。 // func1是不可重入的 , 因为tmp是 static 全局变量，多线程访问时，会出现问题。 static int tmp; void func1(int* x, int* y){ tmp=*x; *x=*y; *y=tmp; } //func2是可重入的 void func2(int* x, int* y){ int tmp; tmp=*x; *x=*y; *y=tmp; } 线程中断 中断是一种特殊的电信号。 处理器接受到中断后，会马上向操作系统反映此信号的到来，然后就由 操作系统 负责处理这些新到来的数据。 要中断一个Java线程，可调用线程类对象的实例方法：interrupte()。 其本质只是设置该线程的中断标志，将中断标志设置为true，并根据线程当前的状态决定做出不同的响应。 怎么终止一个线程 1、使用退出标志，使线程正常退出，也就是当run方法完成后线程终止。 while(flage){...} 2、使用 stop 方法强行终止。不推荐这个方法。 3、使用 interrupt 方法中断线程。 synchronized 悲观锁 就是悲观思想，即认为写多，遇到并发写的可能性高， 每次去拿数据的时候都认为别人会修改， 所以每次在读写数据的时候都会上锁，这样别人想读写这个数据就会block直到拿到锁。 AQS AbstractQueuedSynchronizer AQS (抽象队列同步器) 是一个抽象类 ，是用来构建锁和同步工具的基本框架。 是同步组件乃至整个并发包的基础类。 private volatile int state; // 共享的状态标记, 0 表示没有被占用、 1表示已被某个线程占用锁住了 各个线程去竞争这个 state， 竞争到 state 的，就可以去处理自己的逻辑、没竞争到去排队(进入先进先出队列)， 等拥有状态的线程释放共享状态后，队列中线程的再去竞争。 AQS 搭好了整体框架，我们需要实现哪个具体的功能，重写AQS某些指定方法即可。 例如 排他锁 ReentrantLock 和 共享锁 CountDownLatch 都是基于 AQS 实现的。 也即是说，通过AQS,我们将能很简单的实现同步的要求。这也是模板方法模式的运用。 下面是两个同步器类实现的大体思路： ReentrantLock ： 某个线程获取锁后其他线程就会阻塞直至锁的释放。 共享状态state初始值为0，表示状态未被占有。 某线程访问并设置state为1，表示该线程占有了锁。 当其他线程读取到state不为0后进入队列等待，直到占有锁的线程将其设为0后，队列线程才会得到通知，重新竞争锁。 CountDownLatch ： 如我们想要主线程在2个子线程执行完后再结束， 这时使用CountDownLatch通过构造函数将共享变量state设为2，将主线程锁住， 每个子线程结束后state减一，state为0后表示两子线程执行完毕，此时主线程才得以释放。 // AQS 主要模板方法 (public) aqs.acquire() ; // 独占式获取同步状态，如果当前线程获取同步状态成功，则由该方法返回 , 若获取失败，将进入同步队列。该方法会调用重写的 tryAcquire(int arg)方法 aqs.acquireInterruptibly() ; //独占式获取同步状态，若获取失败，将进入同步队列。 如果当前线程被中断，则该方法会抛出 InterruptedException 并返回 aqs.tryAcquireNanos();// aqs.acquireShared();// 共享式获取同步状态 ，该方法会调用重写的 tryAcquireShared( )方法 aqs.acquireSharedInterruptibly();// 共享式获取同步状态， 能响应中断 aqs.release();// 独占式释放同步状态，成功后将同步队列的第一个线程唤醒 ， 会调用到 自定义的 tryRelease() aqs.releaseShared();// 共享式释放同步状态 // 需要子类实现的方法 (protected) aqs.tryAcquire() ; // 独占方式-获取同步状态 aqs.tryRelease () ; // 独占方式-释放同步状态 aqs.tryAcquireShared () ; // 共享方式-获取同步状态 aqs.tryReleaseShared () ; //共享方式-释放同步状态 aqs.isHeldExclusively () ; //当前线程是否在独占状态 aqs.getState() ; // 获取同步状态 aqs.setState() ; // 通常用于当前正持有锁的线程对state变量进行修改，不存在竞争，是线程安全的，这种情况是没必要用CAS保证原子性 aqs.compareAndSetState() ; // 通常用于在获取到锁之前，尝试加锁时，对state进行修改， 由于当前线程不是锁持有者，所以对state的修改是线程不安全的 。需要保证对state修改的原子性操作。CAS 方式的。 // 其他 aqs.setExclusiveOwnerThread() ;//设置当前线程有 独占访问 权限 aqs.getExclusiveOwnerThread() ;//当前线程是否是 独占线程 //这里给出一个自定义独占同步锁的demo https://gitee.com/Aivin_CodeShare/android_tool_code/raw/master/MyLock.java synchronized 的实现原理 暂未学习 CAS (Compare-and-Swap) 乐观锁 、 非阻塞同步 基于 冲突检测 的乐观并发策略 ， 先将内存的值进行保存，当操作完成时再判断保存的值和当前内存的值是否相同， 如果不同则说明其他线程操作了该数据，所以需要重试或者放弃。 这种乐观的并发策略不需要把线程挂起，因此这种 同步措施 称为 非阻塞同步。 ABA问题 是指在 CAS 操作中带来的一个潜在问题。 例如，线程1将初始值为A的变量 先修改成B，再修改回成A。 线程B的 CAS 操作无法分辨当前V值是否发生过变化。 线程状态的转换 公平锁 Fair 加锁前检查是否有排队等待的线程，优先排队等待的线程，先来先得。 非公平锁 Nonfair 加锁时不考虑排队等待问题，直接尝试获取锁，获取不到自动到队尾等待。 类锁 、对象锁 // 对象锁 在 普通方法或代码块 上加 synchronized 或 synchronized(this) 。 Java的所有对象都含有一个互斥锁，这个锁由jvm自动获取和释放。 synchronized 方法正常返回或者抛异常而终止，jvm会自动释放对象锁。 // 类锁 在 静态方法 或 代码块 加 synchronized 或 synchronized(xxx.class) ； 类锁是用来控制静态方法(或静态变量互斥体)之间的同步。 获取了类锁的线程和获取了对象锁的线程是不互斥的。 他们需要的锁是不同的，因此类锁和对象锁不会产生竞争，二者的加锁方法不会相互影响。 Lock 接口 public interface Lock {... 相比于 synchronized , Lock 接口 具有一些更强的特性 。 1、尝试非阻塞的获取锁 tryLock() ， 当前线程尝试获取锁，如果该时刻锁没有被其他线程获取到，就能成功获取并持有锁 2、能被中断的获取锁 lockInterruptibly() 获取到锁的线程能够响应中断，当获取到锁的线程被中断的时候，会抛出中断异常同时释放持有的锁 3、超时的获取锁tryLock(long time, TimeUnit unit) 在指定的截止时间获取锁，如果没有获取到锁返回false 独享锁 、共享锁 、读写锁 ReadWriteLock 独享锁是指该锁一次只能被一个线程所持有，例如 synchronized 。 共享锁是指该锁可被多个线程所持有。 ReadWriteLock rtLock = new ReentrantReadWriteLock(); rtLock.readLock();//共享锁 rtLock.writeLock();//互斥锁 ReadWriteLock rtLock = new ReentrantReadWriteLock(); ReentrantLock 可重入锁 可重入就是说某个线程已经获得某个锁，可以再次获取锁而不会出现死锁。 private void func1(ReentrantLock lock){ //如果已经被锁定了 就会忽略。不会等待。 boolean result = lock.tryLock() //如果被锁定了，就会尝试等待指定时长。如果还没有就放弃等待。 boolean result = lock.tryLock(5 , TimeUnit.SECONDS) 死锁 多个线程同时被阻塞，它们中的一个或者全部都在等待某个资源被释放。由于线程被无限期地阻塞。 //java 死锁产生的四个必要条件： 1、互斥使用，即当资源被一个线程使用(占有)时，别的线程不能使用. 2、不可抢占，资源请求者不能强制从资源占有者手中夺取资源，资源只能由资源占有者主动释放。 3、请求和保持，即当资源请求者在请求其他的资源的同时保持对原有资源的占有。 4、循环等待，即存在一个等待队列：P1占有P2的资源，P2占有P3的资源，P3占有P1的资源。 这样就形成了一个等待环路。 当上述四个条件都成立的时候，便形成死锁。当然，死锁的情况下如果打破上述任何一个条件，便可让死锁消失。 线程同步 机制 同步一般指的是在多个数据库、文件、模块、线程之间用来保持数据内容一致性的机制。 程同步的真实意思和字面意思恰好相反，其实是“线程排队”, 几个线程之间要排队，一个一个对共享资源进行操作，而不是同时进行操作。 1、java的每个对象都有一个内置锁。 2、同步是高开销，尽量减少同步的内容。一般同步关键代码（代码块）即可。 线程阻塞 阻塞指的是暂停一个线程的执行以等待某个条件发生（如某资源就绪）。 线程 相关方法 sleep() sleep 允许线程在指定的时间内进入阻塞状态，不能得到CPU 时间， 指定的时间一过，线程重新进入可执行状态。 只是不参与cpu时间的竞争， 已经拿到手的锁资源并不释放 （此时不一定占有锁）。 sleep 方法时间到了会自动醒过来， 时间没到可以用interrupt方法强行唤醒。 suspend() 、 resume() 两方法配套使用，调用suspend()进入阻塞状态。 不会立即的停止，而是执行到一个安全点后挂起 ，不会自动恢复。 调用resume()进入唤醒状态。 在多线程场景中很容易造成死锁，目前这2个方法已经被废弃。 yield() 线程礼让、让步。 yield 方法让当前正在执行的线程放弃当前分得的CPU时间， 它只是将该线程从运行状态转入就绪状态。 只是礼让当前的cpu使用权，让系统的线程调度器重新调度一次。 很有可能，当这个线程调用了yield()方法后它又马上抢占了CPU的执行权，继续执行。 wait() 、 notify() wait 、 notify 两个方法配套使用 。都是Object的方法。并不是Thread独有的。 这里要明确 线程等待的就是一个对象发出的信号，所以要基于对象而存在。 wait、 notify 必须在 synchronized 同步方法或块中调用 。 否则运行时会抛出 IllegalMonitorStateException 异常 。 // 为什么java规定 wait()，notify()和notifyAll()必须在同步块或同步方法中调用, // 而 suspend()、 resume()可以在任何地方都调用？ 1、首先suspend()、 resume()是基于线程存在的。 wait()、notify()基于对象存在的。 2、既然是基于对象的，此时在这个对象上可能同时有多个线程调用wait()/notify()方法， 依然存在并发的问题，理论上也需要一个锁来控制。 调用wait进入阻塞后，会释放占用的锁。 obj.wait( time ) ， 超时自动唤醒或者由notify( )、notifyAll()唤醒 进入就绪状态。 obj.wait( ) ，由notify( )、notifyAll( )唤醒 进入就绪状态。 调用wait会让当前线程释放这个对象的锁。 （线程此时不一定持有锁，如果没有锁就忽略，如果占有锁就会释放） 如果多个线程调用了某个对象的 wait() ， 对象的notify()被调用时 是随机选择一个线程唤醒 。 如果多个线程调用了某个对象的 wait() ， notifyAll()被调用时 将这些线程全部唤醒，抢到锁的那个线程 进入就绪状态 。 线程竞争对象的锁。 join() 线程A 里面 调用了 线程B.join() 。 此时线程A进入阻塞状态 ，线程B执行。 直到线程B执行完毕或者被打断，线程A才能恢复继续执行 。 主要用于线程之间的交互。 同步机制有哪些 同步方法 //锁住 当前方法 public synchronized void funcA(){ } //锁住 当前类 public static synchronized void funcB(){ } 同步代码块 synchronized(object) { //同步是一种高开销的操作，通常没有必要同步整个方法， //使用synchronized代码块同步关键代码即可。 } 使用 volatile //一个变量使用volatile后，它将具有以下两种特性： 1、此变量对所有线程可见。体现了 可见性。 当一条线程修改了这个变量的值，新的值对于其他线程来说是立即得知的。(普通变量不能实现这一点。) 2、 volatile 禁止CPU进行指令重排序优化。体现了 有序性 普通的变量可能会进行指令重排序，所以不能保证变量赋值操作的顺序与程序代码中的执行顺序一致。 重入锁 ReentrantLock boolean fair= false ;//fair为true表示是公平锁 。默认非公平。 ReentrantLock reentrantLock = new ReentrantLock(fair) ; private void func1(ReentrantLock lock){ //如果已经被锁定了 就会忽略。不会等待。 boolean result = lock.tryLock() //如果被锁定了，就会尝试等待指定时长。如果还没有就放弃等待。 boolean result = lock.tryLock(5 , TimeUnit.SECONDS) if(result){ try{ //执行相关操作 }finally{ //释放锁 lock.unlock(); } 使用 api LinkedBlockingQueue 阻塞队列 使用java封装的帮助类，实现多线程安全。 每次只允许 一个线程去队列里面存放对象 。 BlockingQueue outQueue = new LinkedBlockingQueue<>(Integer.MAX_VALUE); outQueue.put(msg); msg = outQueue.poll(); 使用 Java api Atomic 原子变量 java.util.concurrent.atomic包提供 Atomic 用CAS方式实现 原子操作。 原子操作就是指将读取变量值、修改变量值、保存变量值, 看成一个整体来操作,即这几种行为要么同时完成，要么都不完成。 根据java 定义，原子操作是不会被打断地的操作，因此被认为是线程安全的。 // 原子更新基本类型类 （没有 double 和float的封装类型） AtomicInteger atomicInt = new AtomicInteger(100); AtomicBoolean atomicBoolean = new AtomicBoolean(false); AtomicLong atomicLong = new AtomicLong(1000000); private void func1( ){ //原子更新数组类 int[]arrayInt ={1,30}; AtomicIntegerArray atomicIntArray = new AtomicIntegerArray(arrayInt); atomicIntArray.getAndSet(i, newValue); atomicIntArray.addAndGet(i, delta); //AtomicReferenceFieldUpdater 一个基于反射的工具类，它能对指定类的指定的volatile引用字段进行原子更新。(这个字段不能是private的) AtomicReferenceFieldUpdater updater=AtomicReferenceFieldUpdater.newUpdater(Dog.class,String.class,\"name\"); updater.compareAndSet(dog1,dog1.name,\"test\") ; //AtomicMarkableReference ,为解决 CAS 操作中潜在的 ABA 问题 设计的解决方案。 AtomicMarkableReference atomicMarkRef= new AtomicMarkableReference (\"StrMsg\", false) ; if(!atomicMarkRef.isMarked()){ atomicMarkRef.set(\"bbb\", true); }; //AtomicStampedReference 用法与 AtomicMarkableReference 类似 } 线程池 为什么要用线程池: 1、减少了创建和销毁线程的次数，每个工作线程都可以被重复利用，可执行多个任务。 2、可以根据系统的承受能力，调整线程池中工作线线程的数目，防止因为消耗过多的内存 newSingleThreadExecutor() 类型1 创建一个单线程的线程池。 这个线程池只有一个线程在工作，也就是相当于单线程串行执行所有任务。 如果这个唯一的线程异常结束，会有一个新的线程来替代它。 此线程池保证所有任务的执行顺序按照任务的提交顺序执行。 // interface ExecutorService ExecutorService pool = Executors.newSingleThreadExecutor(); pool.execute(runnable); newFixedThreadPool(n) 类型2 创建固定大小的线程池。 每次提交一个任务就创建一个线程，直到线程达到线程池的最大大小。 线程池的大小一旦达到最大值就会保持不变，如果某个线程因为执行异常而结束，那么线程池会补充一个新线程。 ExecutorService pool =Executors.newFixedThreadPool(10); pool.execute(runnable); newCachedThreadPool() 类型3 创建一个可缓存的线程池。 如果线程池的大小超过了处理任务所需要的线程，那么就会回收部分空闲（60秒不执行任务）的线程， 当任务数增加时，此线程池又可以智能的添加新线程来处理任务。 此线程池不会对线程池大小做限制， 线程池大小完全依赖于 JVM 能够创建的最大线程大小。 ExecutorService pool=Executors.newCachedThreadPool(); pool.execute(runnable); newScheduledThreadPool(n) 类型4 支持定时及周期性任务执行 。 // interface ScheduledExecutorService extends ExecutorService ScheduledExecutorService pool =Executors.newScheduledThreadPool(10); pool.scheduleAtFixedRate(runnable, initialDelay, period, unit); pool.execute(runnable); jva 官方 ScheduledThreadPoolExecutor 帮助类 ScheduledThreadPoolExecutor(n) 并不是第5种线程池类型，而是一个类， 用来生成 newScheduledThreadPool(n) 类型的线程池。 自JDK1.5开始，JDK提供了 ScheduledThreadPoolExecutor 类来支持周期性任务的调度。 在这之前的实现需要依靠 Timer 、 TimerTask 或者其它第三方工具来完成。 但Timer有不少的缺陷。 // ScheduledThreadPoolExecutor implements ScheduledExecutorService ScheduledThreadPoolExecutor pool =new ScheduledThreadPoolExecutor(10); pool.scheduleAtFixedRate(runnable, initialDelay, period, unit); pool.execute(runnable); 第三方 guava-17.0.jar 线程池帮助类 可以使用 guava-17.0.jar 中的一些更方便地使用线程池。 该 jar包封装了一些方法，可以让我们方便地自定义 核心线程数、最大线程数量，拒绝策略，超时时间等。 public class MyThreadPoolTool { private ExecutorService threadPool = null ; public MyThreadPoolTool(){ } private ExecutorService getThreadPool() { if (threadPool == null) { // guava-17.0.jar ThreadFactory threadFactory = new ThreadFactoryBuilder().setNameFormat(\"wk-pool-%d\").build(); RejectedExecutionHandler handler =new ThreadPoolExecutor.AbortPolicy(); if (threadPool == null) { threadPool = // 核心线程数量 ,最大线程数量 , 空闲时间 ， 时间单位 ，任务队列 ，创建工厂 ，异常提示 // 当线程池数量超过 corePoolSize 以后，空闲时间超过 keepAliveTime 线程会被终止 new ThreadPoolExecutor( 100 , 100 , 100 , TimeUnit.MICROSECONDS , new LinkedBlockingQueue(Integer.MAX_VALUE) , threadFactory , handler ) ; } } return threadPool; } public void addTask(Runnable runnable) { if (threadPool == null) { getThreadPool(); } // 如果你配置的拒绝策略是 AbortPolicy // 显式地shutdown()之后，再向线程池提交任务时 //会抛出ThreadPoolExecutor$AbortPolicy.rejectedExecution if(!threadPool.isShutdown()) { threadPool.submit(runnable) ; } } public void isShutdown() { if (threadPool != null) { if(!threadPool.isShutdown()) { threadPool.shutdownNow() ; } } } } 阿里巴巴开发规范 ,不允许使用 Executors 来创建线程池 规范要求线程池不允许使用Executors去创建，而是通过 ThreadPoolExecutor 的方式， 这样的处理方式让写的同学更加明确线程池的运行规则，规避资源耗尽的风险。 线程池拒绝策略 RejectedExecutionHandler handler1 =new ThreadPoolExecutor.AbortPolicy(); // 丢弃任务并抛出 RejectedExecutionException 异常。 RejectedExecutionHandler handler2 =new ThreadPoolExecutor.DiscardPolicy(); // 丢弃任务，但是不抛出异常 RejectedExecutionHandler handler3 =new ThreadPoolExecutor.DiscardOldestPolicy(); // 丢弃队列最前面的任务，然后重新提交被拒绝的任务 RejectedExecutionHandler handler4 =new ThreadPoolExecutor.CallerRunsPolicy(); // 由调用线程（提交任务的线程）处理该任务 线程池 如何设置 任务优先级 给线程池配置 PriorityBlockingQueue 而不是 LinkedBlockingQueue 。 PriorityBlockingQueue 是具有优先级的队列，传入的对象必须实现comparable接口。 每次添加一个元素，PriorityBlockingQueue 中 的 对象 都会执行 compareTo() 进行排序。 // 注意：优先级仅在有任务等待执行时才有意义。 假如核心线程设置为 10 ，但是你同时提交了5个线程，因为资源充足， 并不一定会按照 优先级 顺序执行，而是同时执行。 只有核心线程不足时，才会按照优先级执行。 public class PrioritizedRunnable implements Runnable, Comparable { private int priority; PrioritizedRunnable(int priority ) { this.priority = priority; } @Override public int compareTo(PrioritizedRunnable secondOne) { return Integer.compare(secondOne.priority, priority); } @Override public void run() { SystemClock.sleep(10); WkLogTool.showLog(\"priority=\"+priority); } } private void testThreadPool( ){ ThreadPoolExecutor executor = new ThreadPoolExecutor( 1, 20, // 测试的时候 注意 corePoolSize 的设置 Long.MAX_VALUE, TimeUnit.NANOSECONDS, new PriorityBlockingQueue<>()); executor.execute( new PrioritizedRunnable(5)); executor.execute( new PrioritizedRunnable(1)); executor.execute( new PrioritizedRunnable(4)); executor.execute( new PrioritizedRunnable(49)); executor.execute( new PrioritizedRunnable(3)); executor.execute( new PrioritizedRunnable(2)); executor.execute( new PrioritizedRunnable(100)); // java.util.concurrent.FutureTask cannot be cast to java.lang.Comparable //executor.submit(runnable1) ; } // 补充：经过测试，执行的顺序 不一定是 100 、49、...1， // 还有可能是 4、100、... 原因猜测是(不太确定，以后再补充)：Java是抢占式的，优先级高只是优先让当前线程执行， 并不保证优先级高的一定先执行。 如何禁止用户 手动创建 线程 使用 自定义 lint 。 如果发现 new Thread ,不让编译通过。 手动写一个线程池 弄懂线程池的原理就行，其他的无非就是细节问题。 // 模拟线程池 public class SimpleThreadPoolExecutor { // 最大任务数量，超过就不进队列。 private final int maximumPoolSize; // 核心线程数,默认值3 private volatile int threadSize = 3; //LinkedBlockingQueue 是线程安全的阻塞队列 private final BlockingQueue workQueue; //目前运行的线程数 private final AtomicInteger threadCount = new AtomicInteger(0); public SimpleThreadPoolExecutor() { //任务上限6，超过拒绝任务。注意：设置小点只是为了好观察。 this.maximumPoolSize = 3; workQueue = new LinkedBlockingQueue<>(); } public SimpleThreadPoolExecutor(int threadSize,int maximumPoolSize ) { this.threadSize = threadSize; this.maximumPoolSize = maximumPoolSize; this.workQueue = new LinkedBlockingQueue<>(); } //新建线程和添加任务 public void execute(Runnable task) { if (threadCount.get() maximumPoolSize){ System.out.println(\"超过最大任务数，拒绝添加任务。thread Count：\"+workQueueSize); return; } //add ：如果队列超过定义队列大小， 会抛出异常。 workQueue.add(task); } private void startThread(int nameTag) { Thread thread = new Thread() { @Override public void run() { super.run(); while (true) { Runnable task = workQueue.take();//没有任务就阻塞,多个线程都会调用这个队列 task.run(); // 执行任务 } } }; thread.setName(\"tag:\" + nameTag); thread.start(); } } // 测试运行 public class SimulationThreadTest { public static void main(String[] args) { productionTask( ); } private static void productionTask( ) { SimpleThreadPoolExecutor executor=new SimpleThreadPoolExecutor(3,10 ); new Thread() { @Override public void run() { super.run(); while (true) { System.out.println(\"添加任务\"); executor.execute(new Runnable() { @Override public void run() { int sleep = getRadomInt(1,5) * 1000; Thread.sleep(sleep); System.out.println(\"任务执行完毕\"); } }); sleep(1000); } } }.start();; } private static int getRadomInt(int startNum, int endNum){ return new Random().nextInt(endNum - startNum + 1) + startNum; } } ( no Copyright，enjoy youself ! ) all right reserved，powered by GitbookThe file was updated at : 2021-07-12 10:15:49 "},"chinese/java基础/java注解.html":{"url":"chinese/java基础/java注解.html","title":"注解详解","keywords":"","body":"java 注解 注解是在 Java 1.5 中开始引入的概念。 注解配合反射可以在 运行时 处理注解、 配合 apt tool可以在编译期处理注解。 在JDK1.6的时候，apt (Annotation Processing Tool 注解处理工具) 被整合到了javac 中。 注解本身只起到一个标记和传值的作用， 有没有注解都不影响程序的运行， 注解的作用取决于对于注解元素的处理。 得当的使用注解，可以极大的提高开发效率，避免编写重复、易错的代码。 元注解 元注解是一种基本注解，它能够应用到其它的注解上面。 @Retention 说明了这个注解的的存活时 @Retention(RetentionPolicy.RUNTIME) @Retention(RetentionPolicy.SOURCE ) @Retention(RetentionPolicy.CLASS ) @Documented 能将注解中的元素包含到Javadoc中去 @Target 指定了注解运用的地方 @Target(ElementType.ANNOTATION_TYPE ) //可以给一个注解进行注解 @Target(ElementType.CONSTRUCTOR ) //可以给构造方法进行注解 @Target(ElementType.FIELD ) // 可以给属性进行注解 @Target(ElementType. LOCAL_VARIABLE) //可以给局部变量进行注解 @Target(ElementType.METHOD ) // 可以给方法进行注解 @Target(ElementType. PACKAGE) //可以给一个包进行注解 @Target(ElementType.PARAMETER ) //可以给一个方法内的参数进行注解 @Target(ElementType.TYPE ) //可以给一个类型进行注解，比如类、接口、枚举 @Inherited 用于放在注解上 。 当 @Inherited 注解加在某个类A上时，假如类B继承了A，则B也会带上该注解。 @Repeatable Java 1.8 才有 重复注解， 注解的值可以同时取多个 @Target(ElementType.FIELD) @Retention(RetentionPolicy.CLASS) public @interface Role { String role() default \"大佬\"; } //如果 Role 注解没有被 Repeatable 修饰的话，以下会报错的 @Role(role = \"小兵\") @Role(role = \"大佬\") public Person person ; java 部分内置注解 @SuppressWarnings 阻止编译器报警告提示 @SuppressWarnings(\"all\") // 抑制所有警告 @SuppressWarnings(\"boxing\") // 抑制装箱、拆箱操作时候的警告 @SuppressWarnings(\"cast\") // 抑制映射相关的警告 @SuppressWarnings(\"dep-ann\") // 抑制启用注释的警告 @SuppressWarnings(\"deprecation\") // 抑制过期方法警告 @SuppressWarnings(\"fallthrough\") // 抑制确在switch中缺失breaks的警告 @SuppressWarnings(\"finally\") // 抑制finally模块没有返回的警告 @SuppressWarnings(\"hiding\") // 忽略 关于隐藏的本地变量的警告 @SuppressWarnings(\"incomplete-switch\") // 忽略没有完整的switch语句 @SuppressWarnings(\"nls\") // 忽略非nls格式的字符 @SuppressWarnings(\"null\") // 忽略对null的操作 @SuppressWarnings(\"rawtypes\") // 使用generics时忽略没有指定相应的类型 @SuppressWarnings(\"restriction\") // 忽略 使用不建议或者禁止的引用的警告 @SuppressWarnings(\"serial\") // 忽略在serializable类中没有声明serialVersionUID变量 @SuppressWarnings(\"static-access\") // 抑制不正确的静态访问方式警告 @SuppressWarnings(\"synthetic-access\") // 抑制子类没有按最优方法访问内部类的警告 @SuppressWarnings(\"unchecked\") // 抑制没有进行类型检查操作的警告 @SuppressWarnings(\"unqualified-field-access\") // 抑制没有权限访问的域的警告 @SuppressWarnings(\"unused\") // 抑制没被使用过的代码的警告 @SafeVarargs JDK 7 才有。 阻止编译器产生 unchecked 这样的警告，效果跟 @SuppressWarnings(\"unchecked\")相同 使用了这种注解后，开发者要确保自己的类型转换是没有问题的，否则运行时可能会报错。 @FunctionalInterface Java 1.8 才有 。 当你写的接口不符合函数式接口定义的时候，编译器会报错。 注解的属性 (成员变量) 注解本身只起到标记的作用， 如果想要给标记的对象传递数据，还需要给注解定义一些属性 。 注意 注解只有属性，没有方法。 注解的属性在注解的定义中以“无形参的方法”形式来声明， 其方法名定义了该 属性 的名字，其返回值定义了该 属性 的类型。 @Retention(RetentionPolicy.RUNTIME) public @interface TestAnnotation { // 给 TestAnnotation 注解定义了2个属性 age 、name public int age() default -1; // 无参方法 age() public String name() default \"aivin\"; } // 使用注解的属性 @TestAnnotation( name = \"tom\",age = 22) public Person person; 运行时注解 运行时注解就是在程序运行的时候通过反射获取到注解然后做处理。 在Java语言中， 所有实现了 java.lang.reflect.AnnotatedElement 接口 的元素，都是可以被注解的元素 例如 Class，Method，Field，Constructor，Package 等， 都可以利用 反射机制获得它的注解 。 自定义 运行时注解 一般在制作自己的框架或者某种小工具时，我们可以使用自定义注解。 注意, 如果仅仅自定义了注解，并使用在代码中。这些注解并不会起作用。 如果想要真正使用上它们，你还得利用反射等原理写一个工具类来解析它。 @Retention(RetentionPolicy.RUNTIME) public @interface TestAnnotation { public int age() default -1; public String name() default \"aivin\"; } @TestAnnotation (name = \"类设置的名字\") public class Person { @TestAnnotation( name = \"属性设置的名字\",age = 22) public Student mystudent; @TestAnnotation( name = \"方法设置的名字\",age = 23) public void setInfo(int age ,String name){ } } public static void getFruitInfo( Class clz ){ boolean isAnnota = clz.isAnnotationPresent(TestAnnotation.class); if(isAnnota){ TestAnnotation testAnnotation = clz.getAnnotation(TestAnnotation.class); System.out.println(clz.getSimpleName()+\"--->\"+testAnnotation.name()); System.out.println(clz.getSimpleName()+\"--->\"+testAnnotation.age()); }else{ System.out.println(\"类没有使用注解\" ); } Field[] fields = clz.getDeclaredFields(); for(Field field :fields){ field.setAccessible(true); // Field field =clz.getDeclaredField(\"mystudent\"); // 获取指定变量的属性 TestAnnotation testAnnotation1 = field.getAnnotation(TestAnnotation.class); if ( testAnnotation1 != null ) { System.out.println(clz.getSimpleName()+\" ->\"+ field.getName()+ \"--->\"+testAnnotation1.name()); System.out.println(clz.getSimpleName()+\" ->\"+ field.getName()+\"--->\"+testAnnotation1.age()); } } Method[] methods = clz.getDeclaredMethods(); for(Method method : methods){ method.setAccessible(true); //clz.getDeclaredMethod(\"setInfo\" ,int.class ,String.class); // 获取指定方法 TestAnnotation testAnnotation2 = method.getAnnotation(TestAnnotation.class); if ( testAnnotation2 != null ) { System.out.println(clz.getSimpleName()+\" ->\"+ method.getName()+ \"--->\"+testAnnotation2.name()); System.out.println(clz.getSimpleName()+\" ->\"+ method.getName()+\"--->\"+testAnnotation2.age()); } } } // 测试 @Test public void myTest() { MyTool.getFruitInfo( Person.class); } 运行时注解 的不足 运行时注解 可能会因为java反射而引起较为严重的性能问题 。 当然因为不用生成额外的代理文件，与编译时注解相比， 可以减少apk的大小。 编译时注解 apt 在编译时获取注解，以我们的源码作为输入，获取注解中的信息，重新输出一份java代码。 因为在是在编译器就将最终的代码生成了，所以并不会像反射那样 影响性能。 android-apt 作者在官网发表声明证实了后续将不会继续维护 android-apt， 并推荐大家使用 Android 官方插件提供的相同能力。 Android Gradle 插件提供了名为 annotationProcessor 的功能来完全代替 android-apt。 自定义 编译时注解 ( 基于Androidstudio) 自定义编译时注解流程与原理 1、自定义注解 2、自定义 处理器 并注册 ( extends AbstractProcessor ) 3、编译生成代理文件，并打包到apk(插件会自动打包到apk) 4、代码中直接调用代理类。 注解处理器是一个在javac编译期处理注解的工具， 在编译期你创建的处理器以Java代码作为输入，生成文件.java文件作为输出。 新的Java文件 本质上就是一个代理类，需要开发在开发中手动调用代理类。 注解处理器不能修改已经存在的Java类 (不能向已有的类中添加方法),只能生成新的Java类。 在编译期扫描 .java 文件的注解，并传递到注解处理器， 注解处理器可根据注解生成新的.java文件， 这些新的.java问和原来的.java一起被 javac编译。 在 Androidstudio 中 使用 编译时注解， 我们需要 依赖 com.google.auto.service:auto-service 和 rt.jar 的 AbstractProcessor 来实现。 自定义 编译时注解 demo 解析 注解并生成 新的Java文件，有两种方式 1、手动拼接 (能更深刻地了解流程) 2、使用 javapoet 插件 生成 (能简化代码) // 注解模块依赖 // 因为一些类 Android系统中已经删除，所以只能是 java 类型的lib implementation 'com.google.auto.service:auto-service:1.0-rc3' annotationProcessor 'com.google.auto.service:auto-service:1.0-rc6' implementation 'com.squareup:javapoet:1.8.0' // app 模块的依赖 annotationProcessor project(':butterknife_compiler') implementation project(':butterknife_compiler') demo地址 https://gitee.com/hnyer/annotation-test Java反射 JAVA反射机制是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法； 对于任意一个对象，都能够调用它的任意方法和属性； 这种动态获取信息以及动态调用对象方法的功能称为java语言的反射机制。 反射可以 修改 final 修饰的字段吗 对静态的final修饰的字段(赋值或者不赋值)进行修改， 都会报错：java.lang.IllegalAccessException错误。 对于非静态的final成员变量，在没有赋值的情况下是可以使用反射对其进行赋值的； 对于已经初始化赋值的变量，反射不能真正该变变量的值， 虽然用反射 fieldXX.get(bean)方法可以获得新值，但是用对象实例访问得到的是旧值。 private final String v1 = null; private final String v2 = \"v2\"; FinalDemo finalDemo = new FinalDemo(); Field f1 = finalDemo.getClass().getDeclaredField(\"v1\"); Field f2 = finalDemo.getClass().getDeclaredField(\"v2\"); f1.setAccessible(true); f2.setAccessible(true); f1.set(finalDemo, \"new_v1\"); f2.set(finalDemo, \"new_v2\"); finalDemo.getV1()); // new_v1 f1.get(finalDemo)); // new_v1 finalDemo.getV2()); // V2 f2.get(finalDemo)); // new_v2 Android 注解库 如果代码运行时不符合注解指定的条件就会报错， 比如标记了是 @MainThread ，但是在子线程中运行，就会报错 implementation 'com.android.support:support-annotations:28.0.0' 如果有添加 androidx 、material 等依赖，无需再添加 annotations 依赖 implementation 'androidx.appcompat:appcompat:1.0.2' implementation 'com.google.android.material:material:1.2.0' 注解名 释义 修饰类型 @AnimatorRes 用于描述一个整型的参数或字段，或者是一个期望返回 animator 资源引用的方法（例如：android.R.animator.fade_in） 参数、字段、方法 @AnimRes 用于描述一个整型的参数或字段，或者是一个期望返回 anim 资源引用的方法（例如：android.R.anim.fade_in） 参数、字段、方法 @AnyRes 用于描述一个整型的参数或字段，或者是一个期望返回任意资源引用的方法 参数、字段、方法 @AnyThread 被注解的元素可以在任意线程被调用 方法、构造器、类、接口、枚举 @ArrayRes 用于描述一个整型的参数或字段，或者是一个期望返回 array 资源引用的方法（例如：android.R.array.phoneTypes） 参数、字段、方法 @AttrRes 用于描述一个整型的参数或字段，或者是一个期望返回 attr 资源引用的方法（例如：android.R.attr.action） 参数、字段、方法 @BinderThread 用于描述一个方法、构造器、类、接口、枚举应该运行在 binder 线程 方法、构造器、类、接口、枚举 @BoolRes 用于描述一个整型的参数或字段，或者是一个期望返回 boolean 资源引用的方法 参数、字段、方法 @CallSuper 用于描述子类方法，希望它们重写父类方法时也要通过 super.() 调用父类方法 方法 @CheckResult 用于描述一个方法，如果它的返回值被忽略了，那么就会报错 方法 @ColorInt 用于描述一个整型的参数或字段，或者是一个期望返回 int 类型颜色值的方法 参数、字段、方法 @ColorLong 用于描述一个整型的参数或字段，或者是一个期望返回 long 类型颜色值的方法 参数、字段、方法 @ColorRes 用于描述一个整型的参数或字段，或者是一个期望返回 color 资源引用的方法（例如：android.R.color.black） 参数、字段、方法 @DimenRes 用于描述一个整型的参数或字段，或者是一个期望返回 dimension 资源引用的方法（例如：android.R.dimen.app_icon_size） 参数、字段、方法 @Dimension 用于描述一个整型的参数或字段，或者是一个期望返回 dimension 的方法 参数、字段、方法、注解 @DrawableRes 用于描述一个整型的参数或字段，或者是一个期望返回 drawable 资源引用的方法（例如：android.R.attr.alertDialogIcon） 参数、字段、方法 @FloatRange 描述一个参数、字段或方法的返回值是一个指定范围内的 float 或 double 类型的值 参数、字段、方法 @FractionRes 用于描述一个分数类型的参数或字段，或者是一个期望返回 fraction 资源引用的方法 参数、字段、方法 @HalfFloat 用于描述一个半精度类型的参数或字段，或者是一个期望返回半精度值的方法 参数、字段、方法 @IdRes 用于描述一个整型的参数或字段，或者是一个期望返回 id 资源引用的方法（例如：android.R.id.copy） 参数、字段、方法 @IntDef 用于描述一个注解，然后再用这个被描述的注解去描述一个整形的参数或字段，或者是一个期望返回值是显示声明常量之一的方法 注解 @IntegerRes 用于描述一个整型的参数或字段，或者是一个期望返回 integer 资源引用的方法（例如：android.R.integer.config_shortAnimTime） 参数、字段、方法 @InterpolatorRes 用于描述一个整型的参数或字段，或者是一个期望返回 integer 资源引用的方法（例如：android.R.interpolator.cycle） 参数、字段、方法 @IntRange 描述一个参数、字段或方法的返回值是一个指定范围内的 int 类型的值 参数、字段、方法 @Keep 被注解的元素不会被混淆 包、参数、字段、方法、类、接口、枚举、注解、构造器 @LayoutRes 用于描述一个整型的参数或字段，或者是一个期望返回 layout 资源引用的方法（例如：android.R.layout.list_content） 参数、字段、方法 @MainThread 被注解的元素只能在主线程被调用 方法、构造器、类、接口、枚举 @MenuRes 用于描述一个整型的参数或字段，或者是一个期望返回 menu 资源引用的方法（例如：android.R.menu.content） 参数、字段、方法 @NonNull 用于描述一个参数或字段、或者一个方法的返回值不为空 参数、字段、方法 @Nullable 用于描述一个参数或字段、或者一个方法的返回值可为空 参数、字段、方法 @PluralsRes 用于描述一个整型的参数或字段，或者是一个期望返回 plurals 资源引用的方法（例如：android.R.plurals.ph） 参数、字段、方法 @Px 用于描述一个整型的参数或字段，或者是一个期望返回像素尺寸的方法 参数、字段、方法 @RawRes 用于描述一个整型的参数或字段，或者是一个期望返回 raw 资源引用的方法（例如：android.R.raw.ph） 参数、字段、方法 @RequiresApi 被注解的元素只能在被给的 API 版本或更高情况下才能被调用 类、接口、枚举、方法、构造器、字段 @RequiresPermission 被注解的元素需要或者可能需要一个或多个权限 注解、方法、构造器、字段 @RequiresPermission.Read @RequiresPermission.Write @RestrictTo 被注解的元素只能在特定的范围内被访问 注解、类、接口、枚举、方法、构造器、字段、包 @Size 被注解的元素需要提供其大小或长度 参数、字段、方法、注解 @StringDef 用于描述一个注解，然后再用这个被描述的注解去描述一个 string 类型的参数或字段，或者是一个期望返回值是显示声明常量之一的方法 注解 @StringRes 用于描述一个整型的参数或字段，或者是一个期望返回 string 资源引用的方法（例如：android.R.string.ok） 参数、字段、方法 @StyleableRes 用于描述一个整型的参数或字段，或者是一个期望返回 styleable 资源引用的方法（例如：android.R.styleable.TextView_text） 方法、参数、字段 @StyleRes 用于描述一个整型的参数或字段，或者是一个期望返回 style 资源引用的方法（例如：android.R.style.TextAppearance） 方法、参数、字段 @TransitionRes 用于描述一个整型的参数或字段，或者是一个期望返回 transitionRes 资源引用的方法（例如：android.R.transition.fade） 方法、参数、字段 @UiThread 被注解的元素只能在主线程被调用 方法、构造器、类、接口、枚举 @WorkerThread 被注解的元素只能在工作线程被调用 方法、构造器、类、接口、枚举 @XmlRes 用于描述一个整型的参数或字段，或者是一个期望返回 xml 资源引用的方法（例如：android.R.xml.test） 参数、字段、方法 @SuppressLint Lint 静态检测工具将会忽略被注解元素的警告 类、字段、方法、参数、构造器 @TargetApi Lint 静态检测工具将会以指定 API 版本对待被注解元素 类、接口、枚举、方法、构造器 ( no Copyright，enjoy youself ! ) all right reserved，powered by GitbookThe file was updated at : 2021-05-23 15:20:37 "},"chinese/java基础/数据解析.html":{"url":"chinese/java基础/数据解析.html","title":"数据解析","keywords":"","body":"数据解析 json解析 fastjson 阿里出品 ，零依赖 。 https://github.com/alibaba/fastjson compile 'com.alibaba:fastjson:1.1.70.android' String detail = JSON.toJSONString(listToStore) ; //list数组转string JSONArray array = JSONArray.parseArray( string ); // string 转json数组 List saveBeans = JSONObject.parseArray(array.toJSONString(), XXBean.class); // JSONArray 转List对象 XXBean item = JSON.parseObject(string, XXBean.class); //json字符串转对象 # fastjson 配置 ↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓ -keepattributes Singature -keepattributes *Annotation -dontwarn com.alibaba.fastjson.** -dontskipnonpubliclibraryclassmembers -dontskipnonpubliclibraryclasses -keep class com.alibaba.fastjson.**{*;} -keep class * implements java.io.Serializable { *; } # fastjson 配置 ↑↑↑↑↑↑↑↑↑↑↑↑ 注意：json转 Javabean，要实现接口 implements Serializable 实体类生成插件 GsonFormat 可以根据json字符串 快速生成对应的Java类 使用方法： 新建一个类 ---> 在类里面右键 ---> Generate ---> GsonFormat Protocol Buffer developers protobuf github protobuf 相比于XML或Json格式存储数据， 数据量较大时，通过Protocol Buffers来定义的文件体积更小，解析速度更快 。 //感觉跟自定义私有协议差不多，只是proto使用起来会更方便一点，比如数据的转换和拓展... 1、引入辅助插件protobuf-gradle-plugin // 最新版本请参考官网 https://github.com/google/protobuf-gradle-plugin classpath 'com.google.protobuf:protobuf-gradle-plugin:0.8.12' // (项目最外层build.gradle) 2、导入 protocol库 （考虑到文件大小，Android采用精简版 protobuf-lite） // 具体版本请参考 https://search.maven.org/artifact/com.google.protobuf/protobuf-lite compile \"com.google.protobuf:protobuf-lite:3.0.1\" //app层build.gradle 3、应用插件 apply plugin: 'com.google.protobuf' // app层build.gradle 4、其他配置 // app层build.gradle protobuf { protoc { artifact = 'com.google.protobuf:protoc:3.0.0' } plugins { javalite { artifact = 'com.google.protobuf:protoc-gen-javalite:3.0.0' } } generateProtoTasks { all().each { task -> task.builtins { remove java } task.plugins { javalite { } } } } } 5、编写.proto文件 在src\\main\\ 目录下新建proto文件夹 ，新建 xxx.proto文件 // 版本号为3 syntax = \"proto3\"; //自动生成的对应的Java文件放这个目录下 option java_package = \"com.myProto.pack\"; // java_multiple_files 为true时，生成的Java类将是包级别的，否则会在一个包装类中。 option java_multiple_files = true; // 该文件对应的Java类名，不用写了，因为 message Person已经写了 //option java_outer_classname = \"Person\"; message Person { //proto3 已经取消了默认值的设置。 // 这里的1 2 3是字段号，不是默认值 string name =1; bool isMan =2; int32 age =3; double money =4; string phone =5 ; } 6、编译工程，系统就会自动生成对应的Java文件。 7、Java层使用和解析数据 private void test(){ Person person = Person.newBuilder(). setName(\"aivin666\") .setIsMan(true) .setAge(20) .setMoney(1000) .setPhone(\"13650909087\") .build(); byte[] dataSend = person.toByteArray();// 对象转byte[] Person result = Person.parseFrom(dataSend); //byte[]转对象 } ( no Copyright，enjoy youself ! ) all right reserved，powered by GitbookThe file was updated at : 2021-05-06 08:42:12 "},"chinese/java基础/java8新特性.html":{"url":"chinese/java基础/java8新特性.html","title":"Java8新特性","keywords":"","body":"java8新特性 java8新特性 说明 1、Lambda表达式 - 2、接口的默认方法与静态方法 - 3、方法引用 - 4、重复注解 - 5、扩展注解的支持 6、Optional - 7、Stream - 8、Date/Time API (JSR 310) - 9、JavaScript引擎Nashorn 10、Base64 java8对Base64进行优化后，放到java.util包下 Java Lambda Lambda是Java8的新特性 ，是一个语法糖 // 语法格式 (params) -> expression (params) -> statement (params) ->{ statements; } // List循环 List list = ...; list.forEach( reslut -> { reslut +=\"_修改过\" ; }); // 循环输出 list.forEach(System.out::println); //Map循环 Map map =...; map.forEach( (key ,value)-> { value +=100 ; }); map.forEach( ( key ,value ) -> System.out.println( \"key=\"+key +\" value=\"+value) ); // List 条件过滤 List result1 = // 将list转为 流 list.stream() // 将符合条件的元素过滤出来 .filter( line -> line.contains(\"aa\")) // 收集并将输出的流转为 list .collect(Collectors.toList()); result1.forEach(System.out::println); // 对象排序 List listSort= ... ; listSort.sort( (Student stu1 , Student stu2) -> stu1.age- stu2.age); listSort.forEach( (sutdent) -> { System.out.println(sutdent.name+\" : \"+sutdent.age); }); 接口的默认方法与静态方法 public interface MyMathTool { // 被 default关键字 修饰过的 sqrt 方法 将在子类上可以直接使用. // 可以有多个 默认方法 default double sqrt(int a) { return Math.sqrt(a); } } // 被 static修饰的方法 ，跟普通类的静态方法一样可以直接调用 // 可以有多个 静态方法 static double cacle(int a, int b){ return a+b ; } 方法引用 方法引用是 lambda 表达式的一种语法糖, 为了简化代码和加速开发。 当我们想要实现一个函数式接口的那个抽象方法，但是已经有类实现了我们想要的功能， 这个时候我们就可以用方法引用来直接使用现有类的功能去实现。（至于为什么可以这样，我暂时还不知道，没看源码。） 方法引用规定：实现抽象方法的参数列表，必须与方法引用方法的参数列表保持一致。返回值就不作要求。 引用分类 分类 说明 引用方法 类名::静态方法名 类名::实例方法名 实例::实例方法名 引用构造器 引用数组 // 实例::实例方法名 Consumer consumer = System.out::println; consumer.accept(\"This is Major Tom\"); // 类名::静态方法名 Function f = Math::abs; Long result = f.apply(-3L); // 类名::实例方法名 // 这个地方有点不太好理解。 // 可以暂时这样理解： 生成了一个 BiPredicate 实例b ， // 并且 b中的 方法 test里面的内容和 String类的静态方法 equals 一模一样 BiPredicate b = String::equals; b.test(\"abc\", \"abcd\"); // 引用构造器 Function fun = StringBuffer::new; StringBuffer buffer = fun.apply(10); // 引用数组 Function fun2 = Integer[]::new; Integer[] arr2 = fun2.apply(10); 函数式接口 Functional Interface 为了更友好的支持 Lambda 表达式，Java 8引入了函数式接口的概念。 所谓的函数式接口，就是是一个接口，这个接口只能有一个 抽象方法 。 1、Java 8为函数式接口引入了一个新注解 @FunctionalInterface，主要用于编译级错误检查， 加上该注解，当你写的接口不符合函数式接口定义的时候，编译器会报错。 2、加不加@FunctionalInterface对于接口是不是函数式接口没有影响， 该注解只是提醒编译器去检查该接口是否仅包含一个抽象方法 3、函数式接口里是可以包含默认方法 、静态方法、Object里的public方法 当一个类是函数式接口的时候，我们可以直接使用Lambda表达式来实例化它， 而不用写很多模板式代码。 @FunctionalInterface public interface Consumer { void accept(String msg); } // 传统 命令式、面向对象 编程 Consumer consumer = new Consumer() { @Override public void accept(String msg) { } }; // Lambda 表达式写法 更简洁 Consumer consumer2 = (String msg) -> { } ; 内置的函数式接口 为了方便开发者，java8内置了一批函数式接口。 Java8内置的函数式接口 参数类型 返回类型 用途 Consumer T void 对类型T参数操作，无返回结果，包含方法 void accept(T t) Supplier 无 T 返回T类型参数，方法时 T get() Function T R 对类型T参数操作，返回R类型参数，包含方法 R apply（T t） Predicate T boolean 断言型接口，对类型T进行条件筛选操作，返回boolean，包含方法 boolean test（T t） BinaryOperator T,T T 对类型T对象进行二元运算，并返回T类型的结果，包含方法T apply(T t1,T t2) BigConsumer T,U void 对类型T，u参数进行操作，包含方法void accept（T t,U u） BiConsumer 代表了一个接受两个输入参数的操作，并且不返回任何结果 BiFunction 代表了一个接受两个输入参数的方法，并且返回一个结果 BinaryOperator 代表了一个作用于于两个同类型操作符的操作，并且返回了操作符同类型的结果 BiPredicate 代表了一个两个参数的boolean值方法 BooleanSupplier 代表了boolean值结果的提供方 Consumer 代表了接受一个输入参数并且无返回的操作 DoubleBinaryOperator 代表了作用于两个double值操作符的操作，并且返回了一个double值的结果。 DoubleConsumer 代表一个接受double值参数的操作，并且不返回结果。 DoubleFunction 代表接受一个double值参数的方法，并且返回结果 DoublePredicate 代表一个拥有double值参数的boolean值方法 DoubleSupplier 代表一个double值结构的提供方 DoubleToIntFunction 接受一个double类型输入，返回一个int类型结果。 DoubleToLongFunction 接受一个double类型输入，返回一个long类型结果 DoubleUnaryOperator 接受一个参数同为类型double,返回值类型也为double 。 IntBinaryOperator 接受两个参数同为类型int,返回值类型也为int 。 IntConsumer 接受一个int类型的输入参数，无返回值 。 IntFunction 接受一个int类型输入参数，返回一个结果 。 IntPredicate 接受一个int输入参数，返回一个布尔值的结果。 IntSupplier 无参数，返回一个int类型结果。 IntToDoubleFunction 接受一个int类型输入，返回一个double类型结果 。 IntToLongFunction 接受一个int类型输入，返回一个long类型结果。 IntUnaryOperator 接受一个参数同为类型int,返回值类型也为int 。 LongBinaryOperator 接受两个参数同为类型long,返回值类型也为long。 LongConsumer 接受一个long类型的输入参数，无返回值。 LongFunction 接受一个long类型输入参数，返回一个结果。 LongPredicate R接受一个long输入参数，返回一个布尔值类型结果。 LongSupplier 无参数，返回一个结果long类型的值。 LongToDoubleFunction 接受一个long类型输入，返回一个double类型结果。 LongToIntFunction 接受一个long类型输入，返回一个int类型结果。 LongUnaryOperator 接受一个参数同为类型long,返回值类型也为long。 ObjDoubleConsumer 接受一个object类型和一个double类型的输入参数，无返回值。 ObjIntConsumer 接受一个object类型和一个int类型的输入参数，无返回值。 ObjLongConsumer 接受一个object类型和一个long类型的输入参数，无返回值。 Predicate 接受一个输入参数，返回一个布尔值结果。 Supplier 无参数，返回一个结果。 ToDoubleBiFunction 接受两个输入参数，返回一个double类型结果 ToDoubleFunction 接受一个输入参数，返回一个double类型结果 ToIntBiFunction 接受两个输入参数，返回一个int类型结果。 ToIntFunction 接受一个输入参数，返回一个int类型结果。 ToLongBiFunction 接受两个输入参数，返回一个long类型结果。 ToLongFunction 接受一个输入参数，返回一个long类型结果。 UnaryOperator 接受一个参数为类型T,返回值类型也为T。 函数式编程 functional programming 命令式 编程语言包括 过程式编程 和 面向对象编程(OOP) 。 函数式编程( FP ) 是一种 编程范式 ，是一种编程思想。 // 命令式编程 更加注重 “如何做”，主要思想是关注计算机执行的步骤，即一步一步告诉计算机先做什么再做什么。 // 声明式编程 主要思想是告诉计算机应该做什么，但不指定具体要怎么做，SQL语句就是最明显的一种声明式编程的例子。 //函数式编程 函数式编程和声明式编程是有所关联的，他们都只关注做什么而不是怎么做。 但函数式编程不仅仅局限于声明式编程。 OOP 关注对象方法的调用，而 FP关注函数之间的调用。 // 函数式编程的特点 1、函数是一等公民。函数可以作为参数 也可以作为返回值。 函数与其他数据类型一样，处于平等地位。 var print = function(i){ console.log(i);}; [1,2,3].forEach(print); // print 就是一个函数，可以作为另一个函数的参数。 2、无副作用。 所有功能就是返回一个新的值，没有其它行为，不修改外部的值 ,不改变 input。 3、引用透明 只依赖于输入的参数，任何时候只要参数相同，引用函数所得到的返回值总是相同的。 4、易于 并发编程 因为它不修改变量，所以根本不存在\"锁\"线程的问题。 总是感觉 Java8的函数式编程有点奇怪。 网上很多文章直接将 函数式编程跟 lambd 或 流式 对应。感觉不太对。 以下举例来自 阮一峰 的博客 现在有这样一个数学表达式 (1 + 2) * 3 - 4 ， 传统的过程式编程，可能这样写： var a = 1 + 2; var b = a * 3; var c = b - 4; 函数式编程要求使用函数，我们可以把运算过程定义为不同的函数，然后写成下面这样 var result = subtract( multiply( add(1,2) , 3), 4); 为什么 函数式编程 又被大量采用和支持 c++ 11 、Java8 都纷纷加入支持 1、精简代码，去掉冗余的模板代码 2、函数式编程 天生的 可以并行特性 。 现在 cpu 和 内存 越来越够用 ， 对于越来越庞大的代码，与其 费大力气去 解决 各种锁和同步问题， 不如直接改用根本不会导致这些问题的 FP 方案 。 匿名函数 参考匿名类。 匿名函数就是一个没有名字的函数。 常与 Lambda 搭配使用 // 新建了一个Runnable 对象。省略了 Runnable 的run函数的名字. Runnable r = () -> System.out.println(\"Thread start...\"); new Thread(r).start(); Optional 是一个封装了一个元素的容器，而这个元素可以是null也可以是其它任意类型的。 Optional 的方法 说明 Optional.of(T t) 创建一个 Optional 实例 Optional.ofNullable(T t) 若 t 不为 null,创建 Optional 实例,否则创建空实例 Optional.empty() 创建一个空的 Optional 实例 optional.get() 获取Optional中的值 optional.isPresent() 判断optional对象是否有值 Stream 这个 Stream 并不是我们以前认识的IO流， 而是一个数据渠道，用于操作数据源（集合、数组等）所生成的元素序列。 Stream API 提供了一种高效且易于使用的处理数据的方式 ，例如 非常复杂的查找、过滤和映射数据等 。 Stream 不会改变源对象。它会返回一个持有结果的新Stream（这样可以链式编程）。 Stream 延迟执行 只要Stream的方法返回的对象是Stream，这些方法就是延迟执行的方法 。 一般在Stream流中，一个方法返回的不是Stream，基本就是 迫切方法 。 // 由集合创建 Stream List list = new ArrayList<>(); //获取一个顺序流 Stream stream = list.stream(); //获取一个并行流 Stream parallelStream = list.parallelStream(); // 由数组创建流 Integer[] nums = new Integer[8]; Stream stream3 = Arrays.stream(nums); // 由值创建流 Stream stream4 = Stream.of(1,2,3,4,5); // 由函数创建流 , 会不停打印一个随机数 Stream.generate(() -> Math.random()).forEach(System.out::println); Stream.iterate(1, (x) -> x + 1).forEach(System.out::println); // 筛选 ,自定义 List list2 = Arrays.asList(2, 3, 5, 4, 4,4, 1, 8, 10, 9, 7, 6); list2.stream() .filter((e) -> e > 5).forEach(System.out::println); // 筛选 ，去重 list2.stream() .distinct() .forEach(System.out::println); // 切割 ，限定个数 list2.stream().limit(3).forEach(System.out::println); // 返回一个去掉了前 n 个元素的流。若元素不足 n 个，则返回一个空流。 list.stream().skip(3).forEach(System.out::println); // 映射 , 将 参数 经过自定义处理后 再返回 list2.stream() .map(x -> x*x) .forEach(System.out::println); // 特殊的 映射操作 ， 结果一定要是 double类型 list2.stream() .mapToDouble(x -> x+0.1) .forEach(System.out::println); // 特殊的映射 ， 将流中的每个元素映射成一个流 list2.stream() .flatMap( xxx ) .forEach(System.out::println); // 按自然顺序排序 list2.stream() .sorted() .forEach(System.out::println); // 自定义排序 list.stream() .sorted( (x,y) -> -x.compareTo(y) ) .forEach(System.out::println); // 检查是否匹配所有元素 ,(是否全部元素都大于2) boolean allMatch = list2.stream() .allMatch(x -> x > 2); // 匹配元素位置 Optional first = list2.stream() .findFirst(); int val = first.get(); // 求最大值 最小值 Optional first1 = list2.stream() .min(Integer::compareTo); Optional first2 = list2.stream() .max(Integer::compareTo); Integer val1 = first.get(); // 将流中元素收集到List中 List resultList = list2.stream() .collect(Collectors.toList()); // 将流中元素收集到Set中 Set resultSet = list2.stream() .collect(Collectors.toSet()); 日期时间 API 在旧版的 Java 中，日期时间 API 存在很多问题，比如线程安全问题 、命名、设计、分包不合理等问题。 Java 8 提供的日期时间 API都在java.time包下， 这个包涵盖了所有处理日期(date)，时间(time)，日期/时间(datetime)， 时区（zone)，时刻（instant），间隔（duration）与时钟（clock）的操作 // 获取当前日期时间 LocalDateTime now = LocalDateTime.now(); int year = now.getYear(); int month = now.getMonthValue() ; int day = now.getDayOfMonth() ; // 将当前日期时间减去两天 LocalDateTime dateTime2 = now.minusDays(2); // 将当前日期时间加上五天 LocalDateTime dateTime3 = now.plusDays(5); // 构造一个指定日期时间的对象 , 年 月 日 时 分 LocalDateTime dateTime = LocalDateTime.of(2016, 10, 23, 8, 20); // 获取当前时间的时间戳 Instant instant = Instant.now(); // 结果跟System.currentTimeMillis()一样 long milli = instant.toEpochMilli(); // 时区偏移 OffsetDateTime dateTime4 = instant.atOffset(ZoneOffset.ofHours(8)); //时间间隔 LocalTime start = LocalTime.now(); LocalTime end = LocalTime.now(); Duration duration = Duration.between(start, end); // 日期间隔 LocalDate startDate = LocalDate.of(2015, 3, 4); LocalDate endDate = LocalDate.of(2017, 8, 23); Period period = Period.between(startDate, endDate); // 日期格式化 为字符串 ， 内置格式 LocalDate now6 = LocalDate.now(); String strNow = now6.format(DateTimeFormatter.BASIC_ISO_DATE); // 日期格式化 为字符串 ， 自定义格式 String strNow2 = now6.format(DateTimeFormatter.ofPattern(\"yyyy年MM月dd日\")); // 将字符串转换成日期 LocalDate date = LocalDate.parse(strNow2, DateTimeFormatter.ofPattern(\"yyyy年MM月dd日\")); // 目前支持的时区 Set set = ZoneId.getAvailableZoneIds(); //获取当前时区的日期时间 ZonedDateTime now3 = ZonedDateTime.now(); //获取美国洛杉矶时区的日期时间 ZonedDateTime USANow = ZonedDateTime.now(ZoneId.of(\"America/Los_Angeles\")); 重复注解 在 java8 以前，同一个程序元素前最多只能有一个相同类型的注解； 如果需要在同一个元素前使用多个相同类型的注解，则必须使用注解“容器”。 java8简化了使用的步骤，虽然仍然要定义“容器” 。但是直接使用的就是注解。 // java8 之前的写法 @Retention(RetentionPolicy.RUNTIME) public @interface Authority { String role(); } @Retention(RetentionPolicy.RUNTIME) public @interface Authorities { Authority[] value(); } @Authorities({@Authority(role = \"Admin\"), @Authority(role = \"Manager\")}) private void test( ) { ... } // java8 及之后的写法 @Retention(RetentionPolicy.RUNTIME) @Repeatable(Authorities.class) public @interface Authority { String role(); } @Retention(RetentionPolicy.RUNTIME) public @interface Authorities { Authority[] value(); } @Authority( role = \"Admin\" ) @Authority( role = \"Manager\" ) private void test( ) { ... } ( no Copyright，enjoy youself ! ) all right reserved，powered by GitbookThe file was updated at : 2020-12-30 15:35:24 "},"chinese/android基础/android零散知识.html":{"url":"chinese/android基础/android零散知识.html","title":"Android部分","keywords":"","body":"虚拟机对比 JVM Java Virtual Machine。基于栈 ，运行java字节码。 DVM Dalvik Virtual Machine 。 运行自谷歌定义的 .dex字节码格式。 Dalvik 基于寄存器的架构， 更适合资源紧张的系统。 ART ART , Android runtime 。 Android 4.4 开始加入 ART模式 , 从 Android 5.0 开始 ART 就全面取代了 Dalvik。 ART下，应用在第一次安装的时候，字节码就会预编译成机器码，首次启动会变慢， 但是以后每次启动执行的时候，都可以直接运行。（空间换时间） R.java 文件结构 R.java 定义了res目录中全部资源的id ， 系统会对工程中的 字符串、图片、xml等资源进行搜索生成一个索引文件， 每一个资源对应一个唯一的ID。 将 id 作为 key，去 resource.arsc 里面去查找对应的真正的资源。 这个 ID，用 32 位的 int 表示。格式为 PPTTNNNN。 前 8 位 PP (Package) 表示资源所属包类型，0x7f 表示应用 Apk 包资源，0x01 表示系统包资源。 中间 8 位 TT(Type) 代表资源 id 的类型 0x02：drawable 0x03：layout 0x04：values 0x05：xml 0x06：raw 0x07：color 0x08：menu 最后 16 位表示资源在此类型里面的编号。 R文件的设计目的是啥，为什么不直接使用资源路径 用 R.java 来映射资源文件 ，大概有以下一些优点。 1、编程工具会对res下的资源进行扫描，删除或增加都会自动更新R文件， 维护一个最新的R文件，相当于维护这一个索引，智能提示提高开发者的开发速度。 2、方便引入非文件资源，例如 字符串和颜色配置等。 3、将每个资源都映射成一个32的int (比很长的文件名节省空间) 。 其他的等待补充。 R 文件的位置 两种情况 1、编码调试阶段 ，在Androidstudio查看 ， 2、打成 apk 后，R文件的位置 .dex 文件 为什么不能超过 65535 个方法 UNEXPECTED TOP-LEVEL EXCEPTION: java.lang.IllegalArgumentException: method ID not in [0, 0xffff]: 65536 Java源文件在打包成一个DEX文件，这个文件就是优化过的、Dalvik虚拟机可执行的文件， Dalvik虚拟机在执行DEX文件时，它使用了 short 这个类型（16 bit）索引DEX文件中的方法， 这意味着单个DEX文件可以被定义的方法最多只能是65535个，当超过这个数量时就会发生编译错误。 双缓冲 两个线程配合完成某一项工作，一个线程做A部分（例如绘制UI）， 另一个线程做B事情（例如读取资源，计算数据）。 常见的例子： 1、TCP数据传输， 数据的收发速度不一致可能导致数据的丢失。 数据线发送到缓冲区中，然后从缓冲区中取走。 有效地防止了数据的丢失。 2、复杂图像绘制过程中。 线程A将一帧的计算结果放在缓冲区中，线程绘制完当前帧后再去缓冲区中取下一帧完整的绘制资源。 这样就可以避免画面闪烁结果。 很多图形操作都很复杂，需要大量的计算，很难访问一次显示缓冲区就能写入待显示的完整图形数据， 通常需要多次访问显示缓冲区，每次访问时写入最新计算的图形数据。 而这样造成的后果是一个需要复杂计算的图形，你看到的效果可能是一部分一部分地显示出来的，造成很大的闪烁不连贯。 硬件加速 图形的绘制如果是 GPU处理的就是 硬件加速绘制，如果是 CPU 处理的 就是软件绘制。 硬件加速使用 GPU 进行View上的绘制操作。 硬件加速可以在以下四个级别开启或关闭： Application ： 为整个 APP开启 Activity： activity 范围 Window： window 范围 getWindow().setFlags( WindowManager.LayoutParams.FLAG_HARDWARE_ACCELERATED View： view 范围 oneView.setLayerType(View.LAYER_TYPE_SOFTWARE, null); 并非所有的2D绘图操作支持硬件加速。所以硬件加速的开关分为四个层次。 以下是已知不支持硬件加速的绘图操作(需要最新的请查阅官网) 支持硬件加速情况 Canvas 第一次支持 Paint 第一次支持 drawBitmapMesh() (colors array) 18 setAntiAlias() (for text) 18 drawPicture() 23 setAntiAlias() (for lines) 16 drawPosText() 16 setFilterBitmap() 17 drawTextOnPath() 16 setLinearText() ✗ drawVertices() ✗ setMaskFilter() ✗ setDrawFilter() 16 setPathEffect() (for lines) ✗ clipPath() 18 setRasterizer() ✗ clipRegion() 18 setShadowLayer() (other than text) ✗ clipRect(Region.Op.XOR) 18 setStrokeCap() (for lines) 18 clipRect(Region.Op.Difference) 18 setStrokeCap() (for points) 19 clipRect(Region.Op.ReverseDifference) 18 setSubpixelText() ✗ clipRect() with rotation/perspective 18 Xfermode 第一次支持 Shader 第一次支持 PorterDuff.Mode.DARKEN (framebuffer) ✗ ComposeShader inside ComposeShader ✗ PorterDuff.Mode.LIGHTEN (framebuffer) ✗ Same type shaders inside ComposeShader ✗ PorterDuff.Mode.OVERLAY (framebuffer) ✗ Local matrix on ComposeShader 18 Drawing operation to be scaled 第一次支持 drawText() 18 drawPosText() ✗ drawTextOnPath() ✗ Simple Shapes* 17 Complex Shapes* ✗ drawPath() ✗ Shadow layer ✗ fork 是什么意思 经常会听到 fork 一个进程，初学者有时不太理解。 fork() 函数用于从一个已经存在的进程内创建一个新的进程， 使用 fork() 得到的子进程是父进程的复制品， 子进程完全复制了父进程的资源， 包括进程上下文、代码区、数据区、堆区、栈区、内存信息、打开文件的文件描述符、 信号处理函数、进程优先级、进程组号、当前工作目录、根目录、资源限制和控制终端等信息， 而子进程与父进程的区别有进程号、资源使用情况和计时器等。 从基本作用上来理解， fork 跟 Java里的深克隆类似。 都是从一个目标完全复制一份新的对象出来。 github 上也有有一个 fork ， 感觉也类似，就是从别人的代码那里， 复制一份一模一样的代码到你的账号上。 hook 是什么意思 hook 的中文翻译是钩子。 在windows系统中，一切皆消息，比如按了一下键盘，也是一个消息。 Hook的意思是勾住 ，也就是在消息过去之前，可以先把消息勾住， 不让其传递，你可以优先处理。 hook 技术就是提供了一个方案， 能够针对不同的消息或者API在执行前，先执行你的操作， 你的操作也称为“钩子函数”， 所以有的时候程序员在讨论的时候，也经常会说，可以先hook住，再处理， 也即在执行某某操作之前，优先处理一下 序列化 序列化，将内存中保存的是对象以二进制数据流的形式进行处理， 可以实现对象的保存或者是网络传输。 与序列化相对的是反序列化，它将流转换为对象。 Bunder 传递对象为什么需要序列化 因为 Bunder + intent 是支持跨进程传递的， 而 Android 进程间是不支持 对象传递的， 所以要将对象序列化成二进制。 serialVersionUID 的作用 serialVersionUID 主要是一种安全机制。 序列化的时候系统会把当前类的 serialVersionUID 写入序列化文件中， 当反序列化的时候系统会去检测文件中的serialVersionUID,看他是否和当前类的一致，如果一致， 说明序列化类的版本和当前类的版本是相同的，这个时候成功反序列化， 否则说明当前类和序列化的类相比发生某些变换，这个时候无法正常反序列化，会报错。 如果不手动指定 serialVersionUID ，那么将对象序列化时系统生成一个 serialVersionUID值 一起持久化了。 此时如果你给这个对象增加了一个属性，再次持久化时，此时生成 serialVersionUID 值是不一样的。 如果你不想进行这样严格的校验，你手动手动 serialVersionUID =1L ，那么即使你新增或者减少了属性， 反序列化的时候也不会报错，只是被忽略或者默认置为0 。 Androidstudio中生成 serialVersionUID的方法。 preferences->Inspections->serialization issues->Serializable class without 'serialVersionUID' 勾上 。 此时会提示生成严格验证的 serialVersionUID的方法 。如果不想严格校验可以直接写成1 。 Serializable 与 Parcelable 的区别 Serializable 是一种标识接口,是一个空接口。 对某个类实现 Serializable 后，Java便会对这个对象进行序列化操作。 这种方法使用了反射原理，序列化的过程较慢。 会在序列化的时候创建许多的临时对象，可能会引起频繁的GC。 使用起来简单但是开销很大，序列化和反序列化过程需要大量I/O操作。 Serializable 主要用于持久化存储对象 ，保存在磁盘或者网络传输。 Parcelable 方式的实现原理是将一个完整的对象进行分解， 而分解后的每一部分都是Intent所支持的数据类型，这样也就实现传递对象的功能了。 因为我们已经清楚地知道了序列化的过程，而不需要使用反射来推断。 为了这种高效分解组合，我们需要按要求进行一些代码书写。 Parcelable 是直接在内存中读写 ， 无法将数据进行持久化 ，只能用于程序内内存间进行对象传输 。 在 Androidstudio 中，我们可以使用 插件 \" Parcelable code generator \" 来自动生成一些代码。减少代码书写量。 Activity 与 AppCompatActivity 区别 随着 Android系统的更新，增加了一些新的特性， 所以后续慢慢地推出了 FragmentActivity 、AppCompatActivity 。 AppCompatActivity 加入了很多新特性，并且向下兼容(兼容老设备,旧系统版本)。 AppCompatActivity extends FragmentActivity FragmentActivity extends ComponentActivity ComponentActivity extends Activity // Activity Activity是最基础的一个，是其它类的直接或间接父类。 Activity中 只能使用系统自带的 FragmentTabHost+Fragment ， 用 getFragmentManager() 来控制Activity和Fragment之间的交互。 // FragmentActivity 在v4包中引 入 FragmentActivity ， FragmentActivity 间接继承自Activity，并提供了对v4包中 support Fragment的支持。 在 FragmentActivity 中必须使用 getSupportFragmentManager() 来处理support Fragment的交互。 // AppCompatActivity AppCompatActivity 继承自FragmentActivity，同时取代了ActionBarActivity。 AppCompatActivity 支持 ActionBar 功能，同时更推荐使用 ToolBar。 而且 AppCompatActivity 为支持Material Design风格控件提供了便利。 另外：与 Activity 相比较， AppCompatActivity 的 theme 只能用 android:theme=”@style/AppTheme ，而不能用android:style。 否则会提示错误： Caused by: java.lang.IllegalStateException: You need to use a Theme.AppCompat theme (or descendant) with this activity. android 严苛模式 、严格模式 在代码中配置严苛模式，用来帮助我们更容易找到违规的代码。 比如在主线程中访问网络、访问磁盘、Activity的泄露 等不合理的操作。 // 线程策略 StrictMode.ThreadPolicy threadPolicy = new StrictMode.ThreadPolicy.Builder() .detectAll() // 检测所有潜在的违例 .detectCustomSlowCalls()// 自定义耗时操作 .detectDiskReads() // 读磁盘 .detectDiskWrites() // 写磁盘 .detectNetwork() // 检查网络 .detectResourceMismatches() // 检查资源类型是否匹配 .penaltyLog() // 将警告输出到LogCat .penaltyFlashScreen()// 屏幕闪烁 .penaltyDropBox() // 将违规信息记录到 dropbox 系统日志目录中（/data/system/dropbox） .penaltyDeath() // 当触发违规条件时，直接Crash掉当前应用程序。 .penaltyDialog() // 弹出dialog .penaltyDeathOnNetwork()// 当触发网络违规时，Crash掉当前应用程序 .build(); // Vm 策略 StrictMode.VmPolicy vmPolicy = new StrictMode.VmPolicy.Builder() .detectAll() // 检测所有潜在的 .detectActivityLeaks()// 检测Activity的泄露 .detectCleartextNetwork() //检测明文的网络 .detectFileUriExposure() // 检测file:// 或 content:// .detectLeakedClosableObjects() // 未关闭的Closable对象泄露 .detectLeakedRegistrationObjects() // 检测需要注册类型是否解注 .detectLeakedSqlLiteObjects() // 泄露的Sqlite对象 .setClassInstanceLimit(Stutent.class ,10)// 检测实例数量 .penaltyLog() // 将警告输出到LogCat .penaltyDropBox() // 将违规信息记录到 dropbox 系统日志目录中（/data/system/dropbox） .penaltyDeath() // 当触发违规条件时，直接Crash掉当前应用程序。 .build(); StrictMode.setThreadPolicy(threadPolicy ); StrictMode.setVmPolicy(vmPolicy ); 线程休眠方法 Thread.sleep() // 抛异常 ,可能会被中断 SystemClock.sleep( ) // 不能被中断 ，Android 推荐用这个 LockSupport.parkNanos(1);// LockSupport.unpark(thread); object.wait() // object.notifyAll(); 不推荐使用 Android 拖拽效果 以前没看过这个知识点，以为绘制那个虚影有点麻烦。 其实 Android api 有提供一个简单的 api view.startDrag( ) ，会自动生成虚影。 在实际项目中，配合处理一下 拖动事件的监听和坐标的处理即可。 可以参考一下这个项目 https://gitee.com/hnyer/RemoteControlView -------------------- public void startDrag(View view ,DraggableInfo draggableInfo ){ Intent intent = new Intent(); intent.putExtra(MyConfig.KEY_DATA, draggableInfo); //用 ClipData 来跨 activity 传值 ClipData dragData = ClipData.newIntent(MyConfig.KEY_Value, intent); View.DragShadowBuilder myShadow = new View.DragShadowBuilder(view); // 震动 (不需要震动权限) view.performHapticFeedback(HapticFeedbackConstants.LONG_PRESS, HapticFeedbackConstants.FLAG_IGNORE_GLOBAL_SETTING); // 执行startDrag后 ，系统就会生成view的拖拽影子 if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.N) { view.startDragAndDrop(dragData, myShadow, null, 0); }else{ view.startDrag(dragData, myShadow, null, 0); } } // 给一个控件添加拖动监听，可以监听到被拖动的那个控件的拖动事件和坐标 frameLayout.setOnDragListener(onDragListener); private View.OnDragListener onDragListener = new OnDragListener() { public boolean onDrag(View v, DragEvent event) { final int action = event.getAction(); switch(action) { case DragEvent.ACTION_DRAG_STARTED: // 开始拖动 break; case DragEvent.ACTION_DRAG_ENTERED: // 进入 break; case DragEvent.ACTION_DRAG_EXITED: // 移出 break; case DragEvent.ACTION_DRAG_ENDED: // 停止拖动 break; case DragEvent.ACTION_DRAG_LOCATION: // 停留 break; case DragEvent.ACTION_DROP: // 释放拖动 break; } return true; } }; 子控件超出父控件 android:layout_gravity=\"bottom\" // 子控件配置 android:clipChildren=\"false\" // 父容器配置 至于 clipChildren = false 带来的超出部分无法点击的问题， 可以通过 手指触摸点和子容器的坐标点来判断。 如果在坐标范围内，就模拟手指点击。 控件阴影 完整版的 https://github.com/lihangleo2/ShadowLayout 如果只是简单使用，使用这个文件即可 https://gitee.com/hnyer/PopuwindowDemo/raw/master/app/src/main/java/com/aivin/popuwindowdemo/widget/ShadowLayout.java 仿 ios 风格的开关 https://github.com/kyleduo/SwitchButton 代码比较少，就两个文件。可以拷贝自己的代码中。 新版本的 isPressed 已经可以正确判断来自用户切换。 boolean isByUser = buttonView.isPressed() ; ( no Copyright，enjoy youself ! ) all right reserved，powered by GitbookThe file was updated at : 2021-08-26 15:59:19 "},"chinese/android基础/常用代码块.html":{"url":"chinese/android基础/常用代码块.html","title":"常用代码","keywords":"","body":"常用代码片段 数组操作 list去重 将重复值去掉，同时不能破坏现有的顺序。 private List removeDuplicate(List list){ Set set = new HashSet(); List newList = new ArrayList(); for (String str : list) { // 借助set的特性 if (set.add(str)) { newList.add(str); } } return newList; } String 操作 字符串切割 String [] array= myString.split(\"[.]\"); 分割字符 表达 . \"[.]\" | \"\\\\|\" * \"\\\\*\" \\ \"\\\\\\\\\" [ \"\\\\[\" ] \"\\\\]\" String 简单格式化 return String.format(\"bookId= %s, bookName=%s]\", bookId, bookName); strig 和 byte[] 互相转换 byte[] bytes = \"hello world\".getBytes(StandardCharsets.UTF_8); String hello = new String(bytes , StandardCharsets.UTF_8); 代码超时 函数超时、 执行超时、等待超时、连接超时 final ExecutorService exec = Executors.newFixedThreadPool(1); Callable call = new Callable() { public String call() throws Exception { // 耗时操作... Thread.sleep(1000 * 3); return \"执行结果(成功或失败)\"; } }; try { Future future = exec.submit(call); // 超时时间 设置 String result = future.get(1000 * 5, TimeUnit.MILLISECONDS); System.out.println(\"执行未超时:\" + result); } catch (TimeoutException ex) { System.out.println(\"处理超时\"); ex.printStackTrace(); } catch (Exception e) { System.out.println(\"处理失败.\"); e.printStackTrace(); } exec.shutdown(); } 对象排序 Collections.sort(mBeanList, new Comparator() { @Override public int compare(MyBean bean1, MyBean bean2) { // 按照对象属性排序 return = bean1.xx - bean2.xx; } }); 数组操作 数组相等 Arrays.equals(myArray, NSS_MSG_TYPE_GET_MAIN_STREAM); 数组打印 System.out.println(Arrays.toString(myArray)); 数组扩容 public String [] getNewArrayWithMoreSpaceString( String [] oldArray ,String [] increceData){ String [] lastArray=new String[oldArray.length+increceData.length]; //数组复制 System.arraycopy(oldArray, 0, lastArray, 0, oldArray.length); System.arraycopy(increceData, 0, lastArray, oldArray.length+1, increceData.length); return lastArray ; } /** * 多个数组合并 */ byte[] concatAll(byte[] first, byte[]... rest) { int totalLength = first.length; for (byte[] array : rest) { totalLength += array.length; } byte[] result = Arrays.copyOf(first, totalLength); int offset = first.length; for (byte[] array : rest) { System.arraycopy(array, 0, result, offset, array.length); offset += array.length; } return result; } byte[]相关 byte[]和基础数据互转 例如一个32位long数据，0x12345678: 0x12345678 高字节 -----------------> 低字节 内存低地址 -----------------> 内存高地址 大端模式 0x12 0x34 0x56 0x78 //符合人的直观认识 小端模式 0x78 0x56 0x34 0x12 // int 转为 byte byte intTo1ByteHex(int intVaue ){ return Integer.valueOf(intVaue & 0xff).byteValue(); } // byte 转 int int bytes1ToInt(byte src) { return src & 0xFF; } // int 转 byte[4] ,大端模式 byte[] intTo4ByteBig(int n) { byte[] b = new byte[4]; b[3] = (byte) (n & 0xff); b[2] = (byte) (n >> 8 & 0xff); b[1] = (byte) (n >> 16 & 0xff); b[0] = (byte) (n >> 24 & 0xff); return b; } // int 转 byte[4],小端模式 byte[] intTo4ByteLittle(int n) { byte[] b = new byte[4]; b[0] = (byte) (n & 0xff); b[1] = (byte) (n >> 8 & 0xff); b[2] = (byte) (n >> 16 & 0xff); b[3] = (byte) (n >> 24 & 0xff); return b; } // byte[4] 转int ，小端模式 int bytes4ToIntLittle(byte[] bytes ) { int int1=bytes[0]&0xff; int int2=(bytes[1]&0xff)> 8 & 0xff); return b; } // short 转 byte[2] ，小端模式 byte[] shortTo2ByteLittle(short n) { byte[] b = new byte[2]; b[0] = (byte) (n & 0xff); b[1] = (byte) (n >> 8 & 0xff); return b; } // byte[2] 转 short ,小端模式 short byte2ToShortLittle(byte[] b) { return (short) (((b[1] > 56)); b[6] = (byte) (0xff & (value >> 48)); b[5] = (byte) (0xff & (value >> 40)); b[4] = (byte) (0xff & (value >> 32)); b[3] = (byte) (0xff & (value >> 24)); b[2] = (byte) (0xff & (value >> 16)); b[1] = (byte) (0xff & (value >> 8)); b[0] = (byte) (0xff & value); return b; } // double 转 byte[8] ,大端模式 byte[] doubleTo8Bytes_Big(double d){ long l = Double.doubleToLongBits(d); byte[] b = new byte[8]; b[0] = (byte) (0xff & (l >> 56)); b[1] = (byte) (0xff & (l >> 48)); b[2] = (byte) (0xff & (l >> 40)); b[3] = (byte) (0xff & (l >> 32)); b[4] = (byte) (0xff & (l >> 24)); b[5] = (byte) (0xff & (l >> 16)); b[6] = (byte) (0xff & (l >> 8)); b[7] = (byte) (0xff & l); return b; } /** * byte[8] 转 double */ double bytes8ToDouble(byte[] bytes, boolean littleEndian) { ByteBuffer buffer = ByteBuffer.wrap(bytes,0,8); if(littleEndian){ buffer.order(ByteOrder.LITTLE_ENDIAN); }else{ buffer.order(ByteOrder.BIG_ENDIAN); } long l = buffer.getLong(); return Double.longBitsToDouble(l); } 获得校验位 /* 只保留低八位，高位舍去。 P1=s/256; //整除高8位 P0=s%256; //取余是低8位 */ public static byte[] getVerifyValue(byte [] lastBytes){ byte checksum = 0; for (int i = 0; i = 0; i--) { array[i] = (byte)(b & 1); b = (byte) (b >> 1); } return array; } // byte[] 转换成十六进制字符串 ,方便打印查看 String byte2HexStr(byte[] b){ String stmp ; StringBuilder sb = new StringBuilder(\"\"); for (int n = 0; n 文件操作 获得指定文件的byte数组 public byte[] getBytesFromFile(File file){ byte[] buffer = null; try { if(!file.exists()){ file.createNewFile(); } FileInputStream fis = new FileInputStream(file); ByteArrayOutputStream bos = new ByteArrayOutputStream(1000); byte[] b = new byte[1000]; int n; while ((n = fis.read(b)) != -1) { bos.write(b, 0, n); } fis.close(); bos.close(); buffer = bos.toByteArray(); } catch ( Exception e) { e.printStackTrace(); } return buffer; } 根据byte数组，生成文件 public void getFileFromBytes(byte[] bfile, File file ,boolean isAppend){ BufferedOutputStream bos = null; FileOutputStream fos = null; try { fos = new FileOutputStream(file ,isAppend); bos = new BufferedOutputStream(fos ); bos.write(bfile); } catch (Exception e) { e.printStackTrace(); } finally { if (bos != null) { try { bos.close(); } catch (IOException e1) { e1.printStackTrace(); } } if (fos != null) { try { fos.close(); } catch (IOException e1) { e1.printStackTrace(); } } } } 保存String到本地 public boolean saveTxtToSdWithAppend(String messgeStr, String filePath, boolean isAppend){ File file = new File(filePath); try { file.createNewFile(); } catch (IOException e) { e.printStackTrace(); } boolean resultFlage = true; try { // 打开一个写文件器，是否追加形式 FileWriter writer = new FileWriter(filePath, isAppend); writer.write(messgeStr + \"\\r\\n\"); writer.close(); } catch (IOException e) { resultFlage = false; e.printStackTrace(); } return resultFlage; } 从txt(小文件) 获取String public String getStringFromTxt(File file) { StringBuffer sb = new StringBuffer(); try { BufferedReader rd = new BufferedReader(new FileReader(file)); String s = rd.readLine(); while (null != s) { sb.append(s); s = rd.readLine(); } } catch (FileNotFoundException e) { e.printStackTrace(); } catch (IOException e) { e.printStackTrace(); } return sb.toString(); } 按行读取(较大文件) 、解决乱码问题 public void read(String filePath, String logPath) throws Exception { RandomAccessFile raf = new RandomAccessFile(filePath, \"r\"); // 设置指针的位置为文件的开始部分 raf.seek(currentInex); long totalLenth = raf.length(); while (currentInex 递归 遍历文件夹 public void getFileList(String strPath) { File dir = new File(strPath); File[] files = dir.listFiles(); if (files != null) { for (File file : files) { if (file.isDirectory()) { getFileList(file.getAbsolutePath()); } else { // 文件 } } } } 时间间隔 public static String getConversationDateString(String result) throws Exception{ if(!result.equals(\"\")){ SimpleDateFormat sdf = new SimpleDateFormat(\"MM-dd HH:mm\"); SimpleDateFormat sdfDay = new SimpleDateFormat(\"MM-dd\"); String now = sdf.format(new Date()); Date oldTime = null; Date newTime = null; oldTime = sdf.parse(result); newTime = sdf.parse(now); long time = newTime.getTime() - oldTime.getTime(); int day; String[] olds = sdfDay.format(oldTime).split(\"-\"); String[] news = sdfDay.format(newTime).split(\"-\"); if(news[0].equals(olds[0])){ day = Integer.valueOf(news[1]) - Integer.valueOf(olds[1]); }else{ Calendar cal = Calendar.getInstance(); //月份设置要减1，所以设置1月就是1-1，设置2月就是2-1，如此类推 cal.set(Calendar.MONTH, 1-1); cal.add(Calendar.MONTH, -(Integer.valueOf(news[0]) - Integer.valueOf(olds[0]))); //得到上一个月最最后一天日期(31/30/29/28) int oldDay=cal.getActualMaximum(Calendar.DAY_OF_MONTH) - Integer.valueOf(olds[1]); day = oldDay + Integer.valueOf(news[1]); } if(time 求夹角 根据正切公式 /**根据两个点获取 斜率*/ public static double getXl(MyPointBean bean1, MyPointBean bean2) { double xlValue = 0; xlValue = (bean2.getY() - bean1.getY()) / (bean2.getX() - bean1.getX()); return xlValue; } /**根据2条线的斜率 获得之间的夹角*/ public static double getAngle(double xl_1, double xl_2) { double angleValue = 0; // 反正切 angleValue = Math.atan((xl_2 - xl_1) / (1 + xl_1 * xl_2)); // 将弧度转为度数 return Math.toDegrees(angleValue); } 遍历map 遍历set Map map=new HashMap(); //方法一 ，需要遍历 两次 for (Object object : map.keySet()) { String key = (String) object; Integer value = (Integer) map.get(key); } // 方法二， 只需遍历一次 （推荐） Set> entrySet = map.entrySet(); for (Entry object : entrySet){ Object key = object.getKey(); Object value = object.getValue(); } //遍历set Set set=new HashSet(); Iterator iterator=set.iterator(); while (iterator.hasNext()) { String obj = iterator.next(); } 随机数 Random Math.Random() 范围是 [0,1) 生成 [startNum,endNum) public int getRadomInt(int startNum, int endNum){ return new Random().nextInt(endNum - startNum) + startNum; } 生成 [startNum,endNum] public int getRadomInt2(int startNum, int endNum){ return new Random().nextInt(endNum - startNum + 1) + startNum; } 文件解压缩 zip解压缩是基于 pache的 ant.jar 实现 。 /** * 解压耗时操作应该在子线程中进行。 */ public class ZipUtil{ private byte[] buf; public ZipUtil(){ this.buf = new byte[ 1024*4]; } /** * @param zipFileAbsulutPaht 压缩文件的绝对路径 xxx/xxx.zip * @param destFileDir　　　解压到的目录　 */ public void unZip(String zipFileAbsulutPaht, String destFileDir) { FileOutputStream fileOut; File file; InputStream inputStream; try { //生成一个zip的文件 ZipFile zipFile = new ZipFile(zipFileAbsulutPaht); //遍历zipFile中所有的实体，并把他们解压出来 for (@SuppressWarnings(\"unchecked\") Enumeration entries = zipFile.getEntries(); entries.hasMoreElements();) { ZipEntry entry = entries.nextElement(); //生成他们解压后的一个文件 String tempNameFile=entry.getName() ; file = new File(destFileDir+File.separator+tempNameFile.replace(\"\\\\\", \"/\")); if (entry.isDirectory()) { file.mkdirs(); } else { File parent = file.getParentFile(); if (!parent.exists()) { parent.mkdirs(); } //获取出该压缩实体的输入流 inputStream = zipFile.getInputStream(entry); fileOut = new FileOutputStream(file); int length = 0; //将实体写到本地文件中去 while ((length = inputStream.read(this.buf)) > 0) { fileOut.write(this.buf, 0, length); } fileOut.close(); inputStream.close(); } } zipFile.close(); } catch (IOException ioe) { ioe.printStackTrace(); } } } // 使用 new ZipUtil().unZip(mnt/xxx/xxx.zip , mnt/xx/xx/); URLEncoder 中文 判断是否有中文 URLEncoder.encode(str ,\"UTF-8\")); public static boolean isChineseChar(String str){ boolean temp = false; Pattern p=Pattern.compile(\"[\\u4e00-\\u9fa5]\"); Matcher m=p.matcher(str); if(m.find()){ temp = true; } return temp; } 正则换URL字符串里面的汉字部分 public static String encode(String str, String charset) { Pattern p = Pattern.compile(\"[\\u4e00-\\u9fa5]\"); Matcher m = p.matcher(str); StringBuffer b = new StringBuffer(); while (m.find()) { m.appendReplacement(b, URLEncoder.encode(m.group(0), charset)); } m.appendTail(b); return b.toString(); } 其他 判断是否是闰年 if (n%400==0 ||n%4==0 && n%100!=0) { //闰年 } 双击退出 、按键监听 private long lastTime = 0 ; private void exitActivity( ) { if (System.currentTimeMillis() - lastTime 不定参数 //相当于是二维数组，arg中每个空间保存一个数组 public void method(int[]...arg); 倒计时 简单场景就使用Chronometer。 复杂场景使用网上很多开源的，比如小米时钟、锤子时钟中的实现思路。 选中效果 xxx.setSelected(false); 点击效果 方法一，可以采取 xml 配置的方式。 方法二，可以采用 Drawable 来实现 。 重写 ImageView 的方法 public boolean onTouchEvent(MotionEvent event) { // 两个 getDrawable 取得的对象, 需要用 mutate 设置一下 Drawable drawable = getDrawable(); if(drawable==null){ return super.onTouchEvent(event); } switch (event.getAction()) { case MotionEvent.ACTION_DOWN: drawable.mutate().setColorFilter(Color.GRAY, PorterDuff.Mode.MULTIPLY); break; case MotionEvent.ACTION_CANCEL: case MotionEvent.ACTION_UP: drawable.mutate().clearColorFilter(); performClick(); break; } return super.onTouchEvent(event); } // 补充 mutate 用法 如果多个控件使用同一个 Drawable ， 如果其中一个控件的 Drawable 发生改变，其他所有的Drawable都会发生改变。 如果使用Drawable.mutate()，就可以从 Drawable 里新建一个不可变的实例， 那么当这个Drawable发生改变时，不会导致其他的Drawable发生改变。 全屏、去掉标题栏 //在setContentView之前设置 requestWindowFeature(Window.FEATURE_NO_TITLE); //Activity supportRequestWindowFeature(Window.FEATURE_NO_TITLE); // ok AppCompatDialog getWindow().setFlags(WindowManager.LayoutParams.FLAG_FULLSCREEN, WindowManager.LayoutParams.FLAG_FULLSCREEN); getWindow().setFlags(WindowManager.LayoutParams.FLAG_FORCE_NOT_FULLSCREEN, WindowManager.LayoutParams.FLAG_FULLSCREEN); //extends AppCompatActivity android:theme=\"@style/Theme.AppCompat.Light.NoActionBar\" getSupportActionBar().hide(); 启动默认浏览器 Intent intent =newIntent(); intent.setAction(\"android.intent.action.VIEW\"); Uri content_url =Uri.parse(\"http://www.xxx.com\"); intent.setData(content_url); startActivity(intent); 启动第三方应用 PackageManager pm = this.getPackageManager(); Intent intent = pm.getLaunchIntentForPackage(\"xxx.包名.xxx\"); try { startActivity(intent); } catch (Exception e) { //请先安装 } ```text 系统分享功能 Intent wechatIntent = new Intent(Intent.ACTION_SEND); wechatIntent.setPackage(\"com.tencent.mm\");//微信 wechatIntent.setType(\"text/plain\"); wechatIntent.putExtra(Intent.EXTRA_TEXT, \"hello world\"); try{ context. startActivity(wechatIntent); }catch (Exception e){ //请先安装微信 } ### 使用自定义字体 ```text AssetManager mgr = getAssets(); Typeface tf = Typeface.createFromAsset(mgr, \"fonts/2.TTF\");// 文件在assets/fonts目录下 textView.setTypeface(tf); XML解析 SAX：Simple API for XML。 相比于DOM，SAX是一种速度更快，更有效的方法。它逐行扫描文档，一边扫描一边解析。 不用实现调入整个文档，占用资源少。尤其在嵌入式环境中，如android，极力推荐使用SAX解析。 复制粘贴 // 得到剪贴板管理器 ClipboardManager cmb = (ClipboardManager) context.getSystemService(Context.CLIPBOARD_SERVICE); //复制 cmb.setText( msg); // 粘贴 String msg=cmb.getText().toString() 防止 Toast 重复提示 private static Toast mToast; public void showMsg(Context context, String msg) { if (mToast == null) { mToast = Toast.makeText(context, msg, Toast.LENGTH_SHORT); } else { //直接设置，不用重复创建 mToast.setText(msg); } mToast.show(); } res/raw和assets // res/raw和assets的相同点： 1、两者目录下的文件在打包后会原封不动的保存在apk包中，不会被编译成二进制。 // res/raw和assets的不同点： 1、res/raw中的文件会被映射到R.java文件中，访问的时候直接使用资源ID即R.id.filename； 2、assets文件夹下的文件不会被映射到R.java中，访问的时候需要AssetManager类。 3、res/raw不可以有目录结构； 4、而assets则可以有目录结构，也就是assets目录下可以再建立文件夹 performClick Custom view FloatingforView overrides onTouchEvent but not performClick less... case MotionEvent.ACTION_UP: performClick(); break; @Override public boolean performClick() { return super.performClick(); } 保存控件截图 public static Bitmap saveViewBitmap(View view) { view.setDrawingCacheEnabled(true); view.buildDrawingCache(true); Bitmap cacheBitmap = view.getDrawingCache(true); Bitmap destBitmap = Bitmap.createBitmap(cacheBitmap); cacheBitmap.recycle(); view.setDrawingCacheEnabled(false); return destBitmap; } 图片转byte[] ByteArrayOutputStream stream = new ByteArrayOutputStream(); bitmap.compress(Bitmap.CompressFormat.JPEG, 100, stream); byte[] array = stream.toByteArray(); 图片转Base64 ByteArrayOutputStream bStream = new ByteArrayOutputStream(); bitmap.compress(Bitmap.CompressFormat.PNG, 100, bStream); byte[] bytes = bStream.toByteArray(); return Base64.encodeToString(bytes, Base64.DEFAULT); 占位符 学号：%1$d ;姓名：%2$s ;成绩：%3$.2f String result = String.format(testStr,1001,\"张三\",9.235); %N代表第N个参数，如%3代表的是第三个参数； $是结束符； d/s/.2f代表的是整数/字符串/保留2位小数点的浮点数 xml 中配置占位符 注意：当前电量低，只剩 %1$.4s %% ！请尽快返航！！！ float percentV= 19.12342342342f; String msg1 =getString(R.string.lowBatteryInfo) ; String alertInfo = String.format(Locale.getDefault() , msg1 , String.valueOf(percentV) ) ; Log.i(\"aivin\" ,\"alertInfo=\"+alertInfo); // alertInfo=注意：当前电量低，只剩 19.1 % ！请尽快返航！！！ 图片平铺 android:background=\"@drawable/redline_verticalbitmap\" 环境变量配置 1、建->变量名：JAVA_HOME 变量值：D:/Java/jdk1.6.0_12(这只是我的JDK安装路径) 2、编辑->变量名：Path 在变量值的最前面加上：%JAVA_HOME%/bin;%JAVA_HOME%/jre/bin 3、新建->变量名：CLASSPATH 变量值：.;%JAVA_HOME%/lib;%JAVA_HOME%/lib/dt.jar;%JAVA_HOME%/lib/tools.jar 分别输入java，javac，java -version 命令测试是否配置成功 SDK解压，把解压后文件夹的tools目录添加到环境变量path中 查看配置好的变量、jdk当前路径、jdk安装路径 echO %JAVA_HOME% //字母o java javac 显示版本正常，也能够编译成功，运行java 的时候出现找不到类的错误。 在classpath中添加 .; 即可解决。 //JDK版本更改后，环境变量不生效 删除 C:\\Windows\\System32目录下 java.exe、javaw.exe、javaws.exe 三个文件。 删除Path中 C:\\ProgramData\\Oracle\\Java\\javapath 配置 ByteBuffer相关 // 深度克隆ByteBuffer private ByteBuffer deepCloneByteBuffer(ByteBuffer original) { ByteBuffer clone = ByteBuffer.allocate(original.capacity()); original.rewind(); // 用put接口，才会把byte数组的内容拷贝到ByteBuffer中 clone.put(original); original.rewind(); clone.flip(); return clone; } //java.nio.ByteBuffer变量解释 int position 读写位置，表示当前进行读写操作时的位置。 position的位置会随着数据的写入而移或者读取一个字节一个字节的移动。 比如添加一个byte类型的数据position会+1, 添加一个int类型的数据position会+4 int limit 读写限制, 缓冲区可以进行读写的范围的最大值。 int capacity 容量，它的值是在创建缓冲区的时候指定的，设定后无法对其进行修改。 int mark 临时标记变量，用来存储 postion的。 //常用方法 ByteBuffer= allocate(int capacity) 分配一个新的字节缓冲区。 ByteBuffer= allocateDirect(int capacity) 分配新的直接字节缓冲区。 int =position() 获取position Buffer= position(10) ; 设置 position int =limit() 获取limit Buffer =limit(10) 设置limit int =capacity() 获取capacity byte[] = array() Buffer= flip() 把limit设为当前position，把position设为0 Buffer= mark() 将存储当前position的值，等下次调用reset()方法时，会设定position的值为之前的标记值； Buffer= reset() Buffer= rewind() 把position设为0，limit不变 Buffer= clear() 把position设为0，把limit设为capacity。并不是清空内容 ByteBuffer= compact() 将 position 与 limit之间的数据复制到buffer的开始位置， 若 position 与limit 之间没有数据的话发，就不会进行复制 。 其实就是删除已读过的数据复制后 position = limit -position,limit = capacity 。 ByteBuffer= wrap(byte[] array, int offset, int length) limit 等于 offset ByteBuffer= wrap(byte[] array ) 这个缓冲区的数据会存放在byte数组中，bytes数组或buff缓冲区任何一方中数据的改动都会影响另一方。 ByteBuffer= slice() 返回原ByteBuffer的一个镜像，所有改变互相可见 ByteBuffe=r put(byte[] src) 将一个数组写入 ByteBuffer= put(byte b) 将一个byte写入，postion+1 ByteBuffer= put(int index, byte b) 把src中可读的部分（也就是position到limit）写入此byteBuffer ByteBuffer =get(byte[] dst) 将内容读取到然后放到 dst中 byte= get() 读取一个byte 如何判断一个 APP 在前台还是后台 借用系统 ActivityLifecycleCallbacks 的回调来进行判断。 进入后台后，有一些机型貌似弹不出toast，比如华为M3 。 暂时没找到解决办法，我试过一些银行的APP 和所得税APP，同样也弹不出来。 // 原理：程序中任何一个activity处于后台时(onStope)都将触发提醒。 // 所以，如果顶层activity中onStope方法被执行，则认为程序处于后台。 public class MyAppLifecycleHandler implements Application.ActivityLifecycleCallbacks { private int started = 0; private int stopped = 0; private String lastActivitName ; private boolean flag = true; public MyAppLifecycleHandler(String name){ lastActivitName= name ; } @Override public void onActivityCreated( ... ) { } @Override public void onActivitySaveInstanceState( ... ) { } @Override public void onActivityResumed(Activity activity) { } @Override public void onActivityPaused(Activity activity) { } @Override public void onActivityStarted(Activity activity) { ++started; } @Override public void onActivityStopped(final Activity activity) { ++stopped; if (!isApplicationInBackground()){ return; } flag = true; new Handler().postDelayed(new Runnable() { @Override public void run() { if ( flag ) { Toast.makeText(activity, \"WkPlayer被切换至后台\", Toast.LENGTH_SHORT).show(); } } // 延时的作用是用来等待一下，看 onActivityDestroyed 是否被执行了。 } ,500) ; } @Override public void onActivityDestroyed(Activity activity) { if (lastActivitName.contains(activity.getClass().getSimpleName())) { flag = false; } } private boolean isApplicationInBackground() { return started == stopped; } } // Application 中调用 MyAppLifecycleHandler lifecycleHandler = new MyAppLifecycleHandler( FileExplorerActivity.class.getSimpleName() ) ; unregisterActivityLifecycleCallbacks(lifecycleHandler); registerActivityLifecycleCallbacks( lifecycleHandler ) ; 皮肤更换 、更换主题 更换皮肤核心原理 重写 LayoutInflater.Factory 接口 View onCreateView(String name, Context context, AttributeSet attrs) 自定义 xml中 view解析的过程，并将解析出来的属性和view保存起来 换肤的时候，遍历这些属性和控件， 重新设置此view的换肤属性对应的资源。 mSkinFactory = new MySkinFactory(); getLayoutInflater().setFactory(mSkinFactory); 如果是设置默认主题皮肤就是从当前的apk包中获取资源id int originColor = context.getResources().getColor(resId); 如果是切换皮肤包，就从皮肤包中加载资源id int newResId = mSkinResources.getIdentifier(resName, \"color\", skinPackageName); 注：皮肤包的本质就是一个apk，里面配置的资源名字跟主apk中的资源名字是一样的 暗黑模式省电原理 目前主流的手机屏幕有 LCD (液晶) 、OLED (有机发光二极管) 屏幕。 LCD 屏幕背光始终被点亮，无论像素显示的是黑色还是其他颜色，都会消耗相同的能量。 早期手机屏幕基本上都是 LCD 。 OLED 屏幕像素点是单独工作的，当像素点是纯黑色时，该像素会被关闭，不消耗能量。 OLED 技术不需要背光的支持，省去了液晶和背光模组，结构非常简单，机身自然也可以达到极致超薄。 所以 只有 OLED屏幕在暗黑模式下省电。 android APP 可以自己设置暗黑主题皮肤包， 也可以简单配置一下，使用系统的暗黑主题。 Android 10 开始从系统层面支持暗黑主题。 换肤demo https://github.com/hnyer/XSkinLoader , 在“史海钩沉”APP中有实际测试。 ( no Copyright，enjoy youself ! ) all right reserved，powered by GitbookThe file was updated at : 2021-08-26 15:44:25 "},"chinese/android基础/基础控件使用.html":{"url":"chinese/android基础/基础控件使用.html","title":"基础控件使用","keywords":"","body":"Application // Application 中显示 Dialog (AlertDialog) 借助 ActivityLifecycleCallbacks 的生命周期回调 获得 Context new AlertDialog.Builder(mContext); // 通过 Application 传值 缺点 EditText EditText 默认不获取焦点 1、解决 在 PopupWindow 中 ，EditText 有时无法获取输入法焦点。 在 PopupWindow 中设置一下 this.setFocusable(true); 2、让 EditText 默认不获取焦点 在 EditText 的父容器中加入以下两个配置，让其抢夺到焦点。 android:focusableInTouchMode=\"true\" android:focusable=\"true\" EditText 按下回车键隐藏光标 和收起键盘 private void closeInputMethod(EditText theEditText) { theEditText.setCursorVisible(false); //关闭光标 InputMethodManager imm = (InputMethodManager) context.getSystemService(Context.INPUT_METHOD_SERVICE); boolean isOpen = imm.isActive(); if (isOpen) { imm.hideSoftInputFromWindow(theEditText.getWindowToken(), InputMethodManager.HIDE_NOT_ALWAYS); } } PopupWindow PopupWindow 设置宽高 https://gitee.com/hnyer/PopuwindowDemo 1、PopupWindow 在 xml 中设置宽高无效的原因和解决方案： PopupWindow 没有继承 Viewgroup ，因此最外层布局属性的宽高无效， 解决方法是： 1、在在xml中套两层，第二层指定长宽。 (第一层其实就相当于添加了一个 Viewgroup ) 3、或者在代码中加一个 Viewgroup 就行了 2、或者在代码中设置具体宽高。 public View initView( Context context ) { LayoutInflater inflater = (LayoutInflater) context .getSystemService(Context.LAYOUT_INFLATER_SERVICE); LinearLayout linearLayout = new LinearLayout(context); View rootView = inflater.inflate(R.layout.oofaywindow, linearLayout); return rootView ; } PopupWindow + ViewPager + fragment 的组合会出现问题 No view found for id 0xxxxxxxxx 可以采用 DialogFragment + ViewPager + fragment 组合 https://gitee.com/Aivin_CodeShare/android_tool_code/raw/master/precheck2.zip PopupWindow 半透明 方案有两个 1、方案1 void setWindowFilter(float alpha ,Activity activity) { WindowManager.LayoutParams lp = activity.getWindow().getAttributes(); lp.alpha = alpha; lp.dimAmount = alpha; activity.getWindow().addFlags(WindowManager.LayoutParams.FLAG_DIM_BEHIND); activity.getWindow().setAttributes(lp); } setOnDismissListener(new OnDismissListener() { @Override public void onDismiss() { setWindowFilter(1f , (Activity) context); } }); @Override public void showAtLocation(View parent, int gravity, int x, int y) { setWindowFilter(alpha , (Activity) context); super.showAtLocation(parent, gravity, x, y); } 2、方案2 android:background=\"#XXxxxxxx\" 说明：半透明颜色值共8位，前2位是透明度，后6位是颜色。 全透明：#00000000 半透明：#80000000 不透明：#FF000000 白色半透明：#80FFFFFF 红色30%透明：#4Dca0d0d 透明度 百分比 数值 不透明 100% FF 95% F2 90% E6 85% D9 80% CC 75% BF 70% B3 65% A6 60% 99 55% 8C 半透明 50% 80 45% 73 40% 66 35% 59 30% 4D 25% 40 20% 33 15% 26 10% 1A 5% 0D 全透明 0% 00 透明度百分比转换成十六进制 透明度以0到255表示，总共有256级，透明是0，不透明是255。 for(float i=100 ;i>=0 ;i-=1){ float temp = i/100f; int alpha = Math.round(temp * 255); // 用四舍五入的方式获得 255维度的百分比 String hex = Integer.toHexString(alpha).toUpperCase(); if (hex.length() == 1){ hex = \"0\" + hex; } int percent = (int) (temp * 100); System.out.println( String.format(\"%d%% — %s\", percent, hex) ); } PopupWindow 里触发弹窗 , 二级弹窗 在popupWindow里面再弹出popupWindow的时候会报这样的错误 ERROR/AndroidRuntime(888): android.view.WindowManager$BadTokenException: Unable to add window -- token android.view.ViewRoot$W@44ef1b68 is not valid; is your activity running? 解决方法1 不要在当前的 popupWindow 里面继续show一个 popupWindow ，应该写一个接口回调到Activity里面进行show， 解决方法2 第二次弹窗改为 Dialog PopupWindow 触碰外边关闭 void setThisOutTouchCancel(final boolean able) { setOutsideTouchable(able); setTouchInterceptor(new View.OnTouchListener() { @Override public boolean onTouch(View v, MotionEvent event) { if (!isOutsideTouchable()) { View mView = getContentView(); if (null != mView) mView.dispatchTouchEvent(event); } return isFocusable() && !isOutsideTouchable(); } }); } PopupWindow 获取 showAtLocation 的 parent popupWindow.showAtLocation( getContentView(MainActivity.this), Gravity.CENTER, 0, 0); private View getContentView(Activity activity) { ViewGroup view = (ViewGroup) activity.getWindow().getDecorView(); FrameLayout content = view.findViewById(android.R.id.content); return content.getChildAt(0); } 或者直接根据id获取到一个具体的view. PopupWindow 内部进行视图切换 PopupWindow + HorizontalScrollView 方案来做 。 scrollView.scrollTo(viewWidth*2, 0); // 这种方案一般不要放很多特别复杂的布局， 因为那些页面都是一次加载到 HorizontalScrollView中的 。 具体参考这个demo. https://gitee.com/hnyer/PopuwindowDemo SharedPreferences 一些简单的、无安全风险的键值对数据，可以通过 SharedPreferences 保存。 SharedPreferences 是一个轻量级的xml键值对文件 。 SharedPreferences 的替代方案 ，使用腾讯的 MMKV . https://github.com/Tencent/MMKV // 设置 缓存失效时间 思路是 MMKV 保存配置时，将当前时间和要有效时长一起保存进去， 取出来的时候判断一下，是否超时了。 如果超时了就返回NULL。 文件保存在 /data/data//shared_prefs 中，明文可见。 用真机中的文件夹管理器一般看不到，可以用过 Androidstudio 去看。 在 SharedPreferencesImpl.java 中 private void startLoadFromDisk() { new Thread(\"SharedPreferencesImpl-load\") { ... loadFromDisk(); // 开启子线程读取 }.start(); } SharedPreferences apply 和 commit 的区别 apply()：提交后同步写入内存，然后异步写入磁盘，没有返回值。 commit()：需要等异步回写磁盘完成后才返回，有返回值。 如果频繁操作的话 apply 的性能会优于 commit 。 SharedPreferences 是线程安全的吗 SharedPreferences 是线程安全的，因为内部有 synchronized 关键字保障。 SharedPreferences 是进程安全的吗？ 如何保证进程安全 因为 SharedPreferences 会从内存取值，但是进程间内存不是共享的，所以不是多进程安全的。 // SharedPreferencesImpl.java public String getString(String key, @Nullable String defValue) { synchronized (mLock) { awaitLoadedLocked(); String v = (String)mMap.get(key); // 从内存取值 return v != null ? v : defValue; } } SharedPreferences sharedPreferences = context.getSharedPreferences(\"xxxName\", Context.MODE_MULTI_PROCESS); // 因为对多进程支持不完善，MODE_MULTI_PROCESS (也不可靠) 模式也已经被废弃， // 官方推荐 ContentProvider 或者 第三方框架 MMKV AlertDialog 按钮大小问题 TextView textView =new TextView(this); textView.setText(\"Hello TextView\"); AlertDialog dialog =new AlertDialog.Builder(this) .setTitle(\"Hello aivin\") .setView(textView) .setPositiveButton(\"ok_Btn\", null ) .show() ; Button btn = dialog.getButton(AlertDialog.BUTTON_POSITIVE) ; btn.setAllCaps(false); // 重新设置 Dialog 全屏显示 public class LoadingDialogUtils { public static Dialog getLoadingDialogInstance(Context context) { // 根据样式创建 Dialog Dialog loadingDialog = new Dialog(context, R.style.iosloading_dialog); loadingDialog.setCancelable(false); // 设置自定义布局 LayoutInflater inflater = LayoutInflater.from(context); View v = inflater.inflate(R.layout.wk_loading_dialog, null); LinearLayout layout = v.findViewById(R.id.dialog_view); int width = MyDeviceInforHelper.getWidth((Activity) context); int height = MyDeviceInforHelper.getRealHeight( (Activity) context) ; ViewGroup.LayoutParams layoutParams = new ViewGroup.LayoutParams( width , height); loadingDialog.setContentView(layout, layoutParams ); layout.setBackgroundColor(Color.parseColor(\"#80000000\"));// 设置自定义背景颜色 loadingDialog.getWindow().setBackgroundDrawable(new ColorDrawable(Color.TRANSPARENT));// 设置window背景 loadingDialog.getWindow().setLayout(ViewGroup.LayoutParams.MATCH_PARENT, ViewGroup.LayoutParams.MATCH_PARENT); return loadingDialog; } } @null @android:color/transparent true true true @null false true public static int getRealHeight(Activity mActivity) { mActivity.getWindowManager().getDefaultDisplay().getRealMetrics(myGetDisplayMetrics()); return myGetDisplayMetrics().heightPixels; } SeekBar 进度条显示不全、显示不顶格的问题 ListView 动态改变高度 public void setListViewHeightBasedOnChildren2(ListView listView) { ListAdapter listAdapter = listView.getAdapter(); if (listAdapter == null) { return; } int totalHeight = 0; for (int i = 0; i 约束布局 ConstraintLayout api 'androidx.constraintlayout:constraintlayout:2.0.2' // 角度约束 (版本1.1中加入) 一个控件在某个控件的某个角度的位置，通过其他的布局其实是不太好实现的， 但是 ConstraintLayout 提供了角度位置相关的属性 app:layout_constraintCircle=\"\" 目标控件id app:layout_constraintCircleAngle=\"\" 对于目标的角度(0-360) app:layout_constraintCircleRadius=\"\" 到目标中心的距离 // 百分比偏移 让控件在父布局的水平方向或垂直方向的百分之多少的位置，可以使用如下属性： app:layout_constraintHorizontal_bias=\"\" 水平偏移 取值范围是0-1的小数 app:layout_constraintVertical_bias=\"\" 垂直偏移 取值范围是0-1的小数 // A依赖B ，B被Gone时，A距离父控件的距离。 app:layout_goneMarginBottom=\"0dp\" app:layout_goneMarginEnd=\"0dp\" app:layout_goneMarginLeft=\"0dp\" app:layout_goneMarginRight=\"0dp\" app:layout_goneMarginStart=\"0dp\" app:layout_goneMarginTop=\"0dp\" //设置宽高比例 给宽或者高其中一个设置为0dp，然后设置该属性是一个比例，宽和高的比 layout_constraintDimensionRatio // Chain 链 Chain 链是一种特殊的约束让多个 chain 链连接的 Views 能够平分剩余空间位置。 最相似的应该是 LinearLayout 中的权重比 weight ， 但 Chains 链能做到的远远不止权重比 weight 的功能。 Chain 链是由多个 Views 组合的，所以要创建一个 Chain 链就需要先选择多个想要链接到一起的 Views ， 然后再右键选择 'Center Horizontally' 或者 'Center Vertically' 来创建水平链或者垂直链。 Chain 链的创建定义的是 Chain 链组件之间的间隙关系，并不影响原有的非成员间的约束。 Chain 链模式一共有三种，分别为：spread ，spread_inside 和 packed 。 1、默认 spread 模式： 将平分间隙让多个 Views 布局到剩余空间。 2、spread_inside 模式： 它将会把两边最边缘的两个 View 到外向父组件边缘的距离去除， 然后让剩余的 Views 在剩余的空间内平分间隙布局。 3、 packed ： 它将所有 Views 打包到一起不分配多余的间隙 ，然后将整个组件组在可用的剩余位置居中。 RecyclerView RecyclerView + RadioGroup RadioButton 防止数据错乱 处理 https://gitee.com/Aivin_CodeShare/android_tool_code/raw/master/PreFlightCheckAdapter.java RecyclerView + 瀑布流 + Glide 长宽比加载 RecyclerView 、瀑布流 、 Glide 长宽比加载 、加载更多、缩略图 完整代码请参看 AivinReader ，里面有示例。 StaggeredGridLayoutManager layoutManager ;// 瀑布流 recyclerView.setLayoutManager(layoutManager); recyclerView.addItemDecoration( ); // 间隔 // 通过添加监听，实现加载更多功能 recyclerView.addOnScrollListener if (newState == RecyclerView.SCROLL_STATE_IDLE) { int [] positions = manager.findLastVisibleItemPositions(null); int lastPos=0 ; for(int pos : positions){ if(pos > lastPos){ lastPos = pos; } } int itemCount = manager.getItemCount(); // 判断是否滑动到了最后一个item，并且是向上滑动 if (lastPos == (itemCount - 1) && isSlidingUpward) { //加载更多 onLoadMore(); } } public void getItemOffsets( ) { super.getItemOffsets(outRect, view, parent, state); int left; int right= margin; int top; int bottom =0; StaggeredGridLayoutManager.LayoutParams params = (StaggeredGridLayoutManager.LayoutParams) view.getLayoutParams(); int position = params.getSpanIndex(); if (position == RecyclerView.NO_POSITION) { return; } WkLog.showLog(\"position==\"+position); // top if(position () { @Override public void onResourceReady(@NonNull Drawable resource, @Nullable Transition transition) { float scale = resource.getIntrinsicWidth() / (float) resource.getIntrinsicHeight(); picBean.setScale(scale); // k = w / h notifyDataSetChanged(); } @Override public void onLoadFailed(@Nullable Drawable errorDrawable) { super.onLoadFailed(errorDrawable); WkLog.showLog(\"获取图片长宽比失败0=\" ); } }); } int screenWidth = (int) (MyDeviceInforHelper.getScreenWidth(context)/columnCount); final ViewGroup.LayoutParams layoutParams =chooseHolder.picShowIv.getLayoutParams(); layoutParams.width = screenWidth ; layoutParams.height = (int) (layoutParams.width / bean.getScale()); Glide.with(context) .load(bean.getPicUrl()) .placeholder(R.mipmap.loading2) .thumbnail(0.5f) // 缩略图为原图的 0.1倍 .transition(new DrawableTransitionOptions().crossFade()) .into(chooseHolder.picShowIv); RecyclerView 修改滑动速度 如果 RecyclerView item 布局比较复杂，虽然有复用机制， 但是如果速度过于快速，会导致内存飙升比较快。 所以我们可以对 RecyclerView 的滑动速度做一个限制。 可以避免过快加载内容，一定程度上减少APP不卡顿不掉帧。 RecyclerView 快速拖动条 完整代码请参看 AivinReader app:fastScrollEnabled=\"true\" app:fastScrollHorizontalThumbDrawable=\"@drawable/recyclerview_thumb_drawable\" app:fastScrollVerticalThumbDrawable= \"@drawable/recyclerview_thumb_drawable\" app:fastScrollHorizontalTrackDrawable=\"@drawable/recyclerview_line_drawable\" app:fastScrollVerticalTrackDrawable= \"@drawable/recyclerview_line_drawable\" 宽度可以通过设置。注：高度不生效。 如果 Thumb 、TrackDrawable 的宽不一样，那么就是大的那个来确定。 系统自带的，有人觉得数据太多的时候滑块的高度太小了， 想要一个固定高度的滑块。系统的是没办法了，因为并没有对外提供可以修改的东西。 我们可以使用第三方的库 https://github.com/quiph/RecyclerView-FastScroller ( no Copyright，enjoy youself ! ) all right reserved，powered by GitbookThe file was updated at : 2021-08-26 16:45:34 "},"chinese/android基础/android坐标体系.html":{"url":"chinese/android基础/android坐标体系.html","title":"Android坐标体系","keywords":"","body":"屏幕坐标系 在Android系统中，屏幕的左上角是坐标系统的原点（0,0）坐标。 原点向右延伸是X轴正方向，原点向下延伸是Y轴正方向。 View坐标系 View坐标系以父视图的左上角为坐标原点。 getTop(); //获取子View左上角距父View顶部的距离 getLeft(); //获取子View左上角距父View左侧的距离 getBottom();//获取子View右下角距父View顶部的距离 getRight(); //获取子View右下角距父View左侧的距离 event.getX(); //触摸点相对于其所在视图坐标的坐标 event.getY(); event.getRawX();//触摸点相对于屏幕的坐标 event.getRawY(); ( no Copyright，enjoy youself ! ) all right reserved，powered by GitbookThe file was updated at : 2021-01-22 11:57:19 "},"chinese/android基础/APP的启动流程.html":{"url":"chinese/android基础/APP的启动流程.html","title":"APP启动流程","keywords":"","body":"android 相关 启动流程 本文的分析都是 基于 android-7.1.1-r1 的源码。 有些类可能在高版中会被废弃。 例如 自 API 26(android8.0 ) ，代理类 ActivityManagerProxy 已经被删除。 init 进程 它是内核启动的第一个用户级进程,它的进程号总是1 。 init的入口函数 // system/core/init/init.cpp int main(int argc, char** argv) { property_init(); // 对属性进行初始化 start_property_service(); // 启动属性服务 parser.ParseConfig(\"/init.rc\"); // 解析init.rc配置文件并启动zygote进程 } zygote 进程 ，受精卵 进程 zygote 由 init进程 通过 fork 的方式创建启动的。 zygote 是Android系统上所有应用进程的父进程，我们系统上app的进程都是由这个zygote分裂出来的。 SystemServer 进程 zygote 进程 fork 出 SystemServer 进程 android\\internal\\os\\ZygoteInit.java public static void main(String argv[]) { startSystemServer(abiList, socketName); // 启动 SystemServer 进程 ，根据反射 fork 出 } PackageManagerService 服务 、PMS 由 SystemServer 服务启动 。 // SystemServer.java , startBootstrapServices() mPackageManagerService = PackageManagerService.main(... ); ActivityManagerService 服务 、 AMS 由 SystemServer 服务启动 。 所有的APP应用都需要 与 AMS 打交道. // SystemServer.java , startBootstrapServices() mActivityManagerService = mSystemServiceManager.startService( ActivityManagerService.Lifecycle.class).getService(); Launcher 启动流程 、 Launcher3 app Launcher app 由 AMS 启动 。 // ActivityManagerService.java , Intent getHomeIntent() { // 启动 的 桌面程序 intent.addCategory(Intent.CATEGORY_HOME); } Launcher APP 启动流程 1、内核启动 2、内核启动 init 进程 3、init 进程 fork Zygote 进程 4、zygote 进程 fork 出 SystemServer 进程 5、SystemServer 服务 启动 AMS 、 PackageManagerService 服务 6、AMS 启动 Launcher app 点击桌面 app 图标 到打开 APP的流程 1、点击App图标，Launcher 用 Binder 跨进程 向 SystemServer 进程发起 startActivity 请求 2、SystemServer 进程接收到请求后，向 zygote 进程发送创建进程的请求 3、zygote 进程 fork 出新的子进程（即App进程） 4、App进程 通过 Binder 向 SystemServer 进程发起 attachApplication() 请求 5、SystemServer 进程在收到请求后，进行一系列准备工作后， 再通过 Binder 向App进程 发送 scheduleLaunchActivity() 请求； 6、App进程 的 binder 线程 ApplicationThread 在收到请求后， 通过handler向主线程发送 LAUNCH_ACTIVITY 消息； 7、主线程在收到 Message 后，通过 handler 机制 创建目标Activity，并回调 Activity.onCreate() 等方法。 Activity 启动流程 、startActivity 启动过程 整个流程有点复杂，不看着源码讲有点麻烦。可以参考这篇博客 http://gityuan.com/2016/03/12/start-activity/ 相关类 Instrumentation .java 每个 Activity 都持有 Instrumentation 对象的一个引用， 但是整个进程只会存在一个 Instrumentation 对象。 Instrumentation 这个类里面的方法大多数和 Application 和 Activity 有关， 这个类就是完成对 Application 和 Activity 初始化和生命周期的工具类 ,是一个大管家。 ActivityThread 在 ActivityThread .java 中定义 负责与 AMS 交互。 ApplicationThread 在 ActivityThread .java 中定义 ActivityStack ActivityStackSupervisor ActivityManagerProxy ApplicationThreadProxy ( no Copyright，enjoy youself ! ) all right reserved，powered by GitbookThe file was updated at : 2021-01-05 16:38:37 "},"chinese/android基础/View加载流程.html":{"url":"chinese/android基础/View加载流程.html","title":"View加载流程","keywords":"","body":"相关类 Window.java、PhoneWindow.java Window 是抽象类，表示一个窗口的概念。Window是所有视图的载体。 PhoneWindow 中有个内部属性 DecorView ， 通过创建 DecorView 来加载 Activity 中设置的布局 R.layout.xxx , PhoneWindow 是 Window 的唯一实现类， PhoneWindow 通过 Activity 去控制 View 。 当我们调用 Activity 的 setContentView() 时，其实最终会调用Window的setContentView()， 当我们调用 Activity 的 findViewById()时，其实最终调用的是Window的findViewById()， 这说明了 Window 是 View 的管理者。 WindowManager.java ( interface ) WindowManager 是外界访问Window的入口 , WindowManager 的主要功能是提供简单的API使得使用者可以方便地将一个控件作为一个窗口添加到系统中， 使得开发者无需关注与WMS复杂的通信过程， 通过WindowManager即可简单的添加删除窗口。 而 WindowManager 通过 Binder 机制与 WindowManagerService 进行跨进程通信， 最终把具体的实现工作交给 WindowManagerService。 WindowManagerImpl.java ( class ) private final WindowManagerGlobal mGlobal; // 实际实现者 private final Display mDisplay; //保存所属屏幕 private final Window mParentWindow; // 窗口 WindowManagerGlobal.java (单例) IWindowSession sWindowSession ;// aidl ,与 WMS ArrayList mRoots // 根View 的管理者 IWindowManager sWindowManagerService // adil ,WMS 在 client 的代理 ArrayList mViews // 所有窗口的根View ( 即DecorView) ArrayList mParams //布局参数 WindowManagerService.java WMS 运行在 system_server 进程中 ， android 的窗口管理服务 ， 要处理对输入事件的派发、 负责管理窗口 Surface 的布局等具体工作。 SurfaceFlinger.cpp SurfaceFlinger 将 WMS 维护的窗口 Surface 显示到 屏幕上。 基本只做与“显示”相关的事情 。 DecorView.java DecorView extends FrameLayout DecorView 是整个 Window 界面的最顶层 View。 可以用 Androidstudio 的工具查看 DecorView的布局。 Tools -> Layout Inspector Activity.java Activity 并不负责视图控制，它只是控制生命周期和处理事件。 真正控制视图的是Window。 Window 通过 Activity 操作 View 。 一个 Activity包含和维护着一个 Window 对象 ，Window才是真正代表一个窗口。 ViewRootImpl.java 、ViewRoot(已经废弃) 从字面上来看 ViewRootImpl 是 ViewRoot 的实现，其实不是的。 Android 2.2 中 ViewRoot 被废弃，由 ViewRootImpl 替代了。 PhoneWindow 通过 WindowManager 将 DecorView 加载其中，并将 DecorView 交给 ViewRootImpl ， ViewRootImpl 作为 连接器，连接 DecorView 与 WMS，负责与 WMS 进行直接的通讯 。 ViewRootImpl 负责与 WMS 进行直接的通讯， 负责管理Surface， 负责触发View的测量、布局、绘制， 同时也是输入事件的中转站， 输入事件的派发处理都由ViewRootImpl触发。 它是WindowManagerGlobal工作的实际实现者， 它需要负责与WMS交互通信以调整窗口的位置大小， 以及对来自WMS的事件（如窗口尺寸改变等）作出相应的处理。 总之，ViewRootImpl是整个控件系统正常运转的动力所在 。 ViewManager.java 接口 是一个功能接口，定义了增、删、更新 View的能力。 void addView(xx); void updateViewLayout(xx); void removeView(xx); 关系图 总结 Window 是 View 的载体，我们想要对Window进行删除，添加，更新 View 就得通过 WindowManager ， WindowManager 与 WindowManagerService 通过 Session 进行通信，具体的实现就交给了 WindowManagerService 处理， WindowManagerService 会为每一个 Window 创建一个 WindowState 并管理它们， 具体的渲染工作 WindowManagerService 就交给 SurfaceFlinger 处理。 提问 Activity、Window、ViewRootImpl、DecorView之间的联系 Activity 中包含一个 Window ,Window中包含一个DecorView 。 MainActivity.this.getWindow() .getDecorView(); 其他的请参看上面的关系图。 Activity 有几个 PhoneWindow (Window) 只有一个。在 Activit.java 中的 attach()中创建 . PhoneWindow 创建的时机 在 Activit.java 中的 attach()中创建 . final void attach( xxx) { attachBaseContext(context); mWindow = new PhoneWindow(this, window, activityConfigCallback); mWindow.setWindowControllerCallback(this); } ViewRootImpl 创建的时机 用户在 添加 View的时候，最终会 跳转到 WindowManagerGlobal 的 addView(xx) , 在这个函数中 ViewRootImpl 被创建 ViewRootImpl root = new ViewRootImpl(view.getContext(), display); view.setLayoutParams(wparams); this.mRoots.add(root); // ArrayList mRoots = new ArrayList(); Activity 创建的时机 在 ActivityThread 的 performLaunchActivity( ...) 中被创建 。 ClassLoader cl = r.packageInfo.getClassLoader(); activity = this.mInstrumentation.newActivity(cl, component.getClassName(), r.intent); DecorView 创建的时机 在 PhoneWindow 的 setContentView(...) 时会进行一系列的判断， 其中会 对 mDecor 进行判断 ，如果为空 就会进行新建。 return new DecorView(context, featureId, this, getAttributes()); 除了 Activity 还有哪些方式显示 Window 1、Dialog Dialog implements Window.Callback, , Window.OnWindowDismissedCallback ... Dialog( Context context, int themeResId, xx) { ... mWindowManager = (WindowManager) context.getSystemService(Context.WINDOW_SERVICE); final Window w = new PhoneWindow(mContext); mWindow = w; } setContentView()后的加载流程 一路追踪源码，发现用户的view是被添加到mContentParent中。 ViewGroup mContentParent = generateLayout(mDecor); ViewGroup contentParent = (ViewGroup)findViewById(ID_ANDROID_CONTENT); public static final int ID_ANDROID_CONTENT = com.android.internal.R.id.content; setContentView 如何把xml文件显示到 Activity中的 setContentView(R.layout.activity_main) 将布局文件交给 PhoneWindow ， 1、PhoneWindow 会实例化一个 DecorView(这是每个Activity根布局)往这个布局里添加了一个 LinearLayout 2、PhoneWindow 最终交给 LayoutInflater 去处理 ，获得一个 Viwe (会被放到 DecorView中)。 先创建最外层的 View // Temp is the root view that was found in the xml final View temp = createViewFromTag(root, name, inflaterContext, attrs); 然后用反射的方式 获得子View ，并添加到 temp 。 3、PhoneWindow 用 Callback 通知刷新 UI final Callback cb = getCallback(); cb.onContentChanged(); LayoutInflater 如何把xml文件显示到 Activity中的 LayoutInflater inflater = (LayoutInflater) mCtx.getSystemService(Context.LAYOUT_INFLATER_SERVICE); View rootView = inflater.inflate(R.layout.lonlatinputwindow, null); this.setContentView(rootView); 具体流程参看 setContentView 的流程。 ViewGroup 相关方法 checkLayoutParams() 用来检查你的 LayoutParams 是否是正确。 @Override protected ViewGroup.LayoutParams generateLayoutParams(ViewGroup.LayoutParams p) { return new SecondaryScreenView.LayoutParams(p); } generateDefaultLayoutParams() 获取默认的 LayoutParams generateLayoutParams() //ViewGroup.LayoutParams generateLayoutParams(AttributeSet attrs) 从 xml 获得的 LayoutParams //ViewGroup.LayoutParams generateLayoutParams(ViewGroup.LayoutParams p) if (!checkLayoutParams(params)) { params = generateLayoutParams(params); } When a ViewGroup is passed a View whose layout params do not pass the test of checkLayoutParams(android.view.ViewGroup.LayoutParams ) , this method is invoked. ( no Copyright，enjoy youself ! ) all right reserved，powered by GitbookThe file was updated at : 2021-08-13 14:03:43 "},"chinese/android基础/事件分发机制.html":{"url":"chinese/android基础/事件分发机制.html","title":"事件分发机制","keywords":"","body":"事件分发理解 一个事件包括三个部分： ACTION_DOWN 、ACTION_MOVE、ACTION_UP 。 如果事件被拦截了导致 ACTION_DOWN都没能接收到，后面两个步骤肯定是没有的。 事件类型 MotionEvent.ACTION_DOWN //按下View(所有事件的开始) MotionEvent.ACTION_UP //抬起View MotionEvent.ACTION_MOVE MotionEvent.ACTION_CANCEL // 非人为原因，事件取消 事件分发的主要对象 1、Activity 通过其他回调方法与Window、View交互 2、View 3、ViewGroup // (ViewGroup extends View) 跟事件相关的常用方法 // Activity dispatchTouchEvent(MotionEvent ev) // 当事件传递给当前对象时，最先被调用 onTouchEvent(MotionEvent event) // 被 dispatchTouchEvent 被调用 // View dispatchTouchEvent(MotionEvent ev) // 当事件传递给当前对象时，最先被调用 onTouchEvent(MotionEvent event) // 被 dispatchTouchEvent 被调用 //ViewGroup //(ViewGroup extends View) dispatchTouchEvent(MotionEvent ev) // 当事件传递给当前对象时，最先被调用 onTouchEvent(MotionEvent event) // 被 dispatchTouchEvent 被调用 onInterceptTouchEvent(MotionEvent ev) // 用来决定是否拦截事件。只有在ViewGroup才有这个方法。被 dispatchTouchEvent 调用。 事件分发、消费顺序 事件如果被上级拦截(return true)，下级就无法收到。 事件如果被下级消费掉(return true)，就不会继续往上传。 分发顺序 Activity –> 外层ViewGroup –> 内层ViewGroup –> View 消费顺序 View –> 内层ViewGroup –> 外层ViewGroup –> Activity Activity事件分发详情 事件开始 --> Activity.dispatchTouchEvent{ getWindow().superDispatchTouchEvent(ev) } --> PhoneWindow(Window).superDispatchTouchEvent{ return mDecor.superDispatchTouchEvent(event) } --> DecorView(FrameLayout).superDispatchTouchEvent{ return super.dispatchTrackballEvent(event) // super是ViewGroup，所以Activity 跟Goup连接起来了 } --> 如果ViewGroup把事件消耗掉，返回true ，Activity的dispatchTouchEvent 就直接返回true ，事件结束。 否则就去调用Activity的onTouchEvent ，然后事件结束。 View事件分发详情 dispatchTouchEvent( ) --> onTouch (setOnTouchListener) 如果onTouch消耗掉事件，返回true --> 事件结束 如果onTouch 不处理事件，返回 false --> onTouchEvent --> performClick --> onClick(setOnClickListener)--> 事件结束 ViewGroup事件分发详情 dispatchTouchEvent() --> onInterceptTouchEvent() --> ... 事件分发图解 ( no Copyright，enjoy youself ! ) all right reserved，powered by GitbookThe file was updated at : 2020-09-10 10:53:57 "},"chinese/android基础/控件绘制流程.html":{"url":"chinese/android基础/控件绘制流程.html","title":"控件绘制流程","keywords":"","body":"UI 绘制的类和函数 LayoutInflater 它的作用类似于 findViewById(),不同点是LayoutInflater是用来找 layout 下xml布局文件，并且实例化。 而findViewById() 是找具体xml下的具体控件。 LayoutInflater inflater1 = activity.getLayoutInflater(); LayoutInflater inflater2 = LayoutInflater.from(this); LayoutInflater inflater3 = (LayoutInflater)activity.getSystemService(LAYOUT_INFLATER_SERVICE); // XmlPullParser parser, ViewGroup root, boolean attachToRoot // 参数意义：parser :R.layout.abc , root :root布局 attachToRoot :是否加到root布局中 View itemView=inflater1.inflate(R.layout.abc, null); 注意： 通过 inflate 获得的view 是获取到的长宽都是为0 。 // itemView.getWidth() 、itemView.getHeight() 都会为0 为了能获得长宽，我目前采用的是如下方式 ： 将这个布局放到启动页下 ，通过 findViewById 的方式获取到后 保存起来给其他用 。 MeasureSpec MeasureSpec 通过一个int数值 (widthMeasureSpec 、heightMeasureSpec) 保存“模式”和“大小”， 前2位表示“大小的模式” ，后30bit表示 “尺寸大小” int mode=MeasureSpec.getMode(widthMeasureSpec); int size=MeasureSpec.getSize(widthMeasureSpec); //MeasureSpec.AT_MOST 父容器给子View一个极限值，最多可以多少。这个值可以用 getSize()获取到 int widthSize =MeasureSpec.getSize(widthMeasureSpec) //MeasureSpec.EXACTLY ,用的较多 父容器给子View指定了一个明确的值，这个值可以用 getSize() 获取到 int widthSize =MeasureSpec.getSize(widthMeasureSpec) //MeasureSpec.UNSPECIFIED ,很少用 父容器不约束子View的大小。 onMeasure() 测量自己 测量 View 的大小 ，决定了 view 本身的大小。 子View 根据父容器传入的对自己的约束参数，根据自己的实际情况进行修改最终确认后 再把修改结果告诉父容器。 父容器传给 子View 的模式是 UNSPECIFIED 还是 AT_MOST ， 是根据 子View 在 xml(或代码) 的配置 和 父容器自己的条件来决定的。 具体原理移步阅读 getChildMeasureSpec() 源码 。 @Override protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) { int measureWidth = getMyViewSize(100, widthMeasureSpec); int measureHeight = getMyViewSize(200, heightMeasureSpec); setMeasuredDimension(measureWidth, measureHeight); } private int getMyViewSize(int defaultSize, int measureSpec) { int result = defaultSize; int specMode = MeasureSpec.getMode(measureSpec); int specSize = MeasureSpec.getSize(measureSpec); // 这里的处理只是举例，实际开发中需要根据自己的控件类型修改方案 switch (specMode) { case MeasureSpec.UNSPECIFIED: result = defaultSize; break; case MeasureSpec.AT_MOST: result = defaultSize; break; case MeasureSpec.EXACTLY: result = specSize; break; } return result; } onLayout() 摆放、布局 结合 measure() 决定 View 自己 在 ViewGroup中的位置如何。 在 ViewGroup 中是 abstract, 必须重写。 在View中是空函数，一般不用重写。 protected void onLayout(boolean boo, int l, int t, int r, int b) { for (int j=0;j onDraw() 绘制 决定如何绘制这个 View 。 measure() // 测量入口，一般不用重写。 public final void measure(int widthMeasureSpec, int heightMeasureSpec){ } getChildMeasureSpec (ViewGroup.java) 父容器对 子View的测量。 ViewGroup.java 中的源码阅读 public static int getChildMeasureSpec(int spec, int padding, int childDimension) { // childDimension 为 layout_width/layout_height 的值，用整数表示 int specMode = MeasureSpec.getMode(spec); int specSize = MeasureSpec.getSize(spec); // padding 为其他已使用的空间，也就是说该布局里已使用了padding， //这部分已经不能分配了，只能分配余下的空间了。 int size = Math.max(0, specSize - padding); int resultSize = 0; int resultMode = 0; switch (specMode) { //父布局的测量模式是确切的 case MeasureSpec.EXACTLY: if (childDimension >= 0) { // 子布局声明了自己想要确切的尺寸：childDimension，那么父布局就答应它， //并且子布局的测量模式为确切的 resultSize = childDimension; resultMode = MeasureSpec.EXACTLY; } else if (childDimension == ViewGroup.LayoutParams.MATCH_PARENT) { //子布局声明了自己想要的尺寸是与父布局一样大，那么父布局就答应它，将剩下的尺寸给它 // 因为父布局是确切的尺寸，因此子布局的测量模式为确切的 resultSize = size; resultMode = MeasureSpec.EXACTLY; } else if (childDimension == ViewGroup.LayoutParams.WRAP_CONTENT) { //子布局声明了自己想要的尺寸是包括内容，它自己当前也不知道具体要多大， //那么父布局就答应它，将剩下的尺寸给它 //因为不知道自己具体多大，因此子布局测量模式为AT_MOST(最多） resultSize = size; resultMode = MeasureSpec.AT_MOST; } break; case MeasureSpec.AT_MOST: if (childDimension >= 0) { //与上面一致 resultSize = childDimension; resultMode = MeasureSpec.EXACTLY; } else if (childDimension == ViewGroup.LayoutParams.MATCH_PARENT) { //虽然子布局声明了与父布局一样大，但是父布局是AT_MOST，父布局也不知道自己有多大， //因此给子布局的测量模式是AT_MOST(最多） resultSize = size; resultMode = MeasureSpec.AT_MOST; } else if (childDimension == ViewGroup.LayoutParams.WRAP_CONTENT) { //与上面一致 resultSize = size; resultMode = MeasureSpec.AT_MOST; } break; // Parent asked to see how big we want to be case MeasureSpec.UNSPECIFIED: ... break; } //通过MeasureSpec 封装测量模式和尺寸 return MeasureSpec.makeMeasureSpec(resultSize, resultMode); } layout() 确定View自己的位置。 ViewGroup中的 是 final void layout ，不能重写。 View中 public void layout ，可以重写。但是一般不重写。 在 父容器中直接让子View直接调用即可。 for (int j=0;j setMeasuredDimension() 子控件控件在 自己的 onMeasure() 确定了自己的尺寸后，告知父容器。 一般在 onMeasure() 中调用。 onSizeChanged() 该方法在当前View尺寸变化时被调用 。 可以在这里重新获取view的长宽等参数。 protected void onSizeChanged(int w, int h, int oldw, int oldh) { super.onSizeChanged(w, h, oldw, oldh); if (w != oldw || h != oldh) { mHeight = h; mMaxOverScrollDistance = w / 2.f; } } dispatchDraw() 绘制子View。 View 没有重写 dispatchDraw的必要。 ViewGroup 貌似一般也不用重写 dispatchDraw ，只是在合适的地方调用一下自己的这个方法，使得自己的子View都去重新绘制。 invalidate() 、postInvalidate() 都是用于刷新界面。 invalidate 在UI线程调用。 postInvalidate 在非UI线程调用，将非UI线程切换到UI线程，最后也是调用invalidate 。 在 View 已被附加在 当前窗口的前提下，invalidate 一定会引起 onDraw 。 如果是 ViewGroup ，默认是认为不需要重新绘制的 ， 如果没有设置过背景 ，调用 invalidate ，viewGroup 的 onDraw 不会被调用。 invalidate 不会导致 onMeasure 和 onLayout 被调用，而 OnDraw 会被调用。 requestLayout() 常用于更新 。 requestLayout 会导致调用 measure()过程 和 layout()过程， 将会根据标志位判断是否需要 onDraw。 invalidate 会导致调用 onDraw 。 所以一般而言，如果是绘制内容变了就调用 invalidate ， 如果是位置变了就调用 requestLayout 。 requestLayout 会导致 onMeasure 和 onLayout 被调用。不一定会触发 OnDraw 。 setWillNotDraw( ) setWillNotDraw(true) // 设置后 就不会调用 onDraw() 。一般用来优化GroupView View中默认设置为false ,ViewGroup默认设置为true 。 提问 自定义控件 xml 中设置 \"wrap_content\"与\"match_parent\" 为什么效果是一样的 当我们分别设置 layout_width=wrap_content、layout_width=match_parent 时， 父容器传给 子控件的 模式分别为: AT_MOST、 EXACTLY 如果 自定义控件没有 重写 onMeasure() ,就会调用 View.onMeasure的方法， 然后在 getDefaultSize() 中对 AT_MOST 、EXACTLY 的处理是一样的。 protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) { setMeasuredDimension(getDefaultSize(getSuggestedMinimumWidth(), widthMeasureSpec), getDefaultSize(getSuggestedMinimumHeight(), heightMeasureSpec)); } public static int getDefaultSize(int size, int measureSpec) { int result = size; int specMode = MeasureSpec.getMode(measureSpec); int specSize = MeasureSpec.getSize(measureSpec); switch (specMode) { case MeasureSpec.UNSPECIFIED: result = size; break; case MeasureSpec.AT_MOST: case MeasureSpec.EXACTLY: result = specSize; break; } return result; } 如何触发重新绘制 invalidate() 、postInvalidate() 首次 View 的绘制流程是在什么时候触发的 始于 ViewRootImpl 的 performTraversals() 。 有调用 performMeasure() -> performLayout() -> performDraw() 如何获取 自定义控件的宽高 1、addOnGlobalLayoutListener private void test(){ final View thisView = this; this.getViewTreeObserver().addOnGlobalLayoutListener(new ViewTreeObserver.OnGlobalLayoutListener() { @Override public void onGlobalLayout() { thisView.getViewTreeObserver().removeOnGlobalLayoutListener(this); int height = thisView.getMeasuredHeight(); int width = thisView.getMeasuredHeight() ; } }); } 2、view.post() 、 view.postDelayed() view.post() 方法在整个view树的 performMeasure 、 performLayout 、performDraw执行完后， 才被主线程轮询到，才得到执行。 因此整个View树都完成了测量，布局，绘制。 所以可以拿到宽高信息。 getWidth() 与 getMeasuredWidth() 的区别 getMeasuredWidth() 获取的是view原始的大小，也就是这个view在XML文件中配置或者是代码中设置的大小。 getWidth() 获取的是这个view最终显示的大小，他们不一定相等。 1、getMeasuredWidth() 的赋值在View的 setMeasuredDimension() 中， 它的值在 onMeasure 方法运行后就会确定。 在 setMeasuredDimension()方法调用之后，我们才能使用 getMeasuredWidth() 和 getMeasuredHeight() 来获取视图测量出的宽高，以此之前调用这两个方法得到的值都会是0。 2、getWidth() 在 onLayout() 完成后才会被赋值。 Window 尺寸测量流程 基于7.1.1源码 WindowManager.addView() , WindowManager的实现类是 WindowManagerImpl ， 所以直接看 WindowManagerImpl的 addView() public void addView( View view, ViewGroup.LayoutParams params) { applyDefaultToken(params); // WindowManagerGlobal mGlobal mGlobal.addView(view, params, mContext.getDisplay(), mParentWindow); } 跳转到 WindowManagerGlobal.addView() public void addView(View view, ViewGroup.LayoutParams params ...) { final WindowManager.LayoutParams wparams = (WindowManager.LayoutParams) params; ViewRootImpl root; View panelParentView = null; synchronized (mLock) { // 传进来的 View 作为 根布局 root = new ViewRootImpl(view.getContext(), display); view.setLayoutParams(wparams); // 传进的 LayoutParams 作为 root 的参数 mViews.add(view); // 记录保存 view mRoots.add(root); mParams.add(wparams); } // ViewRootImpl 和 View 关联起来 root.setView(view, wparams, panelParentView); } // 跳转到 ViewRootImpl 的 setView() public void setView(View view, WindowManager.LayoutParams attrs, View panelParentView) { synchronized (this) { if (mView == null) { mView = view; mWindowAttributes.copyFrom(attrs); // 将 LayoutParams 保存起来 attrs = mWindowAttributes; requestLayout();// 开启 view 的三大流程 try { // IPC 跨进程通信 ，通知 WindowManagerService 去创建 Window // 将 LayoutParams 作为参数传递过去 // 返回的 res 表示这个 Window 可以展示的最大尺寸 res = mWindowSession.addToDisplay(mWindow, mSeq, mWindowAttributes, getHostVisibility(), mDisplay.getDisplayId(), mAttachInfo.mContentInsets, mAttachInfo.mStableInsets, mAttachInfo.mOutsets, mInputChannel); } catch (RemoteException e) { throw new RuntimeException(\"Adding window failed\", e); } // 使用和保存 res mAddedTouchMode = (res & WindowManagerGlobal.ADD_FLAG_IN_TOUCH_MODE) != 0; mAppVisible = (res & WindowManagerGlobal.ADD_FLAG_APP_VISIBLE) != 0; } } } 从上述代码可以看出 LayoutParams 作用于 自定义的View 和 Window 每次 performMeasure() 一定能够触发执行onMeasure()吗？会。 // ViewRootImpl.java private void performMeasure(int childWidthMeasureSpec, int childHeightMeasureSpec) { mView.measure(childWidthMeasureSpec, childHeightMeasureSpec); } // View.java public final void measure(int widthMeasureSpec, int heightMeasureSpec) { final boolean forceLayout = (mPrivateFlags & PFLAG_FORCE_LAYOUT) == PFLAG_FORCE_LAYOUT; final boolean needsLayout = specChanged && (sAlwaysRemeasureExactly || !isSpecExactly || !matchesSpecSize); // 需要强制layout 、尺寸发生变化layout if (forceLayout || needsLayout) { onMeasure(widthMeasureSpec, heightMeasureSpec); } 因为View尺寸没变过，所以 needsLayout 是不满足的， 那么只能是 forceLayout=true了。 在第一次测量 ViewTree 的时候，仅仅只是走了 Measure 过程，并未走Layout过程。 而我们知道 PFLAG_FORCE_LAYOUT 标记是在 Layout 结束后清空的，因此此处 PFLAG_FORCE_LAYOUT 标记并没有清空， 当然 needsLayout=true 满足条件。所以 if (forceLayout || needsLayout) 会执行。 } 为什么会多次调用 onMeasure() ,至少2次 基于7.1.1源码 ViewRootImpl 在 setView() 中调用了requestLayout 注册了回调， 当屏幕刷新信号到来之时执行 performTraversals() 开启三大流程。 public void setView( ) { requestLayout();// 经过几个方法的跳转 最后会调用 scheduleTraversals() } // WindowManagerImpl.java // 在 performTraversals() 有5个重要步骤 private void performTraversals() { WindowManager.LayoutParams lp = mWindowAttributes;// addView() 保存的布局参数 int desiredWindowWidth; // Window 需要的长宽 int desiredWindowHeight; Rect frame = mWinFrame; if (mFirst) { if (shouldUseDisplaySize(lp)) { } else { // 获取在 setView() 保存的 WindowManagerService 返回的 Window长宽 desiredWindowWidth = dipToPx(config.screenWidthDp); desiredWindowHeight = dipToPx(config.screenHeightDp); } if (layoutRequested) { final Resources res = mView.getContext().getResources(); // Ask host how big it wants to be ，测量 ViewTree ① windowSizeMayChange |= measureHierarchy(host, lp, res,desiredWindowWidth, desiredWindowHeight); } if (mFirst || mAttachInfo.mViewVisibilityChanged) { // 重新确定 Window 的尺寸 ② relayoutResult = relayoutWindow(params, viewVisibility, insetsPending); ... if (!mStopped || mReportNextDraw) { if (focusChangedDueToTouchMode || mWidth != host.getMeasuredWidth() || mHeight != host.getMeasuredHeight() || contentInsetsChanged || updatedConfiguration) { // 再次测量 ViewTree ③ performMeasure(childWidthMeasureSpec, childHeightMeasureSpec); ... if (didLayout) { // 对 ViewTree 进行 Layout ④ performLayout(lp, mWidth, mHeight); ... if (!cancelDraw && !newSurface) { // 开始 对 ViewTree 进行绘制 ⑤ performDraw(); } } 步骤① measureHierarchy() 这个函数作用是 1、结合 Window尺寸，确定 RootView 的测量模式和预估测量值 (MeasureSpec) 2、根据 MeasureSpec ，发起对 ViewTree的测量（从RootView开始) measureHierarchy() 执行后，RootView 的测量值已经确定了。 measureHierarchy() 测量 ViewTree 是为了确定 RootView 的尺寸, 步骤② relayoutWindow() relayoutWindow() 依赖于 RootView 的测量尺寸 进而确定 Window 尺寸。 跟着博客还没看完，累了，下次继续看 https://www.jianshu.com/p/6e45f42da304 为什么会多次调用 onLayout() 自定义控件 自定义View的意义 1、实现基础控件无法做到的特效。 2、代码封装后方便给其他成员共用，无需重复造轮子。 3、将控件的内部逻辑封装在自定义View中，便于应用内解耦 Android自定义View类型 1、组合控件 将基础控件(TextView、ProgressBar等)组合而成，比如下拉刷新控件等。 2、完全自定义控件 继承 View(UI在主线程中绘制)、ViewGroup 等顶级控件或 SurfaceView 特定控件。 难点在于程序的设计、事件传递处理、效率优化。 SurfaceView extends View ，但是是一个比较特殊的系统控件。UI在一个子线程中进行绘制。 View自定义属性 通过定义属性，使得开发者可以在xml中对控件进行一些参数配置。 不过，我不喜欢这种方式，我习惯在代码中配置。 动态修改高度 private void setViewHeight(View view, int height) { // 父容器为约束布局时，此处有一个bug， // 动态设置，高度为 0时，设置setLayoutParams 会异常，view.getHeight() 会变成原始高度。 // 原因暂时未知。 if(height 文字绘制 文字宽度 // measureText 测量文字绘制时所占用的宽度。 // 一个文字在界面中，往往需要占用比他的实际显示宽度更多一点的宽度， // 以此来让文字和文字之间保留一些间距，不会显得过于拥挤。 float textWidth= mPaint.measureText(distanceInfo) ; // getTextBounds 测量的是文字的显示范围, // 这段文字外放置一个可变的矩形，然后把矩形尽可能地缩小， // 一直小到这个矩形恰好紧紧包裹住文字，那么这个矩形的范围，就是这段文字的 bounds。 mPaint.getTextBounds(distanceInfo, 0, distanceInfo.length(), rect); WkLog.showLog(\"textWidth2=\"+rect.width()+\" \"+ rect.height()); // getTextWidths 获取字符串中每个字符的宽度，并把结果填入 参数 widths float[] widths =new float[distanceInfo.length()] ; mPaint.getTextWidths(distanceInfo ,widths) ; float sumWidth =0 ; for(float value : widths){ sumWidth+=value ; } 文字高度 以下高度是有差异的，请理解定义标准。 // 通过 FontMetrics 获取 Paint.FontMetrics fm=mPaint.getFontMetrics(); float textHeight1=fm.bottom-fm.top; // 通过 Paint 获取 float textHeight2=mPaint.descent()-mPaint.ascent(); // 通过 getTextBounds 获取 mPaint.getTextBounds(stringInfo, 0,stringInfo.length(), bounds); 对于大部分中文英文，高度如果用 top 和 bottom 计算，会有偏差，字 体被偏下了一点点，应该用ascent和descent计算 部分国家的特殊字符的上下高度会超过descent，ascent，用top和bottom计算 。 字符间距 // 字符行间距 ，这个值是系统根据文字的字体和字号自动计算的。(无法直接设置) float space= mPaint.getFontSpacing(); // 字符之间的间距 float letterSpace =mPaint.getLetterSpacing(); WkLog.showLog(\"letterSpace=\"+letterSpace); mPaint.setLetterSpacing(2.1f) ; drawText() 基准点 canvas.drawText(stringInfo, x, y, mPaint); FontMetrics Android文本绘制是以 baseline 为 y ，以基准点开始绘制。 规定 baseline 的y 坐标为0 ， 所以 top 和 ascent 值是负值， descent 和 bottom 的值是正值。 要在设置完Paint的文字大小，宽度之类属性后再获取 FontMetrics 。 fontMetrics.leading // 上一行文字的descent到当前行文字的ascent ，即行间距。 fontMetrics.ascent // 到字符最高处距离 fontMetrics.descent // 到字符最低处距离 fontMetrics.top // ascent 上面 有一段预留的空间，用于显示读音符号等 fontMetrics.bottom // descent 下面还会有一段预留的空间，用于显示读音符号等 矩形中文字居中 canvas.drawRect(rectF ,mPaint); // 绘制文字 Paint.FontMetrics fontMetrics= mPaint.getFontMetrics(); float distance0=(fontMetrics.bottom - fontMetrics.top)/2 - fontMetrics.bottom; float baseY=rectF.centerY() + distance0; // 基点坐标Y = 矩形Y坐标 + 矩形中心与基线的距离 float baseX = viewWith/2f ; mPaint.setColor(Color.RED); canvas.drawText(strInfo,baseX ,baseY ,mPaint); 圆角图片 通过 paint.setXfermode 绘制( 传统方法) 当绘制多个图层叠加的时候。 在两个绘制图形过程中，Pain 添加Xfermode绘制模式，能够改变两个图的叠加效果。 XferMode主要是将2张图片合在一起，根据不同的参数实现不同的效果 。 类似ps中的 mask 遮罩效果原理。 通过 BitmapShader 绘制圆角 原理就是 新建一个 Drawable， 通过 BitmapShader 来设置 Paint ， 绘制出一个圆角矩形 RectF canvas.drawRoundRect(rectF, ROUNDVALUE, ROUNDVALUE, mPaint); 最后用 ImageView 将 Drawable 显示出来即可。 public class RoundedImageDrawable extends Drawable { private Paint mPaint; private Bitmap mBitmap; private RectF rectF; private static final int ROUNDVALUE =60 ; public RoundedImageDrawable(Bitmap bitmap) { mBitmap = bitmap; BitmapShader bitmapShader = new BitmapShader(bitmap, TileMode.CLAMP, TileMode.CLAMP); mPaint = new Paint(); mPaint.setAntiAlias(true); mPaint.setShader(bitmapShader); } @Override public void setBounds(int left, int top, int right, int bottom) { super.setBounds(left, top, right, bottom); rectF = new RectF(left, top, right, bottom); } @Override public void draw(@NonNull Canvas canvas) { // rx：x方向上的圆角半径。 ry：y方向上的圆角半径。 canvas.drawRoundRect(rectF, ROUNDVALUE, ROUNDVALUE, mPaint); } @Override public int getIntrinsicWidth() { return mBitmap.getWidth(); } @Override public int getIntrinsicHeight(){ return mBitmap.getHeight(); } @Override public void setAlpha(int alpha) { mPaint.setAlpha(alpha); } @Override public void setColorFilter(ColorFilter cf){ mPaint.setColorFilter(cf); } @Override public int getOpacity() { return PixelFormat.TRANSLUCENT; } } // 使用 imageView.setImageDrawable(new RoundedImageDrawable(bitmap)); 通过 canvas.clipPath 绘制圆角 原理非常简单，就是定义一个 Path ， 然后通过 path.moveTo( ) 和 path.lineTo( ) 定义好 path 的轮廓， 然后调用 canvas.clipPath(path) 将轮廓绘制出来。 public class RoundedImageDrawable extends AppCompatImageView { private float width, height; private Path path = new Path(); public RoundedImageDrawable(Context context) { this(context, null); } public RoundedImageDrawable(Context context, AttributeSet attrs) { this(context, attrs, 0); } public RoundedImageDrawable(Context context, AttributeSet attrs, int defStyleAttr) { super(context, attrs, defStyleAttr); // 硬件加速 会导致背景为黑色，不要设置setLayerType(View.LAYER_TYPE_SOFTWARE, null); } @Override protected void onLayout(boolean changed, int left, int top, int right, int bottom) { super.onLayout(changed, left, top, right, bottom); width = getWidth(); height = getHeight(); } private static final int VALUE = 80 ; @Override protected void onDraw(Canvas canvas) { path.reset(); path.moveTo(VALUE, 0); path.lineTo(width - VALUE, 0); path.quadTo(width, 0, width, VALUE); path.lineTo(width, height - VALUE); path.quadTo(width, height, width - VALUE, height); path.lineTo(VALUE, height); path.quadTo(0, height, 0, height - VALUE); path.lineTo(0, VALUE); path.quadTo(0, 0, VALUE, 0); canvas.clipPath(path); super.onDraw(canvas); } } 通过 ViewOutlineProvider 绘制 (支持任何 View ) 直接使用 ViewOutlineProvider Added in API level 21 ， Android 5.0 以上才支持。 private void setClipViewCornerRadius(View view, final int radius) { view.setOutlineProvider(new ViewOutlineProvider() { @Override public void getOutline(View view, Outline outline) { outline.setRoundRect(0, 0, view.getWidth(), view.getHeight(), radius); } }); view.setClipToOutline(true); } 通过 ShapeableImageView 绘制 (推荐) // ShapeableImageView 是 material 包下的一个控件， 底层是使用了 ViewOutlineProvider 来实现的 ， ViewOutlineProvider 是Android在 5.0之 后提出的对 Shape 处理的标准API， 其效率会比传统的通过 Xfermode 进行裁剪的方式高很多。 implementation 'com.google.android.material:material:1.2.0' 注意 padding 要设置成 strokeWidth 的一半。 rounded 50% rounded 20% cut 15dp cut 50% rounded rounded 50% 50% Glide 实现圆角 Glide 图片框架可以直接支持显示圆角图片 .transform(RoundedCorners(300))//设置圆角半径 圆角矩形背景 RoundRectShape 这种方式可以避免 .9.png 切的不好导致的图片模糊问题 class BgRoundRectShapeTool { public static RoundRectShape getRoundRectShap(int leftTop, int rightTop, int rightBottom, int leftBottom){ float [] outerRadii = new float[8]; if (leftTop > 0) { outerRadii[0] = leftTop; outerRadii[1] = leftTop; } if (rightTop > 0) { outerRadii[2] = rightTop; outerRadii[3] = rightTop; } if (rightBottom > 0) { outerRadii[4] = rightBottom; outerRadii[5] = rightBottom; } if (leftBottom > 0) { outerRadii[6] = leftBottom; outerRadii[7] = leftBottom; } return new RoundRectShape(outerRadii, null, null); } } public class BgDrawable extends StateListDrawable { private int buttonPress = 0xFFEAEAEA; private int mBackgroundColor = 0xFFf8f8f8 ; public BgDrawable(int leftTop, int rightTop, int rightBottom, int leftBottom ) { //按下 ShapeDrawable drawablePress = new ShapeDrawable( BgRoundRectShapeTool.getRoundRectShap(leftTop, rightTop, rightBottom, leftBottom) ); drawablePress.getPaint().setColor( buttonPress); //默认 ShapeDrawable defaultDrawable = new ShapeDrawable( BgRoundRectShapeTool.getRoundRectShap(leftTop, rightTop, rightBottom, leftBottom) ); defaultDrawable.getPaint().setColor(mBackgroundColor); addState(new int[]{android.R.attr.state_pressed}, drawablePress); addState(new int[]{-android.R.attr.state_pressed}, defaultDrawable); } } // 使用 textView.setBackground(new BgDrawable(mRadius, mRadius, mRadius, mRadius)); 自定义控件示例 分贝波形图 https://gitee.com/Aivin_CodeShare/android_tool_code/raw/master/AudioWaveView.java 瀑布流 现在的 RecyclerView 已经直接支出 瀑布流布局了。 // 实现思路 将手机屏幕分成N块 ， 每当需要添加一张图片时，会将这张图片的宽度压缩成和列一样宽，再按照同样的压缩比例对图片的高度进行压缩， 然后在这三列中找出当前高度最小的一列，将图片添加到这一列中。 之后每当需要添加一张新图片时，都去重复上面的操作，就会形成瀑布流格局的照片墙。 然后解决下内存溢出问题。 手势控件 GestureDetector ，ScaleGestureDetector 。 支持识别 向左 、向右、 向上 、向下 、手势放大 、手势缩小 、停止缩放、 双击、 单击 、 长按 。 https://gitee.com/Aivin_CodeShare/android_tool_code/raw/master/GestureView.java 九宫格 //思路 在xml中，九宫格宽度设置为 match_parent ,高度设置为 wrap_content， 在代码中计算得到每一张图片的宽度。(根据容器宽度减去图片之间的间隔和容器左右的padding)。 然后根据自定义的规则获取每一行的高度，例如高度等于宽度或者按比例获得高度等。 然后调用 addView 将图片添加到 ViewGroup 。 //demo 代码 https://gitee.com/Aivin_CodeShare/android_tool_code/raw/master/NineGridLayout.zip MPAndroidChart 图表绘制 https://github.com/PhilJay/MPAndroidChart 是 Android 中一个较流行的第三方开源库 。 适用于 Android 2.2 ( API 8 ) 及以上。 本次讲解基于 v3.0.3 版本。 MPAndroidChart 的动画机制只在Android API 11 及以上有效 。 ( no Copyright，enjoy youself ! ) all right reserved，powered by GitbookThe file was updated at : 2021-08-05 11:26:39 "},"chinese/android基础/进程通信.html":{"url":"chinese/android基础/进程通信.html","title":"进程通信","keywords":"","body":"多进程通信 进程通信、多进程通信、 进程间通信 进程和线程的区别 一个程序至少有一个进程,一个进程至少有一个线程。 区别的本质 : 操作系统对他们的调度和资源分配不同。 从逻辑角度来看，多线程的意义在于一个应用程序中，有多个执行部分可以同时执行。 但操作系统并没有将多个线程看做多个独立的应用来实现进程的调度和管理以及资源分配。 进程是具有一定独立功能的程序关于某个数据集合上的一次运行活动, 进程是系统进行资源分配和调度的一个独立单位。 进程在执行过程中拥有独立的内存单元，而多个线程共享内存， 从而极大地提高了程序的运行效率。 进程和线程的主要差别在于它们是不同的操作系统资源管理方式。 进程有独立的地址空间，一个进程崩溃后，在保护模式下不会对其它进程产生影响。 所以多进程的程序要比多线程的程序健壮，但在进程切换时，耗费资源较大，效率要差一些。 dvm 指 dalivk 的虚拟。每一个Android应用程序都在它自己的进程中运行, 都拥有一个独立的 Dalvik虚拟机实例。 而每一个 DVM 都是在Linux 中的一个进程,所以说可以认为是同一个概念. 进程级别 、进程优先级 前台进程 > 可见进程 > 服务进程 > 后台进程 > 空进程 前台进程 正在与用户交互的进程。 可见进程 可以被看见，但是并没有正在交互。 例如你的　activity　被一个悬浮窗或者系统弹窗挡住部分了。 服务进程 例如 下载进程、音乐播放进程 后台进程 例如　按下 Home 键 进入了后台。 空进程 只是出于缓存的目的而被保留,为了更加有效地使用内存而不是完全释放掉 ， 只要系统需要可以随时杀掉它们。 如何提高进程优先级 我们并不能直接指定 XX进程是 前台进程 或可见进程。而是由系统来判断决定的。 我们只能尽可能地让进程的优先级可能高一点。这就是 “进程保活” 的话题了。 例如 指定优先级 多进程的使用场景 1、将核心模块跑在一个进程中，降低被系统kill的概率。 2、android 系统的内存限制是针对进程的，多开几个进程 可以获得更多的内存。 3、模块化开发，子进程中崩溃并不会导致主进程崩溃。提高程序的健壮性 。 APP使用多进程带来的不良影响 因为多进程导致多个虚拟机，会导致以下问题出现： 1、静态成员和单例模式完全失效 。 2、线程同步机制完全失效。 3、SharedPreferences 的可靠性下降， 这是因为 SharedPreferences 不支持两个进程并发进行读写。 4、 Application 会多次创建。 Android 系统在创建新的进程时会分配独立的虚拟机， 所以这个过程其实就是启动一个应用的过程， 自然也会创建新的Application。 5、进程间传递的信息要么是 基本数据类型 ，要么就必须能被序列化 。 跨进程通信原理 因为安全机制，一个进程不能直接操作或者访问另一个进程，只能通过IPC方案进行访问。 Linux系统将一个进程分为 用户空间 和 内核空间。 对于进程之间来说，用户空间的数据不可共享，内核空间的数据可共享。 用户空间 可以通过 系统回调 与内核空间通信。 如果在内核空间中有一个模块，能够完成数据的转发，就实现了跨进程通信。 Android 进程间通信方案 1、 Intent + Bundle 同一个app中的不同进程单向通信。一般用于四大组件中。 2、socket socket都可以实现网络通信，那么实现跨进程通信自然是ok的。开销大。 3、通过文件 不同的进程通过对同一个文件进行读写来实现信息交互。 4、ContentProvider 基于 Binder 的 ContentProvider 可以让 一个应用向其他应用暴露接口，提供数据。 5、BroadcastReceiver 通过广播播放实现单方面通知。 6、android.os.Messenger 基于AIDL。串行通信。 一个 server 运行在一个 apk 中 ， 另一个apk 绑定服务，发送和接收信息。 7、AIDL + Binder 支持并发交互。 相关术语 RPC Remote Procedure Call Protocol， 远程过程调用协议 。 IPC inter process communication ，多进程通信的过程。 oom_adj 对于每一类别的进程会有其 oom_adj 值的取值范围。在系统执行低杀操作时，会从oom_adj值越高的开始杀。 Binder Binder是一种用来实现进程间通信的架构。 AIDL Android Interface definition language ,用来定义进程间的通信接口。 是一种 android内部 进程通信接口的描述语言。 当作为客户的一方和要和作为服务器的一方进行通信时，需要指定一些双方都认可的接口， 这样才能顺利地进行通信。而AIDL就是定义这些接口的一种工具。 为什么要借助AIDL来定义，而不直接编写接口呢, 比如直接通过Java定义一个Interface？ 里涉及到IPC的问题。 在Android平台下,各个进程都占有一块自己独有的内存空间， 各个进程在通常情况下只能访问自己的独有的内存空间，而不能对别的进程的内存空间进行访问。 进程之间如果要进行通信，就必须先把需要传递的对象分解成操作系统能够理解的基本类型， 并根据你的需要封装跨边界的对象。 而要完成这些封装工作，需要写的代码量十分地冗长而枯燥。 因此Android提供了AIDL来帮助你完成这些工作。 AIDL 支持的数据类型 1、Java 的基本数据类型 2、List 和 Map 元素必须是 AIDL 支持的数据类型 、 Server 端具体的类里则必须是 ArrayList 、HashMap 3、其他 AIDL 生成的接口 4、实现 Parcelable 的实体 aidl 的 in 、out 、inout 、oneway // 一般而言，客户端是调用接口， 服务端是服务实现 in 表示数据只能由接口的调用进程流向接口的实现进程， out 表示数据只能由接口的实现进程流向接口的调用进程， inout 则表示数据可在接口的调用进程与实现进程之间双向流通。 oneway 用于修改远程调用的行为， 被oneway 修饰了的方法不可以有返回值，也不可以有带out或inout的参数。 用 oneway 修饰的 AIDL 接口方法，是单向调用，不需要休眠等待另一个进程的返回结果 应用进程只向 binder 驱动发送一次数据就结束返回，不再等待回复数据； 而不用 oneway 修饰的方法需要 休眠 等待 binder 驱动与服务端通信完后，再回复数据给应用端。 注意 不管有没有用 oneway ,binder 驱动最后都会回复 应用进程的， 区别在于 应用进程是否要挂起在那里等待回应。 一些系统服务调用应用进程的时候就会使用 oneway， 比如 AMS 调用应用进程启动 Activity，这样就算应用进程中做了耗时的任务，也不会阻塞系统服务的运行。 AIDL 实例Demo 代码下载： https://gitee.com/hnyer/aidl-demo 1、ERROR: Process 'command 'F:\\sdk2\\build-tools\\30.0.1\\aidl.exe'' finished with non-zero exit value -1073741701 原因是： buildToolsVersion 可能不兼容，尝试改一下 版本号。 //buildToolsVersion \"30.0.1\" //编译不过 buildToolsVersion \"29.0.1\" // 编译ok XXX bookManager = XXX.Stub.asInterface(service); // 根据server 获取在aidl中的自定义接口 XX.asBinder().isBinderAlive() // isBinderAlive ，判断binder是否还存在 xx.asBinder().isBinderAlive() // asBinder ,根据自定义 aidl接口获得 binder对象 // CopyOnWriteArrayList 一个系统类，只有写入和写入之间需要进行同步等待。 但是有不少缺点：一是内存占用问题，毕竟每次执行写操作都要将原容器拷贝一份，数据量大时，对内存压力较大 ； 二是无法保证实时性，由于其实现策略的原因，写和读分别作用在新老不同容器上， 在写操作执行过程中，读不会阻塞但读取到的却是老容器的数据。 // RemoteCallbackList 用来存储监听接口。本质是一个 ArrayMap，内部自动实现了线程同步的功能。 xx.getBroadcastItem(i) // 根据索引获取接口 xx.beginBroadcast() // 获取接口个数。beginBroadcast 必须与 finishBroadcast 配对使用 xx.finishBroadcast() xx.register() //添加接口 xx.unregister() // 移除接口 // IBinder.DeathRecipient unlinkToDeath() // 服务端监听客户端进程是否挂掉 // 启动方式 因为 startService 方式不能获得service的方法，所以不能不能拿到AIDL定义的接口，无法双向通信。 所以只能用 bindService 方式，根据 ServiceConnection 获得接口。 ( no Copyright，enjoy youself ! ) all right reserved，powered by GitbookThe file was updated at : 2021-01-21 17:11:55 "},"chinese/通信方式/通信方式详解.html":{"url":"chinese/通信方式/通信方式详解.html","title":"通信方式详解","keywords":"","body":"http 、https 方式 1、http是基于 TCP/IP 的应用层协议 。 2、 采用 “一问一答” 模式 ，并不会保持长连接。 3、HTTP允许传输任意类型的数据对象。传输的类型由Content-Type加以标记。 HTTP Content-type HTTP Content-type 手册 文件扩展名 Content-Type .*（ 二进制流，不知道下载文件类型） application/octet-stream .txt text/plain .xml text/xml .css text/css .html text/html .js application/x-javascript 无文件的表单提交 application/x-www-form-urlencoded 有文件的表单提交 multipart/form-data json格式的请求 application/json 建立、断开 http连接 http建立连接，底层是通过 Tcp协议 经过了3次握手、断开经过4次挥手。具体请查看tcp的相关知识。 TCP/IP协议族 https请求 即使采用了 HTTPS，也可以实现中间人攻击，或者进行数据解密等，但是，目前 HTTPS 目前使用的加密算法需要巨大的计算量才能破解 HTTPS 的目的主要有三个， 一个是数据的保密性，你给别人送个邮包，但邮包是打了封印的，快递员不知道包里装的是啥。 第二是数据的完整性，快递员不知道邮包是啥，但可以调包啊，HTTPS 发现了调包的数据，可以拒收。 第三就是身份验证，HTTPS 可以保证邮包被正确的送到指定的接收方，而不是第三方。 https相关术语 SSL 、TLS SSL（Secure Sockets Layer） , 网景公司设计的。 到了1999年，SSL 因为应用广泛，已经成为互联网上的事实标准。 IETF 就在那年把 SSL 标准化。 标准化之后的名称改为 TLS (Transport Layer Security ) , 这两者可以视作同一个东西的不同阶段。 证书认证 单向证书认证: 任何客户端都可以访问服务器 双向证书认证: 被允许的客户端才能访问服务器 对称加密 、非对称加密 对称加密：加密和解密时使用的是同一个秘钥 // 对称加密 常见的 对称加密算法 有 DES、3DES、Blowfish、IDEA、RC4、RC5、RC6 、 AES 。 在数据传送前，发送方和接收方必须商定好秘钥。 用同一个秘钥进行加密和解密。如果一方的秘钥遭泄露，那么整个通信就会被破解。 非对称加密：用公钥加密，私钥解密 https 在内容传输的加密上使用的是对称加密，非对称加密只作用在证书验证阶段。 // 非对称加密 常见的非对称加密算法有: RSA、ECC 、Diffie-Hellman、El Gamal、DSA 秘钥自己私下保管，公钥可以公开 ，别人通过公钥加密的信息发给你，只有通过私钥才能解密。 不用担心别人把秘钥泄露而导致整个通信被破解。 公钥 、私钥 公钥：负责加密 ，在网络上传输 私钥：负责解密 ，本地保管，别人无法获取 md5 md5 不是对称和非对称算法。而是一种机制，一般用来做一致性校验。 对任何文件或内容 都生成 一串 32位的字符。不能根据字符反推。 比如一个很大的文件，下载完成之后要验证下 md5和给出的是否一致，如果不一致 说明你下载出错了或者文件被别人修改过。 虽然MD5 有很小很小的概率发生碰撞(可以忽略不计)，是一种非常优秀的算法。 http 与 https 有什么区别 http是超文本传输协议，信息是明文传输。 https 多了 SSL/tls 层。使用了加密算法(对称加密和非对称加密) , 大大增加了数据的传输安全。 网景公司设计了 SSL 协议用于对HTTP协议传输的数据进行加密，从而就诞生了HTTPS。 (https 在内容传输的加密上使用的是对称加密，非对称加密只作用在证书验证阶段。) http 各个版本之间的区别 // HTTP/0.9 是第一个版本的HTTP协议 。 只支持 GET 请求方式 。 // HTTP/1.0 开始支持客户端通过POST方法 。 需要使用 keep-alive 参数来告知服务器端要建立一个长连接。 // HTTP/1.1 默认支持长连接。 // http1.2 使用了多路复用的技术，做到同一个连接并发处理多个请求，而且并发请求的数量比HTTP1.1大了好几个数量级。 // http2.0 使用 HPACK 算法对 header 的数据进行压缩， 在网络上传输就会更快。 服务器可以对客户端的一个请求发送多个响应。 // HTTP3.0 HTTP2.0 解决了很多 1.1的问题，但HTTP/2仍然存在一些缺陷， 这些缺陷并不是来自于HTTP/2协议本身，而是来源于底层的TCP协议， 我们知道TCP链接是可靠的连接，如果出现了丢包，那么整个连接都要等待重传， HTTP/1.1可以同时使用6个TCP连接，一个阻塞另外五个还能工作， 但HTTP/2只有一个TCP连接，阻塞的问题便被放大了。 由于TCP协议已经被广泛使用，我们很难直接修改TCP协议， 基于此，HTTP/3选择了一个折衷的方法——UDP协议。 post 和 get 的区别 1、get参数通过url传递，post放在request body中。 2、get请求在url中传递的参数是有长度限制的，而post没有。 3、get比post更不安全，因为参数直接暴露在url中，所以不能用来传递敏感信息。 4、get请求只能进行 UrlEncode编解码 ，而post支持多种编码方式。 5、get请求会浏览器主动cache，而POST不会，除非手动设置。 6、get请求参数会被完整保留在浏览历史记录里，而post中的参数不会被保留。 7、GET和POST本质上就是TCP链接，并无差别。 但是由于HTTP的规定和浏览器/服务器的限制，导致他们在应用过程中体现出一些不同。 HTTP 状态码 当浏览器接收并显示网页前， 此网页所在的服务器会返回一个包含HTTP状态码的信息头用以响应浏览器的请求。 下面是常见的HTTP状态码： 200 - 请求成功 301 - 资源（网页等）被永久转移到其它URL 404 - 请求的资源（网页等）不存在 500 - 内部服务器错误 100 Continue 继续。客户端应继续其请求 101 Switching Protocols 切换协议。服务器根据客户端的请求切换协议。只能切换到更高级的协议，例如，切换到HTTP的新版本协议 200 OK 请求成功。一般用于GET与POST请求 201 Created 已创建。成功请求并创建了新的资源 202 Accepted 已接受。已经接受请求，但未处理完成 203 Non-Authoritative Information 非授权信息。请求成功。但返回的meta信息不在原始的服务器，而是一个副本 204 No Content 无内容。服务器成功处理，但未返回内容。在未更新网页的情况下，可确保浏览器继续显示当前文档 205 Reset Content 重置内容。服务器处理成功，用户终端（例如：浏览器）应重置文档视图。可通过此返回码清除浏览器的表单域 206 Partial Content 部分内容。服务器成功处理了部分GET请求 300 Multiple Choices 多种选择。请求的资源可包括多个位置，相应可返回一个资源特征与地址的列表用于用户终端（例如：浏览器）选择 301 Moved Permanently 永久移动。请求的资源已被永久的移动到新URI，返回信息会包括新的URI，浏览器会自动定向到新URI。今后任何新的请求都应使用新的URI代替 302 Found 临时移动。与301类似。但资源只是临时被移动。客户端应继续使用原有URI 303 See Other 查看其它地址。与301类似。使用GET和POST请求查看 304 Not Modified 未修改。所请求的资源未修改，服务器返回此状态码时，不会返回任何资源。客户端通常会缓存访问过的资源，通过提供一个头信息指出客户端希望只返回在指定日期之后修改的资源 305 Use Proxy 使用代理。所请求的资源必须通过代理访问 306 Unused 已经被废弃的HTTP状态码 307 Temporary Redirect 临时重定向。与302类似。使用GET请求重定向 400 Bad Request 客户端请求的语法错误，服务器无法理解 401 Unauthorized 请求要求用户的身份认证 402 Payment Required 保留，将来使用 403 Forbidden 服务器理解请求客户端的请求，但是拒绝执行此请求 404 Not Found 服务器无法根据客户端的请求找到资源（网页）。通过此代码，网站设计人员可设置\"您所请求的资源无法找到\"的个性页面 405 Method Not Allowed 客户端请求中的方法被禁止 406 Not Acceptable 服务器无法根据客户端请求的内容特性完成请求 407 Proxy Authentication Required 请求要求代理的身份认证，与401类似，但请求者应当使用代理进行授权 408 Request Time-out 服务器等待客户端发送的请求时间过长，超时 409 Conflict 服务器完成客户端的 PUT 请求时可能返回此代码，服务器处理请求时发生了冲突 410 Gone 客户端请求的资源已经不存在。410不同于404，如果资源以前有现在被永久删除了可使用410代码，网站设计人员可通过301代码指定资源的新位置 411 Length Required 服务器无法处理客户端发送的不带Content-Length的请求信息 412 Precondition Failed 客户端请求信息的先决条件错误 413 Request Entity Too Large 由于请求的实体过大，服务器无法处理，因此拒绝请求。为防止客户端的连续请求，服务器可能会关闭连接。如果只是服务器暂时无法处理，则会包含一个Retry-After的响应信息 414 Request-URI Too Large 请求的URI过长（URI通常为网址），服务器无法处理 415 Unsupported Media Type 服务器无法处理请求附带的媒体格式 416 Requested range not satisfiable 客户端请求的范围无效 417 Expectation Failed 服务器无法满足Expect的请求头信息 500 Internal Server Error 服务器内部错误，无法完成请求 501 Not Implemented 服务器不支持请求的功能，无法完成请求 502 Bad Gateway 作为网关或者代理工作的服务器尝试执行请求时，从远程服务器接收到了一个无效的响应 503 Service Unavailable 由于超载或系统维护，服务器暂时的无法处理客户端的请求。延时的长度可包含在服务器的Retry-After头信息中 504 Gateway Time-out 充当网关或代理的服务器，未及时从远端服务器获取请求 505 HTTP Version not supported 服务器不支持请求的HTTP UDP (User Datagram Protocol) UDP 协议 不会对数据报进行任何的处理，即不合并，也不拆分数据。 UDP 的特色在于它所省略的那些功能: 连接状态、握手、重发、重组、重排、拥塞控制、 拥塞预防、流量控制，甚至可选的错误检测，统统没有。 UDP 特点 1、无连接 通信时不需要提前建立连接。 2、不保证可靠的数据交付 想发就发，无法保证数据在网络传输过程中是否丢失。 3、面向报文传输 不对数据做任何处理，而是直接将应用层数据塞进报文里面。 4、没有拥塞控制 不管网络是否拥塞，它都会把数据给交付出去。 5、首部开销很小 首部仅仅占用8个字节。 1）、不保证消息交付：不确认，不重传，无超时。 2）、不保证交付顺序：不设置包序号，不重排，不会发生队首阻塞。 3）、不跟踪连接状态：不必建立连接或重启状态机。 4）、不需要拥塞控制：不内置客户端或网络反馈机制。 TCP 与 UDP 的区别 1、UDP 通常用于多媒体信息分发， 而 TCP 通常用于可靠信息的传输，例如金融交易、可靠通信等。 2、TCP 面向连接，UDP 是无连接的。 3、TCP 提供可靠的服务，也就是说，通过 TCP 连接传送的数据，无差错，不丢失，不重复，且按序到达； UDP 尽最大努力交付，即不保证可靠交付。 4、TCP 的逻辑通信信道是全双工的可靠信道； UDP 则是不可靠信道。 5、每一条 TCP 连接只能是点到点的； UDP 支持一对一，一对多，多对一和多对多的交互通信。 6、TCP 面向字节流（可能出现黏包问题）， 实际上是 TCP 把数据看成一连串无结构的字节流； UDP 是面向报文的（不会出现黏包问题）。 7、UDP 没有拥塞控制，因此网络出现拥塞不会使源主机的发送速率降低。 8、TCP 首部开销20字节； UDP 的首部开销小，只有 8 个字节。 ftp 第三方工具ftp4j ftp登录 public void run(){ //标记是否登录成功 boolean loginError = false ; try { mFTPClient.setType(FTPClient.TYPE_BINARY); //中文文件名 乱码处理 mFTPClient.setCharset(\"GBK\"); //登录成功后FTP服务器返回的欢迎语句 String[] welcome = mFTPClient.connect(FTP.HOST_IP, FTP.HOST_PORT); mFTPClient.login(FTP.HOST_USER, FTP.HOST_PASSWORD); mHandler.sendEmptyMessage(FTP.MSG_CMD_CONNECT_OK); }catch (Exception e) { loginError = true ; } if(loginError && FTP.mDameonRunning){ mHandler.sendEmptyMessageDelayed(FTP.MSG_CMD_CONNECT_FAILED, 2000); } } ftp删除文件（夹） public void run(){ try { if (isDirectory) { //删除文件夹 mFTPClient.deleteDirectory(realivePath); } else { //删除文件 mFTPClient.deleteFile(realivePath); } mHandler.sendEmptyMessage(FTP.MSG_CMD_DELE_OK); } catch (Exception ex) { mHandler.sendEmptyMessage(FTP.MSG_CMD_DELE_FAILED); } } ftp断开连接 if (mFTPClient != null){ try { mFTPClient.disconnect(true); } catch (Exception ex) { ex.printStackTrace(); } } ftp文件下载 if(! localFile.exists()){ long fileSize = ftpFile.getSize() ; if(fileSize > 0){ mFTPClient.download( ftpFile.getName(), new File(localFilePath), new DownloadFTPDataTransferListener(ftpFile.getSize())); }else{ //文件异常的情况 下载发生异常the size of file muset be larger than zero. } } ftp 获取文件列表 @Override public void run(){ try { mFTPClient.changeDirectory(FTP.FTPSMAllPICDIR); FTPFile[] ftpFiles = mFTPClient.list(); synchronized (mLock){ mFileList.clear(); //数组拷贝到list中去 mFileList.addAll(Arrays.asList(ftpFiles)); } mHandler.sendEmptyMessage(FTP.MSG_CMD_LIST_OK); } catch (Exception ex) { mHandler.sendEmptyMessage(FTP.MSG_CMD_LIST_FAILED); } }// ftp 文件上传（进度条） try { File file = new File(path); mFTPClient.upload(file, new DownloadFTPDataTransferListener( file.length())); } catch (Exception ex) { return false; } ftp 连接守护进程 //在子线程中定时判断 if (mFTPClient != null && !mFTPClient.isConnected()){ try { //解决中文件名乱码问题 mFTPClient.setType(FTPClient.TYPE_BINARY); mFTPClient.setCharset(\"GBK\"); mFTPClient.connect(FTP.HOST_IP, FTP.HOST_PORT); mFTPClient.login(FTP.HOST_USER, FTP.HOST_PASSWORD); Thread.sleep(FTP.MAX_DAMEON_TIME_WAIT); } catch (Exception ex) { } } FTP 传输进度 回调 public class DownloadFTPDataTransferListener implements FTPDataTransferListener{ /**已经传送量*/ private int totolTransferred = 0; /**数据总量*/ private long fileSize = -1; public DownloadFTPDataTransferListener(long fileSize){ if (fileSize 使用场景 FtpManager ftpManager = new FtpManager(); //然后 ftp 的相关操作 要放到子线程中去执行。 建议使用线程池。 sockt tcp_udp 进行tcp通信时，需要注意处理 粘包的问题。然后控制好休眠时间 和 接收的 buffer[] 大小。 TCP标志位 (位码) 标记 含义 SYN synchronous 建立联机 ACK acknowledgement 确认 PSH push传送 FIN finish结束 RST reset重置 URG urgent紧急 术语 Sequence number 顺序号码 Acknowledge number 确认号码 MSL Maximum Segment Lifetime ，报文最长存活时间 tcp相关问题 为什么连接的时候是三次握手，2次不行吗? 为了让服务器、客户端端彼此知道 自己+对方的 接收、发送功能正常。 自己模拟一下就知道至少需要三次。 为什么连接的时候是三次握手，关闭的时候却是四次挥手？ 关闭连接时，当Server端收到FIN报文时，很可能并不会立即关闭SOCKET， 所以只能先回复一个ACK报文，告诉Client端，\"你发的FIN报文我收到了\"。 只有等到我Server端所有的报文都发送完了，我才能发送FIN报文，因此不能一起发送。 故需要四步挥手。 （为了争取一段缓冲时间，完成正在进行的数据传输） 为什么客户端在TIME-WAIT状态必须等待2MSL (Maximum Segment Lifetime) 的时间？ 为了保证客户端发送的最后一个ACK报文段能够到达服务器。 因为这个ACK报文段有可能丢失，因而使处在LAST-ACK状态的服务器收不到对已发送的FIN+ACK报文段的确认。 服务器会超时重传这个FIN+ACK报文段。而客户端就能在2MSL时间内收到这个重传的FIN+ACK报文段。 接着客户端重传一次确认，重新启动2MSL计时器。 最后客户端和服务器都正常进入到CLOSED状态。 粘包处理 目前不是最优方法，速度有点慢。想到高效的方法再补充。 public class AirUnPackTools{ /**帧头*/ private static final byte packHead1= (byte) 0xDD; /**是否在有效数据之内*/ private static boolean isContinue = false ; private static byte mlastByte =(byte) 0x00 ; /**byte索引 ， 用来指示 关键字 和 长度 */ private static int mByteIndex = 0; /**当前帧的长度*/ private static int mFrameLengh =0 ; /**临时list*/ private static List lastBytesList = new ArrayList<>() ; /**数据段 数据长度 */ private static int mbyteCount = 0; /**遥控器返回的消息类型 = 0x55 ,5a ,5b ， 00为默认状态，无意义*/ private static byte msgType =0x00 ; public static DronePacket320 unPackageofGround(byte mByte){ DronePacket320 packetGround = null ; //判断是否是帧开头 switch (mByte) { case packHead1: // 连续出现2个DD ，说明这是帧头 if(mlastByte == packHead1 ) { lastBytesList.clear(); lastBytesList.add(packHead1) ; mByteIndex = 0; isContinue = true ; } break; } if(isContinue) { boolean reslut = getUnpackagedFrame(mByte); if(reslut) { packetGround = new DronePacket320() ; packetGround.msgType = msgType ; packetGround.bytes = listToBytesArray(lastBytesList) ; }else{ packetGround = null ; } }else{ packetGround = null ; } mlastByte = mByte ; return packetGround ; } public static byte [] listToBytesArray(List list) { byte[] bytes = new byte[list.size()] ; for(int i= 0; i public class DronePacket320{ public short msgType; public byte[] bytes; } //使用 for (int i = 0; i 第三方库 netty 用来连接tcp、接收 和发送数据的 public interface MyNettyCallBack{ /**tcp成功建立连接*/ public static final int Key_State_connect=1 ; /**tcp断开*/ public static final int Key_State_disConnect=2 ; /**tcp正在重连*/ public static final int Key_State_isReConnect=3 ; /**连接发生异常*/ public static final int Key_State_error=4; /**连接手动关闭*/ public static final int Key_State_close=5; /**连接正常-正在接收数据*/ public static final int Key_State_recevieData=6; /**服务器返回信息给客户端*/ public void sendMsgToUser(byte[] reslut , int state ,String stateMsg) ; } public class NettyTcpTools{ private int port; private String host; private SocketChannel socketChannel; private Bootstrap bootstrap; private boolean isConnect = false; /**是否需要重连*/ private boolean isRepeate = false; /**用来区分是用户主动断开还是异常导致断开用户主动断开的话就不用去重连*/ private boolean isStopByUser =false ; /**通信管道*/ private ChannelFuture future = null; /**状态回调*/ private MyNettyCallBack myNettyCallBack ; /**线程池工具*/ private MyThreadPoolTools myThreadPoolTools ; public NettyTcpTools(String host , int port){ this.port = port; this.host = host; bootstrap = new Bootstrap(); bootstrap.channel(NioSocketChannel.class); //保持长连接 bootstrap.option(ChannelOption.SO_KEEPALIVE, true); //自动调整下一次缓冲区建立时分配的空间大小，避免内存的浪费 bootstrap.option(ChannelOption.RCVBUF_ALLOCATOR, new AdaptiveRecvByteBufAllocator(1024, 1024 * 32, 1024 * 64)); bootstrap.group( new NioEventLoopGroup()); bootstrap.remoteAddress(host, port); bootstrap.handler(new ChannelInitializer() { @Override protected void initChannel(SocketChannel socketChannel) throws Exception { //超时处理 socketChannel.pipeline().addLast(new IdleStateHandler(3, 3, 3 ,TimeUnit.SECONDS)); //接收服务器信息 socketChannel.pipeline().addLast( new NettyClientHandler()); } }); } private void gotoConnectTcp(){ closeThreadPool(); myThreadPoolTools= new MyThreadPoolTools(); Runnable task = new Runnable() { @Override public void run() { isStopByUser = false ; try { if (future != null) { boolean isActive = future.channel().isActive() ; boolean isOpen = future.channel().isOpen() ; MyLogUtils.mLog_iNormal(\"连接测试：isActive=\" + isActive +\" isOpen=\"+ isOpen); /* 这个地方注意了： 如果 没有关闭，会导致多个tcp连接 使用 网络调试助手.exe 进行调试查看*/ future.channel().close(); } future = bootstrap.connect(new InetSocketAddress(host, port)).sync(); if (future.isSuccess()) { socketChannel = (SocketChannel) future.channel(); sendMsgToUser(null ,MyNettyCallBack.Key_State_connect ,\"connect server Success\"); isConnect = true; return; } } catch (Exception cause) { sendMsgToUser(null ,MyNettyCallBack.Key_State_error ,\"error2:\"+cause.toString()); } //连接状态在此处处理 repeateTcp(); } }; if (myThreadPoolTools == null) { myThreadPoolTools= new MyThreadPoolTools(); } myThreadPoolTools.addTask(task); } public void startTcpTools(){ gotoConnectTcp(); } private void closeThreadPool(){ if(myThreadPoolTools!=null) { myThreadPoolTools.shutdownThreadPool(); myThreadPoolTools=null ; } } public void nettySendBytes(final byte[] bytesSend) { Runnable runnable = new Runnable() { @Override public void run() { if (isConnect) { ByteBuf buf = Unpooled.buffer(bytesSend.length); buf.writerIndex(); buf.writeBytes(bytesSend); socketChannel.writeAndFlush(buf); } } } ; if (myThreadPoolTools == null) { myThreadPoolTools= new MyThreadPoolTools(); } myThreadPoolTools.addTask(runnable); } public class NettyClientHandler extends SimpleChannelInboundHandler{ @Override protected void channelRead0(ChannelHandlerContext channelHandlerContext,ByteBuf byteBuf) throws Exception { //这里是接受服务端发送过来的消息 byte[] result = new byte[byteBuf.readableBytes()]; byteBuf.readBytes(result); /*这种方式会定长读取，后面有很多00 00 00 byte[] bytes = byteBuf.array();*/ sendMsgToUser(result ,MyNettyCallBack.Key_State_recevieData ,\"channelRead0\"); } /**这里是断线要进行的操作*/ @Override public void channelInactive(ChannelHandlerContext ctx) throws Exception { super.channelInactive(ctx); ctx.close() ; if(!isStopByUser) { sendMsgToUser(null ,MyNettyCallBack.Key_State_disConnect ,\"channelInactive\"); repeateTcp(); } } /**这里是出现异常的话要进行的操作*/ @Override public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception { //ctx.close() ; sendMsgToUser(null ,MyNettyCallBack.Key_State_error ,\"error1:\"+cause.toString()); repeateTcp(); } /**用来处理读写超时的 自定义操作*/ @Override public void userEventTriggered(ChannelHandlerContext ctx, Object evt) throws Exception { super.userEventTriggered(ctx, evt); if (evt instanceof IdleStateEvent) { IdleStateEvent event = (IdleStateEvent) evt; if (event.state().equals(IdleState.READER_IDLE)) { // 在指定的时间内没有收到服务器的反馈信息 } else if (event.state().equals(IdleState.WRITER_IDLE)) { //在指定的时间内没有像服务器发送过信息 } else if (event.state().equals(IdleState.ALL_IDLE)) { //在指定的时间内 既没有收到过信息 也没有发送过信息 } } } } // 设置消息回调接口，用来获取从服务器返回的消息。 public void setMyNettyCallBack(MyNettyCallBack myNettyCallBack) { this.myNettyCallBack = myNettyCallBack ; } private void sendMsgToUser(byte[] result , int state ,String sendMsgToUser) { if (myNettyCallBack != null) { myNettyCallBack.sendMsgToUser(result ,state ,sendMsgToUser); } } // tcp重连 private void repeateTcp() { if(isStopByUser) { return; } if (!isRepeate) { if (isConnect) { isConnect = false; //断线监听在此处处理 } isRepeate = true; sendMsgToUser(null ,MyNettyCallBack.Key_State_isReConnect ,\"repeateTcp\"); try { TimeUnit.SECONDS.sleep(5); } catch (InterruptedException e) { e.printStackTrace(); } isRepeate = false; startTcpTools(); } } // 关闭 tcp连接 public void nettyToolsClose() { resetState(); closeThreadPool(); if (future != null && future.channel() != null) { if (future.channel().isOpen()) { sendMsgToUser(null ,MyNettyCallBack.Key_State_close ,\"close\"); future.channel().close(); } } } private void resetState() { isConnect = false; isRepeate=false; isStopByUser = true ; } } 拓展知识 数字信号 、模拟信号 模拟信号和数字信号之间是可以相互转换的。 模拟信号：时间连续，幅值连续。 数字信号：时间离散，幅值离散。 在电学中，将连续变化的电压、电流等物理量称为模拟信号，而离散变化的电压、电流则称为数字信号。 模拟信号在日常生活中很常见，譬如家用的220V交流电压、环境温度及光线的变化、蓄电池的放电、人的说话声，这些皆为模拟信号。 数字信号的波形如上图所示，是一个由一系列高低电平组成的离散变化的物理量。数字信号在生活中较少见。 数字信号就是一系列的“0”和“1”的组合。 咱们自然界中各种事物变化，都是模拟信号，比如，随着时间的流逝，太阳缓缓升起， 在这里，时间是连续变化的，太阳的位置也是连续变化的，每一个时间点，对应于一个太阳的位置。 现在，咱们为了研究太阳位置的变化规律，要将这个时间与太阳的位置变化关系交给计算机研究。 有个问题：咱们的时间是连续的，可以无限分下去的，同样的，太阳的位置点也可以有无穷多个，咱们该如何把这么多的数据存储起来呢？ 并且，对于咱们的研究来说，真的需要将这么多的数据存储下来吗？ 所以咱们要进行离散化的处理，比如早晨8点到10点，每隔5分钟，咱们记录一个太阳的位置，这样，储存的数据是不是大大减少了？ 现在，对于这个问题，咱们的时间变量，变成了每隔五分钟一个，咱们的太阳位置，也相对应的变成了离散化的， 也就是说，时间是离散化的，幅值也是离散化的。变成了一个数字信号，也就可以交给计算机处理啦。 OSI ( Open System Interconnection ) 七层模型 // 物理层 物理设备、例如网线、电缆、集线器等. // 链路层 数据链路层，负责对于底层物理信号识别成某种信息。为了匹配物理层电气特征。 将比特组合成字节,再将字节组合成帧,使用链路层地址 (以太网使用MAC地址)来访问介质,并进行差错检测。 链路层就像同城跑腿（网络层是跨城跑腿，类似邮局快递等），你把货交给他，告诉他地址，他直接送达。 链路层识别mac地址，链路联通后，交换机学习各端口的mac地址，建立mac地址转发表，然后链路层就开始工作了。 // 网络层 就是通常说的IP层。这一层就是我们经常说的IP协议层。IP寻址、IPV4 / IPV6 等。 本层通过IP寻址来建立两个节点之间的连接，为源端的运输层送来的分组，选择合适的路由和交换节点， 正确无误地按照地址传送给目的端的运输层。 网络层按理来说，数据链路层已经能够起到信息识别的作用了，为何还需要网络层呢？ 关键就在于数据链路层所能识别出的信息，能够很好的被机器理解。但不能很好的被人所理解。所以需要构建一层来方便人来进行处理。 为什么有了MAC地址，还需要IP地址？ 历史原因：以太网诞生于因特网之前，在IP地址之前MAC地址就已经在使用了。两者结合使用，是为了不影响已存在的协议 分层实现：对网路协议进行分层以后，数据链路层的实现不需要考虑数据之间的转发，网络层的实现不需要考数据链路层的影响。 分工合作：IP地址是会随着主机接入网络的不同而发生改变的，而MAC一般不会改变。这样的话，我们可以使用IP地址进行寻址，当数据报和目的主机处于同一网络时，就使用MAC地址进行数据交付。 // 传输层 对网络层的进一步封装，TCP 、UDP 就是这一层。 // 会话层 负责建立和断开通信连接（数据流动的逻辑通路）。 例如要根据你自己的逻辑，来决定什么时候要进行数据连接、数据重连、连接断开等。 // 表示层 主要负责数据格式的转换。将设备固有的数据格式转换为网络标准传输格式，不同设备对同一比特流解释的结果可能会不同。 例如同样的一串 byte[]数据，不同的APP采用的不是同一套解析协议，所以要根据不同的协议转为APP能识别的信息。 // 应用层 有些分层版本中，将 会话层+表示层+ 应用层 = 统一称为应用层。 因为会话层和表示层没有办法完全抽象成公共层，一般都是和应用层一起实现。 就是各个公司开发的不同的应用。例如 HTTP超文本传输、 HTTPS FTP文件传输 、SMTP邮件传输 等不同侧重方向的传输协议。 usb 通信 AOA协议 Google推出的 Android开放配件协议AOA（Android Open Accessory Protocol）及配件开发工具包ADK（Accessory Development Kit） 提供了Android设备与Android配件通过USB或蓝牙进行通信的API， 为基于Android系统的智能设备控制外设提供了条件。 利用Android，系统可以连接从家用电器到重型机械、机器人等多种设备。 当前项目用到的是 android 的AOA协议。遥控器作为主机供电，移动设备（手机、平板）作为从机。 使用方法请自行查阅相关文档。 使用场景一 ：android设备作为从机 参考资料 这种模式是Android定义的一种新的通讯模式，它将usb配件作为协议交互的主要角色，配件内置USB Embedded Host端，可以为Android手机供电，并且识别Android手机，建立数据通道。使得配件成为一个简化版的PC Host端。 usb通信demo MusbAccessoryManager.java public class MusbAccessoryManager{ private Context mCtx; private ParcelFileDescriptor fileDescriptor; private FileInputStream inputStream; private FileOutputStream outputStream; private AccessoryReadThread readThread; private AccessoryWriteThread writeThread; private BytesDataRepackThread repackThread ; private boolean enableThread; /**发送队列*/ private BlockingQueue outQueue; private BlockingQueue readQuene; private IOperateResultCallBack iUsbResultCallBack ; //private IBytesTransferInterface iGetBytesInterface ; private IUsbPackageTransferInterface iusbpackageTransInterface ; /**读入流 时的休眠间隔 微秒*/ private final long READ_STRING_SLEEPTIME= 20L; /**写入流 时的休眠间隔*/ private final long WRITE_STRING_SLEEPTIME= 60L; /**解析 byte[] 时的休眠间隔*/ private final long REPACKAGE_SLEEPTIME= 0L; /** 调整读取大小*/ private byte[] buffer= new byte[2048 * 3] ; public MusbAccessoryManager(Context context , IOperateResultCallBack iUsbResultCallBack , IUsbPackageTransferInterface iusbpackageTransInterface) { this.mCtx = context; fileDescriptor = null; inputStream = null; outputStream = null; readThread = null; writeThread = null; repackThread =null ; enableThread = false; this.iUsbResultCallBack= iUsbResultCallBack; this.iusbpackageTransInterface = iusbpackageTransInterface; outQueue = new LinkedBlockingQueue(Integer.MAX_VALUE); readQuene = new LinkedBlockingQueue<>(Integer.MAX_VALUE) ; } // 添加数据 到发送队列 public void addMessage(MyBytesTransfer msg) { try { outQueue.put(msg); }catch (Exception e) { MyLogUtils.mLog_iNormal(\"usb设备== 发送异常1 =\"+e.getMessage()); } } // 打开USB通信 public void OpenAccessory(UsbAccessory accessory) { if (!enableThread) { fileDescriptor = ((UsbManager) mCtx.getSystemService(Context.USB_SERVICE)).openAccessory(accessory); if (fileDescriptor != null) { FileDescriptor fd = fileDescriptor.getFileDescriptor(); inputStream = new FileInputStream(fd); outputStream = new FileOutputStream(fd); if (inputStream == null || outputStream == null) { // 读取流异常 return; } //连接成功 iUsbResultCallBack.onResultCallBack(MyStateConfig.STATE_14); enableThread = true; readThread = new AccessoryReadThread(inputStream); readThread.start(); writeThread = new AccessoryWriteThread(outputStream); writeThread.start(); repackThread = new BytesDataRepackThread() ; repackThread.start(); }else{ toastMsg(\"fileDescriptor==null \" ) ; } } }// // 关闭连接、清空队列、停止线程 public void CloseAccessory() { try { if (fileDescriptor != null) { fileDescriptor.close(); } if (outputStream != null) { outputStream.close(); } if (inputStream != null) { inputStream.close(); } }catch (Exception ie) { ie.printStackTrace(); } outQueue.clear(); readQuene.clear(); enableThread = false; fileDescriptor = null; outputStream = null; inputStream = null; } // 读取子线程 private class AccessoryReadThread extends Thread { private FileInputStream inStream; public AccessoryReadThread(FileInputStream stream) { this.inStream = stream; } @Override public void run() { while (enableThread) { try { int realReaded = inStream.read(buffer); if(realReaded>0) { byte [] realBytes = MyStringUtils.subBytes(buffer, 0 , realReaded) ; readQuene.put(realBytes); } } catch (Exception e) { //发生异常，继续执行 continue; } MyApplication.usbReadStreamState= MyStateConfig.STATE_9; try { TimeUnit.MICROSECONDS.sleep(READ_STRING_SLEEPTIME); } catch (InterruptedException e) { e.printStackTrace(); } } // end while } // end run }// // 发送子线程 private class AccessoryWriteThread extends Thread { private FileOutputStream outStream; public AccessoryWriteThread(FileOutputStream outputStream) { this.outStream = outputStream; } @Override public void run() { MyBytesTransfer msg; while (enableThread){ try{ if (outStream != null) { msg = outQueue.poll(); if (msg != null) { sendByteDataToServer(msg.bytes ); msg = null; }else{ } } else{ MyApplication.usbWriteStreamState= MyStateConfig.STATE_11; outQueue.clear(); } MyApplication.usbWriteStreamState= MyStateConfig.STATE_10; try { Thread.sleep(WRITE_STRING_SLEEPTIME); } catch (InterruptedException e) { e.printStackTrace(); } }catch (Exception ex) { com.walkera.base.utils.MyLogUtils.mLog_iNormal(\"发送测试3= msg=\"+ex.getMessage()); MyApplication.usbWriteStreamState= MyStateConfig.STATE_11; } } } // 将数据发送给服务器 private void sendByteDataToServer(byte[] buffer) { try { if (outStream != null) { iUsbResultCallBack.onResultCallBack(MyStateConfig.STATE_13); outStream.write(buffer, 0, buffer.length); outStream.flush(); } }catch (IOException ex) { iUsbResultCallBack.onResultCallBack(MyStateConfig.STATE_12); } }// } // 解析 重组包 子线程 private class BytesDataRepackThread extends Thread{ @Override public void run() { while (enableThread) { if(readQuene!=null) { byte[] realBytes = readQuene.poll() ; if(realBytes!=null) { rePackageForBytes(realBytes) ; } } try { Thread.sleep(REPACKAGE_SLEEPTIME); } catch (InterruptedException e){ e.printStackTrace(); } } // while }//end run } // 重组包 ， 将遥控器 、 飞控、视屏数据分开 . private void rePackageForBytes(byte[] bytes) { if(bytes!=null) { int size =bytes.length ; for(int i=0 ; i UsbMsgClient.java public class UsbMsgClient{ private Context mCtx ; private UsbManager usbmanager ; /**usb 操作管理类*/ private MusbAccessoryManager mubAccessoryManager; private IUsbMsgBackInterface iUsbMsgBackInterface ; public UsbMsgClient (Context mCtx ,IUsbMsgBackInterface iUsbMsgBackInterface ,IOperateResultCallBack iUsbResultCallBack) { this.mCtx = mCtx; this.iUsbMsgBackInterface= iUsbMsgBackInterface ; usbmanager=((UsbManager) mCtx.getSystemService(Context.USB_SERVICE)) ; mubAccessoryManager = new MusbAccessoryManager(mCtx , iUsbResultCallBack ,iusbpackageTransInterface); discoverAccessories(); } // 回调 来自usb的数据 private IUsbPackageTransferInterface iusbpackageTransInterface = new IUsbPackageTransferInterface() { @Override public void transferUsbPackageBean(MyBytesTransfer myBytesTransfer) { if(myBytesTransfer != null) { // 4759图传 - 3678飞控 - 5869 遥控器 if( Arrays.equals(myBytesTransfer.msgType, MyStateConfig.VEDEO_DATA_RECEIVE)) { //视屏数据 iUsbMsgBackInterface.getUsbVedioByte(myBytesTransfer); }else if(Arrays.equals(myBytesTransfer.msgType, MyStateConfig.FC_DATA_RECEIVE)) { //飞控数据 iUsbMsgBackInterface.getUsbFcByte(myBytesTransfer); }else if(Arrays.equals(myBytesTransfer.msgType, MyStateConfig.RC_DATA_RECEIVE)) { //遥控器数据 iUsbMsgBackInterface.getUsbRcByte(myBytesTransfer); } } } } ; // 扫描usb设备 发现从设备 private void discoverAccessories() { UsbAccessory[] list = usbmanager.getAccessoryList(); if (list != null && list.length!=0) { openTheAccessory(list[0]); }else { //MyToastTools.toastWarning(mCtx ,mCtx.getString( R.string.v5_str_1)); } }// // 连接 指定设备 private void openAccessory(UsbAccessory accessory) { mubAccessoryManager.OpenAccessory(accessory); new Handler().postDelayed(new Runnable() { @Override public void run() { byte[] openSession = { (byte)0xDD , (byte)0xDF ,(byte)0x06 ,(byte)0x00 } ; sendBytesToDevices(openSession); } } , 2000) ; } // 连接USB设备 private void openTheAccessory(UsbAccessory accessory) { if (accessory == null) { MyToastTools.toastWarning(mCtx ,mCtx.getString( R.string.v5_str_2)); }else { if (usbmanager.hasPermission(accessory)) { openAccessory(accessory); }else { com.walkera.base.utils.MyLogUtils.mLog_iNormal(\"usb设备== 无权限1\"); } } } // 通知遥控器关闭 private void closeSession() { byte[] closeSession = { (byte)0xDD , (byte)0xDF ,(byte)0x07 ,(byte)0x00 } ; sendBytesToDevices(closeSession); } // 关闭usb收发工具 public void closeUsbMsgClinet() { closeSession(); new Handler().postDelayed(new Runnable() { @Override public void run() { closeAccessory(); } }, 500); } // 断开设备 private void closeAccessory(){ if (mubAccessoryManager != null) { mubAccessoryManager.CloseAccessory(); } } // 发送数据 public void sendBytesToDevices( byte[] data ) { if (mubAccessoryManager != null) { mubAccessoryManager.addMessage(new MyBytesTransfer(data , MyStateConfig.STATE_6,null)); } } } MyStateConfig.java public class MyStateConfig{ /**请求usb访问的自定义权限*/ public static final String ACTION_USB_ACCESSORY_PERMISSION = \"com.wk.USB_ACCESSORY_PERMISSION\"; /**当前参数无意义 */ public final static int STATE_NULL = -100 ; /**所有的状态的初始化状态 */ public final static int STATE_0 = 0 ; /** usb退出 */ public final static int STATE_1 =1 ; /** usb连接异常 , 读取流异常 */ public final static int STATE_2 =2 ; /** usb 权限被拒绝了 */ public final static int STATE_3 =3; /**接收usb byte 正式*/ public final static int STATE_4 =4; /**接收usb byte 测试*/ public final static int STATE_5 =5; /**发送的bytes[]*/ public final static int STATE_6 =6; /**接收到的byte[]*/ public final static int STATE_7 =7; /**usb输入流异常*/ public final static int STATE_8 =8; /**usb输入流正常*/ public final static int STATE_9 =9; /**usb输出流正常*/ public final static int STATE_10 =10; /**usb输出流异常*/ public final static int STATE_11 =11; /**发送失败*/ public final static int STATE_12 =12; /**发送成功*/ public final static int STATE_13 =13; /**Usb连接成功*/ public final static int STATE_14 =14; /**属于相机数据 */ public final static int STATE_15 = 15 ; } xml中的一些配置、usb插入、拔出监听 请参考官网 使用 /**usb收发工具*/ private UsbMsgClient usbMsgClient ; //初始化usb数据接收器 usbMsgClient = new UsbMsgClient( mContext ,iUsbMsgBackInterface ,iUsbResultCallBack) ; //发送byte[]数据 usbMsgClient.sendBytesToDevices(code); //关闭连接 usbMsgClient.closeUsbMsgClinet(); /** * 接收 usb 返回数据 */ private IUsbMsgBackInterface iUsbMsgBackInterface = new IUsbMsgBackInterface(){ /**视屏数据*/ @Override public void getUsbVedioByte(MyBytesTransfer vedioData) { //解码... } /**飞控数据*/ @Override public void getUsbFcByte(MyBytesTransfer fcData) { //解析飞控数据 } /**遥控器数据*/ @Override public void getUsbRcByte(MyBytesTransfer rcData) { //解析遥控器数据 } } ; /** * 接收 usb 操作、状态码 */ private IOperateResultCallBack iUsbResultCallBack = new IOperateResultCallBack(){ @Override public void onResultCallBack(int state ){ //状态码 } }; 私有协议 参数类型对应的字节数 类型 对应字节数 备注 bit 1/8 byte 1 char 1 (char在java中是2个字节) boolean 1 uint8 1 uint8_t 1 uint16 2 uint16_t 2 int16 2 short 2 int 4 float 4 int32 4 uint32_t 4 double 8 long 8 心跳机制 在私有协议中，我们常常需要用心跳来判断对方是否已经掉线。比如持续20秒收不到约定的信号，判断为对方掉线。 public abstract class HeartBeatTask implements Runnable { private String taskName ; public HeartBeatTask( ){ taskName = \"beatTask_\"+System.nanoTime() ; } public String getTaskName() { return taskName; } } public class WkHeartBeatTool { private ScheduledExecutorService mScheduledExecutorService; private HashMap map ; public WkHeartBeatTool() { initTool(); } public int getTaskNum(){ return map==null? 0 : map.size() ; } private void initTool() { mScheduledExecutorService = Executors.newScheduledThreadPool(5);// 线程池大小 5 map = new HashMap() ; } public void startTheBeatAction(HeartBeatTask task , int period){ if(map.containsKey(task.getTaskName())){ System.out.println(\"心跳正在进行，无需重复添加\"); return ; } Future future = mScheduledExecutorService.scheduleAtFixedRate( task , 0, period, TimeUnit.MILLISECONDS); map.put(task.getTaskName() , future) ; } public void shutDownTheBeatAction(HeartBeatTask task ){ Future future = map.get(task.getTaskName()) ; if(future!=null){ future.cancel(true) ; map.remove(task.getTaskName()) ; }else{ System.out.println(\"你指定的这个心跳任务已经不存在，无需关闭\"); } } public void startDelayedAction( HeartBeatTask task , int delayTime){ mScheduledExecutorService.schedule( task, delayTime ,TimeUnit.MILLISECONDS ); } public void shutDownAll() { if (mScheduledExecutorService != null) { mScheduledExecutorService.shutdownNow(); // 强制关闭 mScheduledExecutorService = null; } map.clear(); map=null ; } } WkHeartBeatTool heartBeatTool = new WkHeartBeatTool() ; HeartBeatTask task1 = new HeartBeatTask() { public void run() { ...} }; heartBeatTool.startTheBeatAction(task1, 1000) ;// 开始心跳 heartBeatTool.shutDownTheBeatAction(task1) ;// 停止心跳 heartBeatTool.startDelayedAction(task1, 5 * 1000) ;// 发送延时任务 int sum = heartBeatTool.getTaskNum() ;// 获取 心跳任务总数 heartBeatTool.shutDownAll() ;// 关闭所有任务 并销毁工具 定时批量执行 JobScheduler 我们可以用 Timer 或者开启线程来进行定时执行， 但是这样会比较消耗资源，因为他们是一直在跑的。 从耗电优化的角度出发，google 从 Android 5.0 开始就推出了 JobScheduler 。 值得注意的是 JobScheduler 和 AlarmManager 不一样， 执行这些操作的时间并不是严格准确的。 JobScheduler 会把一系列的job收集起来一起执行， 这样既允许我们的job被执行，又能兼顾到手机电量的使用情况，达到节电的目的。 JobScheduler 支持的最小版本是 Android5.0 ，到目前为止，还没有兼容包来兼容所有版本。 // 自定义 JobService public class MyJobService extends JobService { @Override public boolean onStartJob(JobParameters params) { PersistableBundle extras = params.getExtras(); int age = extras.getInt() ; // 获取参数 String name = extras.getString() ; doJob(params); /* 当返回false的时候，系统会认为onStartJob这个方法返回的时候，我们要做的工作已经做完了，这不是一个耗时的工作。 当返回true的时候，系统会认为我们要执行一个耗时的工作，在onStartJob这个方法返回的时候，我们的工作仍然在异步执行。 当我们的工作执行完成的时候，我们必须手动调用 jobFinished(JobParameters params, boolean needRescheduled) 如果不调用jobFinished，系统会一直认为我们在执行当前Job，那么系统就不会再入队其他的Job去执行， 也就是说JobScheduler的执行队列就会被阻塞了 */ return true; } /* 也就是说在系统受到取消请求时，并不会一定会调用onStopJob方法， 只有onStartJob返回true的时候，才会调用onStopJob，否则不调用。 但不论是否调用onStopJob方法，系统受到取消请求时，都会取消该 job */ @Override public boolean onStopJob(JobParameters params) { Log.i(\"stop service\",\"stop job service\"); return false; } private void doJob(JobParameters params) { Log.i(\"do service\",\"do job service\"); jobFinished(params ,false); } // 服务申明 # 使用 demo JobInfo.Builder builder = new JobInfo.Builder(1, new ComponentName(this, MyJobService.class)); // 延迟执行时间 ， 与 setPeriodic 互斥，不能同时设置 builder.setMinimumLatency(TimeUnit.MILLISECONDS.toMillis(10)); //设置最大延迟执行时间 ,在某段时间之后必须执行，即使设置的其他条件不满足(比如我们还设置了要求充电，连接wifi等条件)。 // 这是一个严格准时的执行 ,与 setPeriodic 互斥，不能同时设置 builder.setOverrideDeadline(TimeUnit.MILLISECONDS.toMillis(15)); // 执行周期 builder.setPeriodic( TimeUnit.MILLISECONDS.toSeconds(5000)); // 是否为持久任务，如果是持久任务，则系统会将该任务写入磁盘 ，在关机重启后，该任务依然可以恢复执行 // 需要声明权限RECEIVE_BOOT_COMPLETED builder.setPersisted(false) ; // 任务调度失败后的重新调度策略和时间 builder.setBackoffCriteria(TimeUnit.MILLISECONDS.toMillis(10),JobInfo.BACKOFF_POLICY_LINEAR); //启动Job时所需要的网络类型 ,没有达到这条件就不会执行job // NETWORK_TYPE_NONE 不需要网络 ，NETWORK_TYPE_ANY 任何网络 ，NETWORK_TYPE_UNMETERED 需要WiFi builder.setRequiredNetworkType(JobInfo.NETWORK_TYPE_UNMETERED); // 是否需要连接电源 builder.setRequiresCharging(true); // 是否需要机器处于空闲状态。 builder.setRequiresDeviceIdle(false) ; // 是否需要非低电量 ，requires API level 26 builder.setRequiresBatteryNotLow(false) ; // 存储空间非低量， requires API level 26 builder.setRequiresStorageNotLow(false) ; // 设置额外参数 , 在 onStartJob 可以获取 PersistableBundle extras = new PersistableBundle(); extras.putString(); extras.putInt(); builder.setExtras ( extras) ; JobScheduler jobScheduler = (JobScheduler)getSystemService(Context.JOB_SCHEDULER_SERVICE); if(jobScheduler==null){ throw new RuntimeException(\"JobScheduler is null...\") ; } jobScheduler.schedule(builder.build()); // 启动 JobService Intent intent = new Intent(this, MyJobService.class); startService(intent); ( no Copyright，enjoy youself ! ) all right reserved，powered by GitbookThe file was updated at : 2021-04-08 10:38:20 "},"chinese/android基础/Binder详解.html":{"url":"chinese/android基础/Binder详解.html","title":"Binder详解","keywords":"","body":"Binder详解 从英文字面上意思看，Binder 具有粘结剂的意思，那么它把什么东西粘结在一起呢？ 在Android系统的Binder机制中，Binder由 Client、Server、Service Manager 和Binder驱动组成。 Binder就是一种把这四个组件粘合在一起的粘结剂了。 为什么要采用Binder Linux 现有的进程通信手段有以下几种： 1、管道 ; 2、消息队列; 3、共享内存; 4、套接字; 5、信号量。 Linux 已经有多种跨进程通信方式，Android基于Linux的，Android为何还要采用Binder？ 注：( Binder 不是Android提出来的一套新的进程间通信机制，它是基于OpenBinder实现的) 这是主要从以下几个原因考虑的： 1、效率。 对于消息队列、 Socket 和 管道来说， 数据先从发送方的缓存区拷贝到内核开辟的缓存区中， 再从内 核缓存区拷贝到接收方的缓存区，一共两次拷贝。 2、稳定性 因为共享内存需要处理并发同步问题，容易出现死锁和资源竞争，稳定性较差。 3、安全性 传统 Linux IPC 的接收方无法获得对方进程可靠的 UID/PID，从而无法鉴别对方身份。 而 binder方式做了改进，建立私有通道，更安全。 方式 缺点 优点 数据拷贝次数 共享内存 控制机制复杂 0 Binder 可以建立私有通道、有UID鉴别身份 1 socket 开销大、效率低 2 管道、消息队列 效率低 2 Binder 架构 Binder是一种架构 ,定义了一种通信机制。 这种架构提供了 服务端接口、Binder驱动、客户端接口 三个模块。 Binder使用 Client-Server 通信方式 (C/S架构)，安全性好，简单高效，再加上其面向对象的设计思想， 独特的接收缓存管理和线程池管理方式，成为Android进程间通信的中流砥柱。 Binder的通信模型有4个角色： Binder Client 、Binder Server 、ServiceManager 、Binder Driver 这4个角色的关系和互联网类似： Server 是服务器，Client 是客户终端， ServiceManager 是域名服务器 ，Binder Driver 是路由器。 Binder Client 使用数据。 调用其他进程中的相关服务。由开发者实现。 Binder Server 提供数据 。 提供相关的服务。由开发者实现。 ServiceManager 提供了 查询服务 和 注册服务 的功能。 Android系统已经实现。 Service Manager是一个守护进程。 Binder Driver Binder 驱动，将数据从进程B的用户空间中拷贝到进程A的用户空间。 尽管名叫“驱动” ，实际上和硬件设备没有任何关系， 存在于内核空间中。Android系统已经实现。 相关 类、方法 、概念 1、Native端： IBinder 、BBinder 、BpBinder 、IPCThread 、ProcessState、IInterface 、JavaBBinder jni端： android_util_Binder.cpp 2、Java端： IBinder 、 Binder、BinderProxy（Binder的一个内部类）、 Stub、 Proxy 、ServiceManager（Java源码 被@hide了） 3、Binder Driver 端： binder_proc、 binder_thread、 binder_node 、ioctl（是一个函数） Binder实体 是 binder_node结构体的对象。 实名 Binder 注册了名字的Binder。 匿名 Binder Server 端可以通过已经建立的 Binder 连接将创建的 Binder 实体传给 Client 。 由于这个 Binder 没有向 ServiceManager 注册名字，所以是个匿名Binder。 匿名Binder 为通信双方建立一条私密通道，只要 Server 没有把匿名Binder发给别的进程， 别的进程就无法通过穷举或猜测等任何方式获得该Binder的引用。 Binder引用 每一个Binder引用都是某一个Binder实体的引用。 0号引用 我们可能会发现一个细节： ServiceManager 是一个进程，Server 是另一个进程 ， Server向 ServiceManager 注册 Binder 必然会涉及进程间通信。 当前实现的是进程间通信却又要用到进程间通信，这就好象蛋可以孵出鸡前提却是要找只鸡来孵蛋。 Binder 的实现比较巧妙：系统给 ServiceManager 创建一个特殊专门的 Binder实体。 它没有名字也不需要注册。 一个 Server 若要向 ServiceManager 注册自己 Binder 就必需通过0这个引用号和 ServiceManager 的Binder通信。 为什么Binder只进行了一次数据拷贝？ 、mmap() 先把数据拷贝到内核的缓存区，然后再从内核的缓存区拷贝给接收方。 这样做会产生两次数据的拷贝。 linux中的管道通信就是采取这种方式。 但是 binder 进一步优化， 数据从 发送方的缓存区 拷贝到内核的缓存区， 而 接收方的缓存区 与内核的缓存区被是映射到同一块物理地址的，因此只需要一次拷贝即可。 mmap() 分配的内存除了映射进了接收方进程里，还映射进了内核空间。 所以调用 copy_from_user() 将数据拷贝进内核空间也相当于拷贝进了接收方的用户空间 。 binder 怎么验证 pid ( 比传统 验证方式 更安全) 传统 Linux IPC 的接收方无法获得对方进程可靠的 UID/PID，从而无法鉴别对方身份。 pid 验证流程 暂时还未学习。 Binder通信命令字 BINDER_WRITE_READ |该命令向Binder写入或读取数据 BINDER_SET_MAX_THREADS |该命令告知Binder驱动接收方线程池中最大的线程数 BINDER_SET_CONTEXT_MGR|将当前进程注册为SMgr。 BINDER_THREAD_EXIT|通知Binder驱动当前线程退出了。 BINDER_VERSION|获得Binder驱动的版本号 BC_TRANSACTION|Client向Server发送请求数据 BC_REPLY|Server向Client发送回复数据 BC_ACQUIRE_RESULT、 BC_ATTEMPT_ACQUIRE BC_FREE_BUFFER| 释放一块映射的内存 BC_INCREFS、BC_ACQUIRE 、BC_RELEASE 、BC_DECREFS|增加或减少Binder的引用计数 BC_INCREFS_DONE 、BC_ACQUIRE_DONE|处理完毕反馈信息 BC_REGISTER_LOOPER|通知驱动线程池中一个线程已经创建了 BC_ENTER_LOOPER|通知驱动该线程已经进入主循环，可以接收数据 BC_EXIT_LOOPER|通知驱动该线程退出主循环，不再接收数据 BC_REQUEST_DEATH_NOTIFICATION| 要求驱动在Binder实体销毁得到通知 BC_DEAD_BINDER_DONE|收到销毁通知的进程在删除引用后用本命令告知驱动 BR_ERROR|发生内部错误 BR_OK 、BR_NOOP|操作完成 BR_SPAWN_LOOPER|向接收方发送该命令要求创建更多线程以备接收数据 BR_TRANSACTION 、BR_REPLY|表示当前接收的数据是请求还是回复 BR_ACQUIRE_RESULT 、BR_ATTEMPT_ACQUIRE 、BR_FINISHED BR_DEAD_REPLY|交互过程中如果发现对方进程或线程已经死亡则返回该消息 BR_TRANSACTION_COMPLETE|发送数据包后，收到该消息做为成功发送的反馈 BR_INCREFS 、BR_ACQUIRE 、BR_RELEASE 、BR_DECREFS|用于管理强/弱指针的引用计数 BR_DEAD_BINDER 、BR_CLEAR_DEATH_NOTIFICATION_DONE|收到死亡通知书 BR_FAILED_REPLY|如果发送非法引用号则返回该消息 Binder 接收/发送 数据包的标准格式 union { size_t handle;void *ptr; } target; // 指明发送目的地 void *cookie; 存放的是创建Binder实体时由该接收方自定义的任意数值， 做为与Binder指针相关的额外信息存放在驱动中。 unsigned int code; 存放收发双方约定的命令码 unsigned int flags; 与交互相关的标志位 pid_t sender_pid;、uid_t sender_euid; 该成员存放发送方的进程ID和用户ID，由驱动负责填入 size_t data_size; 缓冲区存放的数据长度。 size_t offsets_size; 偏移位置 union { struct { const void buffer; const void offsets; } ptr; uint8_t buf[8]; } data; // 放要发送或接收到的数据, 补充一些 架构图 Binder 通信模型、 Binder 架构 Binder 机制 Binder 驱动 Binder 进程与线程 ServiceManager启动 ServiceManager 注册服务 ServiceManager 获取服务 进行一次完整通讯 ( no Copyright，enjoy youself ! ) all right reserved，powered by GitbookThe file was updated at : 2021-01-14 10:45:22 "},"chinese/android基础/Handler详解.html":{"url":"chinese/android基础/Handler详解.html","title":"Handle详解","keywords":"","body":"Handle、Looper 、Message、MessageQueue 模型 简单的说：一个线程开启一个无限循环模式，不断遍历自己的消息列表，如果有消息就挨个拿出来做处理，如果列表没消息，自己就堵塞（相当于wait，让出cpu资源给其他线程），其他线程如果想让该线程做什么事，就往该线程的消息队列插入消息，该线程会不断从队列里拿出消息做处理。 Looper.prepare() --> sThreadLocal.set(new Looper(quitAllowed)); Looper.loop() // 记住这点就不会弄错执行线程的问题 handleMessage 最终在哪个线程执行 , 要看 Looper 是由哪个 线程创建的。 Message 定义了消息必要的描述和属性数据。 public final class Message implements Parcelable{ public int what;//用来标识一个消息.区分来源 public int arg1; //简单消息 public int arg2; public Object obj; //任意类型数据 public Messenger replyTo; Bundle data;//存储复杂点的对象 Handler target;//发送和处理消息关联的 Handler Runnable callback; //消息的回调 ...... } // 获取 Message 的方式 Message message ; message= new Message(); // Return a new Message instance from the global pool. // Allows us to avoid allocating new objects in many cases. message= Message.obtain(); message= Message.obtain( message ) ; message= Message.obtain( handler ) ; message= Message.obtain( handler, what) ; message= Message.obtain( handler ,runnable) ; // 效果跟 Message.obtain( handler ) 一样 ，因为最终也是执行到了 Message.obtain( handler ) message= handler.obtainMessage(); message= handler.obtainMessage( what); MessageQueue 消息队列 ,提供入队、出队等功能。系统只会自动给主线程建立 MessageQueue。 (子线程也可以有 MessageQueue，只是需要调用 Looper.prepare(); ) boolean enqueueMessage(Message msg, long when) Message next() Handle 负责 Message 的发送和执行处理等。 handler.post(runnable) ; handler.postAtTime(runnable ,0) ; handler.postDelayed( runnable ,0) ; handler.sendMessage(message); handler.sendEmptyMessage( 1 ); handler.sendMessageDelayed(message, 0); // 以上 6个函数 都最后会 被执行到 sendMessageAtTime() handler.sendMessageAtTime(message ,0) ; // 插入到消息队列最前面 handler.postAtFrontOfQueue(runnable) ; Looper 循环器，扮演 MessageQueue 和 Handler 之间桥梁的角色，循环取出 MessageQueue 里面的Message，并交付给 Handler 进行处理。 Looper 在prepare中通过ThreadLocal保证了每个线程Looper对象的唯一性， 对于每个线程，有唯一的Looper对象和MessageQueue队列。 loop() 中有一个死循环 for (;;) ，会不断调用 MessageQueue 的next()，当有消息就处理，否则就阻塞等待。 Looper.loop(); // 死循环 判断是否有需要处理的 Message public static void loop(){ final Looper me = myLooper(); final MessageQueue queue = me.mQueue; for (;;) { Message msg = queue.next(); //如果没有消息则阻塞。 msg.target.dispatchMessage(msg); //将消息进行分发 处理 } } HandlerThread HandlerThread extends Thread.. HandlerThread 是一个内部实现了 Looper循环的线程 。 Android中多线程的场景很多，为了解决多线程问题，Android提供了很多方案。 线程池整体量级有些偏重， HandlerThread 是一种轻量的多线程解决方案。 mHandler = new Handler( mHandlerThread.getLooper()){ public void handleMessage(Message msg){ // 这里是子线程 ，可以执行耗时操作 activity.runOnUiThread(new Runnable() { @Override public void run() { // 这里是主线程 } }); } }; mHandler.sendEmptyMessage(MSG_UPDATE_INFO); mHandler.removeMessages(MSG_UPDATE_INFO); mHandlerThread.quit(); ThreadLocal 从ThreadLocal这个名字看，它带着浓浓的“本地线程”的味道； 其实 ThreadLocal并不是用来操作什么本地线程而是用于实现不同线程的数据副本。 每一个线程都可以独立地改变自己的副本并且不会影响其它线程所持有的对应的副本。 在 Looper.java 中 有使用到 ThreadLocal 的这特性。 static final ThreadLocal sThreadLocal = new ThreadLocal(); //将新创建的对象的引用保存到各线程的自己的一个map中 sThreadLocal.set(new Looper(quitAllowed)); public static Looper myLooper() { // 各线程从自己的map中取出放进去的对象， // 因此取出来的是各自自己线程中的对象 ,使得每个 thread 都有自己独立的 handle return sThreadLocal.get(); } 一个线程有几个Looper 因为在调用 Looper.prepare() 给当前线程新建 Looper 时有判断 , 所以 只能有一个 Looper private static void prepare(boolean quitAllowed){ if (sThreadLocal.get() != null) { throw new RuntimeException(\"Only one Looper may be created per thread\"); } sThreadLocal.set(new Looper(quitAllowed)); } 判断是否是主线程 通过判断两个线程的 Looper 是否是同一个。 return Looper.myLooper() == Looper.getMainLooper(); Can't create handler inside thread that has not called Looper.prepare() 在子线程中 直接调用 Handler handler=new Handler() ,会提示这个错误。 因为 在 Handle 的构造函数中 对 Looper 进行检查 mLooper = Looper.myLooper(); if (mLooper == null) { throw new RuntimeException( \"Can't create handler inside thread \" + Thread.currentThread() + \" that has not called Looper.prepare()\"); } 所以需要 手动调用 Looper.prepare() private static void prepare(boolean quitAllowed) { if (sThreadLocal.get() != null) { throw new RuntimeException(\"Only one Looper may be created per thread\"); } sThreadLocal.set(new Looper(quitAllowed)); // 通过 ThreadLocal 给当前线程设置 looper } 而且需要手动调用 Looper.loop() ,开启 handle 对应 looper 的死循环 for (;;) 为什么主线程中 新建Handle 不要手动调用 Looper.prepare() 和 Looper.loop() 因为在 ActivityThread.java 中的 public static void main(String[] args) 函数中 系统已经 启用了 Looper.prepareMainLooper() 、Looper.loop() 主线程中的Looper.loop()一直无限循环为什么不会造成ANR 为什么当主线程处于死循环的 Message msg = queue.next() 这句会阻塞线程的代码的时候不会产生 ANR 异常, 1、当没有消息的时候会阻塞 2、其他线程有消息发过来，它马上就会被唤醒，去分发message。 所以 阻塞是有的，但是不会报ANR 。 因为ANR的根本原因是在等待的时间内没有回应， 你都没有 Message 要处理，我当然不需要任何回应。 ANR (Application Not Responding )原理 ANR的监控和处理，是在系统层做的。 系统服务发出一条指令后会在约定的时间等待返回， 如果在约定时间内没有返回，系统就会给出 ANR 提示。 为什么 Handler 有潜在内存泄露 在 Activity 中 用这种内部类的方式 新建 handle， handle就会持有外部类 activity 的引用， Handler handler = new Handler() { ... }; 同理 ，Runnable 也会拥有 外部类 activity 的引用 handler.postDelayed(new Runnable() { public void run() { ... } }) Runnable 被封装成 Message 被 MessageQueue 持有，所以 activity 被 MessageQueue 间接持有了。 activity 退出时，如果延时时间还没到，所以 activity 无法被释放掉。 至于为什么 内部类会持有外部类的引用，可以查阅其他资料 ，这里不讲解。 通过 WeakReference 解决 handle 内存泄漏 private static class MyHandler1 extends Handler { //WeakReference 当GC执行时，无论当前内存是否充足，都会将弱引用关联的对象回收掉。 private final WeakReference weakReference; public MyHandler1(InfoHudViewHolder controller) { weakReference = new WeakReference<>(controller ); } @Override public void handleMessage(Message msg) { InfoHudViewHolder holder = weakReference.get() ; if(holder==null){ return; } } } // 使用 MyHandler myHandler =new MyHandler(this) ; GcRoot 角度分析 Handler handler 中引起内存泄漏的根节点（造成无法被gc回收的原因）， 是一个静态对象，即“方法区中类静态属性引用的对象” // 引用链 直接在 activity中声明handler， 使 handler 持有了activity的引用( 因为匿名内部类的特点)。 当任务未执行完，message未被执行完时，message持有了messageQueue的引用, messageQueue持有了 mLooper 的引用, mLooper持有sThreadLocal 的引用, sThreadLocal 是一个静态变量，无法被回收，最终导致了activity无法被回收，造成了内存泄漏。 static final ThreadLocal sThreadLocal = new ThreadLocal(); 为什么 在子线程中调用 activity.runOnUiThread() 也可以更新UI new Thread(new Runnable() { activity.runOnUiThread(new Runnable() ... ) }).start(); public final void runOnUiThread(Runnable action) { if (Thread.currentThread() != mUiThread) { // 在子线程中调用activity.runOnUiThread( ... ) 的情况 mHandler.post(action); } else { // 在主线程中调用activity.runOnUiThread( ... ) 的情况 action.run(); } } 从源码可以得知 ，如果调用 runOnUiThread()的线程就是主线程，就立马执行。 如果是在子线程中调用，就会把 Runnable 封装成 Message ，进入消息队列， 最后会转发给 创建 mHandler 所在的线程执行 ，Handler mHandler = new Handler(); mHandler 是系统在 Activity.java 中创建，所以最后会在主线程中执行了。 为什么 在子线程中调用 handler.post(new Runnable...) 也可以更新UI // 前提条件 ： handler是在 主线程中新建的 new Thread(new Runnable() { handler.post(new Runnable() { // 更新 UI } ).start(); 跟踪源码发现 执行 post 后 ，会经过 一系列函数 ，将 Runnable 包装成 Message ， 最后分发回 handler所依附线程(主线程)中运行。 private static Message getPostMessage(Runnable r) { Message m = Message.obtain(); // 包装 Runnable 给 Message m.callback = r; return m; } public void dispatchMessage(@NonNull Message msg) { if (msg.callback != null) { handleCallback(msg); // 执行 Runnable 的run 函数 } } private static void handleCallback(Message message) { message.callback.run(); } handler 为什么可以更新UI 、为什么可以实现线程间通信 现在有A、B两个线程，在A线程中创建了handler，然后在B线程中调用 A线程的 handler发送一个message。 当A线程创建handler的时候，同时创建了 MessageQueue 与 Looper， Looper在A线程中被调用，进入 for (;;) 循环 ，轮询 MessageQueue 是否有需要处理的消息。 在B线程使用 A线程中的 handler发送一个message ,将message插入到handler对应的MessageQueue中， Looper发现有message插入到MessageQueue中，便取出message执行相应的逻辑， 因为Looper.loop() 是在A线程中启动的，对应的 MessageQueue 和 Looper 都是属于 A线程的 ， 所以 Handle 的方法 handleMessage() 是在 A线程中执行。 Runnable 是一定运行在子线程中吗 Runnable 运行在子线程中是错误的观念。 runnable只是创建了一个执行任务的对象，但是它本身并不会创建一个新的子线程。 最终的执行线程是要看 所依附的线程 。 1、举例 handler.post(runnable) // The runnable will be run on the thread to which this handler is attached. public final boolean post(@NonNull Runnable r) { return sendMessageDelayed(getPostMessage(r), 0); } 2、举例view.post(runnable) The runnable will be run on the user interface thread. 一个 Message ，Handler 可以 post 两次吗 不能，Message 在进入 queue 的时候会标记 inUse , msg 被回收后，重新 obtain的时候 inUse 标记会清除，这时候可以再次 post MessageQueue 如何对 Message 排序的 通过时间排序 。 public final boolean postDelayed(@NonNull Runnable r, long delayMillis) { return sendMessageDelayed(getPostMessage(r), delayMillis); } public final boolean sendMessageDelayed(@NonNull Message msg, long delayMillis) { ... // SystemClock.uptimeMillis() Returns milliseconds since boot, not counting time spent in deep sleep return sendMessageAtTime(msg, SystemClock.uptimeMillis() + delayMillis); } boolean enqueueMessage(Message msg, long when) { synchronized (this) { ... msg.when = when; Message p = mMessages; // 下一条信息 boolean needWake; // 根据 when 进行顺序排序，将消息插入到其中 if (p == null || when == 0 || when Handler.postDelayed()是如何 实现实现延时执行的 会马上进入队列的，而不是等时间到了再加入队列。 Handler 不是自己处理 Delay，而是交给了MessageQueue处理。 大概流程如下： 1、postDelay 一个延时10秒钟的A消息进队，MessageQueue调用 nativePollOnce ()阻塞，Looper阻塞； 2、紧接着post 一个B消息进队，判断现在A时间还没到、正在阻塞，把B插入消息队列的头部（A的前面）， 然后调用nativeWake()方法唤醒线程； 3、MessageQueue.next()方法被唤醒后，读取消息链表，第一个消息B无延时，直接返回给Looper，执行B消息。 4、Looper for(;;) 处理完这个消息再次调用next()方法，MessageQueue继续读取消息链表， 假如消息A还没到时间，继续阻塞；直到阻塞时间到或者下一次有Message进队再次唤醒； 这样就实现了延时。 Handler.postDelayed() 的延时方法是一定非常精准吗 这种方式是不精准的。 Message的执行时机是在加入队列时就计算好的。 sendMessageAtTime(msg, SystemClock.uptimeMillis() + delayMillis); 然后 Looper.looper()函数中的 for (;;) 是串行执行的，执行了上一条后再去判断下一个Message 是否要执行。 (handle 和 Looper 是处于一个线程，所以执行一条才能下一条)。 举个夸张的例子， myThread1.handler1.postDelayed(new Runnable() { @Override public void run() { long time =System.currentTimeMillis() - timeStart ; Wklog.d(\"延时5秒执行=\"+ Thread.currentThread().getId()+\" 间隔描述=\"+ (time/1000)); } } ,5*1000) ; myThread1.handler1.post(new Runnable() { @Override public void run() { timeStart = System.currentTimeMillis() ; Wklog.d(\"马上执行线程=\"+ Thread.currentThread().getId() ); Thread.sleep(3*1000); //Thread.sleep(7*1000); } } }) ; handler1.postDelayed 按计划是延时5秒执行的， handler1.post 是马上执行的 。 如果 post的 Handle在5秒内执行完毕， postDelayed的Runable 还是按照原计划 5秒后执行， 如果 post的 Handle 超过5秒执行完毕， postDelayed的Runable 就不能实现延时5秒了，而是7秒了。 因为，本来应该在 for(;;)判断是否要执行下一条的时间里 却在执行 耗时操作，错过了。 MessageQueue 中为什么不用 wait 而用 epoll 进行等待呢 在旧版本中，是用的wait 实现等待。 后来需要处理 native 层的一些事情，改成 select 再改成 epoll private native void nativePollOnce(long ptr, int timeoutMillis) 实现等待 。 https://android.googlesource.com/platform/frameworks/base/+/46b9ac0ae2162309774a7478cd9d4e578747bfc2%5E%21/#F16 如何退出 Looper 循环 、退出 Handle handler.getLooper().quit(); // 我手动调用这个代码 // Looper.java public void quit() { mQueue.quit(false); } // MessageQueue.java void quit(boolean safe) { synchronized (this) { if (mQuitting) { return; } mQuitting = true; // 1、标记可以退出 if (safe) { removeAllFutureMessagesLocked(); // 2、删除相关数据 } else { removeAllMessagesLocked(); } nativeWake(mPtr); // 3、唤醒线程 } } 然后再来看 Looper.java 中的 loop() 函数 public static void loop() { for (;;) { Message msg = queue.next(); // might block ， if (msg == null) { // 6、nex 返回空 ，退出 loop循环 return; } msg.recycleUnchecked(); } } // MessageQueue.java Message next() { for (;;) { // nativePollOnce 用于“等待”, 直到下一条消息可用为止 // 4、被step3唤醒 ，继续往下执行 nativePollOnce(ptr, nextPollTimeoutMillis); synchronized (this) { if (mQuitting) { // 5、mQuitting 在 step 1被设置为 true了 ，所以返回 null dispose(); return null; } } 主线程 的 looper 能否 quit() void quit(boolean safe) { if (!mQuitAllowed) { throw new IllegalStateException(\"Main thread not allowed to quit.\"); } } 从源码可知，主线程的Looper 禁止开发者 quit 。 因为主线程中的 handle 要处理很多事情，退出之后 整个APP就没得玩了。 private class H extends Handler｛ public void handleMessage(Message msg) { switch (msg.what) { case LAUNCH_ACTIVITY case RELAUNCH_ACTIVITY: { case PAUSE_ACTIVITY: { case PAUSE_ACTIVITY_FINISHING: case STOP_ACTIVITY_SHOW: case STOP_ACTIVITY_HIDE: case LOCAL_VOICE_INTERACTION_STARTED: ... Handler 如何确保线程安全 // 与 handle 对应的 MessageQueue ，Message 进入队列 synchronized 上锁了 boolean enqueueMessage(Message msg, long when) { // MessageQueue.java synchronized (this) { // Looper 中获取 Message 时 MessageQueue 的next 也被上锁了 for (;;) { // Looper.java Message msg = queue.next(); Message next() { // MessageQueue.java synchronized (this) { ... } } Handle 屏障消息 、同步屏障 Message分为3种：普通消息（同步消息）、屏障消息（同步屏障）和异步消息。 我们通常使用的都是普通消息，而屏障消息就是在消息队列中插入一个屏障， 在屏障之后的所有普通消息都会被挡着，不能被处理。屏障不会挡住异步消息， 因此可以这样认为：屏障消息就是为了确保异步消息的优先级， 设置了屏障后，只能处理其后的异步消息，同步消息会被挡住，除非撤销屏障。 屏障消息和普通消息的区别在于屏障没有 tartget，普通消息有 target 是因为它需要将消息分发给对应的 target， 而屏障不需要被分发，它就是用来挡住普通消息来保证异步消息优先处理的。 插入和移除屏障消息 用反射调用 MessageQueue.java 中的私有方法 postSyncBarrier() 、removeSyncBarrier() 注意一点 插入普通消息会唤醒消息队列，但是插入屏障不会。 Message message = Message.obtain(); // 默认是 同步消息 message.setAsynchronous(true); // 设置为 异步消息 // 插入同步屏障消息 MessageQueue queue=handler.getLooper().getQueue();// android 6.0 才有 Method method=MessageQueue.class.getDeclaredMethod(\"postSyncBarrier\"); method.setAccessible(true); int token= (int) method.invoke(queue);// token用来移除屏障 MessageQueue queue=handler.getLooper().getQueue(); Method method=MessageQueue.class.getDeclaredMethod(\"removeSyncBarrier\",int.class); method.setAccessible(true); method.invoke(queue,token); 所谓消息屏障和异步消息是一种插队机制。 viewrootimpl 在 scheduletraversal 的时候在在messagequeue的头部放一个target为null的message， messagequeue的next方法在取下一个消息的时候，发现头部是这样的message， 会忽略普通消息，在列表中只找标记了异步的消息，如果找不到， 即使列表中有其他正常的message都不会去处理。 而系统中发送异步消息的地方，是Choreographer中收到vsync信号的地方。 这样做的效果是，一旦调用了requestlayout等方法，用户的其它代码所发送的消息， 即使发送得更早，都会等layout代码优先执行 手写 handle 机制 实现 线程间通信 handle 不仅仅只用于 主线程 和子线程的通信 ，也可以实现 子线程和子线程的通信 。 可以参考我的 demo https://gitee.com/hnyer/my-handle IdleHandler IdleHandler 主要是在 MessageQueue 出现空闲的时候被执行。 1、MessageQueue 为空，没有消息； 2、MessageQueue 中最近需要处理的消息，是一个延迟消息（when>currentTime），需要滞后执行； IdleHandler 被定义在 MessageQueue 中 , public static interface IdleHandler { // 返回 ture ，执行完 queueIdle 方法之后会保留这个 IdleHandler ， // 反之则删除这个 IdleHandler 。 boolean queueIdle(); } IdleHandler 的处理时机不可控 ， 我们一般用 IdleHandler 闲时特性来做一些性能优化。 只能适合做一些优先级不高的功能。 比如上报一个不重要的埋点日志。 ( no Copyright，enjoy youself ! ) all right reserved，powered by GitbookThe file was updated at : 2021-07-26 11:40:28 "},"chinese/android基础/Fragment详解.html":{"url":"chinese/android基础/Fragment详解.html","title":"Fragment详解","keywords":"","body":"Fragment详解 一个Fragment总是嵌入到一个Activity，是一个模块化的View，它的生命周期受它所嵌入的Activity生命周期的的影响。可以动态的添加、替换、移除某个Fragment。 fragment的优势 同样的界面 ， fragment 比activity 占用内存更少 ，响应速度更快 。 Fragment生命周期 activity与fragment生命周期的关系 与activity相同的生命周期函数 onCreate 、onStart 、onResume、onPause、onStop 、onDestroy 与activity相比多出的生命周期函数 onAttach 、onDetach 、onActivityCreated 、onViewCreated 、onCreateView 、onDestroyView 常用函数 getSupportFragmentManager 获得碎片管理者 getChildFragmentManager 获取自己的FragmentManager对象。 getFragmentManager 获取的是父Fragment(如果没有，则是FragmentActivity)的FragmentManager对象。 getBackStackEntryCount 从管理器中得到Fragment当前已加入Fragment回退栈中的fragment的数量。 onHiddenChanged onHiddenChanged 不是生命周期函数 ，通过 hide 和 show 进行触发。 ( no Copyright，enjoy youself ! ) all right reserved，powered by GitbookThe file was updated at : 2020-12-18 08:52:57 "},"chinese/android基础/Activity详解.html":{"url":"chinese/android基础/Activity详解.html","title":"Activity详解","keywords":"","body":"Activity 生命周期 onDestroy() // onStop 和 onDestroy 回调为什么会延时 由于要关闭的 或者要打开的 Activity 往主线程的 MessageQueue 中发送了 大量的 Message , 导致主线程一直在不断的进行消息循环处理这些消息而没有得到停歇。 App 侧就不能向 AMS 告知自己有空闲时间来处理 AMS 侧的任务。 所以，finish Activity B后，onDestroy不会被及时回调。 具体延时多久，要看主线程什么时候闲下来。 // 为什么 Activity.finish() 之后 10s 才 onStop 、onDestroy 除正常流程外，Android 系统另行安排了一套流程来保证即使正常流程被阻断以后，Activity B还是能被销毁。 ActivityStac.java 中 // schedule an idle timeout in case the app doesn't do it for us. mStackSupervisor.scheduleIdleTimeoutLocked(next); this.mHandler.sendMessageDelayed(msg, 10000L); // 10s onRestart () 经过测试，以下几种情况 onRestart()方法 会被调用 1、按下home键之后，然后切换回来 2、从本Activity跳转到另一个Activity之后，按 back键返回原来 Activity 3、从本Activity切换到其他的应用，然后再从其他应用切换回来 onStop() 两个Activity之间跳转 , 从A跳到B ，A的 onStop 是否执行 取决于 B是否完全覆盖在 A上 导致A整个不可见。 如果 B 是透明的 Activity 或者是个 Dialog 样式 ，A 的 onStop 并不会被执行。 按 Back 键 后，activity 的生命周期变化 这些东西 写个简单demo 实验一把 当场就能出结果。 面试官要是硬要你回答，就是沙比。 按 Home 键 后，activity 的生命周期变化 这些东西 写个简单demo 实验一把 当场就能出结果。 activity 启动另外一个activity的时候横屏切换再点击返回，过程中发生的生命周期 这些东西 写个简单demo 实验一把 当场就能出结果。 Activity 启动模式 通过使用不同的启动模式，来控制是否生成唯一还是多个activity实例 。来满足不同的使用场景 。 standard 模式 默认模式。每当有一次Intent请求，就会创建一个新的Activity实例 。 并且被放到启动它的那个Activity所属的任务栈中。 singleTop 模式 栈顶复用。 栈顶有此实例就使用（调用 onNewIntent()方法） ，没有就重新创建。(调用onCreate()方法) 栈顶模式只有在一种情况下有别于 standrad 默认模式，便是身处栈顶的时候。 singleTask 模式 栈内复用。 若栈中已有该Activity的实例，就重用该实例(调用onNewIntent()方法)。 并且会将它所在任务栈之前的所有activity实例移除掉。因此该实例就处于栈顶了。 若栈中不存在该实例，将会onCreate()。 可以用在 消除交互界面的嵌套循环 场景。 例如APP主页面一般使用 SingleTask 模式， 因为用户点击多次页面的相互跳转后，在点击回到主页，再次点击退出， 这时他的实际需求就是要退出程序， 而不是一次一次关闭刚才跳转过的页面最后才退出。 singleInstance 模式 全局唯一，整个系统中是单例的。 Activity 单独占用一个Task栈 。 例如 A 是 standard 模式 ，B 是 singleInstance ， 那么 A 和 B 是在不同的栈内的。 启动模式属性 // taskAffinity android:taskAffinity=\"task001\" 它倾向于将 taskAffinity 属性相同的Activity，扔进同一个Task中。指定Activity希望归属的栈 // allowTaskReparenting 任务状态是否始终由系统来维护 android:allowTaskReparenting=\"true\" //默认false 任务栈 task stack 每次启动新的Activity都将被添加到Activity Stack。 用户返回就会将当期的activity实例出栈。 如果当前栈空了，就会进入 Home screenn 所在的栈 。 1、一个应用程序一被启动,系统就给它分配一个任务栈 。 一个应用程序一个任务栈。 2、一个任务栈中存放多个activity ,可以来自不同的应用程序。 指定启动模式 代码方式 优先级大于 xml方式 // xml方式 // 代码方式 Intent intent = new Intent( this ,TestActivity.class); intent.addFlags(Intent.FLAG_ACTIVITY_SINGLE_TOP); this.startActivity(intent); Intent的 Flag标志 官网flags Intent的Flag标志 意义 FLAG_ACTIVITY_NEW_TASK 默认的跳转类型 FLAG_ACTIVITY_SINGLE_TOP singletop模式 FLAG_ACTIVITY_BROUGHT_TO_FRONT FLAG_ACTIVITY_CLEAR_TOP SingleTask模式 FLAG_ACTIVITY_NO_HISTORY Activity不会保留在栈中 FLAG_ACTIVITY_NO_ANIMATION 不使用过渡动画 FLAG_ACTIVITY_EXCLUDE_FROM_RECENTS 最近应用里面查看不到这个activity的启动记录 查看 系统的任务栈 、 Activity 栈信息 、各个栈的 Activity 列表 adb shell dumpsys activity Activity 其他方法 onSaveInstanceState() 、onRestoreInstanceState() onSaveInstanceState() 只会在 Activity 即将被销毁 并且有机会重新显示的情况下才会去调用它， 正常情况下系统是不会回调的(如当用户按back键时)。 1、按下 Home键 (常见) 2、长按 Home键 ，选择运行其他的程序 (常见) 3、按下电源键，关闭屏幕显示 4、锁屏 5、屏幕方向切换、键盘可用性、语言切换 (常见) 6、电话打入时 (常见) 不是用户主动退出某个Activity或者跳转到其他Activity的情况下就会触发 onSaveInstanceState ， 即 当系统存在“未经你许可”时销毁了我们的Activity,就会被系统调用， 这是系统的职责，因为它必须要提供一个机会让用户保存数据。 对于一个Activity或者View来说，状态的保存与恢复是必不可少的， 最常见的一种情况是切换屏幕方向了，如果由竖屏切换为横屏， 那么必定会经历Activity的摧毁与重建，那么它所对应的View视图也会被摧毁和重建， 如果此时没有对View进行状态的保存的话，那么待View重建后，其之前的状态便不复存在。 对于系统自带的View（如CheckBox等），Android已经帮我们实现了状态的自动保存与恢复。 但是对于我们自己开发的自定义View，就需要我们去保存状态和恢复状态了， 如果我们没有覆写 onSaveInstanceState() , 此方法的默认实现会自动保存activity中的某些状态数据。 android应用框架中定义的几乎所有UI控件都恰当的实现了onSaveInstanceState(), 因此当activity被摧毁和重建时, 这些UI控件会自动保存和恢复状态数据. 比如 CheckBox控件会自动保存和恢复选中状态。 开发者只需要为这些控件指定一个ID( 设置android:id ), 剩余的事情就可以自动完成了.如果没有为控件指定ID, 则这个控件就不会进行自动的数据保存和恢复操作。 protected void onSaveInstanceState(@NonNull Bundle outState) { outState.putBundle(WINDOW_HIERARCHY_TAG, mWindow.saveHierarchyState()); outState.putInt(LAST_AUTOFILL_ID, mLastAutofillId); Parcelable p = mFragments.saveAllState(); if (p != null) { outState.putParcelable(FRAGMENTS_TAG, p); } if (mAutoFillResetNeeded) { outState.putBoolean(AUTOFILL_RESET_NEEDED, true); getAutofillManager().onSaveInstanceState(outState); } dispatchActivitySaveInstanceState(outState); } 在 onSaveInstanceState() 中保存数据 在 onCreate(Bundle )、onRestoreInstanceState(Bundle) 中恢复数据。 onAttachedToWindow() 调用时机 /** * Called when the main window associated with the activity has been * attached to the window manager. * See {@link View#onAttachedToWindow() View.onAttachedToWindow()} * for more information. */ public void onAttachedToWindow() { } ( no Copyright，enjoy youself ! ) all right reserved，powered by GitbookThe file was updated at : 2021-07-26 11:58:41 "},"chinese/android基础/BroadcastReceiver.html":{"url":"chinese/android基础/BroadcastReceiver.html","title":"BroadcastReceiver详解","keywords":"","body":"BroadcastReceiver 全局广播 全局广播 发出去的消息可以被本机所有应用程序接收到 ， Service 向activity中传递数据，更新UI时不太方便，此时可以使用广播来实现。 在 Service 向 Activity 传递信息 // 在 Service 中发送广播 Intent intent = new Intent(); intent.setAction( MyConfig.KEY_BROADCAST_ACTIONFLAG ); intent.putExtra(MyConfig.KEY_BROADCAST_MSG,msg); service.sendBroadcast(intent); // 定义广播，并传入一个接口，方便回调给activity public class BroadcastReceiver extends BroadcastReceiver { private MsgCallBack msgCallBack ; public BroadcastReceiver(MsgCallBack msgCallBack){ this.msgCallBack =msgCallBack; } @Override public void onReceive(Context context, Intent intent) { String msg = intent.getStringExtra( MyConfig.KEY_BROADCAST_MSG); msgCallBack.onGetMsg(msg); } } // activity中注册广播 IntentFilter intentFilter = new IntentFilter(); intentFilter.addAction(MyConfig.KEY_BROADCAST_ACTIONFLAG); broadcastReceiver = new BroadcastReceiver(msgCallBack); registerReceiver(broadcastReceiver, intentFilter);// 注册广播 unregisterReceiver(broadcastReceiver);// 解绑广播 // 在回调接口中更新UI @Override public void onGetMsg(final String msg) { ((Activity)context).runOnUiThread(new Runnable() { public void run() { showInfoTv.setText(msg); } }); } LocalBroadcastManager 本地广播 本地广播 发出去的消息只能被自己所在的应用程序接收到。 因为消息不会广播范围不会超过自身程序，所以数据安全性和广播效率都比全局广播高。 本地广播是无法通过静态注册的方式来接收的。 LocalBroadcastManager localBroadcastManager = LocalBroadcastManager.getInstance(this); Intent intent = new Intent(MyConfig.KEY_INTENT_FLAG ); intent.putExtra(MyConfig.KEY_BROADCAST_MSG, \"hello msg\"); localBroadcastManager.sendBroadcast(intent);//发送广播 MyLocalBroadcastReceiver localReceiver = new MyLocalBroadcastReceiver(); IntentFilter intentFilter = new IntentFilter(); intentFilter.addAction(MyConfig.KEY_INTENT_FLAG ); //匹配指定的 Intent localBroadcastManager.registerReceiver(localReceiver, intentFilter);//注册监听 unregisterReceiver(localReceiver);//取消监听 为什么本地广播的效率比全局广播高 BroadcastReceiver 的通信是走 Binder 机制 。 而 本地广播 走的是 Handler 机制 ，只是利用到了 IntentFilter 的 match 功能。 不用消耗跨进程的资源消耗，自然就效率高。 // LocalBroadcastManager.java private LocalBroadcastManager(Context context) { mHandler = new Handler(context.getMainLooper()) { public void handleMessage(Message msg) { switch (msg.what) { case MSG_EXEC_PENDING_BROADCASTS: executePendingBroadcasts();// 处理 break; default: super.handleMessage(msg); } } }; } ( no Copyright，enjoy youself ! ) all right reserved，powered by GitbookThe file was updated at : 2021-01-28 09:53:34 "},"chinese/android基础/Service服务.html":{"url":"chinese/android基础/Service服务.html","title":"Service详解","keywords":"","body":"Service 服务 Service 是运行在主线程中的， 所以 Service 处理不当 也是会引起 ANR 的。 如果有耗时操作在Service里，就必须用子线程处理 。 Service的意义 1、优先级高，不容易被系统杀死。用来实现需要稳定、长时间运行的模块。 (Service的优先级高于后台挂起的Activity， 也高于Activity所创建的Thread) 2、用在一些不适合activity的的场景。例如音乐播放和文件下载等场景 。 Service 启动方式 因为 startService 方式不能获得service的方法，所以不能不能拿到AIDL定义的接口，无法双向通信。 所以aidl中只能用 bindService 方式，根据 ServiceConnection 获得接口。 start模式 一旦启动，Service将一直运行在后台，即便启动Service的组件已被destroy。 Intent intent = new Intent(this, MyNormalService.class); startService(intent);//启动服务 stopService(intent) ;//停止服务 //或在服务类中 调用 stopSelf(); bind模式 通过绑定方式启动的Service是一个client-server结构。 多个组件可与一个service绑定，service不再与任何组件绑定时，该service会被destroy。 Intent intent = new Intent(MainActivity.this, MyNormalService.class) ; this.bindService( intent, serviceConnection , BIND_AUTO_CREATE ); // 绑定 this.unbindService(serviceConnection); // 解绑 // 启动远程service ,比如aidl通信时，service不在同一个APP。 Intent intent=new Intent(); intent.setAction(\"com.remoteService.test\"); //用来识别service的标记 intent.setPackage(\"com.wk.iadlservice\"); // 服务所在的应用id bindService(intent, mConnection, Context.BIND_AUTO_CREATE); ServiceConnection serviceConnection = new ServiceConnection(){ @Override public void onServiceConnected(ComponentName name, IBinder service) { MyNormalService.MyBinder myBinder = (MyNormalService.MyBinder) service ; myBinder.func1();//调用自定义Binder中的方法 } @Override public void onServiceDisconnected(ComponentName name) { } } ; //MyNormalService.java @Override public IBinder onBind(Intent intent){ return new MyBinder(); } class MyBinder extends Binder{ public void func1(){ ... } } public class MyNormalService extends Service{ // 通过start方式启动 时回调的方法 @Override public IBinder onBind(Intent intent){ .... } // 通过bind方式启动 回调的方法 @Override public int onStartCommand(Intent intent, int flags, int startId){ ... } } bindService( , ,) bindService( , , int flags ) flags 含义 BIND_AUTO_CREATE //若绑定服务时服务未启动，则会自动启动服务。 BIND_DEBUG_UNBIND // 使用此标志绑定服务之后的unBindService 方法会无效。 这种方法会引起内存泄露，建议只在调试时使用。 BIND_NOT_FOREGROUND // 被绑定的服务进程优先级不允许被提到 FOREGROUND 级别 BIND_ABOVE_CLIENT // 如果当绑定服务期间遇到OOM需要杀死进程，客户进程会先于服务进程被杀死。 BIND_WAIVE_PRIORITY // 被绑定的服务进程不会被OOM列入猎杀对象中。 service 生命周期 // 手动调用方法 startService() stopService() bindService() unbindService() // 内部自动调用的方法 onCreat() onStartCommand() 开始服务 onDestroy() onBind() onUnbind() onStartCommand() 默认情况下， onStartCommand 返回值 START_STICKY_COMPATIBILITY 或 START_STICKY 。 1、START_STICKY // 会重启服务，可能会传递null的intent。 如果Service所在的进程，在执行了onStartCommand方法后，被清理了， 那么这个Service会被保留在已开始的状态，但是不保留传入的Intent， 随后系统会尝试重新创建此Service，由于服务状态保留在已开始状态， 所以创建服务后一定会调用onStartCommand方法。 如果在此期间没有任何启动命令被传递到service，那么参数Intent将为null，需要我们小心处理。 2、START_NOT_STICKY // 不会重启服务。这是最安全的选项 如果Service所在的进程，在执行了onStartCommand方法后，被清理了，则系统不会重新启动此Service。 3、START_REDELIVER_INTENT // 会重启服务。传入最后一个intent 。 如果系统在 onStartCommand() 返回后终止服务，则会重建服务，并通过 传递给服务的最后一个 Intent。 4、START_STICKY_COMPATIBILITY // 是START_STICKY 的兼容版本，但是不能保证被清理后 onStartCommand方法一定会被重新调用。 前台服务、后台服务 // 1、前台服务 前台服务必须给状态栏提供一个通知 。 系统内存不足的时候不允许系统杀死的服务。 // 参数一：唯一的通知标识；参数二：通知消息。 xx.startForeground(12345, notification);// 开始前台服务 xx.stopForeground(true);// 停止前台服务--参数：表示是否移除之前的通知 IntentService 1、public abstract class IntentService extends Service.. 2、HandlerThread thread = new HandlerThread(\"IntentService[\" + mName + \"]\").. 3、mServiceHandler = new ServiceHandler(mServiceLooper).. 1、内部已经采用了独立的子线程处理问题。无需手动开启子线程。 2、内部采用队列处理问题。 不用考虑多线程并发问题。 3、任务结束后会自动停止。无需手动调用停止代码。 解决Service内存泄漏问题。 Service 和 Activity 通信 1、bindService 启动的服务 通过 ServiceConnection 拿到 service的引用，给它发送数据。 activity - > service 通过发送广播，广播在通过回调接口 把消息传给 activity 。 service -> activity 2、startService 启动的服务 eventbus等第三方库 实现 activity - > service 。 // 如果不用第三方库 怎么实现？ 通过广播 发消息给activity 。 service -> activity ( no Copyright，enjoy youself ! ) all right reserved，powered by GitbookThe file was updated at : 2020-12-18 09:05:23 "},"chinese/android基础/动画详解.html":{"url":"chinese/android基础/动画详解.html","title":"动画详解","keywords":"","body":"多个动画之间，是可以组合在一起同时播放的。 AnimatorSet.playTogether(xxx) 动画类型 帧动画 、Drawable Animation、Frame Animation 容易OOM， 将一个完整的动画拆分成一张张单独的图片， 然后再将它们连贯起来进行播放，类似于动画片的工作原理。 补间动画 、View Animation、TweenedAnimation 补间动画 就是在两点之间插入渐变值来平滑过渡。 只能平移、缩放、旋转、透明度。不能拓展效果。 // 特点 1、XML声明文件存放在res/anim目录； 2、基于 Animation 和 AnimationSet 的类结构； 3、效果由四个因素决定：1）初始状态；2）结束状态；3）持续时间；4）Interpolator // 不足之处 1、只能够作用在View上。 2、补间动画机制是使用硬编码的方式来完成的， 功能限定死 淡入淡出(透明度)、缩放(大小)、平移(位置)、旋转四种， 基本上没有任何扩展性可言。 例如不能实现对View的背景色进行动态地改变。 3、它只是改变了View的显示效果而已，而不会真正去改变View的属性。 例如屏幕的左上角有一个按钮，补间动画将它移动到了屏幕的右下角，你点击这个按钮，点击事件不会触发， 因为实际上这个按钮还是停留在屏幕的左上角，只不过补间动画将这个按钮绘制到了屏幕的右下角而已。 （想真正移动某组件，需要在动画结束后添加代码实现。） 属性动画 、Property Animation 顾名思义，通过控制对象的属性，来实现动画效果。 可以拓展动画效果。可以作用于View和非View对象 。 // 特点 1、需要Android API level 11 （android3.0）以上使用。 2、XML文件存放在res/animator目录下； 3、基于Animator和AnimatorSet的类结构； // 优点 1、可以对所有的 Object对象的 任意属性进行操作。 2、动画效果不局限于 透明度、缩放 、平移 、旋转四种效果。 3、因为是一种不断地对值进行操作的机制，并将值赋值到指定对象的指定属性上， 所以不仅仅是一种视觉上的动画效果了。 例如我们通过属性动画来移动一个按钮，那么这个按钮就是真正的移动了， 而不再是仅仅在另外一个位置绘制了而已。 ValueAnimator 是对 值 的平滑过渡动画。你拿到不断变化的值后，你想干嘛就干嘛。 private void testValueAnimator(final View someView){ ValueAnimator valueAnimator = ValueAnimator.ofFloat(0f, 180f) ; valueAnimator.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() { @Override public void onAnimationUpdate(ValueAnimator valueAnimator) { // 拿到这个不断变化的值， 可以给 view的某个属性赋值，或其他 float value = (Float) valueAnimator.getAnimatedValue(); someView.setRotation(value); } }); } ObjectAnimator // ObjectAnimator extends ValueAnimator ObjectAnimator 继承了 ValueAnimator 的所有方法和特性， 并且还封装很多实用的方法，方便开发人员快速实现动画。 private void testObjectAnimator( View someView ){ ObjectAnimator objectAnimator = ObjectAnimator.ofFloat(someView ,\"rotation\" , 0 ,360 ,180 ,0 ); objectAnimator.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() { @Override public void onAnimationUpdate(ValueAnimator valueAnimator) { float value = (float) valueAnimator.getAnimatedValue(); Log.d(\"testTag\" , String.valueOf(value)) ; } }); objectAnimator.setDuration(2000).start(); } ViewPropertyAnimator 虽然属性动画给我们提供了 ValueAnimator 类和 ObjectAnimator 类， 在正常情况下，基本都能满足我们对动画操作的需求， 但ValueAnimator类和ObjectAnimator类本身并不是针对View对象的而设计的， 而我们在大多数情况下主要都还是对View进行动画操作的， 因此Google官方在Android 3.1系统中补充了 ViewPropertyAnimator 类， ViewPropertyAnimator 拥有更好的性能， 他解决了View在使用属性动画时步骤繁琐，效率低下的问题。 因为 提供了更简洁的链式调用设置多个属性动画，这些动画可以同时进行的。 多个属性动画是一次同时变化，只执行一次UI刷新。，也就是只调用一次invalidate, 而n个 ObjectAnimator 就会进行n次属性变化，就有n次 invalidate 。 ViewPropertyAnimator animator = view.animate() ; animator.setDuration(1000) ; animator.translationXBy(100f) ;//每次点击都会向右偏移 //animator.translationX(100f)//点击一次会向右偏移，再点击没效果 animator.start() ; 矢量动画 svg SVG（Scalable Vector Graphics）是Android 5.0中新加入的一个新特性 。 svg文件 使用xml格式定义 。 svg图片可以无限拉伸并不会变形和锯齿。 // svg在安卓上使用稍显复杂 ， 使用 Lottie 库 + AE 导出的json文件 可以更方便快捷地实现同样的效果 。 同时 Lottie 兼容 android 、ios、React Native 、web 。 https://github.com/airbnb/lottie-android 补间动画 、属性动画 的区别 1、补间动画只能作用在view上，属性动画可以作用在所有对象上。 2、补间动画只是改变显示效果，不会改变view的属性。 比如位移操作之后，只是显示位置变了，但是实际坐标还是原来的。 而属性动画实际改变对象的属性。 3、补间动画只能实现位移、缩放、旋转和透明度四种动画操作， 而属性动画还能实现补间动画所有效果及其他更多动画效果。 其实，属性动画机制已经不再是针对于 view 来设计的， 也不限定于只能实现位移、缩放、旋转和透明度这几种动画操作， 同时也不再只是一种视觉上的动画效果。 它实际上是一种不断地对值进行操作的机制，并将值赋值到指定对象的指定属性上， 可以是任意对象的任意属性。 // 速度对比 --来自网络，未验证和实验对比 补间动画是早期的动画实现，所以设计的初衷是优化非硬件加速下的动画效率。 因此在非硬件加速的状态下，实际它的效率才是最高的（高于属性动画和逐帧绘制）； 但在硬件加速的状态下，它的功能已经被属性动画完美覆盖。 所以两者到底怎么选择，还得看具体的情况， 不过考虑到目前绝大部分情况下，都是硬件加速绘制，属性动画显然更胜一筹。 动画连续调用的原理 // 补间动画的执行过程 1、调用 view 的 startAnimation 来设置动画并标记脏区域调用 invalidate 来通知 ViewRootImpl 进行重绘 2、ViewRootImpl 通过一系列的坐标转换将脏区域保存，并开始走View的三大流程（布局未发生改变最后只会走重绘步骤） 3、ViewGroup 调用 drawChild 方法，drawChild 会调用 view 中带三个参数的 draw 方法 4、在 draw 方法中，会调用 applyLegacyAnimation 来判断当前的动画是否执行完毕， 如果没有执行完毕则需要调用 invalidate 重新进行下一次的绘制 。(这里就是连续调用的原理) 5、在 Animation 的 getTransformation 中，通过动画的初始值，结束时间，以及插值器计算当前动画的进度 6、在各个 Animation 子类的 applyTransformation 中实现最终属性的比方位移，旋转角度，透明度， 以及缩放比例的值的计算，并将计算的值存到 ViewGroup 子 View 的 Transformation 中。 7、拿到变换的数据之后，位移，缩放，旋转通过一个3*3的矩阵变换， 最终生成一张bitmap显示出来，而透明度，则通过设置layer的透明度比例来实现。 // 属性动画 1、objectAnimator.start() 之后 ，经过一系列的初始化之后， 会来到 animateValue(currentIterationFraction) ，开始一帧的绘制流程 。 2、在 PropertyValuesHolder 中通过反射修改属性 。 void setAnimatedValue(Object target) { ... mTmpValueArray[0] = getAnimatedValue(); mSetter.invoke(target, mTmpValueArray); ... } 到这里为止，就是动画一帧所走过的流程 。 3 、ValueAnimator 中注册了一个回调函数 AnimationFrameCallback 。 private void addAnimationCallback(long delay) { ... getAnimationHandler().addAnimationFrameCallback(this, delay); ... } interface AnimationFrameCallback { boolean doAnimationFrame(long frameTime); void commitAnimationFrame(long frameTime); } 回调函数 doAnimationFrame() 中有执行 animateBasedOnTime() boolean finished = animateBasedOnTime(currentTime); 然后 animateBasedOnTime 中又执行了 animateValue() animateValue(currentIterationFraction); 这就这样，如果有东西不断触发这个回调函数， 我们就可以连续不断地执行动画。 那么，是在哪里不断主动产生回调的呢 ？ AnimationHandler 中有注册一个 Choreographer.FrameCallback 系统回调 getProvider().postFrameCallback(mFrameCallback); private final Choreographer.FrameCallback mFrameCallback = new Choreographer.FrameCallback() { @Override public void doFrame(long frameTimeNanos) { // 通过 getProvider() 不断驱动 doFrame ，从而 不断回调 doAnimationFrame ，让动画连续进行 doAnimationFrame(getProvider().getFrameTime()); if (mAnimationCallbacks.size() > 0) { getProvider().postFrameCallback(this); } } }; 而 Choreographer 是跟屏幕刷新机制关系紧密， Andorid 中的重绘就是由 Choreographer 1 秒内产生 60 个 vsync 来通知 view tree 进行 view 的重绘的。 而 vsync 产生后会调用它的监听者回调接口 Choreographer.FrameCallback， 也就是说，只要向Choreographer注册了这个接口，就会每 1 秒里收到 60 次回调。 参考链接 https://www.jianshu.com/p/30cfa00fc7a4 属性动画 更新时会调用 onDraw() 吗 1、补间动画 是通过不断调用 invalidate() ,然后 触发 onDraw() ，形成重新绘制。 2、属性动画是通过 反射的方式取修改了 View 的属性值， 比如 修改了透明度 。 然后查看 View 的源码中 ，有如下函数 public void setAlpha( ) { invalidateViewProperty(true, false); mRenderNode.setAlpha(getFinalAlpha()); } public void setTranslationY(float translationY) { mRenderNode.setTranslationY(translationY); invalidateViewProperty(false, true); } 跟踪 mRenderNode.setTranslationY() ， public boolean setTranslationY(float translationY) { return nSetTranslationY(mNativeRenderNode, translationY); } private static native boolean nSetTranslationY(long renderNode, float translationY); 我们发现 会通过 jni 直接执行了 native方法 nSetTranslationY 取执行界面绘制了， 并没有走 Java 层的 onDraw() 方法。 Android 动画 有用到哪些设计模式 1、估值器设置那里用了 策略模式。 objectAnimator.setInterpolator(new AccelerateInterpolator()); // 估值器1 objectAnimator.setInterpolator(new DecelerateInterpolator()); // 估值器2 2、动画进度监听 用了观察者模式 objectAnimator.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() ...); 转场动画 、过渡动画 、Transition Transiton 框架是在api19引入, 但是转场动画却是在api21引入，某些动画效果可能需要api23之上。 SharedElement 共享元素 : 从activityA的一个图片，变大进入到了activityB里面。好像是把A的图片传递给了B去显示。 其实几乎所以的变换都是在B里面完成的，A并没有干什么卵事情。 简单的说就是把A里面的图片的位置，大小等信息传递给B， 然后B通过这些信息在自己的界面里面绘制出一模一样的， 然后在通过比较最终的大小和位置等信息，创建出一个Animator， 再然后就是动画的执行。这就看起来像是A里面的元素共享到了B里面。 if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.LOLLIPOP) { // 21- android 5.0 // 启用 transition api getWindow().requestFeature(Window.FEATURE_ACTIVITY_TRANSITIONS); getWindow().requestFeature(Window.FEATURE_CONTENT_TRANSITIONS); // 响应到返回的共享元素 setExitSharedElementCallback(new MaterialContainerTransformSharedElementCallback()); // 指示共享元素在转换期间是否应使用叠加层 getWindow().setSharedElementsUseOverlay(false); } if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.LOLLIPOP && !TextUtils.isEmpty(ImagePreviewManager.getInstance().getTransitionShareElementName())) { getWindow().requestFeature(Window.FEATURE_ACTIVITY_TRANSITIONS); findViewById(android.R.id.content).setTransitionName(\"shared_element_container\"); // android.R.id.content ?? setEnterSharedElementCallback(new MaterialContainerTransformSharedElementCallback()); getWindow().setSharedElementEnterTransition(new MaterialContainerTransform().addTarget(android.R.id.content).setDuration(300L)); getWindow().setSharedElementReturnTransition(new MaterialContainerTransform().addTarget(android.R.id.content).setDuration(250L)); } public void onClick(View view) { ImagePreview.getInstance() .setTransitionView(view) // .setTransitionShareElementName(\"shared_element_container\") // .start(); } 其他 插值器 Interpolator 插值器 和估值器 对于实现非匀速动画是非常重要的。 加速/减速运动都属于非线性运动。 差值器是一种能修改速率的东西，用来设置动画运行过程中的变化规律。 比如，匀速、快到慢、慢到快、快慢快或者慢快慢、加速变化、回弹等。 内置插值器 // 动画先加速再减速，相当于view速度从0一直加速，最后又减速到0 AccelerateDecelerateInterpolator accelerateDecelerateInterpolator ; // 动画加速进行,动画开始运行时变化很慢，越到后面越快，最后突然结束。 AccelerateInterpolator accelerateInterpolator ; // 先退后再加速前进 ，类似投掷标枪，先往后一点，然后加速运行。 AnticipateInterpolator anticipateInterpolator ; // 先退后再加速前进，超出终点后再回终点 AnticipateOvershootInterpolator anticipateOvershootInterpolator ; // 最后阶段弹球效果，就是会在到达终点后，类似弹球回弹几次。 BounceInterpolator bounceInterpolator ; //周期运动，动画可以不到终点就回弹，也可以到了终点后在回弹，还可以回弹多次， // 小于1.0f不到终点就回弹，大于1.0f会到了终点后回弹，如果大于2，则会回弹多次。 CycleInterpolator cycleInterpolator ; // 动画运行越来越慢，减速运行 ，说明开始的时候是最高速。 DecelerateInterpolator decelerateInterpolator ; // 动画匀速改变 LinearInterpolator linearInterpolator ; // 快速完成动画，会超出一点然后再回到结束样式。 OvershootInterpolator overshootInterpolator ; //根据路径来控制动画的执行快慢，路径可以是贝塞尔曲线，也可以是普通Path。 PathInterpolator pathInterpolator ; Support V4 的插值器 LookupTableInterpolator // 父类 FastOutLinearInInterpolator // 子类 FastOutSlowInInterpolator // 子类 LinearOutSlowInInterpolator // 子类 自定义插值器 自定义插值器需要实现 Interpolator / TimeInterpolator 接口， 补间动画需要 implements Interpolator ， 属性动画需要 implements TimeInterpolator 。 TimeInterpolator 接口是属性动画中新增的。 public class MyInterpolator implements TimeInterpolator { @Override public float getInterpolation(float input) { float result; // 返回的result值 = 随着动画进度呈先减速后加速的变化趋势 if (input 估值器 Evaluator 插值器算出属性改变的百分比，估值器根据这个百分比算出属性值。 插值器决定属性值随时间变化的规律； 而具体变化属性数值则交给估值器去计算。 内置估值器 // Int类型估值器，返回int类型的属性改变 IntEvaluator intEvaluator ; // Float类型估值器，返回Float类型属性改变 FloatEvaluator floatEvaluator ; ; // 颜色类型估值器，返回16进制颜色值 ArgbEvaluator argbEvaluator ; 自定义估值器 自定义估值器，这里举个匀速估值器的例子： 动画进行了50%（初始值=100，结束值=200 ）， 那么匀速插值器计算出了当前属性值改变的百分比是50%， 那么估值器则负责计算当前属性值 = 100 + （200-100）x50% = 150。 异常记录 华为部分机型使用 setRotationY 会导致 view 消失 view.setRotationY(20); view.setRotationX(20); 这是华为的 EMUI 系统 的bug。 有类似的旋转动画时，注意避开华为系统， 或者使用 android.graphics.Camera 等3D动画方案去实现。 ( no Copyright，enjoy youself ! ) all right reserved，powered by GitbookThe file was updated at : 2021-08-19 09:46:35 "},"chinese/android基础/屏幕刷新机制.html":{"url":"chinese/android基础/屏幕刷新机制.html","title":"屏幕刷新机制","keywords":"","body":"屏幕刷新机制 CPU 计算屏幕数据、GPU 进一步处理和缓存、最后 display 再将缓存中（buffer）的屏幕数据显示出来。 屏幕每一帧的画面可以持续 16.6ms，当过了 16.6ms，底层就会发出一个屏幕刷新信号，而屏幕就会去显示下一帧的画面。 当屏幕刷新信号到的时候，屏幕就去将 CPU 计算的屏幕画面数据显示出来；同时 CPU 也接收到屏幕刷新信号，所以也开始去计算下一帧的屏幕画面数据。 在每一次屏幕刷新信号来的时候都会去切换这一帧的画面，这点我们是控制不了的，是底层的工作机制。 当用户不操作了、当前界面也没动画 时 ，CPU没有 下一帧画面数据需要计算，但是底层仍然会以固定的频率来切换每一帧的画面，只是它后面切换的每一帧画面都一样，所以给我们的感觉就是屏幕没刷新。 CPU 绘制视图树来计算下一帧画面数据的工作是在屏幕刷新信号来的时候才开始工作的，而当这个工作处理完毕后，也就是下一帧的画面数据已经全部计算完毕，也不会马上显示到屏幕上，而是会等下一个屏幕刷新信号来的时候再交由底层将计算完毕的屏幕画面数据显示出来。 https://www.jianshu.com/p/0d00cb85fdf3 ( no Copyright，enjoy youself ! ) all right reserved，powered by GitbookThe file was updated at : 2020-08-19 17:20:00 "},"chinese/android基础/屏幕适配.html":{"url":"chinese/android基础/屏幕适配.html","title":"屏幕适配","keywords":"","body":"屏幕适配 术语 术语 解释 屏幕尺寸 屏幕的对角线的长度 屏幕分辨率 屏幕的宽和高的像素数 density 屏幕密度，等于dpi/160 。 表示 每英寸有多少个显示点 dpi 像素密度 ， dots per inch px 每一个光点就是一个像素。 dp , dip device independent pixels ， 基于屏幕密度抽象长度单位，在每英寸160点的显示器上，1dp = 1px。 ppi pixels per inch 屏幕尺寸、屏幕分辨率、像素密度的关系 为什么规定160dpi规格的显示器上，1dp = 1px px=dp*（dpi/160） Google的官方文档中给出解释，因为第一款Android设备（HTC的T-Mobile G1）是属于160dpi的。于是就成为标准了。 常用公式 px = density * dp // 例如 density=2时 ，1dp =2px density = dpi / 160 // 例如 dpi=320时 ， density =2 px = (dpi / 160) * dp // 例如 dpi=320时 ， 1dp = 2px 引起适配问题的根源 1、屏幕密度不一样 density 。 举例： A 、B 手机的分辨率都是 1080 *1920 ， 但是 A的 密度为 160 ， B的密度为 320 。 此时你设置一条线的长度 为 1080dp ，在A手机上 刚好占满 长度， 但是在 B手机中只能占据一半 。 2、设备的长宽比例不一样。 假如 设计师的 基于 4：3 比例的屏幕设计的效果图 ，无论如何不可能跟 在 16：9上的效果一样的。 采用的适配方案一般是根据图片宽度 跟比等比例决定图片的高度。 适配思路 因为目前设备的长宽比是不一样的，所以一套设计图在不同的设备上的效果不可能是一模一样的。一般遵循以下原则即可。 1、可以上下滑动的界面，保证宽的纬度与设计图一致 。 2、不支持上下滑动的界面 ，保证高的纬度与设计图一致 。 //为了满足“显示比例和设计的长宽比例一致”，某些地方只能做留白处理。 3、 多使用 wrapcontent matchparent 以及线性布局的权重 4、多套xml 布局 方案 // 感觉很繁琐，基本很难采用。 布局限定符。 业界 推荐的 适配方案 1、今日头条的 代码 更改 屏幕密度 density 的方案。 缺点就是非常依赖设计图，假如引入的第三方的一些控件 跟设计图相差较大，效果就不太好。 2、多套 diments.xml 方案。将市面上主流的手机 收集起来，生成 values-sw320dp 等 values-xxx 的文件夹 ， 每个文件夹里 有同名文件 diments.xml , xxdp ,xx的值各不相同。 缺点是会增加 xml 文件数量 增加apk 大小。 其他 //以 设计师给定的 图片屏幕尺寸作为标准 ， 返回当前设备下的触摸点坐标 public static int getValues_x(Context context, int value_x){ return (int) ((float) value_x / 720 * MyDeviceInforHelper .getWindowWidth(context)); } ( no Copyright，enjoy youself ! ) all right reserved，powered by GitbookThe file was updated at : 2020-10-15 17:28:54 "},"chinese/android基础/图片加载详解.html":{"url":"chinese/android基础/图片加载详解.html","title":"图片加载详解","keywords":"","body":"相关概念和算法 什么是 三级缓存 1、内存缓存，优先加载，速度最快 2、本地磁盘缓存，次优先加载，速度快 3、网络缓存，最后加载，速度慢，消耗流量 LruCache 缓存算法 Least Recently Used Cache /近期最少使用 。 核心思想是当缓存满时，会优先淘汰那些近期最少使用的缓存对象。 Bitmap 复用池 使用 inBitmap 选项, 需要获取图片时 , 优先从 Bitmap 复用池中查找已存在的 Bitmap 对象 ; 假如 Bitmap 对象长时间不使用 , 就会从 LruCache 内存缓存中移除 , 放入到 Bitmap 复用池中 相关提问 Bitmap 内存 和 drawable 目录的关系 drawable 屏幕密度 ldpi 120 mdpi 160 hdpi 240 xhdpi 320 xxhdpi 480 drawable 目录 会影响原图缩放比，进而影响 bitmap 的内存占用。 缩放比K = 设备dpi / drawable目录所代表的 dpi 图片占用内存 的计算规则 同一个图片在不同屏幕密度下会缩放。 缩放比K = 设备dpi / drawable目录所代表的 dpi Bitmap 占用内存 = (K*原图长度 ) * (K*原图宽度) * 1个像素占用的字节数 单位px占用的字节数 跟图片的编码格式有关： ALPHA_8 : 每个像素占用 1byte 内存 -(用 一个 8 bit 存储) ARGB_4444 : 每个像素占用 2byte 内存 -(alpha red green blue 各4个 bit -> (4*4)/8 =2 ) RGB_565 : 每个像素占用 2byte 内存 -(red 5 bit green 6 bit blue 5 bit -> (5+6+5)/8 =2 ) ARGB_8888 : 每个像素占用 4byte 内存 -(alpha red green blue 各8 bit -> (4*8)/8 =4 ) 图片 从 xhdpi 放到 xxhdp ，内存为什么会减小 缩放比K = 设备dpi / drawable目录所代表的 dpi ， 所以 缩放比会变小 ，根据内存计算规则，所以会减小。 图片 占用 磁盘 存储空间计算 并没有像占用内存空间一样有个明确的公式。 而且要明确占用磁盘空间和占用内存空间完全是不同的概念， 例如占用磁盘10kb的图片 占用的内存空间需要1M。 不要尝试通过压缩图片磁盘存储大小来缓解OOM的问题。 占用 磁盘的大小 跟图片的分辨率和 压缩算法有关， 同样的一张图片，等质量压缩后的大小可能相差很大。 例如 https://tinypng.com/ 就提供了非常好的压缩体验。 Android 大图、长图 加载 给一张 10M的“清明上河图”，如果直接加载，很可能会直接 OOM ， 如果通过配置压缩率 inSampleSize 压缩展示，那么图片就会很模糊。 此时我们可以通过其他方案来展示高清大图，例如先展示一张较小的缩率图， 然后通过手指选定，加载局部的大图，手指移动时加载的大图区域也跟着移动。 例如京东和淘宝的网页上高清商品图就是这种方式。 总之就是，只加载需要显示的部分，要看哪里就加载哪里。 配合 Android 的 BitmapRegionDecoder 可以实现这种方案。 Bitmap 内存复用 (options.inBitmap options.inMutable ) inBitmap 生效的规则 1、inBitmap 只能在 3.0 才有 。 1、在Android 4.4之前，只能重用相同大小的 Bitmap 内存区域； 4.4之后只要复用内存空间的 Bitmap 对象大小比 inBitmap 指向的内存空间要小即可。 2、 新申请的Bitmap与旧的Bitmap必须有相同的解码格式。如果前面的Bitmap是8888， 那么就不能支持4444与565格式的Bitmap了。 BitmapFactory.Options options; Bitmap inBitmap ; void init(Context context , int resId){ options = new BitmapFactory.Options() ; options.inMutable =true; // 允许复用，必须配套使用 inBitmap =BitmapFactory.decodeResource( context.getResources(), R.drawable.resId, options) ; } void getBitmap(Context context ,int resId ){ options.inBitmap = inBitmap; // 指定复用 Bitmap bitmap = BitmapFactory.decodeResource(context.getResources(), resId, options); } inJustDecodeBounds 减小内存开销 用来获取图片的大小信息的同时不占用内存。 例如我们只要获取图片本身的大小，直接decodeResource 加载 ，那么会返回一个 Bitmap 会浪费内存，但是设置 inJustDecodeBounds = true ，那么返回的 bitmap 是空的，并不会消耗内存。 Bitmap getImage(Context context) { BitmapFactory.Options options = new BitmapFactory.Options(); options.inJustDecodeBounds = true ; // 标记只获取图片信息，并不去加载bitmap 到内存 BitmapFactory.decodeResource(context.getResources(), R.drawable.test2, options) ; //获取图片的长宽 options.inSampleSize = getImageSampleSize(options.outWidth, options.outHeight) ; options.inJustDecodeBounds = false ;// 关闭标记 return BitmapFactory.decodeResource(context.getResources(), R.drawable.test2, options); } Bitmap 不改变图片质量的情况下,如何减少内存 根据 内存占用公式得知，影响内存的因素 有图片的长宽 和图片的质量。 无论是改变图片的长宽尺寸 还是压缩图片质量 都会影响最终的显示效果， 所以在不影响质量的前提下，可以采用内存复用的方案。inBitmap 。 图片显示不全、变形怎么处理 图片显示变形的原因是因为 imageview 的长宽比 和 图片的长宽比不一致导致的。 例如 正方形的照片要显示成 长方形，肯定会变形。 显示不全的现象是因为长宽比不一致，为了避免变形采取的 scaleType=\"centerCrop\" 。 为了避免显示不全和变形的问题，一般是从源头来解决， 例如：宽度固定，然后根据长宽比动态计算出 imageview的 高度， 或者长宽都固定，此时就要用 centerInside ,然后两边留白处理。 如何跨进程传递大图 1、如果对效率没要求，可以通过 存储文件的方式。 限把图片保存到SD卡，然后只传递 路径。然后根据路径加载文件。 2、通过 Intent 直接传递 (不推荐) intent.putExtra(\"myBitmap\" ,bitmap) ; 问题是 Bitmap 太大会抛 TransactionTooLargeException 异常。 为什么 Intent 传值会有大小限制。 应用进程在启动 Binder 机制时会映射一块 1M 大小的内存， 所有正在进行的 Binder 事务共享这 1M 的缓冲区 。 当使用 Intent 进行 IPC 时申请的缓存超过 1M - 其他事务占用的内存时， 就会申请失败抛 TransactionTooLargeException 异常了。 3、Bundle + AIDL (推荐) bundle.putBinder(\"myBitmap\", new IRemoteGetBitmap.Stub() { public Bitmap getBitMap() throws RemoteException { return mBitmap; } }); intent.putExtras(bundle); 较大的 bitmap 直接通过 Intent 传递容易抛异常， 是因为 Intent 启动组件时，系统禁掉了文件描述符 FileDescriptor 机制 , bitmap 无法利用共享内存，只能拷贝到 Binder 映射的缓冲区，导致缓冲区超限, 触发异常; 而通过 putBinder 的方式，避免了 Intent 禁用描述符的影响, 可以利用共享内存，所以能高效传输图片。 图片格式 webP 在保证图片视觉不失真前提下缩小体积，对于节省带宽和apk体积十分重要。 然而目前对于 JPEG、PNG、GIF 等常用图片格式的优化已几乎达到极致， 因此Google于2010年提出了 WebP ，给图片的优化提供了新的可能。 WebP为网络图片提供了无损和有损压缩能力，有损和无损 都支持透明通道。 谷歌于2014年提出了 动态WebP，拓展WebP使其支持动图能力。 动态WebP相比 GIF 支持更丰富的色彩，并且也占用更小空间。 Android 4.0 开始支持有损的WebP图像， Android 4.3 开始支持无损和透明的WebP图像。 Androidstudio 自带 图片转换 webP 和 .9 格式的图片。 可以将 PNG、JPG、BMP 或静态GIF 图像转换为WebP格式 。 暂时不支持 ico 格式的图片转换。 SVG (Scalable Vector Graphics) 矢量图 ，在各种设备上能实现自然伸缩或扩展而不影响图片质量。 1、加载、解析 svg文件 ，获得 path 数据 2、将path数据转换为 Path 对象。谷歌官方有现成的工具类 PathParser.java。 3、将解析出来的所有path绘制出来 4、判断点击点是否在当前path范围内。 public boolean isInArea(Path mPath ,float x, float y){ RectF r=new RectF(); mPath.computeBounds(r, true); Region re=new Region(); re.setPath(mPath, new Region((int)r.left,(int)r.top,(int)r.right,(int)r.bottom)); return re.contains((int)x, (int)y); } SVG 绘制不规则图形 https://github.com/hnyer/taiwanDemo vector vector 是Android 中的矢量图使用方案。 Android 5.0发布的时候，Vector只支持Android 5.0+。 不过自从AppCompat 23.2之后，Google做了兼容处理 ， 只需要引用com.android.support:appcompat-v7:23.2.0以上的版本 就适用于Android 2.1以上的所有系统 。 vector 标签 width // 图形宽度 height // 图形高度 viewportHeight // 画布高度 viewportWidth // 画布宽度 group // 对Path进行分组 path 对应一个Path name // path名字 fillAlpha//填充透明度 fillColor //填充颜色 strokeColor//线条颜色 pathData //path指令 strokeWidth//线条宽度 vector 绘制不规则图形 https://github.com/hnyer/RegionDetector 图片加载工具 Glide 在线文档 https://muyangmin.github.io/glide-docs-cn/doc/download-setup.html Glide 优点 https://github.com/bumptech/glide Glide 可以设置 最大内存缓存空间大小、最大磁盘缓存空间大小、 缓存失效时间。 1、Glide.with(xxx)方法 接受 Context、Activity 、 Fragment 。 建议使用后面两个。因为图片加载会和Activity 、Fragment的生命周期保持一致。 2、支持加载 gif 格式。 Glide3.x 使用 RequestOptions requestOptions = new RequestOptions() .placeholder(R.mipmap.icon_us) //.diskCacheStrategy(DiskCacheStrategy.NONE) //.skipMemoryCache(true) // 缓存失效策略 ，key 不一样 缓存就会失效 .apply(RequestOptions.signatureOf(new ObjectKey(getSignatureKey()))) .error(R.mipmap.icon_us); Glide.with(activity) // 根据路径、File 加载 .load(filePath) .apply(requestOptions) .into(userImg); private long getSignatureKey() { ///long key = System.currentTimeMillis() / INVALID_TIME long key = System.currentTimeMillis() ; return key ; } // 当通过get访问接口 ，直接返回图片流的时候。 可以直接加载这个接口也可以显示。 // 不需要去加载接口返回的值。 glide 4.x 的变化 glide4.x 和 glide3.x 的api 有一些变化。 /** The default value for DecodeFormat. */ public static final DecodeFormat DEFAULT = PREFER_ARGB_8888; glide4.x 默认加载格式 是 PREFER_ARGB_8888 。 glide3.x 的默认格式貌似是 565，如果遇到一些 带有透明度的图片导致效果不对的时候， 设置一下加载格式就行了。 // 设置自定义缓存签名 请参考 AivinReader 中的代码 Glide.with(activity) .asGif() .signature(new MySignature( imageUrl )) // 传入自定义签名 // 获取缓存的名字 （glide 生成缓存的时候也使用的 SHA-256 方法？ 没看源码，猜测的 ） public String getSafeKey(Key key) { String safeKey= System.currentTimeMillis()+\"\"; MessageDigest messageDigest = MessageDigest.getInstance(\"SHA-256\"); key.updateDiskCacheKey(messageDigest); safeKey = Util.sha256BytesToHex(messageDigest.digest()); return safeKey; } // 配置缓存地址 /** * 这个类不要删除 ，通过 注解的方式给 Glide 设置 缓存路径等的。 否则会使用默认路径。 */ @GlideModule public class MyGlide extends AppGlideModule { public static String diskCachePath =null ; @Override public void applyOptions(Context context, GlideBuilder builder) { int diskCacheSizeBytes = 1024 * 1024 * 100; appRootPath = context.getCacheDir().getPath(); diskCachePath = getStorageDirectory(); builder.setDiskCache( new DiskLruCacheFactory( diskCachePath, diskCacheSizeBytes ) ); } private String sdRootPath = Environment.getExternalStorageDirectory().getPath(); private String appRootPath = null; private String getStorageDirectory() { String path = Environment.getExternalStorageState().equals(Environment.MEDIA_MOUNTED) ? sdRootPath : appRootPath; path+= \"/z_wkReaderGlideDisk123456\" ; return path ; } } // 根据签名获取sd中的缓存 public static File getGlideCacheFile(Context context, String url) { MySignature mySignature = new MySignature(url); String safeKey = new SafeKeyGenerator().getSafeKey( mySignature); File file = new File(MyGlide.diskCachePath);// 注意此处缓存的路径要跟 glide 设置的缓存路径一致 DiskLruCache diskLruCache = DiskLruCache.open(file, 1, 1, DiskCache.Factory.DEFAULT_DISK_CACHE_SIZE); DiskLruCache.Value value = diskLruCache.get(safeKey); if (value != null) { return value.getFile(0); } return null; } // 缓存的生效时间设置 貌似是没有api直接设置的 我们可以通过签名的方式自己去判断，如果超过一定时间， 就让签名变化即可。 ( no Copyright，enjoy youself ! ) all right reserved，powered by GitbookThe file was updated at : 2021-08-26 16:47:22 "},"chinese/android基础/WebView详解.html":{"url":"chinese/android基础/WebView详解.html","title":"WebView详解","keywords":"","body":"WebView详解 [ Android4.4, +∞) Chromium内核取代了Webkit内核。 [ Android5.0, +∞) WebView移植成了一个独立的apk，可以不依赖系统而独立存在和更新。 [ Android7.0, +∞) 如果用户手机里安装了 Chrome ， 系统优先选择 Chrome 为应用提供 WebView 渲染。 [ Android8.0, +∞) 默认开启WebView多进程模式，即WebView运行在独立的沙盒进程中。 ( no Copyright，enjoy youself ! ) all right reserved，powered by GitbookThe file was updated at : 2020-08-19 17:20:00 "},"chinese/android基础/沉浸式.html":{"url":"chinese/android基础/沉浸式.html","title":"沉浸式","keywords":"","body":"沉浸式 Android 至4.4才开始支持沉浸式状态栏 。 所谓的 沉浸式 就是 可以设置手机状态栏的背景 。 实际的效果其实就是透明的状态栏，然后在状态栏的位置显示我们自定义的颜色 或图片 。 这里 有一个比较好用的第三方库 ImmersionBar ( no Copyright，enjoy youself ! ) all right reserved，powered by GitbookThe file was updated at : 2020-08-19 17:20:00 "},"chinese/android基础/相机模块.html":{"url":"chinese/android基础/相机模块.html","title":"相机模块","keywords":"","body":"相机模块 从Android 5.0(21)开始， android.hardware.Camera 被废弃 ，启用 android.hardware.Camera2 。 Android相机兼容性问题非常大,如果只是拍照,尽量调用系统相机,如果需要预览和拿视频流, 可以基于某些第三方库开发。 natario1 CameraView     谷歌非官方 cameraview     基于谷歌非官方 cameraview     camerakit-android 参考资料 拍出来的照片旋转了 获取照片的角度值，然后再用矩阵纠正过来。 拍照后闪退 部分机型对自家相机做了优化，会销毁我们的activity。 根据调试情况，在onSaveInstanceState()中保存对应状态即可。 图片无法显示 图片太大导致OOM ，对图片进行压缩即可。 自拍镜像 开启前置摄像头后，预览的画面和拍照后的画面是左右相反的。进行图片翻转即可。 预览画面 贴图 相机 + opengl es 方案。 ( no Copyright，enjoy youself ! ) all right reserved，powered by GitbookThe file was updated at : 2020-08-19 17:20:00 "},"chinese/android基础/地图模块.html":{"url":"chinese/android基础/地图模块.html","title":"地图模块","keywords":"","body":"地图模块 坐标类型 // 世界标准地理坐标 、WGS-84 国际标准，从国际标准GPS设备中获取到的坐标都是 WGS84 。 WGS－84 坐标系是美国建立的GSP原始坐标系； // 中国国测局地理坐标 、 GCJ-02 、 火星坐标 中国标准，国家测绘局 发布的坐标系 。在中国，必须至少使用GCJ02对地图进行首次加密。 火星坐标系统 ，就是中国设计的一个加密插件，是对真实地图进行人为的加偏处理，按照一定的加偏算法，将真实的坐标加密成虚假的坐标。 加偏处理不是线性的加偏，所以各地的偏移情况都会有所不同。这样一来地图的坐标就与实地的坐标不相符了，于是大家把这种坐标戏称为\"火星坐标\" 。 // CGCS2000 坐标系 China Geodetic Coordinate System 2000 ,是我国建立的大地坐标系，类似于WGS－84坐标系，是原始坐标系。 // 搜狗坐标系 由GCJ-02进行进一步的偏移算法得到。 // 百度地理坐标 、 BD-09 百度标准， 在GCJ02 的基础上进行二次加密。 各个地图软甲采用的坐标系 在中国，任何一个地图产品 至少使用GCJ-02进行首次加密，不允许直接使用WGS-84坐标下的地理数据，同时任何坐标系均不可转换为WGS-84坐标。 网上有人总结反推的一些转换接口，都是有偏差的。对精度非常严格的使用场景，要慎重使用。 基于 GCJ-02 转 WGS-84 的转换结果都有偏差。 基于 WGS-84 转 GCJ-02 的转换结果没有偏差。 // 百度地图 1、境内、包括港澳台 : BD09 。 2、境外 : WGS-84 。 // 高德地图: 1、境内：GCJ-02 2、境外：暂不支持 // 腾讯地图 1、境内：GCJ-02 2、境外：暂不支持 // google地图 1、境内：GCJ-02 , 数据来源于高德，两者互通。 2、境外：WGS-84 。 // bing地图 ,微软的 全球统一：WGS-84 。Bing地图图源较老 。 // 天地图 全球统一 ：CGCS2000 地图坐标互相转换 https://github.com/hnyer/JZLocationConverter-for-Android 高德地图 根据指定经纬度显示和导航 String.format(Locale.getDefault(), \"https://m.amap.com/share/index/lnglat=%f,%f\" , xx.longitude ,xx.latitude) ; 隐藏左下角Logo // 高德地图隐藏左下角Logo UiSettings settings = aMap.getUiSettings(); settings.setLogoBottomMargin(-50);//高德logo图标无法移除 ，但是可以通过设置偏移的位置 来隐藏它 地理围栏 https://lbs.amap.com/api/android-location-sdk/guide/additional-func/local-geofence/ 加载谷歌瓦片地图数据 http://mt0.google.cn/vt/lyrs=y&hl=en&gl=en&src=app&x=6678&y=3558&z=13&s= // ok http://mt0.google.cn/vt/lyrs=y&x=6678&y=3558&z=13http://mt0.google.cn/vt/lyrs=y@110&x=6678&y=3558&z=13 格式 http://mt0.google.cn/vt/lyrs={lyrs}&hl=en&gl=en&src=app&x=%d&y=%d&z=%d&s= http://mt0.google.cn/vt/lyrs={lyrs}&x=%d&y=%d&z=%d // 一般用这个就可以了，不需要很多其他参数 // 服务器地址 ，可选，效果都是一样的 http://mt0.google.cn http://mt1.google.cn http://mt2.google.cn http://mt3.google.cn // x 列号 、 y 行号 、 z zoom级别 // hl :en 、 zh-CN // gl : en 、cn // src : 标记来自哪里的请求？ // s : 作用未知，可用可不用。随便填 。 // lyrs m：路线图 ​t：地形图 ​s：卫星图 ​p：带标签的地形图 ​y：带标签的卫星图 ​h：标签层（路名、地名等） 我看到其他有些后面跟了个@参数，暂时不知道什么作用。lyrs=m@167000000 。不用貌似也没有问题。 经过测试发现 谷歌中国，高德 都采用了 火星坐标系。不过谷歌中国同时也提供了 wgs84坐标系方式的地图，只要修改一个参数即可， 将gl=cn去掉，则下载的地图 就变成了 wgs84,否则 则是火星坐标系。 高德地图 加载 .mbtiles 文件 mbtiles 文件其实就是一个 sqllite 数据库文件。此处给出我写的一个demo。关键点在于 y 坐标的转换。 https://gitee.com/Aivin_CodeShare/android_tool_code/raw/master/MbTilesDataTool.java 如果 高德要加载国外地图，需要 Mbtiles 是个有偏移过的 数据库。 如何编辑和生成 mbtiles 文件暂时没有研究。暂由客户自己提供。 加载英文地图 自 Android 3D 地图SDK V5.5.0起，地图支持切换中英文显示。 AMap.CHINESE 表示中文，即\"zh_cn\", AMap.ENGLISH 表示英文，即\"en\" aMap.setMapLanguage(AMap.ENGLISH); 高德地图定位不准确的问题 WkLogTool.showLog(\"定位信息= getAccuracy=\"+accuracy); WkLogTool.showLog(\"定位信息= getLocationType=\"+type); WkLogTool.showLog(\"定位信息= getLongitude=\" + aMapLocation.getLongitude() + \",getLatitude=\" + aMapLocation.getLatitude() ) ; WkLogTool.showLog(\"定位信息=getLocationDetail=\"+aMapLocation.getLocationDetail()); 可以将定位类型和定位精度打印出来看看， 有些地方太偏僻了，基站定位不准确， 尝试换成gps定位试试。 mLocationOption.setLocationMode(AMapLocationClientOption.AMapLocationMode.Device_Sensors); // 定位类型查看表 https://lbs.amap.com/api/android-location-sdk/guide/utilities/location-type/ // 定位SDK错误码对照表 https://lbs.amap.com/api/android-location-sdk/guide/utilities/errorcode/ 另外，你的APP和高德地图对比，高德地图显得会更准确一点， 跟技术客服咨询过， 解释的原因是高德地图有对回调的数据做过二次过滤， 比如去掉精度太大的数据等。 另外注意 AMapLocationListener 只能单次回调， 而 locationManager.requestLocationUpdates(LocationListener) 可以不停地回调 。 有些手机，例如小米9，用的定位方式可能不一样，如果不开启 setMockEnable(true) ， 就会定位失败，返回错误码为 “ ErrCode:15, errInfo:当前返回位置为模拟软件返回，请关闭模拟软件，或者在option中设置允许模拟” 多边形计算 AMapUtils public static float calculateArea(java.util.List points) 从 6.0.0 版本开始支持多边形的面积计算。 小于 6.0的sdk ，只支持矩形的面积计算。 如果你的sdk版本小于6.0 又想计算多边形的面积， 可以网上搜索一下多边形的面积的计算。 地图导航 (不是真的导航) 这里说的导航不是地图APP的那种导航，并没有语音和路线规划等。 实际应用场景为： 无人机的方向在不停变化的， 在地图上表现为 机头一直朝北，让地图一直在旋转。 详细业务代码可以参考 R400 。 @Override public void onCameraChange(CameraPosition cameraPosition) { bearingByMap =cameraPosition.bearing ; updateMarkerOrMapAngle(true); } private void updateFlyingLocationMaker(LatLng latLngTemp) { // 飞控不断下发机头方向和坐标 updateMarkerOrMapAngle(false) ; } // 旋转地图 或者旋转飞机图标 private void updateMarkerOrMapAngle(boolean fromOnCameraChange){ // 地图导航模式下已经禁止用户旋转地图，所以不用考虑 fromOnCameraChange if(isMapAutoMoveToFlyLocation){ aMap.moveCamera( CameraUpdateFactory.changeBearing(planeYawAngle) ); } if(flightMarker!=null){ float lastAngle = -planeYawAngle + bearingByMap; flightMarker.setRotateAngle( lastAngle); } } // 手动旋转模式转为自动导航模式时，需要把机头图标指向北方 public void handMode2AutoMode(){ float markerAngle = flightMarker.getRotateAngle() ; // 箭头的角度 float mapWantAngle = bearingByMap + markerAngle ; //地图当前的角度 aMap.moveCamera( CameraUpdateFactory.changeBearing(mapWantAngle) ); aMap.moveCamera(CameraUpdateFactory.changeLatLng(flightMarker.getPosition())); aMap.moveCamera(CameraUpdateFactory.zoomTo(aMap.getMaxZoomLevel())); } 中国禁飞区 大疆禁飞区查询 https://www.dji.com/cn/flysafe/geo-map 优凯限飞区查询与下载 http://xianfei.u-care.net.cn/#/downLoad 在线导入kml查看效果图 http://geojson.io/#map=2/20.0/0.0 Java主要用dom4j包解析kml文件。 经纬度反查地址 https://lbs.amap.com/tools/picker // 高德 https://www.earthol.com/ // 地球在线 ( no Copyright，enjoy youself ! ) all right reserved，powered by GitbookThe file was updated at : 2021-08-20 15:34:53 "},"chinese/android基础/Androidstudio插件开发.html":{"url":"chinese/android基础/Androidstudio插件开发.html","title":"Androidstudio插件开发","keywords":"","body":"Androidstudio 插件开发 环境配置 1、使用 IntelliJ IDEA 进行开发 创建 Intelli Platform Plugin 项目 创建项目时可能找不到sdk，选择 IntelliJ IDEA 的根目录即可。 2、如果开发的 plugin 拖放到 Androidstudio报错 com.intellij.diagnostic.PluginException: While loading class FirApkAction: FirApkAction has been compiled by a more recent version of the Java Runtime (class file version 55.0), this version of the Java Runtime only recognizes class file versions up to 52.0 [Plugin: com.aivin.firapkuploadplugin] [Plugin: com.aivin.firapkuploadplugin] 这是由于 IntelliJ IDEA 版本过高导致的，我用的是 IntelliJ IDEA2021，结果需要 jdk11， 但是 Androidstudio 用的是 jdk8 ，打不开 jdk11编译出来的jar包。 最后我下载安装 ideaIC-2018.3.6.win 版本即可解决。 插件源码开发 1、使用 IntelliJ 社区版就可以(我用的是 ideaIC-2018.3.6.win) 注意 IntelliJ 版本如果过高，可能要求jdk11，但是很多人还在用 jdk8， 所以用 较低版本的 IntelliJ 即可。 2、创建工程类型选 Intelli Platform Plugin 3、插件UI界面的编写推荐使用插件 JFormDesigner， 这是个收费插件，网上有破解版。 插件界面用的是 Java的 swing 框架，如果你对swing 不熟悉，可以使用这个插件进行可视化开发。 另外，intelliJ 可能默认开启了自带“UI Designer”插件 ( 可视化操作 .form 文件)， 但是这个插件不好用，可以直接禁用它。 其他的一些工程配置可以直接搜索百度或者参考我这个demo https://gitee.com/hnyer/FirApkUploadPluginX 插件打包 build -> Prepare All Plugin Modules For Deployment 执行成功插件会默认在项目根目录下。 无依赖的插件是JAR包，带有依赖的插件是ZIP格式。 插件发布 注册账号，上传到 https://plugins.jetbrains.com/ 提交后一般需要两天的审核期，审核通过后可以在Androidstudio的插件中查到。 发布的时候，可能会遇到报错不让提交 Plugin has no dependencies. Please check the documentation 解决方案是： 在plugin.xml文件中添加 com.intellij.modules.lang JFormDesigner 破解 JFormDesigner 是一个第三方收费插件 ，可以可视化开发 swing 界面。 我的组合是 ideaIC-2018.3.6.win + JFormDesigner-7.0.3-intellij-idea 将 JFormDesigner\\lib\\JFormDesigner-Idea.jar 解压出来，然后用注册机进行注册，获得注册码。 插件文件在我的阿里云盘有保存。 ( no Copyright，enjoy youself ! ) all right reserved，powered by GitbookThe file was updated at : 2021-06-07 10:26:20 "},"chinese/android基础/Apk插件化开发.html":{"url":"chinese/android基础/Apk插件化开发.html","title":"Apk插件化开发","keywords":"","body":"Apk插件化开发 插件化开发是什么 把一个完整的App拆分成宿主和插件两大部分， 宿主就是先运行的app，插件即宿主运行时加载的apk文件， 这样宿主和插件结合的方案技术就是插件化。 模块化 、 组件化 、模块化 概念 模块化是一个较大的概念 ， 指分拆代码，即当我们的代码特别臃肿的时候，用模块化将代码分而治之、解耦分层。 组件化 将一个工程拆成多个模块，每个组件是一个 lib ， lib 之间没有直接依赖关系，用功能接口方式进行交互。 每个组件可以独立当做App存在。 可以参考后端开发的 “微服务”概念。 插件化 将一个工程拆成一个宿主 和多个 插件， 每个插件是一个可以独立运行的 apk ， 宿主可以主动调用打开 插件。 组件化侧重功能独立、没有依赖关系，可以作为独立的组建对外提供功能。不存在兼容性。 插件化侧重于动态调用、体现在“插”字，插入某个功能，用完就拔走再插入另外一个功能， 因为插件化不可避免的去 hook 一些系统的 api，也就不可避免地有兼容性的问题， 而且Android系统版本更新对插件化方案的影响很大。 因此每个插件化方案需要有专门的团队去负责维护； 插件化开发的优点 1、解耦。 独立各大模块的业务成为插件，互不干扰，即用即插，方便开发与维护。 2、加快编译。 每次修改后无需重新编辑整个工程项目， 可以单独编译某个插件工程，对于庞大的项目而言可以节约大量编译时间。 3、动态更新。 无需重新下载与安装app ，可以单独下载某个插件apk， 从动态更新、包体积和流量上感觉是个不错的选择。 4、模块定制。 需要什么模块下载什么模块，无需让app变得庞大。 插件化缺点 插件化已经是一个过去式了， Google从@hide开始就已经表明决心要干掉这些所谓“插件化”的不法分子了， 和google对着干没意义，需要投入大量精力， 采用田维术先生的一句话：“2018年Android 9.0上私有API的限制几乎称得上是盖棺定论了 ——曾经波澜壮阔的插件化进程必将要退出历史主流”。 从Android Jetpack可以看出Google规范开行为的用意。 滴滴开源的 VirtualAPK 已经于 2018年 停止更新。 Android每次版本升级都会给各个插件化框架带来不少冲击， 所以不再更新的框架在新系统上会存在兼容等问题。 googleplay 已经不允许动态更新类的插件化， 所以插件化已经慢慢退出历史舞台。 第三方插件化开发 框架 VirtualAPK (滴滴 ) 2018年 停止更新。 RePlugin (360) 更新缓慢，不支持最新 Gradle , 不支持 androidx 。 atlas (阿里巴巴) 更新缓慢，不兼容最新版本。 DynamicAPK (携程) 2015 停止更新 。 插件化开发原理 利用 hook 一些系统的 api 等。 技术已经废弃，不深入研究。 ( no Copyright，enjoy youself ! ) all right reserved，powered by GitbookThe file was updated at : 2021-05-07 08:54:12 "},"chinese/android基础/App组件化开发.html":{"url":"chinese/android基础/App组件化开发.html","title":"App组件化开发","keywords":"","body":"App组件化开发 组件化开发解决的痛点 1、项目模块多且复杂，编译一次要5分钟甚至10分钟？太慢不能忍？ 2、改了一行代码 或只调了一点UI，就要run整个项目，再忍受一次10分钟？ 3、合代码经常发生冲突？很烦？ 4、被人偷偷改了自己模块的代码？很不爽？ 5、做一个需求，发现还要去改动很多别人模块的代码？ 6、别的模块已实现的类似功能，自己要用只能去复制一份代码再改改？ 7、“这个不是我负责的，我不管”，代码责任范围不明确？ 8、只做了一个模块的功能，但改动点很多，所以要完整回归测试？ 9、做了个需求，但不知不觉导致其他模块出现bug？ 组件化开发的关键特征 组件化的核心就是解耦， 每个业务组件是互相独立的，不存在直接的依赖关系。 比如登录组件、支付组件是互不影响的。 组件独立调试 (单工程模式 - 单人开发，推荐) // 输出 apk (调试阶段配置) com.android.application // 输出 aar (集成阶段配置) com.android.library // 批量自动切换 1、在根 build.gradle 中做一个全局变量 ext { isLibrary = true } 2、在组件 build.gradle 中配置 def isLibrary = rootProject.isLibrary if (isLibrary.toBoolean()){ apply plugin: 'com.android.library' }else { apply plugin: 'com.android.application' } defaultConfig { if(!isLibrary.toBoolean()){ applicationId \"com.wkreader.base\" } } sourceSets { main { if (isLibrary.toBoolean()) { manifest.srcFile 'src/main/AndroidManifestlib.xml' } else { manifest.srcFile 'src/main/AndroidManifest.xml' } } } 组件独立调试 (多工程模式 - 多人开发，推荐) 相比较单工程，多工程模式非常简单，不需要上述配置，不讲解。 组件页面跳转 、通信 框架 组件之间没有依赖，不能使用显示启动来打开对方的Activity， 隐式启动是可以实现跳转，但是隐式 Intent 需要通过 AndroidManifest 配置和管理，协作开发显得比较麻烦。 这里一般采用业界通用的方式—路由。 业界采用的路由框架有阿里的 ARouter 、美团的 WMRouter 。 ARouter 基本使用 https://github.com/alibaba/ARouter/blob/master/README_CN.md 1、路由跳转是子模块都需要用到的，所以我们在 最基础模块 lib_base 中引入， 各个模块会引用这个lib_base。 compile \"com.alibaba:arouter-api:$rootProject.arouterVersion\" 2、然后在各子模块的build文件中引入： annotationProcessor \"com.alibaba:arouter-compiler:$rootProject.arouterProcessorVersion\" defaultConfig { javaCompileOptions { annotationProcessorOptions { arguments = [AROUTER_MODULE_NAME: project.getName()] } } } 3、如果工程启用了混淆机制，需要keep相关部分，否则会找不到路径 -keep public class com.alibaba.android.arouter.routes.**{*;} -keep public class com.alibaba.android.arouter.facade.**{*;} -keep class * implements com.alibaba.android.arouter.facade.template.ISyringe{*;} -keep interface * implements com.alibaba.android.arouter.facade.template.IProvider -keep class * implements com.alibaba.android.arouter.facade.template.IProvider 4、注意配置路径的时候，如果是在不同的模块里，第一级目录不能相同 public static final String BookshelfActivity=\"/lib_reader/BookshelfActivity\" ; public static final String EnglishListActivity=\"/lib_english/EnglishListActivity\" ; 5、Activity 跳转 // 应用内简单的跳转 ARouter.getInstance().build(\"/test/activity\").navigation(); // 携带参数跳转 ARouter.getInstance().build(\"/test/1\") .withLong(\"key1\", 666L) .withString(\"key3\", \"888\") .withObject(\"key4\", new Test(\"Jack\", \"Rose\")) .navigation(); ARouter 路由原理 ARouter 为了解耦, 在组件之间没有依赖时也可以彼此跳转。 ARouter 中使用了 javapoet 注解处理器，生成额外的Java文件 ， 将注解的key与类的路径通过一个Map关联起来了， 要我们拿到这个Map,即可在运行时通过注解的key拿到类的路径 ， #基本原理： Class targetClass = Class.forName(\"com.xxx.xxx.xxxActivity\") ; Intent intent = new Intent(this , targetClass) ; startActivity(intent); # ARouter代码体现 1、加入 map中 public void loadInto(Map atlas) { atlas.put(\"/lib_japaneese/JapneseShowActivity\", RouteMeta.build(RouteType.ACTIVITY, JapneseShowActivity.class, \"/lib_japaneese/japneseshowactivity\", \"lib_japaneese\", null, -1, -2147483648)); } 2、从 map 中取出 class 生成 Intent ,最后启动activity RouteMeta routeMeta = Warehouse.routes.get(postcard.getPath()); final Intent intent = new Intent(currentContext, postcard.getDestination()); ActivityCompat.startActivityForResult((Activity) currentContext, intent, requestCode, postcard.getOptionsBundle()); ActivityCompat.startActivity(currentContext, intent, postcard.getOptionsBundle()); ARouter 组件之间通信、组件和APP主模块之间通信 ( 通过暴露服务 IProvider ) // 定义服务 public interface ILoginProvider extends IProvider { boolean isLogined() ; } @Route(path = ProviderConfig.LoginInfoProvider, name = \"登录数据服务\") public class LoginInfoProvider implements ILoginProvider { public void init(Context context) { } public boolean isLogined(){ return true ; } } // 发现和使用服务 ILoginProvider service = (ILoginProvider) ARouter.getInstance().build(ProviderConfig.LoginInfoProvider).navigation(); boolean isLogined = service.isLogined( ) ; // 使用步骤 1、在公共的基础lib中定义服务接口， 2、在各自的lib中继承这个接口并实现具体功能 3、在其他模块中调用接口 ARouter 预处理服务 跟页面拦截差不多，就是在调用服务之前预先处理一下。 比如 想调用支付模块的服务，就可以先判断你是否已经登录，不登录就禁止调用 @Route(path = RouteUtils.MyPretreatmentService) public class MyPretreatmentService implements PretreatmentService { @Override public boolean onPretreatment(Context context, Postcard postcard) { String path = postcard.getPath() ; if(path.equals(RouteUtils.EnglishListActivity)){ boolean isLogined = xx ; if (!isLogined){ Toast.makeText(mcontext , \"请先登录\", Toast.LENGTH_SHORT).show() ; return false ; } } return true; } private Context mcontext ; @Override public void init(Context context) { this.mcontext = context ; } } ARouter 页面拦截 比较经典的应用就是在跳转过程中处理登陆事件，这样就不需要在目标页重复做登陆检查 。 拦截器会在跳转之间执行，多个拦截器会按优先级顺序依次执行。 @Interceptor( priority = 8 , name = \"登录检验拦截器\") public class LoginInterceptor implements IInterceptor { @Override public void process(Postcard postcard, InterceptorCallback callback) { boolean isLogined = false; callback.onContinue(postcard); if (isLogined) { callback.onContinue(postcard); //不拦截 } else { String path = postcard.getPath(); switch (path) { case RouteUtils.EnglishListActivity: callback.onInterrupt( new RuntimeException(\"还未登录\")); //需要登陆拦截 break; default: callback.onContinue(postcard); //不拦截 break; } } } @Override public void init(Context context) { // 会在sdk初始化的时候调用该方法 } } ARouter.getInstance().build(RouteUtils.EnglishListActivity).navigation( context , new NavigationCallback.... // 如果被拦截器拦截了，NavigationCallback 的函数 onInterrupt() 会被调用... ARouter 降级策略 一个奇怪的术语。感觉术语名字和功能不是很匹配。 因为 arouter 框架activity 跳转是需要配置路由表的， 所以可能因为粗心导致路由表配置错误的现象， 为了解决这个问题，所以搞了一个 所谓降级策略来补救， 给用户一个好一点的体验，而不至于点击后没有任何反应。 // 全局监测 @Route(path = RouteUtils.MyDegradeService) public class MyDegradeService implements DegradeService { @Override public void onLost(Context context, Postcard postcard) { WkLog.showLog(\"检测到无效跳转: \" + postcard.getPath()); } @Override public void init(Context context) { } } // 2、独立跳转 ARouter.getInstance().build(RouteUtils.EnglishListActivity).navigation( context , new NavigationCallback.... 如果路由路径错误，NavigationCallback 的 onLost() 会被回调 ARouter 重写跳转URL 、重定向 就是将传经来的 路由地址 按照你的规则修改一下，再去执行， 目前我不知道有哪些应用场景，先不用。 PathReplaceService ( no Copyright，enjoy youself ! ) all right reserved，powered by GitbookThe file was updated at : 2021-05-13 14:34:52 "},"chinese/android基础/sdk开发.html":{"url":"chinese/android基础/sdk开发.html","title":"sdk开发","keywords":"","body":"SDK开发 将一些业务逻辑独立出来，打包成jar、so、aar，暴露一些APIs给外部调用，也可以称为SDK。 SDK 不同于普通应用,不能频繁的进行更新,以免让开发者觉得 SDK 不稳定或者让开发者频繁的集成 。 为了安全起见,数据加密类、模块算法类都都应该采用NDK开发 。 sdk加密方案 方案名字 缺点 优点 代码混淆 1、有些类不能混淆（例如工具类，自定义控件等，如果被混淆了用户就不方便调用），所以对代码架构要求比较高。2、混淆后的代码虽然不易识别了，但是仔细分析还是能看懂的。 修改class的字段 某些字段对运行没有影响，但是能导致别人无法反编译。 自定义类加载器ClassLoader ClassLoader容易被攻破 jvmti 不适用于Android平台？（我暂时还未测试成功） SDK 版本号命名及修改原则 SDK版本号命名和我们以往的命名规则并无太大不同,通由4部分组成,格式为: V主版本号_子版本号_阶段版本号_日期版本号_希腊字母版本号 比如：V1_1_2_161209_beta. 希腊字母版本号说明 1、Alpha版:内部测试版。此版本表示该软件在该阶段主要是以实现功能为主,Bug相对较多,需要继续修改,通常只在内部流通流通而不对外开放。 2、Beta版:外部测试版。该版本相对Alpha已经有了很大的改进,不存在严重的Bug,但还是存在一些缺陷,需要进一步的测试以检查和消除Bug。 3、RC版: 该版本已经相当成熟,不存在导致错误的Bug，与正式版相差无几。 4、Release版:该版本意味着”最终版本”,是最终交付用户或者公开发布的版本,也称为标准版。在发布的时候回以符合R来代替Release单词。 版本号修改规则 1、 主版本号变化:当功能模块有较大的变化或者整体架构发生变化 2、子版本号变化:当功能有一定变化 3、阶段版本号变化:一般是Bug修复或者较小的变动,根据反馈,需要经常发布修订版本. 4、日期版本号(161209):用于记录修改项目的当前日期,每天对项目的修改都要更改日期版本号. 5、希腊字母版本号:此版本号用于标注当前软件处于那个开发阶段,当软件进入到另一个阶段是需要修改. API版本管理 原则上SDK API一旦公开发布后其状态应为不可变。 1、对于特殊情况下API的变更,需要遵守”开闭原则” 2、在需要废除某些方法时,需要在正式版发版前使用 @deprecated 标识。并给出替代方案和开始废弃的 SDK版本号。 经验之谈 原文 http://blog.csdn.net/dd864140130 有删减。 //SDK实现目标 1、简洁易用 SDK不应该对宿主应用有过多的代码侵入,也不应该有复杂频繁的接入工作。 当我们需要使用该 SD K的服务时,通过一行代码便可启用 Ad.init(this,params) 2、稳定 ① SDK的API一旦确定,如无非常严重情况不可更改。 ②、必须确保SDK自身运行的稳定,并且保证接入方不会因为我们的SDK产生不稳定。 ③、不能频繁更新迭代。防止增加用户负担。 //SDK整体架构设计 模块化开发 根据单一职责将系统拆分为不同的小模块，每个模块保持相对独立。 模块之间通过协议或接口通信，以减少相互之间的依赖耦合。 为了安全起见, 核心逻辑应该采用NDK开发。 //API版本管理 原则上SDK API一旦公开发布后，应为不可变。 对于特殊情况下API的变更,需要遵守”开闭原则”: 1、在需要调整SDK API时,优先选择添加新方法,而不是在原方法上修改 。 2、在需要废除某些方法时,需要在正式版发版前使用 @deprecated 标识,并标明开始废弃的版本。 sdk开发-Module支持c++ 1、按照正常流程创建一个支持c++的项目。 此时 CMakeLists.txt 文件在 app 这个项目里面。 2、新建一个module ，并添加到app中。 3、将 CMakeLists.txt 剪切到 module对应的 目录下。 4、 同理 ，以下代码也剪切到 module对应的文件中去。 externalNativeBuild { cmake { path \"CMakeLists.txt\" } } externalNativeBuild { cmake { cppFlags \"-std=c++11 -frtti -fexceptions\" } } 5、刷新工程即可。 ( no Copyright，enjoy youself ! ) all right reserved，powered by GitbookThe file was updated at : 2020-09-24 11:36:25 "},"chinese/android基础/APP优化.html":{"url":"chinese/android基础/APP优化.html","title":"APP优化","keywords":"","body":"App 优化 , APM 应用的性能优化，需要建立一套成体系的性能优化方案， 这套方案被业界称为 APM (Application Performance Manange)。 绘制优化 （完成） 在 Android 的每个 View 都会经过 Measure 和 Layout 来确定当前需要绘制的View所在的大小和位置， 然后通过 Draw 绘制到 surface 上。 在 Android 系统中整体的绘制源码是在 ViewRootImpl.performTraversals()方法， 通过这个方法可以看出 Measure 和 Layout 都是递归来获取View的大小和位置， 并且以深度作为优先级。 显然，层级越深，元素越多，耗时就越长。 所以，绘制优化最终的问题会转化为 布局优化 和卡顿优化。 绘制类型 Android 支持两种绘制方式 ，即 软件绘制（CPU）、硬件绘制（GPU） 硬件加速从 Android 3.0 开始支持，它在UI显示和绘制效率方面远高于软件绘制。 但它的局限如下： 耗电：GPU功耗高于CPU。 兼容性：不兼容某些接口和函数。 内存大：使用 OpenGL 的接口需要占用较大内存。 布局优化 (完成) 布局优化的核心问题就是要解决因布局渲染性能不佳而导致的应用卡顿问题。 卡顿优化可以看做是卡顿优化的子集。 卡顿分析工具 Systrace ，查看耗时/掉帧 Systrace 是 Android4.1 中 新增的性能数据采样和分析工具。 它可帮助开发者收集 Android 关键子系统（如 SurfaceFlinger/ Kernel/Input/Display 等 Framework 部分关键模块、服务，View系统等）的运行信息， 从而帮助开发者更直观的分析系统瓶颈，改进性能。 Systrace 的原理是在系统的一些关键链路插入一些信息(称之为Label) ( 系统的渲染的关键步骤都有framework预置的label )， 通过Label的开始和结束来确定某个核心过程的执行时间， 然后把这些Label信息收集起来得到系统关键路径的运行时间信息， 进而得到整个系统的运行性能信息。 系统版本越高，Android Framework中添加的系统可用Label就越多， 能够支持和分析的系统模块也就越多； 因此，在可能的情况下，尽可能使用高版本的Android系统来进行分析； 然后对待分析的App也有一个限制——需要是debuggable的。 // 打开 Systrace 由于Androidstudio 不方便找到或者找不到 Systrace的入口， 所以建议 去 F:\\sdk2\\tools\\monitor.bat 双击打开 在启动trace前指定采集哪些系统预置的标签。 Graphics: Graphic系统的相关信息，包括SerfaceFlinger， VSYNC消息，Texture，RenderThread等；用来分析卡顿。 View System: View绘制系统的相关信息，比如onMeasure，onLayout等；用来分析卡顿。 Activity Manager: ActivityManager调用的相关信息；用来分析Activity的启动过程。 Dalvik VM: 虚拟机相关信息，比如GC停顿等。 CPU Scheduling: CPU调度的信息；你能看到CPU在每个时间段在运行什么线程；线程调度情况，比如锁信息。 在 Chrome浏览器 地址栏输入 chrome://tracing ， (没启动这个服务，trace.html 打开有时是空白的) 然后将生成的trace.html文件拖进来，或者通过load按钮导入。 常用快捷键说明： W: 放大横轴，用于查看耗时方法细节； S: 缩小横轴，用于查看整体情况； A： 将面板左移； （左右的方向键也可以移动） D: 将面板右移； M: 高亮某一段耗时内容。 找到自己APP包名的进程 右侧有一行写有F的圈圈，表示每个Frame的综合评价。 如果是绿色，表示这一帧的渲染是ok的。如果是红色或者黄色，表示渲染超时了。 点击这个F圆圈，在下部的窗口中会展示一些详细信息。 如果这一帧的渲染没有任何问题，下面的内容是空的； 如果这一帧有问题，会展示Alert信息。 但是要注意的是 Systrace 只是能看到出错的类型和修改思路， 并不能像在Androidstudio里面如果报错可以精确到具体的代码行。 布局优化 常规方案 减少层级 由于Android的碎片化程度很高，所以使用 RelativeLayout 能使构建的布局适应性更强。 约束布局 ConstraintLayout 比 RelativeLayout 相比，能消除一些冗余布局。 布局复用 ``` ### 避免过度绘制 ```text 导致过度绘制的主要原因是： XML布局：控件有重叠且都有设置背景。 View自绘：View.OnDraw里面同一个区域被绘制多次。 过度绘制检测工具 打开手机开发者选项中的Show GPU Overdraw选项， 会有不同的颜色来表示过度绘制次数， 依次是无、蓝、绿、淡红、深红，分别对应0-4次过度绘制。 合理的刷新机制 1、减少刷新次数 控制刷新频率、避免没有必要的刷新。 2、缩小刷新区域 如自定义View一般采用 invalidate 方法刷新，可以用以下重载方法刷新要刷新的区域： invalidate(Rect dirty); invalidate(int left, int top, int right, int bottom); 3、避免后台线程的影响 如通过监听 ListView的onScrollStateChanged事件， 在滚动时暂停图片下载线程工作，结束后再开始，可以提高ListView的滚动平滑度。 布局优化 第三方框架方案 可以采用一些第三方的UI库，例如 1、facebook 的异步布局框架 Litho 2、掌阅的 X2C •读取xml很耗时 •递归解析xml较耗时 •反射生成对象的耗时是new的3倍以上 X2C方案 在编译生成APK期间，将需要翻译的layout翻译生成对应的java文件， 这样对于开发人员来说写布局还是写原来的xml， 但对于程序来说，运行时加载的是对应的java文件。 布局优化 用到了哪些工具 1、线下工具 LayoutInspector 、 Systrace 2、利用 系统 api Choreographer 的 FrameCallback 回调接口 监控 fps ，然后上传到自己服务器。 fpsviewer 就是基于 Choreographer 开发的。 此外我们还可以用第三方的监控服务 ，例如 微信的 matrix 。 布局为什么可能会卡顿，你又是如何优化的？ 以下四点可能会导致布局卡顿： 1、系统会将我们的Xml文件通过IO的方式映射的方式加载到我们的内存当中，而IO的过程可能会导致卡顿。 针对布局加载Xml文件的优化，我们使用了异步Inflate的方式，即 AsyncLayoutInflater。 它的核心原理是在子线程中对我们的Layout进行加载，而加载完成之后会将View通过Handler发送到主线程来使用。 所以不会阻塞我们的主线程，加载的时间全部是在异步线程中进行消耗的。 2、布局加载的过程是一个反射的过程，而反射的过程也会可能会导致卡顿。 我们发现了一个从根源解决上述痛点的方式，即使用X2C框架。 它的一个核心原理就是在开发过程我们还是使用的XML进行编写布局， 但是在编译的时候它会使用APT的方式将XML布局转换为Java的方式进行布局， 通过这样的方式去写布局，它有以下优点： ①、它省去了使用IO的方式去加载XML布局的耗时过程。 ②、它是采用Java代码直接new的方式去创建控件对象，所以它也没有反射带来的性能损耗。 这样就从根本上解决了布局加载过程中带来的问题。 3、这个布局的层级如果比较深，那么进行布局遍历的过程就会比较耗时。 我们可以使用 ConstraintLayout 去减少我们界面布局的嵌套层级，如果原始布局层级越深， 它能减少的层级就越多。而使用它也能避免嵌套RelativeLayout布局导致的重绘次数过多。 4、最后，不合理的嵌套RelativeLayout布局也会导致重绘的次数过多。 我们可以使用 AspectJ 框架（即AOP）和 LayoutInflaterCompat.setFactory2 的方式分别去建立线下全局的布局加载速度和控件加载速度的监控体系。 发现不合理的嵌套从而进行优化。 做完布局优化有哪些成果产出？ 1、首先，我们建立了一个体系化的监控手段， 针对线下，我们使用AOP或者ARTHook，可以很方便地获取到每一个布局的加载耗时以及每一个控件的加载耗时。 针对线上，我们通过 Choreographer.getInstance().postFrameCallback的方式收集到了FPS， 这样我们可以知道用户在哪些界面出现了丢帧的情况。 2、在每一个版本上线之前，我们都会对我们的核心路径进行一次Review， 确保我们的FPS、布局加载时间、布局层级等达到一个合理的状态。 卡顿优化 （完成） 卡顿的按场景可以分成：UI绘制、应用启动、页面跳转、事件响应。 造成卡顿的根本原因可以分为两大类： 1、界面绘制 页面复杂 、绘制层级深 、刷新不合理 2、数据处理 数据处理在UI线程 、 占用CPU高，导致主线程拿不到时间片 内存增加导致GC频繁，从而引起卡顿 UI流畅度优化 、界面卡顿 排查及优化 Skipped 60 frames! The application may be doing too much work on its main thread. 在大部分Android平台的设备上，Android系统是 16ms (1000 /60 = 16.67 ) 刷新一次，也就是一秒钟60帧。 要达到这种刷新速度就要求在ui线程中处理的任务时间必须要小于16ms，如果ui线程中处理时间长， 就会导致跳过帧的渲染，也就是导致界面看起来不流畅，卡顿。 卡顿引起的具体原因 1、cpu 占用过高，容易卡顿 。一般是 后台线程处理的东西太繁忙。 注意逻辑的优化，线程不要空跑。 2、主线程 绘制时间过长。 UI的层级别太大 ，不要冗余嵌套 卡顿检测 Choreographer 使用 Androidstudio 自带的 工具，和一些第三方的监控工具 例如 BlockCanary 就差不多了。 // FPS ( Frames Per Second ) 即 Frame Rate，单位 fps，是指 gpu 生成帧的速率 ，Android中更帧率相关的类是 SurfaceFlinger 。 SurfaceFlinger (SurfaceFlinger.h) 是Android的一个 native进程 ， 接受多个来源的图形显示数据，将他们合成，然后发送到显示设备。 // VSync (Synchronization ) ,垂直同步 信号。 Android系统每隔16ms发出 VSync 信号，触发对UI进行渲染， Android 4.1 开始引入 VSync 机制，用来同步渲染， 让 UI 和 SurfaceFlinger 可以按硬件产生的 VSync 节奏进行工作。 WkHeartBeatTool wkHeartBeatTool = new WkHeartBeatTool(); wkHeartBeatTool.startTheBeatAction(new HeartBeatTask() { @Override public void run() { // 一秒钟统计一次 ，如果小于 60 ，就说明掉帧了 WkLogTool.showLog(\"fps====\"+count); count= 0 ; } } ,1000); // Choreographer 编舞者 ，统计一秒内 count 的数量 ， Choreographer.getInstance() .postFrameCallback( new Choreographer.FrameCallback() { // frameTimeNanos: The time in nanoseconds when the frame started being rendered, @Override public void doFrame(long frameTimeNanos) { count++ ; Choreographer.getInstance().postFrameCallback(this); } }); 排查 线上App ,用户反馈卡顿的问题 1、记录用户的使用机型和使用场景。例如操作流程、网络环境 2、加入卡顿检测机制，有第三方的 SDK 也可以自己写 ， 将卡顿时的堆栈信息记录并回传，定位分析。 启动优化 （完成） 启动速度是用户对我们App的第一体验，如果启动速度过慢，用户第一印象就会很差。 启动卡顿常见现象 1、点击图标很久都不响应 这是因为预览窗口被禁用或设置为透明。 2、首页显示太慢 因为初始化任务太多。 3、首页显示后无法进行操作 太多延迟初始化任务占用主线程CPU时间片。 查看 APP 启动耗时 1、在Android Studio Logcat中过滤关键字“ Displayed ” (线下使用，时间精确) 会打印出对应的 activity 启动耗时时间 。 2、用 adb 查看 (时间不是特别精确) // adb shell am start -W 包名/Activity全路径 adb shell am start -W com.aivin.myapp/com.test.activity.MainActivity 会打印出以下三个参数 ThisTime: 1138 // 最后一个Activity启动耗时 TotalTime: 1138 // 所有耗时，包括创建进程 + Application初始化 + Activity初始化到界面显示的过程。 WaitTime: 1153 // AMS 启动Activity的总耗时, 即系统启动应用耗时。 3、 代码打点/函数插桩 （可控部分插入时间统计代码） 这里严格说来并不是APP的启动耗时，而是只能统计到核心部分的耗时操作。 3、AOP 切面编程 打点 AOP(Aspect Oriented Programming) ， Android 端有 第三方工具 AspectJX 。 在android中配置aspectj比较麻烦， 可以直接参考这个 https://github.com/HujiangTechnology/gradle_plugin_android_aspectjx 启动速度分析工具 — TraceView 1、使用方法1 代码中添加：Debug.startMethodTracing()、检测方法、Debug.stopMethodTracing()。 运行过一段时间后，将生成的 .trace 导出到电脑， 然后用 Android Studio的 Profiler 进行加载后进行分析。 load from file... 2、或者直接将手机连接上电脑，直接调试，用 Android Studio的 Profiler 进行实时查看。 打开 Profiler -> CPU -> 点击 Record -> 点击 Stop -> 查看Profiler下方Top Down/Bottom Up 区域，以找出耗时的热点方法。 冷启动 冷启动就是从0开始启动 App 。 从点击应用图标到UI界面完全显示且用户可操作的全部过程。 用户进行了一个点击操作，这个点击事件它会触发一个 IPC 的操作， 之后便会执行到 Process 的 start 方法中，这个方法是用于进程创建的， 接着便会执行到 ActivityThread 的 main 方法，这个方法可以看做是我们单个App进程的入口， 相当于Java进程的main方法，在其中会执行消息循环的创建与主线程 Handler 的创建， 创建完成之后，就会执行到 bindApplication 方法，在这里使用了反射去创建 Application 以及调用了 Application相关的生命周期，Application结束之后， 便会执行Activity的生命周期，在Activity生命周期结束之后， 最后，就会执行到 ViewRootImpl，这时才会进行真正的一个页面的绘制。 // 冷启动涉及的相关任务 -> 启动App -> 加载空白Window -> 创建进程 -> 创建Application -> 启动主线程 -> 创建 MainActivity -> 加载布局 -> 布置屏幕 -> 首帧绘制 通常到了界面首帧绘制完成后，我们就可以认为启动已经结束了。 冷启动优化 优化方向主要就是 Application 和 Activity 的生命周期 这个阶段。 1、Application中对 第三方的SDK进行异步或延时初始化 。 2、做一个闪屏界面。在展示的这段时间里，去加载下一页需要的资源。 热启动优化 直接从后台切换到前台。 // 热启动优化 在app 退出时 不要finish ，而是 moveTaskToBack ，即模拟 HOME按键的事件 。 温启动优化 当启动应用时，后台已有该应用的进程， 在已有进程的情况下，会从已有的进程中来启动应用 。 只会重走 Activity 的生命周期，而不会重走进程的创建， 也不走 Application 的创建与生命周期等。 启动优化 方案总结 闪屏页优化 消除启动时的白屏/黑屏，市面上大部分App都采用了这种方法，非常简单， 但是这只是一个障眼法，并不会缩短实际冷启动时间。 懒加载第三方库 对项目中用到的库进行按需初始化，特别是针对于一些应用启动时不需要初始化的库， 可以等到用时才进行加载，减少启动时间。 延迟初始化 利用 IdleHandler特性 (闲时机制) ，在CPU空闲时执行，对延迟任务进行初始化。 异步初始化 核心思想是子线程分担主线程任务，并行减少时间。 如果有依赖关系，可以使用 CountDownLatch 来控制等待最后完成。 对 Multidex 进行预加载优化 ( 减少 ANR ，并不是减少启动速度) 之所以写在这里，是为了兼顾一下其他博客的节奏。 dex的install过程比较复杂，容易引起ANR的发生。 注意：很多博客说 对 Multidex 进行优化是可以减少启动时间，其实是减少 ANR 的。 方法思路一般有两种，1是开子线程去加载，2 是开子进程去加载 https://github.com/hnyer/MultiDexTest 类预加载优化、Activity 预加载 省略加载类的时间，做到极致。但是大部分APP业务都做不完，没这个必要做这些。 WebView 启动优化 因为 WebView 第一次创建比较耗时，所以可以预先创建WebView，提前将其初始化。 而且要使用WebView缓存池，用到WebView的地方都从缓存池取，缓存池中没有缓存再创建。 本地预置 html 和 css ，WebView创建的时候先预加载本地html，之后通过js脚本填充内容部分。 减少 html 和css 从网络下载的等待时间。 页面数据预加载 在主页空闲时，将其它页面的数据先准备好， 等到打开该页面时，就直接从内存或数据库取数据并显示。 尤其是针对那些需要从网络读取的内容。 例如pc端的浏览器，有的会有一个预加载功能。 主页的绘制优化 针对布局和绘制进行优化，减少加载和渲染时间。 启动阶段抑制GC （普通APP 难搞、成本高，难度大） 启动时 GC 抑制，允许堆一直增长，直到开发人员主动停止 GC 抑制或者 OOM 停止 GC 抑制， 这是一种\"空间换时间\"策略，用更多的内存消耗来换取启动时间的缩短， 这种策略可行有两个前提： 一是设备厂商没有加密内存中的 Dalvik 库文件， 二是设备厂商没有改动 Google 的 Dalvik 源码（或者少量的改动）， 理论上通过白名单的方式可以覆盖所有设备，但是实现和维护成本都非常高。 CPU锁频（普通APP 难搞，没权限） 一个设备的CPU通常都是4核或者8核， 但是应用在一般情况下对CPU的利用率并不高，可能只有30%或者50%， 如果我们在启动速度暴力拉伸CPU频率，以此提高CPU的利用率， 那么，应用的启动速度会提升不少。 在Android系统中，CPU相关的信息存储在/sys/devices/system/cpu目录的文件中， 通过对该目录下的特定文件进行写值， 实现对CPU频率等状态信息的更改。 IO优化 1、启动过程不建议出现网络IO。 2、只读取启动中用到的数据。 数据重排 Dex 文件用到的类和APK里面各种资源文件都比较小， 读取频繁，且磁盘地址分布范围比较广。 我们可以利用Linux文件IO流程中的page cache机制 将它们按照读取顺序重新排列在一起，以减少真实的磁盘IO次数。 1、使用 Facebook 的 ReDex 的Interdex调整类在Dex中的排列顺序。 2、资源文件重排 （普通APP用不上） 最佳方案是修改内核源码，实现统计、度量、自动化，其次也可以使用Hook框架进行统计得出资源加载顺序列表。 1 1 1 IO 优化 （完成） 使用事务进行批量数据操作： 数据库操作的本质是对磁盘文件的操作， 频繁操作文件是一个耗时操作，影响数据库的存取速度。 使用事务会降低数据库文件的开关频率，从而节约操作时间。 IO 相关的概念 虚拟文件系统（VFS） ： 屏蔽具体的文件系统，为应用程序的操作提供统一的接口; 页缓存（Page Cache）: 文件系统对数据的缓存，目的是提升内存命中率; Buffer Cache : 磁盘对数据的缓存，目的是合并部分文件系统的 I/O 请求、降低磁盘 I/O 的次数, 后来它也合并到 Page Cache 中的 Buffer Page 了; I/O 有时候为什么会突然很慢？ 1、内存不足。 内存不足的时候，系统会回收 Page Cache 和 Buffer Cache 的内存， 大部分的写操作会直接落盘，导致性能低下； 2、写入放大。 写入放大（ Write amplification，简称WA ）是闪存和固态硬盘（SSD）中一种不良的现象， 即实际写入的物理数据量是写入数据量的多倍。 [1] 闪存重复写入需要先进行擦除，擦除操作的基本单元是 block 块， 一个 page 页的写入操作将会引起整个块数据的迁移，这就是典型的写入放大现象， 低端机或者使用比较久的设备，由于磁盘碎片多、剩余空间少，非常容易出现写入放大的现象。 3、配置不够。 低端机的 CPU 和闪存的性能相对也较差，在高负载的情况下容易出现瓶颈。 I/O 性能评估指标 // 磁盘吞吐量 每秒磁盘I/O的流量，即磁盘写入加上读出的数据的大小。 //存储 IOPS ( Input/Output Operations Per Second ) 磁盘IOPS是指一秒内磁盘进行多少次I/O读写； io 类型 标准IO 、 MMAP 、直接IO ; BIO 、 NIO // BIO ( Blocking I/O ) 一个线程里只能处理一个socket，就算accept了多个也没用， 前一个socket被阻塞了，后面的是无法被执行到的。 // NIO ( Non-blocking I/O): NIO是一种同步非阻塞的I/O模型，在Java 1.4 中引入了NIO框架，对应 java.nio 包。 使用非阻塞IO的话，一到两个线程基本上就够了，因为线程不会产生阻塞， 好比一下接收A请求的数据，另一下接收B请求的数据，等等， 就是不停地东奔西跑，直接到把数据接收完了。 IO 监控工具 腾讯开源工具 Matrix ， https://github.com/Tencent/matrix#matrix_cn IO Canary 性能、泄漏全面监控，对 IO 质量心中有数 IO优化措施 对大文件使用 mmap 或者 nio 方式。 ... 安装包不压缩。 对启动过程需要的文件，我们可以指定在安装包中不压缩， 这样也会加快启动速度，但带来的影响是安装包体积增大。 Buffer 复用 我们可以利用 Okio 开源库， 它内部的 ByteString 和 Buffer 通过重用等技巧， 很大程度上减少 CPU 和内存的消耗。 存储结构和算法的优化 通过算法或者数据结构的优化，让我们可以尽量的少 I/O 甚至完全没有 I/O, 比如一些配置文件从启动完全解析，改成读取时才解析对应的项； 替换掉 XML、JSON 这些格式比较冗余、性能比较较差的数据结构; 存储优化 （完成） 需要优化存储的原因 1、储存耗时较长 2、线程不安全 3、有潜在的 ANR 4、不支持跨进程。 常用的存储方案 SharedPreferences 用来存储一些比较小的键值对集合 。简单，轻量。 多线程安全，但是跨进程不安全 ContentProvider 四大组件之一，提供不同进程甚至不同应用程序之间共享数据的机制； DataStore DataStore 是 Jetpack 中的一员。 MMKV 腾讯开源的第三方工具。口碑还不错。 SQLite 数据库存储 文件存储 存储优化的方向 稳健正确性优化 是否能无错误地进行读取和恢复。 是否完善支持多线程和多进程的场景。 存储时间开销优化 包括CPU时间和IO时间。 如编解码或加解密过于复杂，会影响CPU时间； 存储空间开销优化 相同数据使用不同编码方式，占用的存储空间也会不同；（如 XML > JSON > Protocol Buffer） 还可引入压缩策略进一步减小存储空间.如 zip 、 lzma 还需考虑内存空间占用量，是否会导致大量GC，OOM等 存储数据安全优化 一些敏感数据需加密，防止别人查看。 根据敏感度，数据量大小的不同，选择不同的加密方式。 存储兼容性优化 需要考虑 向前向后兼容，老数据在升级时是否能迁移过来，新数据在老版本能否降级使用 。 存储的数据是否方便迁移到其他平台。 开发时间成本优化 有些存储方案虽高大上，但业务落地成本高，尽量做到无缝接入，缩减开发成本 。 网络优化 （完成） 网络优化的意义 等待网络是我们 App 最大的性能瓶颈， 再怎么优化绘制、内存、卡顿或其它方面，也抵不上网络优化, 而网络优化最核心的处理方式就是 消除和减少不必要的网络延迟，把传输的字节数降到最少。 网络性能指标 速率 // 速率 即 bps bit/s 为什么电信拉的 100M 光纤，测试峰值速度只有 12M 每秒？ 网络常用单位是 Mbps ，因此这里的 100M 指的是 100 Mbps。 100 M/S = 100 Mbps = 100 Mbit/s 100 Mbit/s = （100/8）MB/s = 12.5 MB/s 时延 // 发送时延 发送时延 = 数据长度（bit）/ 发送速率（bit/s） // 传输时延 传播时延 = 传输路径距离 / 传播速率（bit/s） // 排队时延 数据包在网络设备中等待被处理的时间， 例如路由器需要一个一个处理完前面的数据包才能处理后面的。 // 处理时延 数据包到达设备或者目的机器被处理所需的时间。 总时延 = 发送时延 + 排队时延 + 传播时延 + 处理时延 往返时间 RTT （Route-Trip Time） 评估网络质量的一项重要指标。 表示数据报文在端到端通信中来回一次的时间。 通常使用 ping 命令查看 RTT 带宽 逻辑或物理通通信路径的最大吞吐量。 网络监听优化常用工具 Network Profiler 使用 Androidstudio 自带的 监控工具 Profiler，其中有 网络监控模块。 第三方抓包工具 charles ( 小茶壶 ) https://www.charlesproxy.com/download/ 第三方抓包工具 Wireshark https://www.wireshark.org Linux 命令工具 TcpDump yum install -y tcpdump Facebook 的工具 Stetho http://facebook.github.io/stetho/ Stetho 是Facebook推出的一款 使用 Chrome 来调试Android Application的工具。 最主要的用途：查看数据库、查看网络 NetworkStatsManager ( Android api ) Android 6.0（API23）中新增加 NetworkStatsManager， 提供网络使用历史统计信息， 可查询指定时间间隔内的统计信息。 TrafficStats ( Android api ) android2.2 加入了 TrafficStats类， 可以轻松获取流量信息， TrafficStats 类也是读取 Linux 提供的文件对象系统类型的文本进行解析。 // 从开机开始Mobile网络接收的字节总数，不包括Wifi getMobileRxBytes() // 从开机开始所有网络接收的字节总数，包括Wifi getTotalRxBytes() // 从开机开始Mobile网络发送的字节总数，不包括Wifi getMobileTxBytes() // 从开机开始所有网络发送的字节总数，包括Wifi getTotalTxBytes() 网络优化纬度 针对 硬件 软件成本 优化 带宽、服务器数量、CDN、耗电 针对 流量消耗监控 并针对优化 精确获取网络流量的消耗量，解决整体均值掩盖单点异常流量的问题。 1、精准获取一段时间的流量消耗、网络类型、前后台。 2、用户流量消耗均值、异常率（消耗多、次数多）。 3、完整链路全监控、主动上报。 针对 网络请求质量、成功率优化 1、请求时长、业务成功率、失败率、TOP 失败接口， 导致请求失败的原因通常有两种情况： ①、弱信号： 可以简单看成手机信号只有一两格的时候， 这时不仅仅是信令发出去困难，还可能导致不断切换网络、基站。 App 只能在应用层做重试，因为弱信号一般都是一时的。 ②、拥塞网络 可以类比为堵车、排队的场景，数据包排队，信令也在排队。 这时 App 不断重试，只会使得拥塞网络更为严重。 我们只能让自己的非核心业务不要去排队，并让核心业务的数据量更少，协议来回更少。 2、在弱网、网络不稳定时，要最大程度上保证网络的连通性。 网络信息安全优化 要确保交互的信息不被第三方劫持、窃听甚至篡改。 网络优化办法 TCP 的瓶颈都是延迟，而非带宽。 1、TCP 三次握手增加了整整一次往返时间; 2、TCP 流量及拥塞控制会影响所有连接的吞吐量; 3、TCP 的吞吐量由当前拥塞窗口大小控制。 搭建或者购买 CND 内容分发服务 CDN ( Content Delivery Network ) 通过在不同的地区部署服务器，把数据放到接近客户端的地方， 可以减少网络往返的延迟，从而显著提升 TCP 性能。 连接重用 (tcp) 三次握手带来的延迟使得每创建一个新 TCP 连接都要付出很大代价。 而这也决定了提高 TCP 应用性能的关键，在于想办法重用连接。 使用 TFO(TCP Fast Open) -(tcp) TFO 致力于减少新建 TCP 连接带来的性能损失。 但却只能在某些情况下有效。 注意 TFO 需要客户端和服务器共同支持。 TCP窗口流量控制​ (tcp) TCP在传输数据时和 windows size 关系密切，本身窗口用来控制流量， 在传输数据时，发送方数据超过接收方就会丢包， 流量控制要求数据传输双方在每次交互时声明各自的接收窗口「rwnd」大小， 用来表示自己最大能保存多少数据，这主要是针对接收方而言的， 通俗点儿说就是让发送方知道接收方能吃几碗饭，如果窗口衰减到零， 也就是发送方不能再发了，那么就说明吃饱了， 必须消化消化，如果硬撑胀漏了，那就是丢包了。 慢启动 (tcp) 虽然流量控制可以避免发送方过载接收方，但是却无法避免过载网络， 这是因为接收窗口「rwnd」只反映了服务器个体的情况，却无法反映网络整体的情况。 为了避免网络过载，慢启动引入了拥塞窗口「cwnd」的概念， 用来表示发送方在得到接收方确认前 最大允许传输的未经确认的数据。 「cwnd」同「rwnd」相比不同的是：它只是发送方的一个内部参数，无需通知给接收方， 其初始值往往比较小，然后随着数据包被接收方确认，窗口成倍扩大， 有点类似于拳击比赛，开始时不了解敌情，往往是次拳试探， 慢慢心里有底了，开始逐渐加大重拳进攻的力度。 在慢启动的过程中，随着「cwnd」的增加，可能会出现网络过载， 其外在表现就是丢包，一旦出现此类问题， 「cwnd」的大小会迅速衰减，以便网络能够缓过来 压缩优化交互的数据 (jons 、byte、图片 文件) 1、消除不必要的数据传输，减少下载不必要的资源， 选择合适的交互格式、选择合适格式的图片等。 2、通过压缩算法把要发送的比特数降到最低， 可以使用 gzip 对post 数据进行压缩。 数据缓存 服务端返回加上过期时间，避免每次重新获取。 节约流量且大幅提高数据访问速度，更好的用户体验。 移动网络采用 “爆发传输数据并转为空闲” 因为移动无线接口专门为爆发性传输做过优化， 所以我们应该要尽可能多、快地下载数据， 然后让无线模块转为空闲。 这样既可以获得最大的网络吞吐量，也能节约电量。 例如如果需要大型音频或视频文件， 优先考虑下载整个文件，而不要以比特为单位地流式下载。 大数量量优先考虑放 WiFi 场景下载 Wi-Fi 连接下的大数据量传输更省电， 而且在通信过程中也不需要 RRC， 相对于 4G 网络，所以速度也会更快。 RRC (Radio Resource Control) ,无线资源控制层 谨慎使用 base64 编码 Base64编码会使数据量变大。 从 base64 编码规则得知，通过Base64编码， 即字节增加了33.3%，数据量相应变大。 https://base64.us 流量统计、流量兜底能力 如果发现流量异常，我们可以通过后台服务器终止协议交互，以避免问题恶化。 内存优化 (完成) 1、别频繁GC 2、控制好对象的引用，防止对象一直无法释放。 需要注意的是，出现OOM是因为内存溢出导致， 但是这种情况不一定会发生在相对应的代码处， 也不一定是出现OOM的代码使用内存有问题，而是刚好执行到这段代码。 内存泄漏就是在当前应用周期内不再使用的对象被 GC Roots 引用， 导致不能回收，使实际可使用内存变小。 内存优化的作用 1、减少OOM，提高应用稳定性。 2、减少卡顿，提高应用流畅度。 3、减少内存占用，提高应用后台运行时的存活率。 常见内存泄漏场景 资源性对象未关闭 对于资源性对象不再使用时，应该立即调用它的close()函数，将其关闭，然后再置为null。 例如Bitmap等资源未关闭会造成内存泄漏，此时我们应该在 Activity 销毁时及时关闭。 注册对象未注销 例如 BraodcastReceiver 、EventBus 未注销造成的内存泄漏， 我们应该在Activity销毁时及时注销。 类的静态变量持有大数据对象 尽量避免使用静态变量存储数据，特别是大数据对象，建议使用数据库存储。 单例造成的内存泄漏 优先使用Application的Context， 如需使用Activity的Context，可以在传入Context时使用弱引用进行封装 。 Handler 内存泄漏 请查看 Handle 详解 这一块。 AsyncTask 内存泄露 AsyncTask 的内存泄漏的原因跟 Handle 原因类似。 由于 持有外部类 activity 的强引用 ， 如果 activity 退出时， AsyncTask 还在执行操作，导致 activity 无法释放。 解决办法有2个： 1、在退出是 手动调用 asyncTask.execute() 2、static + WeakReference private static class MyTask extends AsyncTask { private final WeakReference weakReference; private MyTask(MainActivity activity) { weakReference = new WeakReference<>(activity); } @Override protected Bundle doInBackground(Bundle... bundles) { return bundle; // 耗时操作 } @Override protected void onPostExecute(Bundle bundle) { if (weakReference.get() == null){ return; } weakReference.get().handleResult(bundle); } } 容器中的对象没清理造成的内存泄漏 及时将集合里的东西clear，然后置为null，再退出。 否则会造成集合越来越大，万一静态集合忘记退出和清空了，会造成内存泄漏。 WebView Bug 造成内存泄漏 WebView 因为bug ，都存在内存泄漏的问题。 我们可以为 WebView开启一个独立的进程，使用AIDL与应用的主进程进行通信， WebView所在的进程可以根据业务的需要选择合适的时机进行销毁， 达到正常释放内存的目的。 ListView 使用不当造成内存泄漏 如果不使用缓存 convertView 的话，调用getView时每次都会重新创建View， 这样之前的View可能还没有销毁， 加之不断的新建View势必会造成内存泄露。 Application 低内存回调 // Android 4.0前 检测内存使用情况, 4.0 以后建议使用 onTrimMemory @Override public void onLowMemory() { super.onLowMemory(); } // 4.0 新增的 API ,level 值表示当前内存状态， // 可以根据返回的状态来适当回收资源避免 app 被杀死的风险。 @Override public void onTrimMemory(int level) { switch (level){ // 你的应用在运行且不会被杀掉，但设备可用内存低，系统正在执行杀掉LRU缓存里的进程 case TRIM_MEMORY_RUNNING_MODERATE: // 你的应用在运行且不会被杀掉，但设备可用内存过低，你需要释放不再使用的资源来改善性能 case TRIM_MEMORY_RUNNING_LOW: // 你的应用在运行，但系统已经杀死了其他LRU缓存里的大部分进程，你需要立刻释放所有不重要的资源。 case TRIM_MEMORY_RUNNING_CRITICAL: // 你的进程当前是后台被缓存的，系统运行在低内存，你的应用临近LRU缓存List的开始位置。 case TRIM_MEMORY_BACKGROUND: // 你的进程当前是后台被缓存的，系统运行在低内存，你的应用临近LRU缓存的中间位置，如果系统可用内存变得更糟糕你的应用很可能被杀掉 case TRIM_MEMORY_MODERATE: // 你的进程当前是后台被缓存的，系统运行在低内存，如果系统可用内存无法恢复，你的应用是需要被首先杀死的进程中的一个。 // 等价于onLowMemory() case TRIM_MEMORY_COMPLETE: // 你的应用界面被隐藏并且你应该释放界面相关的资源。 case TRIM_MEMORY_UI_HIDDEN: break; } super.onTrimMemory(level); } 内存优化方案 减少自动装箱和拆箱 ，Autoboxing and unboxing Integer total = 99;//自动装箱 int totalprim = total; //自动拆箱 在自动装箱转化时，都会产生一个新的对象，这样就会产生更多的内存和性能开销。 内存复用 1、资源复用：通用的字符串、颜色定义、简单页面布局的复用。 2、视图复用：可以使用ViewHolder实现ConvertView复用。 3、对象池：显示创建对象池，实现复用逻辑，对相同的类型数据使用同一块内存空间。 4、Bitmap对象的复用： 使用 inBitmap 选项 使用最优的数据类型 1、 ArrayMap 比 HashMap 更省内存。 2、使用 IntDef 和 @IntDef @StringDe 替代枚举类型 枚举最大的优点是类型安全 ，但是很消耗内存。 使用合理的缓存策略 LruCache (Least Recently Used) 它内部维护了一个队列，每当从中取出一个值时，该值就移动到队列的头部。 当缓存已满而继续添加时，会将队列尾部的值移除，方便GC。 LruCache用于内存缓存，在避免程序发生OOM和提高执行效率有着良好表现。 图片内存优化 具体跳转到 “图片加载详解” 一章查看。 列表 item 被回收不可见时释放掉对图片的引用 ListView：因此每次item被回收后再次利用都会重新绑定数据， 只需在ImageView onDetachFromWindow的时候释放掉图片引用即可。 RecyclerView：因为被回收不可见时第一选择是放进mCacheView中， 这里item被复用并不会只需bindViewHolder来重新绑定数据， 只有被回收进mRecyclePool中后拿出来复用才会重新绑定数据， 因此重写Recycler.Adapter中的onViewRecycled()方法 来使item被回收进RecyclePool的时候去释放图片引用。 禁用字符串的拼接 我们可以在字符串拼接的时候使用StringBuffer，StringBuilder。 代替 字符串拼接。 自定义View中的内存优化 在 onDraw 方法等频繁调用的函数里面不要执行对象的创建， 一般来说，都应该在自定义View的构造器中创建对象。 final 优化 (不同意) 我看到有博客说是 用 static final 修饰字段会优化内存。 但是在参考了一些其他资料后，没有发现 final 跟内存优化有关。 使用final方法的原因有2个， 1、锁定，禁止再修改 2、高效。编译器在遇到调用 final 时会转入内嵌机制，提高执行效率。 调用一个函数除了函数本身的执行时间之外，还需要额外的时间去寻找这个函数。 所以减少函数调用次数就等于降低了性能消耗。 编译器直接将 final 函数体内嵌到了调用函数的地方，这样的结果是节省了寻找函数的时间。 Android 查看一个对象的回收情况 使用 Android profiler 来查看一个对象的回收情况 对象内存回收情况 Shallow Size是对象本身占据的内存的大小，不包含其引用的对象。 对于常规对象的 Shallow Size 由其成员变量的数量和类型来定， 而数组的 ShallowSize 由数组类型和数组长度来决定，它为数组元素大小的总和。 Retained size是该对象自己的shallow size，加上从该对象能直接或间接访问到对象的shallow size之和。 换句话说，retained size 是该对象被GC之后所能回收到内存的总和。 包体积优化 (完成) 优化 APK 体积的意义 1、瘦身优化最主要的好处是对应用 下载转化率 的影响， 如果你的 App 与其它同类型的 App 相比 Apk 体积要更小的话， 那么你的 App 下载率就可能要高一些。 包体积越小，用户下载等待的时间会越短，下载转换成功率就越高。 2、有些应用商店对APP的大小有限制， 以谷歌应用商店为例，就有150M 的限制。 With Android App Bundles, the compressed download size restriction is now 150MB 。（2021-3-17 记录，以后可能会改） 3、一些渠道合作商的要求，比如预装应用，限制APP大小或者根据大小收费。 4、apk 过大 对用户的使用体验有影响。 文件的拷贝、解压、初始化 会消耗比较常的时间，让用户等待过久。 同时也占用过大的SD空间，例如王者荣耀占用空间四五个G，是我卸载它的原因。 apk 的组成 1、代码相关 classes.dex 2、资源相关：res、assets ，存放图片和音频等。 优化空间较大，尤其是图片。 3、lib 、So 相关。这一块的优化空间比较大。 APK 体积优化方案 Proguard 代码混淆 (建议) Android 有自带的混淆工具 Proguard 。 将类中的字段、方法、类的名称改成简短无意义的名字。 例如 ActivityMainBinding 被混淆替换成了 一个字母 a . 混淆后，增加代码被反编译的难度，一定程度上保证代码的安全。 并且减少了代码的体积。 同时 Proguard 可以检测并移除未使用到的类、方法、字段以及指令、 冗余代码，并能够对字节码进行深度优化。 R8 代码混淆 https://r8.googlesource.com/r8 R8 是 Proguard 压缩与优化部分的替代品，并且它仍然使用与 Proguard 一样的 keep 规则。 当使用 Android Gradle 插件 3.4.0 或更高版本构建项目时， 不再使用 ProGuard 来执行编译时代码优化，而是与 R8 编译器协同工作来处理编译时任务 。 R8 与 Proguard 比较 ， R8 在 inline 内联容器类中更有效，并且在删除未使用的类，字段和方法上则更具侵略性。 并且 ，R8 进行了 ProGuard 尚未提供的一些 Kotlin 的特定的优化。 release { // 启用代码收缩、混淆和优化。 minifyEnabled true // 启用资源缩减 shrinkResources true // proguard-android-optimize.txt 这是默认的配置文件，包含一些通用的混淆规则，在sdk/tools/proguard目录下 // proguard-rules.pro 供开发者自定义混淆规则 proguardFiles getDefaultProguardFile('proguard-android-optimize.txt'), 'proguard-rules.pro' } # google 推荐的混淆算法 -optimizations !code/simplification/arithmetic,!code/simplification/cast,!field/*,!class/merging/* # 指定执行几次优化，默认情况下，只执行一次优化。 -optimizationpasses 5 # 允许改变作用域的 ，例如将 public 改成 private ，如果是对外的lib，不要配置 -allowaccessmodification # 不做预校验，预校验是作用在Java平台上的，Android平台上不需要这项功能 -dontpreverify # 混淆时不使用大小写混合类名 -dontusemixedcaseclassnames #不忽略库中的非public的类 -dontskipnonpubliclibraryclasses # 输出详细信息 -verbose #使指定的类不输出警告信息 -dontwarn android.support.** # 保留指定的属性，不混淆 -keepattributes *Annotation* # 保持指定包下的类名 不混淆 -keep public class com.google.vending.licensing.ILicensingService -keep public class com.android.vending.licensing.ILicensingService -keep class android.support.annotation.Keep #保持指定包下的类名以及类里面的内容 -keep @android.support.annotation.Keep class * {*;} #保持指定包下的类名，不包括子包下的类名 # 如果拥有某成员，保留类和类成员 ，防止被混淆 -keepclasseswithmembernames class * { native ; } # 类成员 防止被移除或者被混淆 -keepclassmembers class * extends android.app.Activity { public void *(android.view.View); } -keepclassmembers public class * extends android.view.View { void set*(***); *** get*(); } -keepclassmembers enum * { public static **[] values(); public static ** valueOf(java.lang.String); } -keepclassmembers class * implements android.os.Parcelable { public static final android.os.Parcelable$Creator CREATOR; } -keepclassmembers class **.R$* { public static ; } # 如果拥有某成员，保留类和类成员 ，防止被移除或者被混淆 -keepclasseswithmembers class * { @android.support.annotation.Keep ; } -keepclasseswithmembers class * { @android.support.annotation.Keep ; } -keepclasseswithmembers class * { @android.support.annotation.Keep (...); } 使用 D8 编译器 Google 在 Android Studio 3.1 版本中引入 D8 编译器作为默认的 DEX 字节码文件编译器。 通过在 gradle.properties 中新增 android.enableD8=true 开启 D8 编译器。 D8 编译器特点是： 编译更快、时间更短； DEX 编译时占用内容更小； .dex 文件大小更小； D8 编译的 .dex 文件拥有相同或者是更好的运行时性能； redex 去除 debug 信息与行号信息 -keepattributes SourceFile,LineNumberTable , 如果在混淆开启后，开启了这个语句，就会保留 dex 中的 debug 和 行号信息,用于混淆后定位错误位置。 所以我们可以想办法去掉行 dex 中的debug 和行号信息来减小 apk 体积。 有什么方式可以去掉 debugItem，同时又能让 crash 上报的时候能拿到正确的行号呢？ 我们可以尝试直接修改 Dex 文件，保留一小块 debugItem， 让系统查找行号的时候指令集行号和源文件行号保持一致。 具体操作可以使用第三方工具，redex 。 redex ， Dex 分包优化 当 app 的方法数超过65536个，就要采用 mutildex 进行分包， 但是此时每一个 Dex 可能会调用到其它 Dex 中的方法，这种 跨 Dex 调用的方式会造成许多冗余信息。 为了减少跨 Dex 调用的情况，我们必须 尽量将有调用关系的类和方法分配到同一个 Dex 中。 ReDex 的 CrossDexDefMinimizer 类分析了类之间的调用关系， 并使用了贪心算法去计算局部的最优解（编译效果和dex优化效果之间的某一个平衡点）。 使用 \"InterDexPass\" 配置项可以把互相引用的类尽量放在同个 Dex 我们可以使用 facebook 提供的 redex 来进行优化 https://github.com/facebook/redex ReDex 可以分包优化、去除 debug 信息及行号信息。 XZ Utils 进行 Dex 压缩 https://tukaani.org/xz/ 有些大公司(facebook ?)在用 xz utils 对 Dex 进行压缩优化， 不过难度较大。 去掉冗余的第三方库 (建议) 比如有些库会提供 图片加载、网络访问、数据等， 但是你只需要要用到 数据库，你就可以将其他的没用上的库去掉。 可以 只引入部分需要的代码，而不是将整个包的代码都引入进来。 很多库的代码结构都设计的比较好，比如 Fresco，它将图片加载的各个功能，如 webp、gif 功能进行了剥离， 它们都处于单个的库当中。 同时注意同一个APP中尽量不要有相同的库， 比如不要有两个图片加载库。 删除无用代码、无用资源 (建议) 可以借助 lint 工具等 检测出无用的代码和资源，删除减少包体积。 文件相同，文件名不同。可以通过MD5 去识别。 自带的 资源去重 配置 // 防止同名资源 1、从源头控制，配置 resourcePrefix 指定前缀， xml资源会红色提示(但是不影响运行)你要加前缀。 图片资源没有提示，需要有意识地添加。 android { resourcePrefix \"app_\" } 2、图片相同，名字不一样。文件去重 方法。 这里写了一个 Md5文件去重 示例。 https://gitee.com/Aivin_CodeShare/android_tool_code/raw/master/md5%E6%96%87%E4%BB%B6%E5%8E%BB%E9%87%8D/CalcMD5.java 图片压缩、图片格式 (建议) 可以使用 https://tingpng.com/ 压缩图片大小。 图片格式不同，也会导致大小相差较大。 可以根据以下规则进行优先选择。 VectorDrawable（矢量图）-> WebP ->Png（有透明通道） -> jpg（无alpha通道） 删除 Java access 方法 可以参考 西瓜技术团队 的文章 “西瓜视频apk瘦身之 Java access 方法删除” Java语言的封装性要求一个类的私有成员不能被其他类直接访问， 然而内部类和其外部类可以直接访问对方的私有成员，这个现象显然违反了Java封装性的要求， 因此为了能提供内部类和其外部类直接访问对方的私有成员的能力，又不违反封装性要求， Java编译器在编译过程中自动生成package可见性的静态access$xxx方法， 并且在需要访问对方私有成员的地方改为调用对应的access方法 access方法的影响 1、dex文件格式对类、方法、字段的数目有限制，超过65535就得分包。 因此额外生成的access方法数的增加会导致app对multidex依赖的增强。 2、大量的access方法会使得代码体积增加，apk文件也会变大，在西瓜视频中未优化前access方法增加了几百k的包大小； 3、access方法调用会有额外开销（比如要分配栈帧），对性能也有一定的影响。 解决办法： 1、选择使用 ASM在编译时自动删除 access方法 2、ReDex 也提供了 access-marking 这个功能去除代码中的 Access 方法 。 代码编写方面的优化 每一个枚举值都是一个对象, 在使用它时会增加额外的内存消耗 ，同时也会增加 DEX文件的大小 。 所以 android官方文档建议尽量避免使用枚举。 R文件常量内联，R文件瘦身 （减少体积有限，一两M就很厉害了） 我们可以通过内联 R Field 来进一步对代码进行瘦身， 此外它也解决了 R Field 过多导致 MultiDex 65536 的问题。 R.layout.activity_main 实际上对应的是一个 int 型的常量值， 那么如果我们编译打包时，将所有这些对 R 类的引用直接替换成常量值， 替换一个就会减少一个 R文件中的字段，R文件体积就会变小。 例如 setContentView(213196283) 效果也是一样的。 R.java 类里有2种数据类型，一种是 static final int 类型的，这种常量在运行时是不会修改的， 另一种是 static final int[] 类型的，虽然它也是常量，但它是一个数组类型， 并不能直接删除替换，所以打包进 apk 的 R 文件中， 理论上除了 static final int[] 类型的字段，其他都可以全部删除掉。 一个工程如果有多个 模块，会对应多个R文件， 如果工程比较大，R文件也会比较大，甚至会有几个M。 R文件的 Field 过多时 可能会导致 MultiDex 65536 的问题。 可以使用地方的一些工具 快速实现R文件内联瘦身，例如 抖音的 ByteX https://github.com/bytedance/ByteX ProGuard 也会对R文件进行混淆， 但是现在很多应用或者SDK里都有通过反射调用来获取资源， 比如大家最常用的统计SDK友盟统计、友盟分享等， 就要求 R 文件不能混淆掉，否则会报错， 所以我们常用的做法是开启混淆，但 keep 住 R 文件 resConfigs 去除无用语言资源 （建议） 例如使用了 AppCompat，如果不做任何配置的话，最终 APK 包中会包含 AppCompat 中所有已翻译语言字符串， 无论应用的其余部分是否翻译为同一语言。 对此，我们可以 通过 resConfig 来配置使用哪些语言，从而让构建工具移除指定语言之外的所有资源。 defaultConfig { resConfigs \"en\" } 资源在线化 一些图片等资源 可以放服务器，结合预加载技术，可以减少apk打包大小。 统一应用风格，减少 xml 配置文件 和图片 （建议） 如设定统一的 字体、尺寸、颜色和按钮按压效果、分割线 shape、selector 背景等。 剪裁 so 库 （建议） 如果用到第三方的库的某个功能，可以把不需要的部分剪裁掉， 减少 so 的体积，例如 ffmpeg 中 可以通过选择配置，编译出自己想要功能的so 即可。 过滤掉不常用 CPU 平台的 so 。 abiFilters \"armeabi\" ，“xxx” XZ Utils 压缩 so Native Library 同 Dex 一样,也可以使用 XZ Utils 进行压缩， 对于 Native Library 的压缩，我们 只需要去加载启动过程相关的 Library， 而其它的都可以在应用首次启动时进行解压。 So 动态下载 可以参考 腾讯的技术文章 “动态下发 so 库在 Android APK 安装包瘦身方面的应用” https://mp.weixin.qq.com/s/X58fK02imnNkvUMFt23OAg 插件化思路 如果我们 App 当中的每一个功能都是一个插件，并且都是可以从服务器下发下来的，那 App 的包体积肯定会小很多。 电池耗电优化 (完成) 手机耗电是通过使用相应的硬件模块来消耗电能。 CPU、屏幕、WIFI、数据网络、GPS、音视频通话在日常耗电量中占比最大。 Android系统做的 省电优化 1、Android 4.4 新增“硬件传感器批处理”支持 “硬件传感器批处理”(需要硬件支持)可以显著降低传感器持续活动所消耗的电量。 因为我们有时并不需要非常快的数据更新频率，比如GPS定位不需要一秒十几次位置更新。 所以我们通过 API 可以指定系统向应用传输批量传感器事件的频率。 系统会将一段时间内发生的所有事件保存起来，然后一次性将它们传输到应用， 而不是在每个事件发生时将其传输到你的应用。 这样处理只降低了传输的频率并不会减少次数。 2、Android4.4 新增 AlarmManager “对齐唤醒”API支持， 简单的说就是每隔一段时间后台程序唤醒一次，比如你的QQ、微信在后台运行，如果你没有开启智能唤醒， 那么QQ有消息了后台马上唤醒，微信有消息了也马上唤醒，这样就会非常耗电。 对齐唤醒就是每隔一段时间唤醒一次，能省电不少。 3、Android 5.0 ，加入了 Volta 项目 ， 这个项目可以对电池进行更精细的管理，能够大大降低操作系统对于电池电量的持续消耗。 4、Android5.0 进入 任务调度机制 JobScheduler ，省电原理类似于 Android4.4加的 闹钟对齐唤醒。 5、Android6.0 加入 Doze 休眠低功耗模式 。 在 Doze 模式下，系统通过限制app访问网络和其对CPU使用来达到省电的目的， app的网络访问功能会被禁用，同时延时执行作业，异步任务及标准闹钟事件。 为了保证app的工作，系统会周期地退出Doze模式，以保证app完成那些被延时的任务。 6、Android6.0 加入 App Standby（ app待命模式）。 这个概念则是针对于应用的，当App进入AppStandby状态后，也会受到网络等状态的限制。 此处不列出具体触发和退出条件 。 7、Android7.0 删除了三个隐式广播，减少无用功耗。 8、Android8.0 增加 “后台执行限制”。 每次在后台运行时，应用都会消耗一部分有限的设备资源，例如内存和CPU。 后台执行限制包括 后台服务限制和 广播限制。 9、Android8.0 增加 “后台位置限制”。 耗电分析工具 Energy Profiler 设备系统在 Android 8.0 以上的系统 使用 Energy Profiler Androidstudio 中 view -> Tool Windows --> Profiler 其中会分栏显示 CPU 、 MEMORY 、NETWORK 、ENERGY 其中 ENERGY 就是电量的消耗情况。 battery-historian 电量分析工具 android 8.0 以下使用 battery-historian https://github.com/google/battery-historian 在本地搭建 battery-historian 工具有两种方法 第一种是用 dock 方式，第二种是 编译编码方式。 具体步骤参考了 https://blog.csdn.net/cui130/article/details/103934363 但是可能是因为网络的问题 走到 go get -d -u github.com/google/battery-historian/... 无法下载了... go get -d -u github.com/google/battery-historian/... go get github.com/google/battery-historian/...: module github.com/google/battery-historian: Get \"https://proxy.golang.org/github.com/google/battery-historian/@v/list\": dial tcp 172.217.161.145:443: connectex: A connection attempt failed because the connected party did not properly respond after a period of time, or established connection failed because connected host has failed to respond. 以后有空再用编译源码的方式去弄了， 暂时先用一个在线的服务 https://bathist.ef.lc/ // 获取手机电量报告信息 adb shell dumpsys batterystats --enable full-wake-history //允许记录电池日志 adb shell dumpsys batterystats --reset // 清空日志 adb bugreport bugreport.zip // 7.0 和更高版本的开发设备中获得 bug 报告 adb bugreport > bugreport.txt // 6.0或更低版本的设备 将导出的文件上传到 工具里进行分析 https://bathist.ef.lc/ 检查统计 单个App的耗电情况 battery-historian 、Energy Profiler 中均可以根据包名 选择指定的APP进行分析。 省电优化方案 优化后台耗电 避免后台长时间获取 WakeLock、WIFI 和蓝牙的扫描等。 WakeLock 是android系统中一种锁的机制，只要有进程持有这个锁，系统就无法进入休眠状态。 WakeLock 要记得释放。 制定 符合系统的耗电规则 1、Alarm Manager wakeup 不能唤醒过多： 当手机不在充电状态， wakeup 唤醒次数 每小时不能大于 10 次。 2、不能频繁使用局部唤醒锁， 当手机不在充电状态，partial wake lock 持有不能超过1小时。 3、后台网络使用量不能过高 当手机不在充电状态而且应用在后台，每小时网络使用量不要超过 50MB。 4、、后台 WiFi scans 不能过多 当手机不在充电状态而且应用在后台，每小时 WiFi scans 不能 大于4次。 CPU 时间片优化 Android 手机包括 AP 和 BP 两个 CPU。 AP 即 Application Processor，所有的用户界面以及 App 都是运行在 AP 上的。 BP 即 Baseband Processor，手机射频都是运行在这个 CPU 上的。 我们所说的耗电，PowerProfile 文件里面的 CPU，指的是 AP。 CPU 耗电通常有两种情况： 1、长期频繁唤醒。 原本可以仅仅在 BP 上运行， 但是因为唤醒，AP 就会运作 增加耗电量。 2、CPU 长期高负荷。 例如 App 退到后台的时候没有停止动画，或者程序有不退出的死循环等等，导致 CPU 满频、满核地跑。 3、一些计算不够优化 例如浮点运算比整数运算更消耗 CPU 时间片，耗电也会增加。 一些图像算法比较耗时，可以换个更优的算法也可以大大降低cpu使用。 所以常用优化 CPU 时间片的方式有： 1、定位并解决 CPU 占用率异常方法。 2、减少应用在后台的唤醒和运行。 网络耗电优化 通常情况下，使用 WIFI 连接网络时的功耗要低于使用移动网络的功耗。 使用移动网络传输数据，电量的消耗有以下3种状态： Full power ：高功率状态，移动网络连接被激活，允许设备以最大的传输速率进行操作。 Low power ：低功耗状态，对电量的消耗差不多是 Full power 状态下的 50%。 Standby ：空闲态，没有数据连接需要传输，电量消耗最少。 所以为了避免网络连接所带来的电量消耗，我们可以采用如下几种方案： 1、尽量在 WIFI 环境下进行数据传输，在使用 WIFI 传输数据时， 应该尽可能增大每个包的大小（不超过最大传输单元 MTU ），并降低发包的频率。 2、在蜂窝移动网络下需要对请求时机及次数控制， 可以延迟执行的网络请求稍后一起发送，最好做到批量执行，尽量避免频繁的间隔网络请求， 以尽量多地保持在 Standby 状态。 3、使用 JSON 和 Protobuf 进行数据压缩，减少网络使用时间。 4、禁止使用轮询功能：轮询会导致网络请求一直处于被激活的状态，耗电过高。 定位耗电优化 、传感器耗电优化 、蓝牙耗电优化等 1、根据场景谨慎选择定位模式。 对定位准确度没那么高的场景可以选择低精度模式。 2、可以考虑网络定位代替 GPS。 3、使用后务必及时关闭，减少更新频率， 例如定位开启一定时间后超过某个阈值可以执行一个兜底策略：强制关闭 GPS。 界面耗电优化 1、离开界面后停止相关活动，例如关闭动画。 2、耗电操作判断前后台，如果是后台则不执行相关操作。 稳定性 优化 (完成) 崩溃率 、DAU DAU ( Daily Active User )，日活跃用户数量。 崩溃率 是奔溃次数或人数除以 DAU 。 稳定的纬度 稳定的纬度： 1、崩溃角度 非常重要，出现闪退现象会导致用户体验非常差。 容错机制，发生异常尽量不要闪退，而是给出提示。 不要随意使用try catch去隐藏问题：而应该从源头 了解崩溃的本质原因，保证后面的运行流程。 2、性能稳定 启动速度、流畅卡顿程度、内存占用、耗电量、界面绘制速度、网络流量、 保证业务功能可用。ANR 响应超时、 能持续运行多长时间 3、业务可用性纬度。 保证APP主流程 和核心路径的稳定可用性。确保核心业务高可用。因为核心业务覆盖的人群最多。 其他方面只有经常用的人才有可能触发。 保证业务可用的高效可用，性能不能相差起伏太大。 稳定优化的方向 解决方案： 1、预防为主、监控修复为辅 ①、开发阶段 ，采用成熟稳定方案、加强编码能力； 对APP的 cpu、内存、进程线程数、网络流量、耗电量、log记录、启动页耗时 等信息记录和分析 ②测试阶段：加强机型覆盖测试、压力测试、特殊场景测试(例如无网络、故意下发错乱数据等)； 从用户角度入手，尽量模拟真实使用场景、测试验证。不要从开发者角度进行测试。 线下大规模覆盖测试、发现问题 解决问题； ③发布阶段：进行灰度发布、多轮发布 ； 发布前多测试、捕获异常上传并分析 、发新包修复或者热修复。 如果新发布的功能出现BUG，可以通过远程开关进行关闭功能模块，不让该功能显示。 ④ 运维阶段： 版本回退策略、热修复、发布新版本 线上定位问题 定位机型。 发生崩溃异常时，需要远程上报相关信息，包括 报错信息、机型、系统版本、APP版本、渠道等。 稳定监控工具 1、例如Android 自带的 monkey 2、 腾讯的 Bugly 3、阿里的 mobileperf APP单元测试 单元测试 // 黑盒测试 一般而言，都是自己或者测试做做黑盒测试，模仿用户使用场景 使用即可。 我问过很多人，他们基本都是这样测试后就上线了。 // 白盒测试 1、对于一些 要求严谨的大型 app ，例如 微信 支付宝，肯定是要做白盒测试了。 黑盒测试无法完全覆盖，一旦出错，损失无法承受 ，当然，这种级别的测试，都有专门的测试人员。 2、有一些大型的app ,编译时间比较长，或者路径比较深。采用手动点击试验看效果的方法，会比较浪费时间。 为了免去编译安装的等待时间，要引入白盒测试，缩短自测的时间。 // TDD ( Test-Driven Development ) 测试驱动开发 单元测试 JUnit4 方案 Androidstudio 自带。 测试运行在本地开发环境的Java虚拟机上，无需连接Android设备或模拟器。 因此，无法获得Android相关的API，只能测试只使用Java API的一些功能。 @Test 表示此方法为测试方法 @Before 在每个测试方法前执行，可做初始化操作 @After 在每个测试方法后执行，可做释放资源操作 @Ignore 忽略的测试方法 assertEquals 断言传入的预期值与实际值是相等的 assertArrayEquals 断言传入的预期数组与实际数组是相等的 assertNull 断言传入的对象是为空 assertTrue 断言条件为真 assertSame 断言两个对象引用同一个对象，相当于“==” assertThat 断言实际值是否满足指定的条件 @Ignore(\"等会再测\") @Test public void getAppVersion(){ } @Test public void valueAdd() { MyDeviceTool tool = new MyDeviceTool() ; int sum = tool.valueAdd(10 ,5); assertEquals(5 ,sum); } 单元测试 Instrumentation 方案 需要将整个项目打包成apk，上传到模拟器或真机上，就跟运行了一次app 。 最近的文章(20201222)讲到 Androidstudio +Instrumentation 比较少， Androidstudio3.4.1 默认生成的代码中也没有 Instrumentation 相关配置， 是被替代了吗，暂时去看看其他的方案。 单元测试 robolectric 方案 With Robolectric, your tests run in a simulated Android environment inside a JVM, without the overhead of an emulator. http://robolectric.org https://github.com/robolectric/robolectric // 配置 testImplementation 'junit:junit:4.12' testImplementation 'org.robolectric:robolectric:4.1' testImplementation 'org.robolectric:shadows-multidex:4.1' testOptions { unitTests { includeAndroidResources = true } } // 会提示下载文件失败，你可以手动下载一下。 Downloading: org/robolectric/android-all/9-robolectric-4913185-2/android-all-9-robolectric-4913185-2.jar from repository sonatype at https://oss.sonatype.org/content/groups/public/ Transferring 118099K from sonatype 下载地址就是按提示拼接一下,将下载好的文件放到 android-all-9-robolectric-4913185-2.jar.tmp 目录下 ， 用 everything 全局搜索一下。 ----> https://oss.sonatype.org/content/groups/public/org/robolectric/android-all/9-robolectric-4913185-2/android-all-9-robolectric-4913185-2.jar // 简单示范 @RunWith(RobolectricTestRunner.class) @Config( sdk = 28) public class TestShow { @Test public void myTest(){ Context context = RuntimeEnvironment.application.getApplicationContext() ; MyDeviceTool myDeviceTool = new MyDeviceTool(); String packageName =myDeviceTool.getPackageName(context) ; WkLogTool.showLog(\"packageName=\"+packageName); } } 我用的较少，一般只是用来测试一下逻辑。 crash 崩溃解决办法 1、(线上) 常规Crash 发版时或者通过热修复解决 2、系统级 Crash 尝试Hook绕过 3、疑难 Crash重点突破或更换方案 目前技术能力暂时无法解决的就想办法规避问题，更换实现方案 如果发生了异常情况，怎么止损 1、有异常情况，紧急关闭功能的入口，让App处于可控的状态。 2、热修复。 3、兜底策略，如果监测到连续多次在同一个地方奔溃，可以拦截此流程， 给予用户相关提示，不要一直崩溃。然后再上报错误。 提问 （持续更新） 如何技术选型 首先要确保一点：技术选型是稳定压倒一切、先验证后使用。 不稳定的技术或框架，在后期会带来很多的麻烦， 此项技术是否要被采纳，可以考虑以下因素 1、该技术是否成熟，是否已经被广泛应用和验证过。 一些技术随着开发版本的推进，API会大幅改变，甚至不再维护旧版本，导致旧版本中的BUG无人修复，逼迫你升级。 新技术可能会有很多未知的BUG，如果你深度使用后遇到一个Bug，你自己无法解决 也没人解决过，你会非常难受。 还有一些新技术可能会影响你的APP上架。 2、该技术是谁发起和主持的，权威性如何，后续更新如何，是否有版权风险。 可能会有一些技术精英会开源一个框架，但是并没有形成一个好的社区来维护，后期可能导致项目更新缓慢，甚至停更。 有些可能会慢慢地演化成开源版和收费版，你想要的功能只在收费版中提供。影响你的预算。 3、该技术的复杂性如何、学习成本 、以后替换的成本如何。 在一些工期比较紧的项目中，如果采用新技术，因为团队成员需要学习成本，可能无法把控开发进度。 4、使用该技术是否带来过多的冗余模块，对程序的健壮性是否有影响。 例如一些工具类想做得大且全，但是你引入它只是为了使用它的一个小模块，此时要好好考虑和验证下。 如果出现 依赖冲突、安装包增大等问题，你又对该技术不太熟悉，无法进行优化和排查， 会给项目带来很多不稳定因素。 5、对技术进行考虑时不仅仅要看到它的优点，更要看到它的不足点，改技术在宣传时，它一般是对缺点避而不谈的， 所以你要留心并验证。 导致 代码质量问题 的原因 1、新手 ，经验和能力不足 2、人员的调动和更换，导致对业务的理解有偏差 3、没有一个约定的 代码规范 ，导致沟通和维护困难 如何保证代码质量 1、架构师搭建、设置 合理优秀的基础框架。 2、要求 开发者 单元测试、代码自测。bug率跟绩效挂钩。 3、代码 评审、复查、 review 代码提交后，由其他人 一般是水平更高的人来评审代码， 评审点可以放在 代码是否符合约定的代码规范、 设计思路和逻辑、性能 ， 必要时要进行重构，实行老人带动新人成长 一般而言， 采用 以小组为单位，组长责任制的代码复查形式。 小组长不要分配太多的开发任务，而是以指导设计、评审代码为主。 4、定期开总结大会，做分享，团队成员能力共同提高 如何 提高 线上代码 质量 1、上线前先做好本地测试，加入 bugly等获取异常信息，以便排查修复 2、支持热更新 ，无感知修复小bug 3、全局异常捕捉，防止APP崩溃。 如何自定义 Lint Android Lint 是 ADT 16 引入的一个代码扫描工具 ， 通过对代码进行静态分析，可以帮助开发者发现代码质量问题和提出一些改进建议。 Lint 已经被集成在 AS 中。 原生 Lint 有时无法满足自己的需求，例如团队的编码规范。所以有时需要进行自定义 Lint 。 自定义lint 的方案目前主要有两种。 1、第一种当然是 谷歌官方的，https://sites.google.com/a/android.com/tools/tips/lint-custom-rules 不过这种方案有点不妥，这种方案配置的 lint 规则会 影响机器上所有的Android工程。 拷贝到了 .android/lint 文件夹下了。所以一般采用第二种方案。 2、第二种方案是 LinkedIn (就是那个领英) 的，https://engineering.linkedin.com/android/writing-custom-lint-checks-gradle 将lint.jar放到一个 aar 中。将需要 lint 检测的项目中引入这个 aar，仅对当前工程有效。 demo ( LinkedIn 方案) 参考博客写的demo ，以 aar方式引用出了点问题。(只生效一次，暂时不知道原因) 暂时只用 java lib 的方式 引用。 具体的使用请参考代码 https://gitee.com/hnyer/aivin_lint_demo 目前有的效果有 枚举检测、图片大小检测、系统日志检测、命名规范检测、xml 字段名命名检测 手动创建线程检测、系统吐司检测、xml硬编码检测、代码中硬编码检测 ( no Copyright，enjoy youself ! ) all right reserved，powered by GitbookThe file was updated at : 2021-06-22 15:41:08 "},"chinese/android基础/项目参数配置.html":{"url":"chinese/android基础/项目参数配置.html","title":"项目参数配置","keywords":"","body":"权限配置 动态权限申请第三方辅助工具 一般权限 这类权限一般不涉及用户隐私，是不需要用户进行授权的，比如手机震动、访问网络等 普通权限 含义 ACCESS_LOCATION_EXTRA_COMMANDS 访问额外的位置提供命令 ACCESS_NETWORK_STATE 访问有关GSM网络信息 ACCESS_NOTIFICATION_POLICY ？ ACCESS_WIFI_STATE 访问Wi-Fi网络状态信息 BLUETOOTH 连接到已配对的蓝牙设备 BLUETOOTH_ADMIN 允许程序发现和配对蓝牙设备 BROADCAST_STICKY 允许一个程序广播常用intents CHANGE_NETWORK_STATE 允许程序改变网络连接状态 CHANGE_WIFI_MULTICAST_STATE ？ CHANGE_WIFI_STATE 允许程序改变Wi-Fi连接状态 DISABLE_KEYGUARD 允许程序禁用键盘锁 EXPAND_STATUS_BAR 允许一个程序扩展收缩在状态栏 GET_PACKAGE_SIZE 允许一个程序获取任何package占用空间容量 INSTALL_SHORTCUT ？ INTERNET 允许程序打开网络套接字 KILL_BACKGROUND_PROCESSES ？ MODIFY_AUDIO_SETTINGS 　允许程序修改全局音频设置 NFC ？ READ_SYNC_SETTINGS 允许程序读取同步设置 READ_SYNC_STATS 　允许程序读取同步状态 RECEIVE_BOOT_COMPLETED 允许程序接收到 REORDER_TASKS 允许程序改变Z轴排列任务 REQUEST_INSTALL_PACKAGES ？ SET_ALARM ？ SET_TIME_ZONE 允许程序设置时间区域 SET_WALLPAPER 允许程序设置壁纸 SET_WALLPAPER_HINTS 允许程序设置壁纸hits TRANSMIT_IR 允许使用设备的红外发射器 UNINSTALL_SHORTCUT ？ USE_FINGERPRINT ？ VIBRATE 允许访问振动设备 WAKE_LOCK ？ WRITE_SYNC_SETTINGS 允许程序写入同步设置 危险权限 1、需要用户授权。必须在Manifest中申明，否则申请时不提示用户，直接回调开发者权限会被拒绝。 2、同一个权限组的任何一个权限被授权了，这个权限组的其他权限也自动被授权。 3、申请某一个权限的时候系统弹出的Dialog是对整个权限组的说明，而不是单个权限。 4、Android 6.0开始需要动态权限申请 危险权限 含义 READ_CALENDAR WRITE_CALENDAR 日历 CAMERA 相机 READ_CONTACTS WRITE_CONTACTS GET_ACCOUNTS 联系人 ACCESS_FINE_LOCATION ACCESS_COARSE_LOCATION 位置 RECORD_AUDIO 麦克风 READ_PHONE_STATE CALL_PHONE READ_CALL_LOG WRITE_CALL_LOG ADD_VOICEMAIL USE_SIP PROCESS_OUTGOING_CALLS 手机 BODY_SENSORS 传感器 SEND_SMS RECEIVE_SMS READ_SMS RECEIVE_WAP_PUSH RECEIVE_MMS 短信 READ_EXTERNAL_STORAGE WRITE_EXTERNAL_STORAGE 存储 常用权限配置 application 标签下 largeHeap 系统源码 /system/build.prop 中有以下参数 dalvik.vm.heapsize=128m // 最大内存限制 dalvik.vm.heapgrowthlimit=64m // 普通内存限制 当在 application 对 largeHeap进行配置时 android:largeHeap=\"true\" 应用申请的内存最大为 128M android:largeHeap=\"false\" 应用申请的内存最大为 64M overrideLibrary 第三方库 和项目的 minSdkVersion 不一致，会导致 Manifest 文件合并失败。 我们可以通过配置来忽略。如果存在多个库有此异常，则用逗号分割它们。 下载源替换 、镜像 应为谷歌等国外的 下载源 速度比较慢， 可以考虑缓存国内 阿里云 的下载源 google() jcenter() 替换成 maven{ url 'https://maven.aliyun.com/repository/google'} maven{ url 'https://maven.aliyun.com/repository/gradle-plugin'} maven{ url 'https://maven.aliyun.com/repository/public'} maven{ url 'https://maven.aliyun.com/repository/jcenter'} url \"https://maven.google.com\" 替换成 url \"http://maven.aliyun.com\" url \"https://jitpack.io\" 替换成 url \"https://maven.aliyun.com/repository/public\" ( no Copyright，enjoy youself ! ) all right reserved，powered by GitbookThe file was updated at : 2021-08-17 16:36:06 "},"chinese/android基础/App发布.html":{"url":"chinese/android基础/App发布.html","title":"App发布","keywords":"","body":"代码混淆 混淆规则 guardsquare androidstudio 混淆配置 // build.gradle 文件下 (这是系统默认生成的，可以修改) 1、导入 xxx\\tools\\proguard\\proguard-android.txt 。 这里面是一些比较常规的不能被混淆的代码规则。 2、导入当前工程里面的 proguard-rules.pro 。这里是一些自定义的混淆规则。 proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.pro' //是否开启混淆 true or false minifyEnabled true 不能混淆的内容 混淆了这些内容，会导致出错。 1、 自定义控件 2、 枚举 3、 第三方库中的类 （作者一般会标明） 4、 运用了反射的类 5、 使用了 Gson 之类的工具的实体类 6、 WebView 的 JS 的接口方法 7、 Parcelable 的子类和 Creator 静态成员变量不混淆 设置 不参与混淆 # 保持该包下的类名 (子包下的会被混淆) -keep class cn.wk.test.* # 把本包和所含子包下的类名都保持 -keep class cn.wk.test.** # 保持类名和里面的内容不被混淆 -keep class com.example.bean.** { *; } 自用的 aar 混淆 # 代码混淆压缩比，在0~7之间，默认为5,一般不下需要修改 -optimizationpasses 5 # 混淆时不使用大小写混合，混淆后的类名为小写 -dontusemixedcaseclassnames # 不混淆第三方引用的库 不忽略library里面非public修饰的类 ？？？ -dontskipnonpubliclibraryclasses # 指定不忽略非public类里面的成员和方法 -dontskipnonpubliclibraryclassmembers # 不做预检验， 去掉这一步可以加快混淆速度 -dontpreverify # 把所有信息都输出，而不仅仅是输出出错信息 -verbose #apk 包内所有 class 的内部结构 ?? -dump class_files.txt # 列出了没有被混淆的类和成员 -printseeds seeds.txt #列出从 apk 中删除的代码 -printusage unused.txt #混淆前后的映射 -printmapping mapping.txt # 混淆时所采用的算法 ，后面的参数是一个过滤器 # 这个过滤器是谷歌推荐的算法，一般不改变 -optimizations !code/simplification/artithmetic,!field/*,!class/merging/* #保留Annotation不混淆 -keepattributes *Annotation*,InnerClasses # 避免混淆泛型 -keepattributes Signature # 保留异常 -keepattributes Exceptions # 抛出异常时保留代码行号 -keepattributes SourceFile,LineNumberTable # 不打印指定类的警告信息 -ignorewarnings #==================================【项目配置】================================== # 保留所有的本地native方法不被混淆 -keepclasseswithmembernames class * { native ; } # 保留了继承自Activity、Application (四大组件等)这些类的子类 -keep public class * extends android.app.Activity -keep public class * extends android.app.Application -keep public class * extends android.app.Service -keep public class * extends android.content.BroadcastReceiver -keep public class * extends android.content.ContentProvider -keep public class * extends android.app.backup.BackupAgentHelper -keep public class * extends android.preference.Preference -keep public class * extends android.view.View -keep public class com.android.vending.licensing.ILicensingService -keep public class * extends android.database.sqlite.SQLiteOpenHelper{*;} # 如果有引用android-support-v4.jar包，可以添加下面这行 -keep public class com.null.test.ui.fragment.** {*;} #如果引用了v4或者v7包 -dontwarn android.support.** # 保留Activity中的方法参数是view的方法 -keepclassmembers class * extends android.app.Activity { public void * (android.view.View); } # 枚举类不能被混淆 -keepclassmembers enum * { public static **[] values(); public static ** valueOf(java.lang.String); } # 不混淆反射 -keepattributes EnclosingMethod # 保留自定义控件(继承自View)不能被混淆 -keep public class * extends android.view.View { public (android.content.Context); public (android.content.Context, android.util.AttributeSet); public (android.content.Context, android.util.AttributeSet, int); public void set*(***); *** get* (); } # 保留Parcelable序列化的类不能被混淆 -keep class * implements android.os.Parcelable{ public static final android.os.Parcelable$Creator *; } # 保留Serializable 序列化的类不被混淆 -keepclassmembers class * implements java.io.Serializable { static final long serialVersionUID; private static final java.io.ObjectStreamField[] serialPersistentFields; !static !transient ; private void writeObject(java.io.ObjectOutputStream); private void readObject(java.io.ObjectInputStream); java.lang.Object writeReplace(); java.lang.Object readResolve(); } # 对R文件下的所有类及其方法，都不能被混淆 -keepclassmembers class **.R$* { *; } # 对于带有回调函数onXXEvent的，不能混淆 -keepclassmembers class * { void *(**On*Event); } #==================================【根据自己的项目（自己写的代码），配置需要 忽略混淆的类================================== -keep class org.litepal.** { *; } -keep class com.walkera.wktools.** { *; } #==================================【根据自己的项目（自己引用的第三方jar），配置需要 忽略混淆的类================================== # ant.jar #-libraryjars libs/ant.jar -keep class org.apache.** { *; } # ftp4j.jar #-libraryjars ./libs/ftp4j-1.7.2.jar -keep class it.sauronsoftware.** { *; } # guava.jar #-libraryjars ./libs/guava-17.0.jar -keep class com.google.** { *; } # netty.jar #-libraryjars ./libs/netty-all-4.0.25.Final.jar -keep class io.netty.** { *; } # nineoldandroids.jar #-libraryjars ./libs/nineoldandroids-2.4.0.jar -keep class com.nineoldandroids.** { *; } Gradle 配置 Gradle 是什么 Gradle 是一款强大的 构建工具 ，而不是语言。 它使用了 Groovy 这个语言，创造了一种 DSL ，但它本身不是语言。 gradle 打印日志 调试信息 println \"hello gradle\" 或 println (\"hello gradle\") 然后在 Gradle 或 Build Console 中可以输出内容 输出 gradle 编译的详细信息 gradlew compileDebug --stacktrace gradlew compileDebug --info gradlew compileDebug --debug gradlew compileDebug --scan gradle 编码GBK的不可映射字符 1、在模块的 build.gradle 中加入: tasks.withType(JavaCompile) { options.encoding = \"UTF-8\" } 2、在Androidstudio 中搜索 File encoding ，将编码格式设置为 utf-8 3、如果还不行，就在跟目录的 gradle.properties 加入参数 org.gradle.jvmargs=-Xmx1536m -Dfile.encoding=UTF-8 Gradle 基础命令 // gradlew -v 查看 gradle 版本 // gradlew clean 删除 build 文件夹 // gradlew clean build --refresh-dependencies 强制更新最新依赖，清除构建后再构建 // gradlew build 编译 打包 (debug 和 release) // gradlew build --info 编译打包并打印日志 // gradlew build --profile 编译并输出性能报告，一般在构建工程根目录 build/reports/profile // gradlew build --info --debug --stacktrace 调试模式构建并打印堆栈日志 // gradlew assembleRelease // gradlew aR (简化版命令 ) 编译并打 Release 的包 // gradlew assembleDebug 编译并打 Debug 包 // gradlew installDebug debug 模式打包并安装 // gradlew installRelease Release 模式打包并安装 // gradlew uninstallRelease 卸载 Release 模式包 // gradlew assemble debug 、release 模式全部渠道打包 // gradlew app:dependencies > xxx.txt 查找 app模块的依赖关系，并输出到 xxx.txt文件中。 // gradlew -q xxx 运行xxx 插件 ，-q是quiet，不会生成gradle的日志信息。 gradle - apk重命名 android { applicationVariants.all{ variant -> variant.outputs.all { output -> def releaseTime = new Date().format(\"yyyyMMdd-HHmm\", TimeZone.getTimeZone(\"GMT+08:00\")) ; def outputFile = output.outputFile if(outputFile != null && outputFile.name.endsWith('.apk')) { def newName = \"WkReader-${variant.buildType.name}-2.0.1.${releaseTime}.apk\" outputFileName = newName }// } } // } gradle - 将apk拷贝到指定目录 在项目根目录的 build.gradle 下添加 subprojects(){ def releaseTasks = project.getTasksByName(\"assembleRelease\",false) def debugTasks = project.getTasksByName(\"assembleDebug\",false) copyApkFile(releaseTasks, project) copyApkFile(debugTasks, project) } def copyApkFile(Set tasks , Project project) { for (task in tasks) { // 删除上一次的 build 文件夹 def apkDirFile = new File(project.getProjectDir().getAbsolutePath() + \"/build/outputs/apk\") if (apkDirFile.exists()) { delete( project.getProjectDir().getAbsolutePath() + \"/build/outputs/\") } task.doLast { // 拷贝 apk 到指定目录 if (apkDirFile.exists()) { FileTree tree = fileTree(dir: apkDirFile.absolutePath) tree.each { File myFile -> println \">>> myFile.name=\"+myFile.name if(myFile.name.endsWith(\".apk\")){ copy{ from myFile.absolutePath into \"F:\\\\apks2\" } } } } } } } gradle - 自动签名 android { def keystorePropertiesFile = rootProject.file(\"keystore.properties\") def keystoreProperties = new Properties() keystoreProperties.load(new FileInputStream(keystorePropertiesFile)) signingConfigs { wk2017 { storeFile file(keystoreProperties['storeFile']) storePassword keystoreProperties['storePassword'] keyAlias keystoreProperties['keyAlias'] keyPassword keystoreProperties['keyPassword'] } } defaultConfig { signingConfig signingConfigs.wk2017 } buildTypes { release { signingConfig signingConfigs.wk2017 } debug { signingConfig signingConfigs.wk2017 } } } gradle - 版本统一管理配置 1、新建 配置文件 myconfig.gradle ext { appLibversions = [ lib_compileSdkVersion : 28, lib_minSdkVersion : 22 , lib_targetSdkVersion : 28 , lib_versionCode : 12 , lib_versionName : \"1.0.0.20210419\" ] // 第三方依赖 my_libdependencies = [ lib_recyclerview: \"com.simplecityapps:recyclerview-fastscroll:2.0.1\" ] } 2、让配置生效 ，在根目录下的 build.gradle 添加 apply from: 'myconfig.gradle' 3、引用配置中的变量 def appLibversions = rootProject.ext.appLibversions compileSdkVersion appLibversions.lib_compileSdkVersion buildToolsVersion \"28.0.3\" defaultConfig { applicationId \"com.wk.reader\" minSdkVersion appLibversions.lib_minSdkVersion targetSdkVersion appLibversions.lib_targetSdkVersion versionCode appLibversions.lib_versionCode versionName appLibversions.lib_versionName } Gradle 打多渠道包 1、在 build.gradle 文件下的 android 标签下配置 productFlavors{ // 渠道1，免费版 freeVersion{ applicationId \"com.wk.freereader\" buildConfigField (\"String\", \"BaseApi\", '\"http://baidu.com\"') resValue (\"string\", \"tipTest\", '\"这是免费版\"') manifestPlaceholders = [ app_nameflavors: \"@string/app_name_free\" , app_logoflavors: \"@mipmap/ic_launcher\" ] } // 渠道2，专业版 proVersion{ applicationId \"com.wk.proreader\" buildConfigField (\"String\", \"BaseApi\", '\"http://baidu.com\"') resValue (\"string\", \"tipTest\", '\"这是专业版\"') manifestPlaceholders = [ app_nameflavors: \"@string/app_name_pro\" , app_logoflavors: \"@mipmap/ic_launcher\" ] } } // 2、如果报错 ERROR: All flavors must now belong to a named flavor dimension. 在 defaultConfig 标签下配置 flavorDimensions \"default\" 即可。 3、配置简单说明 // 直接让不同的 apk 包名生效， applicationId \"com.wk.freereader\" // BuildConfig 中会生成对应的变量，在Java代码中可以调用 ，类型-变量名-变量值 buildConfigField (\"String\", \"BaseApi\", '\"http://baidu.com\"') // 系统会生成对应的 xml 风格的变量名 ，在xml 中可以调用 resValue (\"string\", \"tipTest\", '\"这是免费版\"') manifestPlaceholders = [ // 占位符 android:label=\"${app_nameflavors}\" app_nameflavors: \"@string/app_name_free\" , // 占位符 android:icon=\"${app_logoflavors}\" app_logoflavors: \"@mipmap/ic_launcher\" ] 通过在代码中 调用 BuildConfig 中的变量，可以动态控制一些值， 比如域名、默认配置等等。 4、要想让占位符生效，需要在 main 同级目录下 新建渠道包同名的文件夹，里面放置资源文件 Gradle 生命周期监控 (不知道用来做什么) 在 settings.gradle 中添加， gradle.addBuildListener(new BuildListener() { void buildStarted(Gradle var1) { // 这个函数没有触发，暂时不知道原因 println 'Gradle 开始构建' } void settingsEvaluated(Settings var1) { println 'settings.gradle 代码执行完毕, Project 还未初始化' } void projectsLoaded(Gradle var1) { println '项目结构加载完成 ，可访问根项目：' + var1.gradle.rootProject } void projectsEvaluated(Gradle var1) { println '所有项目评估完成，配置阶段结束' } void buildFinished(BuildResult var1) { println 'Gradle 构建结束 ' } }) Gradle 耗时监控 在 settings.gradle 中添加 long beginOfSetting = System.currentTimeMillis() def beginOfConfig def configHasBegin = false def beginOfProjectConfig = new HashMap() def beginOfProjectExcute gradle.projectsLoaded { println '耗时信息>>> 初始化阶段 耗时：' + (System.currentTimeMillis() -beginOfSetting) + 'ms' } gradle.beforeProject { project -> if (!configHasBegin) { configHasBegin = true beginOfConfig = System.currentTimeMillis() } beginOfProjectConfig.put(project, System.currentTimeMillis()) } gradle.afterProject { project -> def begin = beginOfProjectConfig.get(project) println '耗时信息>>> 配置阶段 ' + project + '耗时：' + (System.currentTimeMillis() - begin) + 'ms' } gradle.taskGraph.whenReady { println '耗时信息>>> 配置阶段 总共耗时：' + (System.currentTimeMillis() - beginOfConfig) + 'ms' beginOfProjectExcute = System.currentTimeMillis() } gradle.taskGraph.beforeTask { task -> task.doFirst { task.ext.beginOfTask = System.currentTimeMillis() } task.doLast { println '耗时信息>>> 执行阶段，' + task + '耗时：' + (System.currentTimeMillis() - task.beginOfTask) + 'ms' } } gradle.buildFinished { println '耗时信息>>> 执行阶段，耗时：' + (System.currentTimeMillis() - beginOfProjectExcute) + 'ms' } Gradle 相关API 和配置 getAllprojects () 获取所有 project 的实例。 在根目录下的 build.gradle 添加 def getProjects() { println \"getAllprojects>> Root Project Start \" this.getAllprojects().eachWithIndex { Project project, int index -> if (index == 0) { println \"getAllprojects>> Root Project is $project\" } else { println \"getAllprojects>> child Project is $project\" } } } this.getProjects() getSubprojects () 获取当前工程下所有子 project 的实例 def getSubProjects() { println \" getSubProjects>> Sub Project Start \" this.getSubprojects().each { Project project -> println \"getSubProjects>> child Project is $project\" } } this.getSubProjects() getParentProject () 获取当前 project 的父类 def getParentProject(){ def name=this.getParent().name println \"getParentProject >> the parent project name is :${name}\" } getParentProject() getRootProject () 获取当前的 project 实例 def getRootPro() { def rootProjectName = this.getRootProject().name println \"getRootProject >> root project is $rootProjectName\" } this.getRootPro() getRootDir() 、 getBuildDir() 、getProjectDir() println \"the root file path is:\" + getRootDir().absolutePath println \"this build file path is:\" + getBuildDir().absolutePath println \"this Project file path is:\" + getProjectDir().absolutePath the root file path is:F:\\sourceSpace\\AivinReader this build file path is:F:\\sourceSpace\\AivinReader\\app\\build this Project file path is:F:\\sourceSpace\\AivinReader\\app project 配置 表示的是指定工程的实例，然后可以在闭包中对其进行操作。 allprojects 配置 表示用于配置当前 project 及其旗下的每一个子 project 。 subprojects 配置 统一配置当前 project 下的所有子 project 。 gradle 文件操作 // 获取单个文件内容 this.getMyFile(\"config.gradle\") def getMyFile(String path) { try { def mFile = file(path) println('getfile>>'+ mFile.text); } catch (GradleException e) { println e.toString() return null } } // 获取多个文件内容 this.getMyFileS(\"config.gradle\", \"build.gradle\") def getMyFileS(String path1, String path2) { try { def mFiles = files(path1, path2) println('getfiles>>'+ mFiles[0].text + mFiles[1].text ); } catch (GradleException e) { println e.toString() return null } } gradle 诊断报告工具 Profile report 我们一般会使用如下命令来生成一份本地的构建分析报告： gradlew assembleDebug --profile xxx/build/reports/profile/profile-xxx.html 可以查看各个模块、依赖、任务的执行时间。 Build Scan 一个更细致的构建汇报工具， gradlew build --scan 命令执行完成后，需要将一些信息上传到 https://scans.gradle.com 上， 然后填写一个 email 地址接收最后的 scan 报告。 Gradle 打包提速方案 Gradle 升级到 最新的版本 将 Gradle 和 Android Gradle Plugin 的版本升至最新， 所带来的的构建速度的提升效果是显而易见的， 特别是当之前你所使用的版本很低的时候。 Gradle 开启离线模式 打开 Android Studio 的离线模式后， 所有的编译操作都会走本地缓存 , 这将会极大地缩短编译时间。 尤其是中国大陆的网络访问外网龟速的情况下。 增加 Androidstudio 的内存空间 、并行的处理器核心数 在性能好的电脑上给 AS 一个大的内存，会让 as 有更好的表现。 maxProcessCount // cpu核心数 删除不必要的 Moudle 、合并部分 Module 过多的 Moudle 会使项目中 Module 的依赖关系变得复杂， Gradle 在编译构建的时候会去检测各个 Module 之间的依赖关系， 它会去梳理这些 Module 之间的依赖关系， 以避免 Module 之间相互引用而带来的各种问题。 除了删除不必要的 Moudle 或合并部分 Module 的方式外， 我们也可以将稳定的底层 Module 打包成 aar， 上传到公司的本地 Maven 仓库，通过远程方式依赖。 删除 项目中的无用资源 1、如果我们不需要写单元测试代码，可以直接删除 test 目录。 2、如果我们不需要写 UI 测试代码，也可以直接删除 androidTest 目录。 3、此外，如果 Moudle 中只有纯代码，可以直接删除 res 目录。 在 Android Studio 中提供 Remove Unused Resource 功能， 将一些无用的图片 等资源删除， 减少 gradle 分析时间。 优化第三方库的引用 1、使用更小的库去替换现有的同类型的三方库。 2、使用 exclude 来排除三方库中某些不需要或者是重复的依赖。 3、使用 debugImplementation 来依赖仅在 debug 期间才会使用的库， 如一些线下的性能检测工具。 resConfigs 去除多余的语言资源 如果你使用的库包含语言资源(例如使用的是AppCompat或 Google Play服务)， 则APK将包括这些库中消息的所有已翻译语言字符串， 无论应用的其余部分是否翻译为同一语言。 如果你想只保留应用正式支持的语言，则可以利用 resConfigs 属性指定这些语言。 系统会移除未指定语言的所有资源。 使用增量编译 (新版gradle 已经开启 ，属性已经废弃) 在 Gradle 4.10 版本之后便默认使用了增量编译 。 Gradle 常用注解 https://docs.gradle.org/current/javadoc/org/gradle/api/tasks/package-summary.html @Input // 在代码中定义 @Input public void checkString(boolean flag) { this.strings = flag; } // 在 build.gradle 中使用 // checkResources 是 task 的名字 checkResources{ checkString true } @TaskAction Marks a method as the action to run when the task is executed. Gradle plugin ( Gradle 插件) 插件方式1 Build script 把插件写在 build.gradle 文件里， 一般用于简单的逻辑，仅仅在该 build.gradle 文件里可见。 比如做一些简单的版本统一管理，apk重命名等 插件方式2 buildSrc 项目 demo 地址在 https://gitee.com/Aivin_CodeShare/android_tool_code/tree/master/buildsrc 仅仅对该项目中可见，适用于逻辑较为复杂，但又不须要外部可见的插件。 1、Module 的名字一定要是 buildSrc 2、修改 module的 build.gradle文件内容为： apply plugin: 'groovy' apply plugin: 'maven' dependencies { compile gradleApi() compile localGroovy() } repositories { mavenCentral() } 3、在main目录下新建groovy目录，在groovy目录下创建包名目录。 Gradle插件本身用的是groovy语言，groovy 和 Java可以互通，我们可以直接用Java来写。 4、在包名目录下新建名为 xxx 的groovy文件, 5、在main目录下新建resources目录，在resources目录里新建META-INF目录， 再在META-INF里面新建gradle-plugins目录。 6、gradle-plugins目录里面新建properties文件， 如 aivingradleplugin.properties,注意这个文件可以随意命名,但是后面使用这个插件的时候， apply plugin:'aivingradleplugin'。 7、properties 文件里指明Gradle插件的具体实现类： implementation-class=com.aivin.buildsrc.AivinPluginX // 使用方法 1、在项目的根目录下的 build.gradle 下引入这个 插件 apply plugin:'aivingradleplugin' 2、配置一些参数 // fileMd5CheckTask 是 task名字 ，isOpenFileMd5Check 是被 @Input 标记注解的变量 fileMd5CheckTask{ isOpenFileMd5Check true } 3、在命令行输入命令即可 gradlew fileMd5CheckTask // checkResources 是在代码中定义的 task 名字 // GeekTask task = project.getTasks().create(\"fileMd5CheckTask\", GeekTask.class) 4、如果其他项目引入你的 buildSrc 报错 Duplicate root element buildSrc , 是因为 buildSrc 被 Androidstudio 篡改成了 小写的 buildsrc ，手动改成 “buildSrc”即可 插件方式3 独立项目 (推荐) 编写独立的gradle插件工程，将插件发布到本地或者远程仓库。 具体demo参考我的 asm 工程。 // build.gradle 配置 apply plugin: 'groovy' apply plugin: 'maven' dependencies { compile gradleApi() compile localGroovy() //引入asm库 compile 'org.ow2.asm:asm:9.1' compile 'org.ow2.asm:asm-commons:9.1' compile 'org.ow2.asm:asm-analysis:9.1' compile 'org.ow2.asm:asm-util:9.1' compile 'org.ow2.asm:asm-tree:9.1' compileOnly 'com.android.tools.build:gradle:3.4.1' , { //排除gradle自带的asm库 exclude group:'org.ow2.asm' } } repositories { jcenter() } //在本地生成仓库 - uploadArchives 是个关键字，不能改成其他名字 uploadArchives { repositories.mavenDeployer { //本地仓库路径，在项目根目录下的 生成 repo 的文件夹 repository(url: uri('F:\\\\mygradleplugin/aivinAsmRepo')) //groupId ，组织id pom.groupId = 'com.aivin.android' //artifactId 项目id pom.artifactId = 'asmplugin' //插件版本号 pom.version = '1.0.0' } } // 2、其他工程的可以直接饮用本地磁盘的插件 maven { //指定本地插件地址 url uri('F:\\\\mygradleplugin\\\\aivinAsmRepo') } // 引入插件 classpath 'com.aivin.android:asmplugin:1.0.0' // 在需要插件的模块中启用插件 并进行相关配置 apply plugin: 'aivin.asm.gradleplugin' thePluginForShowMethodTime { isShowDebugInfo = true; excludePackageList=[] needModifyPackageList=[] } demo 地址 https://gitee.com/aivinCompany/AsmgradlePlugin https://gitee.com/aivinCompany/AsmUseDemo 其实，我感觉 groovy 的编译错误提示不是很好，可以使用java。 渠道包 为什么需要打渠道包 1、为了区分用户从哪个 渠道下载的，比如官网、应用宝、华为、小米等商店， 因为一般是分渠道进行推广的，这样就能统计出每个渠道的推广效果进而进行调整。 2、可以针对每个不同渠道的 APP配置不同的 APP名字 和APP logo、包名。 例如 搜狗输入法小米版、搜狗输入法华为版。 多渠道 打包 方案 目前公司APP集中于官网发布，暂时用不上。需要的时候再来更新具体使用方法。 1、gradle 官方方案。 2、其他一些第三方的插件，例如美团就有一个 Walle（瓦力）https://github.com/Meituan-Dianping/walle gralde默认的配置，缺点是每个渠道包都会重新编译一次，编译速度慢。 对大量的多渠道打包推荐用美团的walle Sqlite 数据库升级 public class XXXHelper extends SQLiteOpenHelper { /** * 1、在第一次打开数据库的时候才会走 * 2、在清除数据之后再次运行-->打开数据库，这个方法会走 * 3、没有清除数据，不会走这个方法 * 4、数据库升级的时候这个方法不会走 */ @Override public void onCreate(SQLiteDatabase db) { } /** * 1、这个方法只有当数据库已经存在，而且版本升高的时候，才会调用 * 2、第一次创建数据库的时候，这个方法不会走 * 3、清除数据后再次运行(相当于第一次创建)这个方法也不会走 */ @Override public void onUpgrade(SQLiteDatabase db, int oldVersion, int newVersion) { } } onCreate() onUpgrade() 是数据库创建和升级的重要函数，在里面进行 sql 语句操作即可。 只是 在升级的逻辑会比较麻烦和繁琐， 因为升级情况会比较多， 比如用户可能是从 版本1 、2、3、4... 升级到版本10的，要针对这几种情况都要做相应的逻辑。 如果不想写sql 语句，可以使用 郭霖 开源的 LitePal Android 数据库。 封装的比较好 ，增删改查、数据库升级 事务操作都有。 appkey 、 token 保证数据安全 1、token token 是客服端登录成功后，服务器生成并下发给APP的。 token 可以采用不可逆加密方式生成，有较短的有效期。 客户端直接保存在本地就可以了。请求数据时，带着token， 服务器根据客户端上传的token 和保存在服务器上的对应客户端当前的token ， 进行对比，来判断token是否有效。 2、appkey 有一些sdk，需要在 Application 进行初始化，需要授权 appkey ， 此时我们对 appkey 不能加密，那么怎么防止别人反编译我们的apk 获得这个 appkey 去篡改数据 ？ 一般的做法就是服务器会将 appkey 和APP签名绑定好。 app 签名由开发者在后台手动填写。 签名不对的，认为是非法APP在调用，可以拒绝服务。 例如 高德地图 采用 key 和 apk 的 SHA1 绑定方案 。 bmob sdk 采用 key 和apk 签名绑定方案。 如果不采用 APP签名和appkey 绑定的方式，解决不了这个问题， 你即使将 appkey 写入 jni 的so 中，别人只要拦截到了 就照样可以使用。 apk 签名获取 keytool -list -v -keystore xxx.keystore 然后输入密码， MD5: 80:60:94:3E:7C:97:xxx:0F:C9:B1:67:4C SHA1: B8:94:EC:79:72:DD:91:0E:19:D6:CD:xxx:C2:0C:BA:31 SHA256: D5:3B:CB:D7:1D:B3:64:89:D6:FAxxxxxDB:3B:1B:4E:F0:FE:05:E4:15:BD 其中，把 MD5 的值把 冒号去掉，然后转为小写，就是apk的签名 8060943e7c973xxx15fb0fc9b1674c Android apk 打包过程 、打包流程 一个完整的 Android 项目可能包含多个 module， 而从宏观上看每一个 module 中的内容可以分为 资源文件 + 源代码。 因此整个项目的编译打包过程也是针对这 2 部分来完成。 编译阶段 (资源文件) 资源文件包括项目中 res 目录下的各种 XML 文件、动画、drawable 图片、音视频等。 所有资源文件会被编译处理(drawable 图片除外)，XML 文件会被编译成二进制文件， 所以解压 apk 之后无法直接打开 XML 文件。 注：assets 和 raw 目录下的资源不会被编译，会被原封不动的打包到 apk 压缩包中。 资源文件编译之后的产物包括：resources.arsc 、 R.java。 前者保存的是一个资源索引表，后者定义了各个资源 ID 常量。 这两者结合就可以在代码中找到对应的资源引用 编译阶段 (源码文件) 源代码首先会通过 javac 编译为 .class 字节码文件， 然后这些 .class 文件连同依赖的三方库中的 .class 文件一同被 dx 工具优化为 .dex 文件。 如果有分包，那么也可能会生成多个 .dex 文件。 注意，源代码文件也包括 AIDL 接口文件编译之后生成的 .java 文件， Android 项目中如果包含 .aidl 接口文件， 这些 .aidl 文件会通过aidl工具（源码位于system/tools/aidl）被编译成 .java 文件。 打包阶段 工具 APK Builder 将经过编译之后的 resource 和 .dex 文件 和其他一些资源一起打包到 apk 中， 其他一些资源 是指 比如 AndroidManifest.xml 清单文件和 动态库 .so 文件 等。 签名阶段 apk 创建好之后，还不能直接使用。需要对其进行签名， 因为 Android 系统不会安装没有进行签名的程序。 签名之后会生成 META_INF 文件夹，此文件夹中保存着跟签名相关的各个文件。 MANIFEST.MF // 定义了与扩展和包相关的数据。 INDEX.LIST // 它包含在应用程序或者扩展中定义的包的位置信息。 xxx.SF // 签名文件。 xxx.RSA // 与签名文件相关联的签名程序块文件， 存储了用于签名的公共签名。 优化阶段 打包过程还会有 apk 优化操作。 就是使用工具 zipalign 对 apk 中的未压缩资源（图片、视频等）进行对齐操作， 让资源按照 4 字节的边界进行对齐。 这种思想同 Java 对象内存布局中的对齐空间非常类似， 主要是为了加快资源的访问速度。 如果每个资源的开始位置都是上一个资源之后的 4n 字节， 那么访问下一个资源就不用遍历，直接跳到 4n 字节处判断是不是一个新的资源即可。 apk中是否会打包 Activity 、ListView 等系统组件的源码 安装在手机上的应用，用到的 Activity 、ListView ， 这个SDK提供的api的内部的代码逻辑，是跟着系统变化，还是在应用打包的时候就已经确定？ // 跟着系统变化 Android 标准组件的代码在 /system/framework/framework.jar里面， 它包含了所有系统自带的标准组件，包括 Activity 、View、Button 、ListView 等。 Android 标准组件，编译器在编译时只是引用一下，apk 里面并没有这些标准组件的实现代码。 apk 在设备里面启动后默认会将 framework.jar 加载进来，所以你的的apk运行的时候会有这些代码。 另外，android-support-v4.jar 或者 v7 里面的扩展组件是会编译到apk里面去的，因为它并不是android的标准组件。 分包流程、分包过程 需要分包的原因 1、dex 中包含的方法包括了所有依赖的 jar包 和源码中的方法。 而 dex 中表示方法数目的是 short 类型，所以最大只能表示到 65536 ， 当项目比较大时，会出现一个 dex无法保存所有方法的问题，此时需要分包。 新版本的Android系统中修复了这个问题， 但是我们仍然需要对低版本的 Android 系统做兼容. 2、即使方法数没有超过 65536，能正常编译打包成 apk， 在安装的时候，也有可能会提示 INSTALL_FAILED_DEXOPT 而导致安装失败， 这个一般就是因为 LinearAlloc 的限制导致的。这个主要是因为 Dexopt (dex文件优化工具) 使用 LinearAlloc 来存储应用的方法信息。 Dalvik LinearAlloc 是一个固定大小的缓冲区。 在 Android 版本的历史上，LinearAlloc 分别经历了 4M/5M/8M/16M 限制。 Android 2.2 和 2.3 的缓冲区只有 5MB， Android 4.x 提高到了 8MB 或 16MB。 当方法数量过多导致超出缓冲区大小时，也会造成 Dexopt 崩溃。 Android 5.0 以前 分包方案 因为 Android 5.0 之前使用 Dalvik 执行应用代码， 默认情况下，Dalvik限制每个APK只能使用一个 Classes.dex ，所以要支持运行时多Dex加载。 需要引入支持包。 defaultConfig ｛ multiDexEnabled true ｝ dependencies { implementation 'com.android.support:multidex:1.0.3' } 支持运行时多Dex加载，引入方法： 方法 1、Application 继承 MultiDexApplication 方法 2、 protected void attachBaseContext(Context context) { //其实方法1 最终也是调用这个方法 MultiDex.install(this); } Android 5.0 以后 分包方案 Android 5.0 之后的版本使用 ART ， 它支持从APK文件中加载多个Dex文件。 并且 ART 在应用安装时会执行预编译， 扫描所有的ClassesN.dex， 统一优化为.oat文件。 所以 minSdkVersion >=21 , 不需要引入分包的 support 库。 multidex 分包原理 , Dex 拆分 dex拆分步骤分为： 1、自动扫描整个工程代码得到 main-dex-list ； Android SDK 从 build tools 21 开始提供了 mainDexClasses 脚本来生成主 dex 的文件列表。 它主要做了下面两件事情： ①调用 proguard 的 shrink 操作来生成一个临时 jar 包； ②将生成的临时 jar 包和输入的文件集合作为参数， 然后调用 com.android.multidex.MainDexListBuilder 来生成主 dex 文件列表。 在 shrink 这一步，proguard 会根据 keep 规则保留需要的类和类成员，丢弃不需要的类和类成员。 shrink 步骤生成的临时 jar 包里面保留了符合 keep 规则的类，这些类是需要放在主 dex 中的入口类。 但是仅有这些入口类放在主 dex 还不够，还要找出入口类引用的其他类，不然仍然会在启动时出现 NoClassDefFoundError。 而找出这些引用类，就是调用的 com.android.multidex.MainDexListBuilder 2、根据 main-dex-list对 整个工程编译后的所有class进行拆分，将主、从dex的class文件分开； 3、用dx工具对主、从dex的class文件分别打包成 .dex文件，并放在apk的合适目录。 multidex 分包原理 , Dex 加载 Android系统在启动应用时只加载了主dex ，其他的 dex 需要我们在应用启动后进行动态加载安装。 Dex 加载的主要工作就是从 apk 中提取出所有的从 dex（classes2.dex，classes3.dex，...）， 然后通过 ClassLoader + 反射 依次安装加载从 dex， 并将取出的文件包装成 Element 对象放在 ClassLoader 的 pathList //反射调用 ClassLoader 的 pathList Field pathListField = MultiDex.findField(loader, \"pathList”); //将取出的zip文件包装成 Element 对象并扩展 dexElements MultiDex.expandFieldArray(dexPathList, \"dexElements\", makeDexElements(dexPathList, new ArrayList(additionalClassPathEntries), optimizedDirectory)); 注：（热修复、插件化技术中也有用到 ClassLoader + 反射 ） multidex 局限性 1、如果分包的 Dex 过大，因为 install 过程涉及IO等操作，容易触发ANR问题 ； 2、当运行的版本低于 Android 5.0 时，多 dex 文件 并不足以避开 linearalloc 限制。 linearalloc 的缓冲区大小在 Android 4.0 中有所提高，但这并未完全解决该问题。 在低于 Android 4.0 的版本中，可能会在达到 DEX 索引限制之前就达到 linearalloc 限制。 所以一些大的、复杂的项目在低配机器上有很大概率会出现问题。 为了解决这个问题，可以直接不支持低版本设备，或者针对旧版本设备提供精简版本。 ( no Copyright，enjoy youself ! ) all right reserved，powered by GitbookThe file was updated at : 2021-06-22 09:54:17 "},"chinese/android基础/Android外挂.html":{"url":"chinese/android基础/Android外挂.html","title":"Android外挂","keywords":"","body":"安卓外挂 AccessibilityService https://gitee.com/hnyer/wechat-tool 安卓辅助功能服务 。简单的说无障碍就是一个后台监控服务， 当你监控的内容发生改变时，就会调用后台服务的回调方法。 4.0以前，Accessibility功能单一，仅能过单向获取窗口信息(获取输入框内容)； 4.0及以后，Accessibility增加了与窗口元素的双向交互，可以操作窗口元素(点击按钮)。 具体案例可以参考 开头的demo 。 已经有的功能： 1、朋友圈自动滑动、 朋友圈点赞 、微信运动点赞 2、全局悬浮窗 实现(需要授权)。 ( no Copyright，enjoy youself ! ) all right reserved，powered by GitbookThe file was updated at : 2021-06-07 11:46:38 "},"chinese/android基础/Android字节码插桩.html":{"url":"chinese/android基础/Android字节码插桩.html","title":"Android字节码插桩","keywords":"","body":"Android 字节码插桩 什么是插桩 插桩就是将一段代码插入或者替换原本的代码。 字节码插桩顾名思义就是在我们编写的源码编译成字节码（Class）后， 在Android下生成dex之前修改Class文件， 修改或者增强原有代码逻辑的操作。 插桩的应用场景 通过 代码插入、代码替换实现 无痕埋点、性能监控 、日志记录、 性能统计、异常处理、修改三方库代码等目的。 总之就是 AOP（面向切面编程）。 插桩的时机 字节码操作框架的作用在于生成或者修改Class文件， 因此在Android中字节码框架本身是不需要打包进入APK的， 只有其生成/修改之后的Class才需要打包进入APK中。 它的工作时机在Android打包流程中的 java 文件生成 Class 之后，打包 .dex 之前。 字节码插桩框架 ASM 在maven 库中查看最新版本， https://search.maven.org/search?q=g:org.ow2.asm The source code is hosted on Gitlab. https://gitlab.ow2.org/asm/asm //引入asm库 compile 'org.ow2.asm:asm:9.1' compile 'org.ow2.asm:asm-commons:9.1' compile 'org.ow2.asm:asm-analysis:9.1' compile 'org.ow2.asm:asm-util:9.1' compile 'org.ow2.asm:asm-tree:9.1' compileOnly 'com.android.tools.build:gradle:3.4.1' , { //排除gradle自带的asm库 exclude group:'org.ow2.asm' } asm 是直接使用指令来控制字节码，执行效率很高。 ASM提供了两种API来生成和转换已编译类， 一个是 基于事件形式的 core API ， 另一个是基于对象形式 的 tree API 。 我们一般采用占用内存较多但是难度较小的 tree API 。 demo 地址 https://gitee.com/aivinCompany/AsmgradlePlugin https://gitee.com/aivinCompany/AsmUseDemo ClassVisitor 可以访问class文件的各个部分，比如方法、变量、注解等，用于修改 class 文件。 ClassVisitor 方法 作用 visit() 拿到 .class 的信息version jdk的版本 *access 类的修饰符 signature 泛型信息 superName 类的父类 interfaces 类实现的接口 visitMethod() 拿到函数信息。access 方法的修饰符name 方法名desc 方法签名signature 泛型相关信息exceptions 方法抛出的异常信息 visitEnd() 类访问结束 MethodVisitor MethodVisitor 的方法 作用 onMethodEnter() 方法开头 onMethodExit(int opcode) 方法结束 ClassReader 对具体的 class 文件进行读取与解析 ClassWriter 将修改后的class文件通过文件流的方式覆盖掉原来的 class 文件，从而实现 class 修改； ASM Bytecode Outline (字节码辅助工具) 在开发插件，需要进行插桩时，需要对字节码进行操作。 如果你不熟悉字节码代码，可以借助 这个插件进行辅助编码。 Transform API ( Android平台) Android Gradle 工具从 1.5.0-beta1 版本开始，包含了 Transform API， Transform API 允许第三方插件在将编译后的类文件转换为 dex 文件之前对 .class 文件进行操作。 可以这么简单地理解，ASM的作用是修改你指定的 class文件， Transform的作用是遍历你的工程中的 class文件， 根据你设定的条件找到你想要修改的class文件， 让 asm 去修改， 并让修改后的 class文件 打包到apk中。 关于混淆可以不用担心。 混淆其实是个ProguardTransform，在自定义的Transform之后执行。 Transform 方法 作用 getName() 返回该 transform 对应的task名称，在编译过程中会打印出类似的信息 ,{Name} 是 getName()的值。Task :app:transformClassesWith{Name}ForDebug UP-TO-DATE getInputTypes() 需要处理的数据类型。CONTENT_CLASS 代表 java 的 class(含jar中的)文件RESOURCES 代表资源 getScopes() 指 Transform 要操作内容的范围 EXTERNAL_LIBRARIES 只有外部库PROJECT 只有项目内容 PROJECT_LOCAL_DEPS 只有项目的本地依赖(本地jar)PROVIDED_ONLY 只提供本地或远程依赖项 SUB_PROJECTS 只有子项目。 SUB_PROJECTS_LOCAL_DEPS 只有子项目的本地依赖项(本地jar)。 TESTED_CODE 由当前变量(包括依赖项)测试的代码 TransformManager.SCOPE_FULL_PROJECT 处理所有的字节码 isIncremental() 是否增量构建。增量编译能有效提升编译速度。但是需要自己在transform方法里面根据增量文件的状态进行判断处理。 transform( xx) 就算什么都不做，也需要把所有的输入文件拷贝到目标目录下,否则下一个Task就没有TransformInput了。如果是此方法空实现，最后会导致打包的APK缺少.class文件 其他 TransformInput Transform 的 inputs 有两种类型，一种是目录，一种是 jar 包，要分开遍历 。 DirectoryInput 用来遍历目录 JarInput 用来遍历jar ( no Copyright，enjoy youself ! ) all right reserved，powered by GitbookThe file was updated at : 2021-06-07 10:18:27 "},"chinese/android基础/智能家居.html":{"url":"chinese/android基础/智能家居.html","title":"智能家居","keywords":"","body":"智能家居 http://hnyer.gitee.io/nativedev/chinese/linux/linux%E5%9F%BA%E7%A1%80.html?h=%E6%A0%91%E8%8E%93%E6%B4%BE 红外遥控器 红外遥控功能从Android4.4之后才开始支持。 家电遥控器通信距离往往要求不高，而红外的成本比其它无线设备要低的多，所以家电遥控器应用中红外始终占据着一席之地。 遥控器的基带通信协议很多，大概有几十种，常用的就有 ITT 协议、NEC 协议、Sharp 协议、Philips RC-5 协议、Sony SIRC 协议等。 用的最多的就是 NEC 协议了。 ConsumerIrManager Added in API level 19 。 格力空调遥控器 Sample ( ConsumerIrManager ) 请参考代码，搞清楚通信协议即可。 https://gitee.com/hnyer/GeliAirConditionerTool 所谓的万能遥控器就是有维护一个编码库， 不断搜集和更新上面上常用的编码库，然后去让用户去测试， 例如空调设备有反应了，就说明找到对应的编码库了。 NEC协议 有开发需求的时候 再查文档 进行调试。 https://gitee.com/hnyer/ir_-remote-control MediaPlayer 、 SoundPool MediaPlayer 不支持同时播放多个音频 。可以同时新建多个 MediaPlayer 实例进行播放，不过这样比较消耗系统资源。 如果需要同时播放多个音频，可以考虑 SoundPool 。 以下是我封装的 示例代码。 MediaPlayerHolder 、 SoundPoolTool (这个demo SoundPool 我做了限制，一次只能播放一个音频，需要播放多个的，需要修改一下) ( no Copyright，enjoy youself ! ) all right reserved，powered by GitbookThe file was updated at : 2021-07-12 10:27:12 "},"chinese/python/python基础.html":{"url":"chinese/python/python基础.html","title":"python部分","keywords":"","body":"Python 推荐使用 PyCharm 这个IDE进行代码编写。 Java 是强类型，编译型语言。 Python 是弱类型、解释型语言，运行速度比java慢。python的源码不能加密。 python -V //查看当前版本 python版本 import sys print (sys.version) python3 数据类型 Python中的变量不需要声明。 1、字符串 2、数字 3、列表 4、元组 5、集合 6、字典 7、日期 if 判断 age = 20 if age > 18: print('aaa') elif age >= 6: print('bbb') else: print('ccc') for 循环 list = [100, 200, 300] for temp in list: print(temp) while 循环 N = 10 x = 0 while x 6: break 列表 # 集合中数据类型可以不一样的 mList = ['Michael', 100, True] print(\"第一个数据=\" + mList[0]) print(\"最后一个数据=\" + str(mList[-1])) print(\"数组大小=\" + str(len(mList))) mList.append('AA') mList.insert(0, 'BB') # 删除最后一个 mList.pop() # 删除指定索引的数据 mList.pop(1) 元组 类似java中的数组 t = ('AA', 1 , True) print (t) 字典 dict = { 'Adam': 95, 'Lisa': \"aaaaaaa\", 'Bart': True } # 根据 key 获得 值 for mkey in dict: print(dict[mkey]) # 获得全部的值 for temp in dict.values(): print(temp) # 取出键值对 for key, value in dict.items(): print(key, ' ，', value) 类、对象 # 继承自 object class Person3(object): # 类属性 address='地球' # 构造方法 def __init__(self, name): # 对象属性 # 公开 self.name = name # 公开 self._sex = '女' #私有 self.__job = '学生'#外部不可以访问 # 类方法 @classmethod def getAddress(self): return self.address # 对象方法 def printInfo(self): print(\"当前对象名字是：\", self.name) # 设置、获取属性 p= Person3('小芳') setattr(p, 'name', 'small dog') msg = getattr(p, 'name') # 对象类型判断 if isinstance(p,object): print('类型判断正确') else: print('类型判断错误') 连接 mysql 安装 pymysql 插件。 如果使用的是pycharm， 是可以指定python环境目录的。方便灵活切换2.x和3.x . import pymysql from poetry.author import Author conn= pymysql.connect( host='114.xx.xx.65', port=3306, user='xx', passwd='xx',db='xx',charset='UTF8') print(\"获得数据库连接:\") print(conn) cursor = conn.cursor() def addAuthor(author): sql = ' insert into poetryauthor( mname, msex , mdesc, mpic,mtime,mtype ) values( \"%s\" ,\"%s\" ,\"%s\" ,\"%s\" ,\"%s\" ,\"%s\" ) '\\ % (author.mname, author.msex, author.mdesc, author.mpic, author.mtime, author.mtype) cursor.execute( sql) newId = int(conn.insert_id()) conn.commit() print(\"插入 新记录的id是: \", newId) def deleteAuthorById( mId): sql = 'delete from poetryauthor where mId = %d '% (mId) count = cursor.execute(sql) conn.commit() print(\"删除结果：\", count) def updateAutorById(author ,mId): sql = 'update poetryauthor set mname=\"%s\", msex=\"%s\", mdesc=\"%s\", mpic=\"%s\", mtime=\"%s\" , mtype=\"%s\" where mId=%d ' \\ % (author.mname, author.msex, author.mdesc, author.mpic, author.mtime, author.mtype, mId) count = cursor.execute(sql) print(\"更新结果：\", count) conn.commit() def queryAuthor(): count=cursor.execute('select * from poetryauthor') print('共有'+str(count)+' 条记录') rows = cursor.fetchall() for row in rows: mid = row[0] mname = row[1] msex = row[2] mdesc = row[3] mpic = row[4] mtime = row[5] mtype = row[6] print(mid, mname, msex , mdesc, mpic,mtime,mtype) # 测试 author = Author(\"李白2\", \"男1\" , \"牛逼诗人1\", \"baidu.com...png1\", \"唐代1\" , \"浪漫主义1\") # addAuthor(author) # queryAuthor() # deleteAuthorById(5) # updateAutorById(author , 6) # queryAuthor() # 关闭连接等... cursor.close() conn.commit() conn.close() 中文乱码 1、先用chardet检测读取到的内容的编码 chardet.detect(content) 2、转换成合适的编码格式 html = unicode(content, \"gb2312\").encode(\"utf8\") pip 安装库 pip 是Python的软件包管理系统，Python语言自带的命令行工具，它可以安装和管理第三方软件包。 pip install requests pip install beautifulsoup4 http://www.lfd.uci.edu/~gohlke/pythonlibs/ urllib、urllib2 在Python3已拆分更名为urllib.request和urllib.error urllib GET f=urllib.urlopen(\"http://m.cnblogs.com/\") s=f.read() print s 带参数 GET params = urllib.urlencode({'id': 8, 'name': 'jack', 'age': 25}) f = urllib.urlopen(\"http://localhost:18797/MailClient/test.aspx?%s\" % params) print f.read() POST params = urllib.urlencode({'id': 8, 'name': 'jack', 'age': 25}) f = urllib.urlopen(\"http://localhost:18797/MailClient/test.aspx\",params) print f.read() import urllib URL='http://192.168.0.102:8081/findYou/pointsApi/queryAllPointsTaskFy/{offset}/{limit}' URL= URL.replace('{offset}','0') URL = URL.replace('{limit}','1') f=urllib.urlopen(URL) s=f.read() print s //下载 import urllib import urllib.request import os def downCallBack(a, b, c): ''''' a:已经下载的数据块 b:数据块的大小 c:远程文件的大小 ''' per = 100.0 * a * b / c if per > 100: per = 100 print('下载进度： %.2f%%' % per) url = 'http://www.python.org/ftp/python/2.7.5/Python-2.7.5.tar.bz2' local = os.path.join('F:\\\\pythonDown\\\\', 'downDemo.zip') urllib.request.urlretrieve(url, local, downCallBack) ( no Copyright，enjoy youself ! ) all right reserved，powered by GitbookThe file was updated at : 2020-12-23 17:29:33 "},"chinese/python/python爬虫.html":{"url":"chinese/python/python爬虫.html","title":"python爬虫","keywords":"","body":"python 爬虫 古诗文网 爬取作者信息 (静态页面) // 数据库帮助类 class MySqlTool(object): def __init__(self): self.conn = pymysql.connect(host='xx.xx.xx.xx65', port=3306, user='xx', passwd='xx', db='xx', charset='UTF8') print(\"获得数据库连接:\") print(self.conn) self.cursor = self.conn.cursor() def addAuthor(self ,author): sql = \" insert into poetryauthor( mname, msex , mdesc, mpic,mtime,mtype ) values( '%s','%s','%s','%s','%s','%s' ) \" \\ % (author.mname, author.msex, author.mdesc, author.mpic, author.mtime, author.mtype) self.cursor.execute(sql) newId = int(self.conn.insert_id()) self.conn.commit() print(\"插入 新记录的id是: \", newId) def deleteAuthorById(self, mId): sql = 'delete from poetryauthor where mId = %d ' % (mId) count = self.cursor.execute(sql) self.conn.commit() print(\"删除结果：\", count) def updateAutorById(self, author, mId): sql = \" update poetryauthor set mname= '%s', msex='%s', mdesc='%s', mpic='%s', mtime='%s' , mtype='%s' where mId=%d \" \\ % (author.mname, author.msex, author.mdesc, author.mpic, author.mtime, author.mtype, mId) count = self.cursor.execute(sql) print(\"更新结果：\", count) self.conn.commit() def queryAuthor(self): count = self.cursor.execute('select * from poetryauthor') print('共有' + str(count) + ' 条记录') rows = self.cursor.fetchall() for row in rows: mid = row[0] mname = row[1] msex = row[2] mdesc = row[3] mpic = row[4] mtime = row[5] mtype = row[6] print(mid, mname, msex, mdesc, mpic, mtime, mtype) def closeConnection(self): # 关闭连接等... self.cursor.close() self.conn.commit() self.conn.close() // 作者类 class Author(object): # 构造方法 def __init__(self ,mname, msex , mdesc, mpic,mtime,mtype): self.mname = mname self.msex = msex self.mdesc = mdesc self.mpic = mpic self.mtime = mtime self.mtype = mtype # 对象方法 def printInfo(self): print(\"当前对象信息：\", self.mname, self.msex, self.mtime, self.mtype, self.mpic, self.mdesc) // 入口程序 user_agent = 'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_11_5)' headers = {'User-Agent': user_agent} session = requests.session() sqlTool = MySqlTool() def getAsleep(): sleepTime = random.uniform(0, 2) print(\"休眠：\", sleepTime) time.sleep(sleepTime) def getUrlData( url ,mTime): # print(\"--------------------------------------\") # print(url) page = session.get(url, headers=headers) soup = BeautifulSoup(page.text, 'lxml') # contents = soup.findAll('div', class='left') datas = soup.findAll(name='div', attrs={\"class\": \"left\"}) for data in datas: items = data.findAll( name= 'div',attrs={\"class\": \"sonspic\"}) for item in items: urlDiv = item.find( name= 'div',attrs={\"class\": \"divimg\"}) if not urlDiv is None: imgUrl= urlDiv.find(name= 'img') name= imgUrl['alt'] pic= imgUrl['src'] descP = item.find( name= 'p',attrs={\"style\": \" margin:0px;\"}) desc= descP.text pos = desc.index(\"►\") # 去掉无用的内容 desc = desc[0:pos] author = Author(name, \"\", desc, pic, mTime, \"\") author.printInfo() sqlTool.addAuthor(author) print(\"--------------------------------------\") dict = { # \"先秦\": 4, # \"两汉\": 10, \"魏晋\": 13, \"南北朝\": 20, \"隋代\": 3, \"唐代\": 232, \"五代\": 4, \"宋代\": 583, \"金朝\": 10, \"元代\": 64, \"明代\": 279, \"清代\": 598 } for mkey in dict: index = 0 sum = dict[mkey] while index 喜马拉雅 json解析 + 文件下载 import requests import urllib.request import demjson user_agent = 'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_11_5)' headers = {'User-Agent': user_agent} session = requests.session() def getAsleep(): sleepTime = random.uniform(0, 2) print(\"休眠：\", sleepTime) time.sleep(sleepTime) def downAFile(fileName ,fileUrl ,downCallBack): downPath = 'F:\\\\小伊\\\\%s.m4a'%(fileName) print(\"正在下载：\" ,fileName) urllib.request.urlretrieve(fileUrl, downPath ,downCallBack) def downCallBack(downedCount, countSize, allSize): per = 100.0 * downedCount * countSize / allSize if per > 100: per = 100 print('下载进度： %.2f%%' % per) def getUrlData( url ): page = session.get(url, headers=headers) jsonData = page.text bean1 = demjson.decode(jsonData) bean2 = bean1['data'] bean3 = bean2['tracksAudioPlay'] for data in bean3: name = data['trackName'] # print(\"名字：\" ,name) arrays= name.split(\"-\") if len(arrays) 权谋网 文章 // 获取文章列表 import requests from bs4 import BeautifulSoup user_agent = 'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_11_5)' headers = {'User-Agent': user_agent} session = requests.session() def getAndSaveUrl( url): print(url) page = session.get(url, headers=headers) soup = BeautifulSoup(page.text, 'lxml') contents = soup.findAll('div', id='contentleft') for child in contents: item = child.findAll('h2') for hValue in item: aValue = hValue.find('a') title = aValue.string url = aValue['href'] print(title) f = open('D:/网址.txt', 'a') f.write('\\n' + url) # sum大小 请根据网站最新页数调整 sum = 181 index =1 while index 每日毒鸡汤 public void getWeatherOfFoshanNanhai() { String url= \"https://lwdjt.com\"; String filePath =\"c://test/毒鸡汤.txt\" ; File file = new File(filePath); try { if(!file.exists()){ file.createNewFile(); } } catch (IOException e) { e.printStackTrace(); } FileWriter writer = new FileWriter(filePath, true); int count = 1; while (count ( no Copyright，enjoy youself ! ) all right reserved，powered by GitbookThe file was updated at : 2020-12-23 17:27:33 "},"chinese/gradle/Groovy.html":{"url":"chinese/gradle/Groovy.html","title":"Groovy","keywords":"","body":"Groovy groovy 简介 Groovy 是一种基于 JVM 的敏捷开发语言, 可以与 Java 完美结合，而且可以使用 Java 所有的库 Groovy 在语法上构建除了非常多的语法糖， 许多在 Java 层需要写的代码，在 Groovy 中是可以省略的。 既可以作为编程语言也可以作为脚本语言 Groovy 开发环境配置 1、配置JDK Groovy 依赖于Java ，所以需要 JDK。 2、配置 Groovy 库 https://groovy.apache.org/download.html 下载、解压。 3、测试环境 命令行输入 groovy -v ，如果打印 Groovy版本 说明配置成功。 4、自带编辑器 (不推荐) 使用 groovyconsole 命令会启动自带的编辑器。 按 CTRL + R 运行。 5、IntelliJ IDEA编辑 (推荐) IntelliJ IDEA 默认支持 Groovy ，无需额外安装插件。 基本数据类型 byte 、short 、int 、long 、 float double 、char 、Boolean 、String 其他数据类型 Byte 、Short Integer 、Long Float 、Double java.math.BigInteger java.math.BigDecimal 循环 while 、for 、for-in int[] array = [0,1,2,3]; for(int i in array) { println(i); } 定义变量 不用像Java那样指定明确类型，会自动判断类型。 def a = 100; println(a); def d = \"HelloWorld\"; println(d); 函数、方法 参数可以设置默认值 static int sum(int a,int b = 5) { int c = a+b; return c; } Groovy 闭包 // 无参闭包 def clos = { param -> println \"Hello ${param}\"}; clos.call(\"World\"); // 带参闭包 def str1 = \"Hello\"; def clos1 = {println \"${str1} ${it}\"}; clos1.call(\"World\"); // 闭包可以作为函数的参数 display(clos); // 数组使用闭包 def lst = [11, 12, 13, 14]; lst.each {println it} // 字典使用闭包 def mp = [\"TopicName\" : \"Maps\", \"TopicDescription\" : \"Methods in Maps\"] mp.each {println it} mp.each {println \"${it.key} maps to: ${it.value}\"} def static display(clos) { clos.call(\"aivin\"); } 相等判断 == 相当于 Java 的 equals， 如果需要比较两个对象是否是同一个，需要使用 .is()。 ( no Copyright，enjoy youself ! ) all right reserved，powered by GitbookThe file was updated at : 2021-04-16 09:16:01 "},"chinese/kotlin/kotlin部分.html":{"url":"chinese/kotlin/kotlin部分.html","title":"kotlin部分","keywords":"","body":"kotlin Kotlin 是 JetBrains 开发的基于 JVM 的语言。完全兼容java。 DSL（domain specific language） 领域专用语言：专门解决某一特定问题的计算机语言，比如 SQL 和正则表达式。 DSL 与系统编程语言走的是两个极端， 系统编程语言是希望解决所有的问题， 比如 Java 语言希望能做 Android 开发，又希望能做服务器开发，它具有横向扩展的特性。 而 DSL 具有纵向深入解决特定领域专有问题的特性。 DSL 的 核心思想 就是：“求专不求全，解决特定领域的问题”。 相关 库、工具 // Anko 以往的布局都是要从 XML 中解析出来。 而 Anko 则是直接创建 View，用代码构建布局，省去了解析 XML 的时间。 // ktor 由 Kotlin 团队打造的 Web 框架 ，可以用来编写服务器。 Kotlin Android 扩展 https://www.kotlincn.net/docs/tutorials/android-plugin.html findViewById() 。尽管存在一系列的开源库能够为这个问题带来解决方案。 现在 Kotlin 安卓扩展插件能够提供与这些开源库功能相同的体验，不需要添加任何额外代码。 apply plugin: 'kotlin-android-extensions' //扩展插件 import kotlinx.android.synthetic.main.＜布局＞.* //关联xml 访问范围 private, protected //子类可见 internal // 同一模块 public 数据类型 Byte、Short、Int、Long、Float、Double 、Boolean 、String 变量 、常量 var value : Int = 10 // 变量 val name : String =\"abcdedfdfa\" // 常量 类型转换 var info : String = \"100\" var info2 :Int = info.toInt() var info3 :String = info2.toString() 将y转为String类型 ，如果转换失败就会返回null 。 val x: String? = y as? String // 转换失败就会抛出异常 val x: String? = y as String 位运算符 shl —— 类似Java的> ushr —— 类似Java的>>> and —— 类似Java的& or —— 类似Java的| xor —— 同Java中的按位异或 ^ inv —— Java中的按位取反 - 函数 // fun ,有参数 ，有返回值 fun sum(a: Int, b: Int): String { return (a + b).toString() } // 无返回值 fun showInfo(a: Int, b: Int){ } // vararg是关键字 可变参数 fun vars(vararg v:Int){ for(vt in v){ //... } } 字符串模板 val age :Int = 20 var info :String =\"年龄是$age\" //复杂格式 var info2 = \"$info 字符串长度是${info.length}\" 集合 // List val list: List = listOf(1, \"2\", 3) val list1 = mutableListOf() // mutableListOf 和 ArrayList 区别不大 val list2 = ArrayList() // Array val faces = Array(5) { \"a\" } // Array初始化，大小5，初始值为\"a\" // Set val set: Set = setOf(1, \"2\", 3, \"3\") // Map val map: Map = mapOf(\"k1\" to \"v1\" , \"k2\" to 3) indices //collection.joinToString(xxx) 对集合中的元素进行简单的拼接 // collection.any(XXX) Returns `true` if at least one element matches the given [predicate]. 空指针 //? 表示可为null var ageString : String ? //?. 为空就返回null ，不是空 就返回 对应的值 ageString =student ?. name // ?: ageString 为空就用默认值 ，否则用取得的值 var info :String? info = ageString ?: \"21\" // !! 非空断言 ageString不为空时获取对应的值 ，否则直接报错 。 val length : Int = ageString!!.length // 判断是否为空 var flag : Boolean = ageString.isNullOrBlank() let 常与非空判断符?. 一起使用 mSurfaceTexture?.let { // compoundDrawables 不为空就执行... // it 是指 mSurfaceTexture mCamera?.setSurfaceTexture(it) } @标签 ## return@ return@XXlabel 语法用于指定此语句从几个嵌套函数中返回哪个函数。 对象 所有的类都继承自 Any 。 默认所有的类都是final类型 。 // (info: String) 是主构方法 open class Person (info: String){ // 可以被重写 open var info : String =\"人类\" var age1 : Int = 25 // 次构造函数 constructor(info: String ,age: Int) : this(info) { this. info = info this.age1 = age } // open 普通函数 ,可以被重新 open fun showInfo(){ } // 普通函数 不可以被重新 fun showInfo2(){ } } public class Student(info: String) : Person(info) { override var info : String =info // 次构造函数 constructor(info: String ,age: Int) : this(info) { this. info = info this.age1 = age } // override 重写函数 override fun showInfo() { super.showInfo() } } // 测试 var student1 : Student = Student(\"新人类\" ,19) var student2 : Student = Student(\"新人类\" ) 类初始化 kotlin增加了一个新的关键字init用来处理类的初始化问题， init模块中的内容可以直接使用构造函数的参数。 继承 Kotlin 中所有类都继承该 Any类，Any是所有类的超类。 如果一个类要被继承，需要用open 关键字进行修饰。 函数重写、属性重写 在基类中，使用fun声明函数时，默认不能被子类重写。如果需要被子类重写。 需要用open修饰它, 然后子类重写方法使用 override 说明 。 接口 interface Language { fun chinease(msg :String ) fun english(msg :String ) } // Person 是父类 ， Language是接口 public class Student(info: String) : Person(info),Language{ override fun english(msg: String) { } override fun chinease(msg: String) { } .... } Any 、 Unit 、Nothing Unit 类似于 Java中 的 Void 。 一切方法/函数都是表达式，表达式是总是有值的，所以每一个方法都必有一个返回值。 如果没有用 return 明确的指定，那么一般来说就会用自动帮我们加上 Unit . Nothing 在Java中并没有一个相似的概念。 Nothing 类型表达式计算结果永远是不会反回的。 //因为 pick 永远不会反回值，而是直接抛出了异常，这个时候可以用 Nothing 作为 pick 函数的返回值 fun pick(index: Int): Nothing { throw Exception() } apply 调用对象的apply函数，在函数范围内， 可以任意调用该对象的任意方法，并返回该对象。 with 将对象作为函数的参数，在函数内可以通过 this指代该对象。 返回值为函数的最后一行或return表达式 when 表达式类似 java 中的 switch . 可以用when替换复杂的if/else语句 。 在when中，else同switch的default。这是你给出的当你的表达式没有覆盖情况下的解决方案。 intArrayOf 创建一个int数组 循环 for(i in 0..9){ // [0,9] } (0 until 9){ // [0,9) } mapTo // mapTo 与循环搭配使用。此处的解释是： // [0 ,size)中循环取索引i ，新建BeanB对象，并将这些对象全部添加到集合 listA中 (0 until mTitles.size) .mapTo( listA) { BeanB( array1[it], array2[it] ) } 三目表达式 kotlin不支持。 请直接使用 if else来代替 data data class , 在 Kotlin 中，不需要自己动手去写一个 JavaBean， 可以直接使用 DataClass，使用 DataClass 编译器会默默地帮我们生成以下函数 。 双冒号 :: // 调用d对象的方法getResult d::getResult 原生字符串 三引号 A raw string is delimited by a triple quote (\"\"\" xxx \"\"\"), contains no escaping and can contain newlines and any other characters. val str:String= \"\"\" the price is$\\d 199 \"\"\" 拓展函数 如果一个类没有定义某个功能，可以在类外（具体使用的地方）写一个拓展函数。 拓展函数名可以跟类的原有函数名字相同，但是会优先使用类的原有函数。 空对象也可以使用拓展函数。 this指的是被改造的那个对象是例。 class User(var name:String) /**扩展函数**/ fun User.Print(){ print(\"用户名 $name\") } fun main(arg:Array){ var user = User(\"Runoob\") user.Print() } 伴生对象 Kotlin移除了static 的概念。 通常用 object 和 companion object 来实现 使用\"object\"修饰静态类 被修饰的类，可以使用类名.方法名的形式调用 var version_name1 = Util.getName() object Util { fun getName(): String { return BuildConfig.VERSION_NAME } } 使用\"companion object\"修饰静态方法 可以使用类名.方法名的形式调用 var version_name2 = Util2.getName() class Util2 { companion object { fun getName(): String { return BuildConfig.VERSION_NAME } } } 数据类 kotlin的数据类 类似java中手动创建的 javaBean ，用来传递数据 。 用关键字 data 申明。 数据类不能继承其他类（可以实现其他接口） 。 在使用数据类时，与普通类无异 。 密封类 用关键字 sealed 申明。 密封类就像一个更强大的枚举。密封类只有固定子类 。 枚举 enum class Color{ RED,BLACK } 枚举可以被初始化 enum class Color(val rgb: Int) { RED(0xFF0000), GREEN(0x00FF00) } 挂起函数 用 Suspend 修饰 等xx函数执行完才会输入某个结果。 但是线程并不会阻塞。 类似回调的使用 协程 Coroutine 协程并不是 Kotlin 提出的，概念已经提出很久了。 java 原生语法暂未支持 ,但是可以通过一些第三方的框架来实现。 对操作系统来说，线程是最小的执行单元，进程是最小的资源管理单元。 协程不是被操作系统内核所管理，是完全由程序所控制的。 一个进程可以拥有多个线程一样，一个线程可以拥有多个协程。 当系统线程较少的时候没有什么问题，当线程数量非常多的时候，却产生了问题。 一是系统线程会占用非常多的内存空间，二是过多的线程切换会占用大量的系统时间。 协程运行在线程之上，当一个协程执行完成后，可以选择主动让出，让另一个协程运行在当前线程之上。 协程并没有增加线程数量，只是在线程的基础之上通过 分时复用 的方式运行多个协程， 协程的切换在用户态完成，切换的代价比线程从用户态到内核态的代价小很多。 协程跑在单个线程内，是单线程下的并发 。不适合 CPU 密集型任务 ，适合 IO密集型任务。 此外，协程代码中决不能出现阻塞，否则整个线程都会停下来等待该操作完成。 kotlin 协程 引入 https://github.com/Kotlin/kotlinx.coroutines implementation 'org.jetbrains.kotlinx:kotlinx-coroutines-core:1.4.2' implementation 'org.jetbrains.kotlinx:kotlinx-coroutines-android:1.4.2' val jobWork= GlobalScope.launch( Dispatchers.Main ){ }// 工作线程 val mainWork =GlobalScope.launch(Dispatchers.IO) { }// 主线程切换 jobWork.cancel() // 取消协程 协程作用域 CoroutineScope 暂未学习 协程上下文 CoroutineContext 暂未学习 命名参数 、 默认参数 函数定义：第一个参数没有默认值，后面的都有默认值 fun reformat(str: String, normalizeCase: Boolean = true, upperCaseFirstLetter: Boolean = true, divideByCamelHumps: Boolean = false, wordSeparator: String= \"bbb\") { // .... } //不会引起歧义的时候调用 (全部使用默认值) reformat(\"tom\") //有歧义时，必须要指定参数名字。 指定命名。否则不知道你要将值赋给谁 reformat(\"tom\" , upperCaseFirstLetter= false) kotlin main 入口函数 fun main(args: Array){ println(\"hello kotlin\") } java 调用 kotlin // Companion 是关键字 ， newInstance 是kotlin中的静态方法 mFragments[FIRST] = DeviceFragment.Companion.newInstance(); kotlin 调用 java val javaDemo = JavaDemo() //新建对象 val msg =javaDemo.helloMsg // 调用对象的方法 println(\"msg=\"+ msg) kotlin 调用 jni external表示将一个声明标记为不是在 Kotlin 中实现. init { System.loadLibrary(\"joke-lib\") } external fun getWXAPPID(): String init kotlin增加了一个新的关键字 init 用来处理类的初始化问题， init模块中的内容可以直接使用构造函数的参数。 对象表达式 对象表达式，是一种代替Java中的匿名内部类的方法。 使用object关键字来进行编写。比匿名内部类更先进。 可以实现多个接口。 // 关键 object : 指明 tab_layout.setOnTabSelectListener( object : OnTabSelectListener { // 设置监听函数 }) 监听函数 private val onGestureListener = object : RecordButton.OnGestureListener { override fun onUp() { } } 新建对象 java中新建对象要用到new 关键字。 kotlin中没有new关键字。 直接写类名 即可。 get set 方法 kotlin中可以直接使用对象的属性，不用调用 get和set方法。 //这是FragmentActivity.java中的源码 public FragmentManager getSupportFragmentManager() { return mFragments.getSupportFragmentManager(); } 为了获得一个 FragmentManager 实例， java中需要这样写 this.getSupportFragmentManager() , 而kotlin中可以直接这样使用 this.supportFragmentManager 注意 getSupportFragmentManager 和getSupportFragmentManager 之间的特点。（符合set和get的命名规范的） //var 默认有get set方法。不写就用默认的。 var heiht: Float = 145.4f private set // 说明这个set方法是私有的 // 重写了get方法 private val isViewAttached: Boolean get() = mRootView != null 延迟初始化 、 懒加载 lateinit 和 lazy 、notNull 1、lateinit 、notNull 只用于var，lazy只用val 2、lateinit 不能用在可空的属性上和 基本类型上。 让编译期忽略对属性未初始化的检查，后续在哪里以及何时初始化还需要开发者自己决定。 （让编译器别BB，我知道这个变量一定要初始化，别老是提醒我） 3、lazy 用到的时候才会调用，生成过程只会执行一次， 多次调用用到的是第一次生成的结果 。 private val linearLayoutManager by lazy { LinearLayoutManager(activity, LinearLayoutManager.VERTICAL, false) } 4、一般情况使用lateinit修饰符，最为优雅。 当类型是原生类型，或者为局部变量时，只能只用notNull委托。 var context: Context by Delegates.notNull() 委托 by Kotlin 直接支持委托模式 。 委托属性也是一种 约定 。 setValue 和 getValue都需带有 operator 关键字修饰。 operator fun getValue(thisRef: Any?, property: KProperty): T { return xx } operator fun setValue(thisRef: Any?, property: KProperty, value: T) { // } 星号 * 将数组展开并传入可变参数 val arr = intArrayOf(2, 1, 3) sumTest( * arr) // 星号的意思是将数组中的值取出来作为可变参数 private fun sumTest( vararg values :Int ){ // 参数是可变参数 } 泛型 跟java的泛型差不多。参考java即可。 return@ return@XXlabel 语法用于指定此语句从几个嵌套函数中返回哪个函数。 ( no Copyright，enjoy youself ! ) all right reserved，powered by GitbookThe file was updated at : 2021-06-23 17:00:40 "},"chinese/flutter/flutter部分.html":{"url":"chinese/flutter/flutter部分.html","title":"flutter部分","keywords":"","body":"flutter部分 flutter 配置 1、修改整个工程的文件夹名字， 修改后需要在工程里 重新命名xxx.imld的名字（例如 wk-weather.iml ） 2、版本号在 pubspec.yaml version 中配置 version: 1.0.20201109+1 1.0.20201109 是版本标记 ， 1是版本号 3、隐藏右上角 debug 标记 debugShowCheckedModeBanner: false, Your Flutter application is created using an older version of the Android embedding. It's being deprecated in favor of Android embedding v2 在 application 标签下 添加 签名配置 keystore 跟Android 工程 一样配置即可。 app 显示调试模式界面 import 'package:flutter/rendering.dart'; void main() { debugPaintSizeEnabled = true; runApp( ) ; } flutter工程中 Android部分爆红 如果工程能正常运行，请不要理会。 编写Android部分代码时你重新用Androidstudio打开Android部分即可，它也是一个Android工程。 // 如果是 build.gradle 中 Properties 、GradleException 爆红 按照提示引入 sdk ，并将 GradleException 改成 Exception ，然后重新刷新工程即可。 flutter 插件开发 Android项目部分爆红 在Android的 build.gradle下加入以下配置，引入 flutter.jar即可。 //获取local.properties配置文件 def localProperties = new Properties() def localPropertiesFile = rootProject.file('local.properties') if (localPropertiesFile.exists()) { localPropertiesFile.withReader('UTF-8') { reader -> localProperties.load(reader) } } //获取flutter的sdk路径 def flutterRoot = localProperties.getProperty('flutter.sdk') if (flutterRoot == null) { throw new GradleException(\"Flutter SDK not found. Define location with flutter.sdk in the local.properties file.\") } dependencies { compileOnly files(\"$flutterRoot/bin/cache/artifacts/engine/android-arm/flutter.jar\") } flutter BloC 模式 业务逻辑组件 （Business Logic Component ），实际上BloC设计模式，似乎和MVP没有什么本质区别， 两种设计模式的最终目的就是为了把和UI糅合在一起的业务逻辑代码剥离开来，单独的抽取到一层中。 项目类型 Flutter Application Flutter Application 表示一个Flutter项目，主体是Flutter， 当然它也可以接入Android Module 或者 iOS Framework， 其内部包含 Android 和 iOS 项目。以后可能会支持其他平台。 Flutter Plugin Flutter Plugin 表示 Flutter 插件，包含 Android 和 iOS 项目， 如果你要开发一个 Plugin 且此 Plugin 涉及到原生支持，比如蓝牙功能、网络功能等， 这些功能纯 Flutter 是无法实现的。 Flutter Plugin 开发完成后可以发布到 pub 上。 Flutter Package Flutter Package 和 Flutter Plugin 基本一样，唯一的区别是Flutter Package表示纯 Flutter 模块， 不需要原生开发，没有Android 和 iOS 项目，比如开发一个纯 UI 的插件。 Flutter Module Flutter Module 用于原生项目中插入 Flutter 模块，原生为主体，与 Flutter 进行混合开发。 json // 举例使用 // json.decode(modelStr) // Parses the string and returns the resulting Json object // json obj 转对象 WeatherModelEntity weatherModelEntity = WeatherModelEntity().fromJson(json.decode(modelStr)); ------------------ json部分的代码使用 FlutterJsonBeanFactory 插件生成的 。 https://plugins.jetbrains.com/plugin/11415-flutterjsonbeanfactory 如果改变了结构，需要在变动过的文件上 alt+ j 重新生成 json_convert_content.dart ------------------ 1、将 json 字符串转为 map 格式的json 对象 import 'dart:convert'; //系统自带 2、将 json 对象转为 实体类对象 借助第三方工具 FlutterJsonBeanFactory 简化人工代码 国际化 翻译支持 系统自带的控件 国际化 Flutter给我们提供的Widget默认情况下就是支持国际化。例如时间日期选择控件。 1、 pubspec.yaml中新增配置 flutter_localizations:# 国际化支持 包 sdk: flutter 2、 对 MaterialApp 进行配置 return MaterialApp( title: 'Flutter Demo', // localizationsDelegates 指定哪些Widget需要进行国际化 localizationsDelegates: [ GlobalMaterialLocalizations.delegate, // Material GlobalCupertinoLocalizations.delegate, // Cupertino GlobalWidgetsLocalizations.delegate // Widgets ], // supportedLocales 支持哪些 语言 supportedLocales: [ Locale(\"en\"), Locale(\"zh\") ], 自定义控件、文本、信息展示 国际化 大部分情况，是需要对自定义的控件或信息等进行国际化。 为了方便快速，一般使用第三方插件 Flutter intl 进行配置。 1、安装插件，重启 Androidstudio 2、 pubspec.yaml中新增配置 flutter_localizations:# 国际化支持 包 sdk: flutter 3、在Tools栏目下找到 Flutter Intl 进行初始化。 初始化后 ， pubspec.yaml 中会新增配置 flutter_intl: enabled: true lib 目录下 会新增 generated 、l10n文件夹 4、在Tools栏目下找到 Flutter Intl 添加语言支持 ，例如 en_IN, zh_CN, de_DE 5、在 l10n 目录下 找到对应的文件，进行语言配置 ，例如 { \"string_title\": \"测试标题\" , \"string_Name\": \"测试名字\" } 6、 在 MaterialApp 中进行多语言支持配置 。 return MaterialApp( title: \"123123\", // 快照上显示的APP名字 // title: S.of(context).string_title, // 这里使用会报错， localizationsDelegates: const [ S.delegate, GlobalMaterialLocalizations.delegate, GlobalCupertinoLocalizations.delegate, GlobalWidgetsLocalizations.delegate ], supportedLocales: S.delegate.supportedLocales, localeListResolutionCallback: (locales, supportedLocales) { // 设备支持的语言 print(\"---------$locales\"); return; }, 7、使用 Text( S.of(context).string_title ) // S是自定生成的代码定义的类名 Text( S.current.string_title ) 屏幕适配 final mediaQueryData = MediaQuery.of(context); // 逻辑宽高 final screenWidth = mediaQueryData.size.width; final screenHeight = mediaQueryData.size.height; // 物理宽高、分辨率 final physicalWidth = window.physicalSize.width; // import 'dart:ui'; final physicalHeight = window.physicalSize.height; // 密度 final dpr = window.devicePixelRatio; // 状态栏高度 final statusBarHeight = mediaQueryData.padding.top; // 底部高度 final bottomHeight = mediaQueryData.padding.bottom; flutter的长度单位是 dp ，而不是px ,适配方案参考Android的适配经验即可。 无论设计稿的单位是px,或者是dp,我们都能够转换成px。 1、先将设计稿换成 dp为单位的设计稿 例如 1920 * 1080 ( px ) 2、转换原理(比例一样)如图. flutter 运行模式 release //发布模式 profile // 性能模式 debug // 调试模式 flutter run --release flutter run --debug // It's likely that this file was generated under xxx \\build, but the tool couldn't find it. 这个问题 我这边导致的原因是 签名信息配置错了 ， 不能改成 wk2017之类的 ， 要用 release 或者debug ， 或者干脆不要签名。 Androidstudio 菜单下的 Flutter fun xxx.dart in release/profile mode 。 状态管理 1、添加支持 provider: ^4.3.2+2 https://pub.flutter-io.cn/packages/provider/install 2、定义共享数据类 xxx extends ChangeNotifier notifyListeners(); // 通知刷新 3、ChangeNotifierProvider 将数据共享类 和 widget 关联起来 Widget someWidget = ChangeNotifierProvider( create: (context) => GlobalModel(), // ChangeNotifier child: child, // Widget ); 4、更新数据 var shareBean = Provider.of(context); // 如果 Widget 和 ChangeNotifier 没有关联过，是不是就是null？ shareBean.xxx = \"abc\" // 更新数据 引入本地第三方库 1、在工程目录下新建一个文件夹存放插件，比如plugin 2、打开工程的pubspec.yaml，在dependence里添加plugin下的插件 //本地插件引用 注意缩进格式 webview_flutter: path: plugin/webview_flutter flutter 插件开发 1、新建插件工程 2、调用者中 引入插件地址 wk_flutter_plugin: path: wk_flutter_plugin # 本地flutter插件库 msg_plugin flutter 与 Android 数据 交互 有些功能，flutter暂时不支持(例如蓝牙)，所以需要用Android开发获得数据，然后传递给蓝牙。 flutter和Android通信的方式目前主要可以采用 MethodChannel // flutter调用方法，方法返回，一问一答模式 EventChannel // Android端不断往flutter发送数据 ，单向? BasicMessageChannel // 双向通信 注意：新建通道对象时 ，flutter 和 Android 端，name 参数是对应的， public class MainActivity extends FlutterActivity implements MethodChannel.MethodCallHandler { int count = 0; @Override protected void onCreate( ... ) { super.onCreate(savedInstanceState); Activity activity = this ; new Thread(new Runnable() { @Override public void run() { while(true){ try { Thread.sleep(500); } catch (InterruptedException e) { e.printStackTrace(); } if(eventSink==null){ WkLog.showLog(\"myEvent ==null\"); }else{ count ++ ; activity.runOnUiThread(new Runnable() { @Override public void run() { if(count%2==0){ eventSink.success(\"hello android...\"+count); }else{ eventSink.error(\"500\" ,\"发生异常\" ,null); } } }); } if(basicMessageChannel!=null){ activity.runOnUiThread(new Runnable() { @Override public void run() { basicMessageChannel.send(\"Android主动发送消息 \" + count); } }); }else{ WkLog.showLog(\"basicMessageChannel ==null\"); } } } }).start(); } private final String KEY_METHODCHANNEL =\"KEY_METHODCHANNEL_20201124\" ; private final String KEY_EventChannel =\"KEY_EventChannel_20201124\" ; private final String KEY_BasicMessageChannel =\"BasicMessageChannel_20201124\" ; private MethodChannel methodChannel; private EventChannel.EventSink eventSink = null ; private BasicMessageChannel basicMessageChannel; // configureFlutterEngine 函数 在 onCreate 之前执行 @Override public void configureFlutterEngine(@NonNull FlutterEngine flutterEngine) { super.configureFlutterEngine(flutterEngine); initEngineConfig(flutterEngine); } private void initEngineConfig(FlutterEngine flutterEngine){ // MethodChannel methodChannel = new MethodChannel(flutterEngine.getDartExecutor(), KEY_METHODCHANNEL); methodChannel.setMethodCallHandler(this); // EventChannel EventChannel eventChannel =new EventChannel( flutterEngine.getDartExecutor() ,KEY_EventChannel); eventChannel.setStreamHandler( new EventChannel.StreamHandler() { @Override public void onListen(Object arguments, EventChannel.EventSink events) { // events 传出去，用来主动发送数据 eventSink =events ; } @Override public void onCancel(Object arguments) { } }); // basicMessageChannel = new BasicMessageChannel ( flutterEngine.getDartExecutor() , KEY_BasicMessageChannel, StringCodec.INSTANCE); // StandardMessageCodec.INSTANCE basicMessageChannel.setMessageHandler( new BasicMessageChannel.MessageHandler() { @Override public void onMessage(Object message, BasicMessageChannel.Reply reply){ String str = (String) message; WkLog.showLog(\"收到来自flutter=\"+ str); } }); } @Override public void onMethodCall(MethodCall call, MethodChannel.Result result) { if (call.method.equals(\"userLogin\")) { String hostIp = call.argument(\"hostIp\"); String hostPort = call.argument(\"hostPort\"); result.success(hostIp+ \" \"+hostPort + \"登录成功...\" + System.currentTimeMillis()) ; }else { result.notImplemented(); } } } class MsgTransmissionTool { static String KEY_METHODCHANNEL =\"KEY_METHODCHANNEL_20201124\" ; static String KEY_EventChannel =\"KEY_EventChannel_20201124\" ; static String KEY_BasicMessageChannel =\"BasicMessageChannel_20201124\" ; static MsgTransmissionTool _instance ; static MsgTransmissionTool getinstance() { if(_instance ==null){ _instance = MsgTransmissionTool() ; } return _instance ; } MethodChannel methodChannel ; EventChannel eventChannel ; BasicMessageChannel basicMessageChannel ; MsgTransmissionTool(){ // todo 重要注释： 要先在 flutter端新建初始化这些对象，否则Android端的那些对象是空的。 methodChannel = MethodChannel(KEY_METHODCHANNEL); eventChannel = EventChannel(KEY_EventChannel ); basicMessageChannel = BasicMessageChannel( KEY_BasicMessageChannel, StringCodec()); // StandardMessageCodec } setMessageHandler( Future Function( dynamic message) handler ){ if(basicMessageChannel!=null){ basicMessageChannel.setMessageHandler(handler) ; } } setEnventChannelListener( void onData(dynamic event) ,void _onError(dynamic event) ){ if(eventChannel!=null){ eventChannel.receiveBroadcastStream().listen( onData, onError: _onError); } } void sendMsgByBasicMessageChannel(String msg) async { if(basicMessageChannel!=null){ await basicMessageChannel.send(msg ); } } Future sendMsgByMethodChannel( String hostIp ,String hostPort) async { if(methodChannel!=null){ final String version = // 参数以键值对的方式传递过去 await methodChannel.invokeMethod('userLogin' , {\"hostIp\":hostIp , \"hostPort\":hostPort}); return version; }else{ print(\"methodChannel ==null\"); } return null ; } } // 使用 // 设置监听函数 _initTool() async{ await MsgTransmissionTool.getinstance().setMessageHandler( ongetMsgFromMessageChannerl); await MsgTransmissionTool.getinstance().setEnventChannelListener( _onEvent , _onError); } void _onEvent(Object event) { setState(() { msg2 = event ; }); print(\"收到数据==_onEvent==$event\"); } void _onError(Object error) { PlatformException exception = error ; setState(() { msg2 = \" ${ exception.message} , ${exception.code} \"; }); print(\"收到数据==_onError\"); } Future ongetMsgFromMessageChannerl( dynamic message) { setState(() { msg3= message ; }); } // 往Android发送数据 Future testSend() async { String result = await MsgTransmissionTool.getinstance().sendMsgByMethodChannel(\"192.168.1.1\" ,\"8080\"); setState(() { loginResult=result ; }); MsgTransmissionTool.getinstance().sendMsgByBasicMessageChannel(\"BasicMessageChannel 给Android 发送消息\") ; } flutter 调用Android控件 // Android 端 新建 View 和工厂类 class MyView implements PlatformView { private TextView textView; MyView(Context context ) { // configureFlutterEngine 函数 在 onCreate 之前执行 ，所以不能通过 findViewById 方式获得控件 //View rootView = inflater.inflate(R.layout.testlayout, null); //rootView.findViewById() TextView myNativeView = new TextView(context); myNativeView.setTextColor(Color.RED); myNativeView.setClickable(true); myNativeView.setOnClickListener(new View.OnClickListener() { @Override public void onClick(View view) { textView.setTextColor(Color.BLUE); Toast.makeText(context ,\"hello android\" ,Toast.LENGTH_SHORT).show(); } }); this.textView = myNativeView; } public void updateValue(String value){ textView.setTextColor(Color.RED); textView.setText(\"----> \"+value); } @Override public View getView() { return textView; } @Override public void dispose() { } } public class MyViewFactory extends PlatformViewFactory { private MyView myView ; public MyViewFactory( ) { super(StandardMessageCodec.INSTANCE); } @Override public PlatformView create(Context context, int id, Object args) { myView = new MyView(context) ; // 新建时 传递过来的参数 Map params = (Map) args; String value = params.get(\"key123456\") ; myView.updateValue(value); return myView; } } // 在XXActivity中 注册这个控件 @Override public void configureFlutterEngine(@NonNull FlutterEngine flutterEngine) { super.configureFlutterEngine(flutterEngine); PlatformViewRegistry registry = flutterEngine.getPlatformViewsController().getRegistry() ; myViewFactory = new MyViewFactory() ; // platform_text_view12345678 是全局唯一的，要与flutter端对应使用 registry.registerViewFactory(\"platform_text_view12345678\",myViewFactory) ; } // flutter端 通过 AndroidView 来包裹调用 var androidView = AndroidView( viewType: \"platform_text_view12345678\", creationParams: {\"key123456\": \"我来自flutter\"}, creationParamsCodec: const StandardMessageCodec()); Container( // width: 80, height: 80, child: androidView, ) , flutter第三方库 package_info 获取版本号等 版本号在 pubspec.yaml version 中配置 https://pub.flutter-io.cn/packages/package_info PackageInfo.fromPlatform().then((PackageInfo packageInfo) { String appName = packageInfo.appName; String packageName = packageInfo.packageName; String version = packageInfo.version; String buildNumber = packageInfo.buildNumber; }); url_launcher 通过 url 打开第三方应用 ，例如网址打开浏览器 ， 拨打电话，调用第三方APP等。 https://pub.flutter-io.cn/packages/url_launcher/install _launchURL() async { const url = 'tel:13457980678'; // 唤起电话界面 // const url = 'weixin://'; 唤起微信 //const url = 'http://typhoon.zjwater.gov.cn/wap.htm'; // 打开浏览器 if (await canLaunch(url)) { await launch(url); } } flutter_bloc https://pub.flutter-io.cn/packages/flutter_bloc // Bloc 业务逻辑组件 (Business Logic Component) 。 Bloc 将 Event 事件转换为 States 状态. 每个 Bloc 都有一个 add 方法，用来添加新的 Event 到 mapEventToState 中； // BlocBuilder extends StatefulWidget ... 构造器，主要用于构建 Widget 。 // BlocProvider extends Widget ... BlocProvider 为 Bloc 的供应者； // MultiBlocProvider extends Widget ... 是一个用于将多个BlocProvider合并为一个BlocProvider的组件。 // BlocListener t extends Widget ... 用于监听状态变更，可在此做出相应的业务处理； shared_preferences key-value 存储插件， 跟android SharedPreferences 的类似。 https://pub.flutter-io.cn/packages/shared_preferences SharedPreferences prefs = await SharedPreferences.getInstance(); prefs.setString(KEY_CITY_MODELS, encodeStr); // 保存 var parseValue = prefs.getString(KEY_CITY_MODELS); // 获取 prefs.remove(key); prefs.clear(); dio http 网络访问框架。 Dart Http请求库，支持Restful API、FormData、拦截器、请求取消、Cookie管理、文件上传/下载、超时。 int timeout = 15 *1000 ; BaseOptions options = BaseOptions( baseUrl: \"https://www.baidu.com/\", connectTimeout:timeout , receiveTimeout:timeout , sendTimeout:timeout ); Dio dia = Dio(options) ; Interceptor dInter = InterceptorsWrapper( onRequest: (RequestOptions options) { return options; // 拦截请求 }, onResponse: (Response response) { return response; // 拦截响应 }, onError: (DioError error) { // 拦截异常 print(\"拦截了错误\"); return error; } ); dia.interceptors.add( dInter); // 添加拦截器 String url=\"https://www.baidu.com/\" ; Map param= Map() ; Response response = await dia.get(url, queryParameters: param); // get 请求 var result = response.data ; print(\"请求结果=\"+ result); event_bus 消息传递框架 https://pub.flutter-io.cn/packages/event_bus https://github.com/marcojakob/dart-event-bus EventBus eventBus = EventBus(); eventBus.fire(\"helloflutter\"); // 发送 StreamSubscription streamSubscription =eventBus.on().listen((event){ // 接收 }); streamSubscription.cancel() ; // 取消监听 streamSubscription.pause() ;// streamSubscription.resume() ;// flutter_screenutil flutter 屏幕适配方案，让你的UI在不同尺寸的屏幕上都能显示合理的布局。 https://pub.flutter-io.cn/packages/flutter_screenutil https://github.com/OpenFlutter/flutter_ScreenUtil //设置适配尺寸 (填入设计稿中设备的屏幕尺寸) 此处假如设计稿是按iPhone6的尺寸设计的(iPhone6 750*1334) // 设置字体大小是否根据系统的“字体大小”辅助选项来进行缩放 // ScreenUtil.init(context); //默认 width : 1080px , height:1920px , allowFontScaling:false ScreenUtil.init(context,designSize: Size(750, 1334), allowFontScaling: false); // var width = 1.wp ; var width = 1.sw ; // screen height var width2 = 0.2.sw ; // screen height 屏幕宽度的0.2倍 ScreenUtil().pixelRatio ; //设备的像素密度 ScreenUtil().screenWidth ; // (sdk>=2.6 : 1.sw) //设备宽度 ScreenUtil().screenHeight ; //(sdk>=2.6 : 1.sh) //设备高度 ScreenUtil().bottomBarHeight ; //底部安全区距离，适用于全面屏下面有按键的 ScreenUtil().statusBarHeight; //状态栏高度 刘海屏会更高 单位dp ScreenUtil().textScaleFactor; //系统字体缩放比例 ScreenUtil().scaleWidth ; // 实际宽度的dp与设计稿px的比例 ScreenUtil().scaleHeight; // 实际高度的dp与设计稿px的比例 modal_bottom_sheet 底部弹窗控件 https://pub.flutter-io.cn/packages/modal_bottom_sheet https://github.com/jamesblasco/modal_bottom_sheet 可以直接用系统控件，没必要用这个。 path_drawing 绘制虚线的工具 https://pub.flutter-io.cn/packages/path_drawing Path _path = Path(); Canvas canvas ; Paint _paint = Paint(); canvas.drawPath( dashPath(_path, dashArray: CircularIntervalList([10, 5])), // 每个线段长度、间隔长度 _paint); toast https://pub.flutter-io.cn/packages/toast Toast.show(\"Toast plugin app\", context, duration: Toast.LENGTH_SHORT, gravity: Toast.BOTTOM); Toast.show(msg, context, duration: duration, backgroundColor: backgroundColor, textColor: textColor, backgroundRadius: backgroundRadius, border: border); flutter_tts 语音播报 https://pub.flutter-io.cn/packages/flutter_tts ota_update 升级、 下载apk https://pub.flutter-io.cn/packages/ota_update cupertino_icons 一个icon图标库，具体怎么用 不知道。 https://pub.flutter-io.cn/packages/cupertino_icons equatable 用来简化 对象比较的一个库。 这个库内部做了一些处理，让我们简单地用 == 即可判断对象是否相等，不用重写hashcode。 https://pub.flutter-io.cn/packages/equatable dart 语法 dart 文件名和类名 可以不一样。这点跟Java不一样。 在变量中可以放置的所有东西都是对象，而每个对象都是类的实例。无论数字、函数和null都是对象。 如果要明确说明不需要任何类型，请使用[特殊类型dynamic]。 胖箭头语法 = >expr 语法是{return expr;}的简写写法。“=>”符号有时被称为胖箭头语法。 => expr 等同于{ return expr; } 可见性 // 可见性 ，public private 跟Java不一样 Dart没有公开、保护和私有的关键字。 如果标识符以下划线(_)开头，则该标识符对其库是私有的。 final 、const final和const区别 ： const可以使用其他const常量的值来初始化其值。 final dt = DateTime.now();//正确，运行时有确定的值 const dt = const DateTime.now();//错误，需要编译时有确定的值 // 初始化后不能再赋值 final a = 'aaa'; a = 'abc'; //错误 const b = 'bbb'; b = 'abc'; //错误 //不能和var同时使用 final var d = 'abc';//错误 const var e = 'abc';//错误 数字类型 // 数字类型 只有 int 和 double var one = int.parse('1'); var msg = 3.156.toString() ; var msg2 = 3.156.toStringAsFixed(2); 变量 的初始值 未初始化的变量的初始值为null。 甚至具有数字类型的变量最初也是null，因为数字，就像dart中的其他东西一样也是对象。 在Dart2中new关键字是可选的。 即 new 关键字可写可不写。 Dart是一种真正的面向对象语言，所以即使函数也是对象。 b ??= value; // 仅仅在b为空的情况下b被赋值value ，否则b的值不变 print(person ?.name) // person 为空 就直接返回null ，不为空 就返回 name的值 类型 判断 、转换 if (emp is Person) // 类型判断 is (emp as Person) // 类型转换 as 字符串 // 用r前缀创建一个原始字符串 (即 转义字符没有被转义) var msg1 = r'In a raw string, not even \\n gets special treatment.'; // 多行字符串 ，用 + 连接 ，或者是 带有单引号或双引号的三重引号 var msg1 = '''1111 222222 33333 '''; 字符串用 等号 == 来判断对象是否相等，跟Java不太一样。 var msg1 =\"abc1\" ; var msg2 =\"abc\"+\"1\" ; print(msg1==msg2) ; // true 函数 // 命名函数 ，可以带有默认值 void enableFlags( { int age =18, String myName } ) { print( \"age=$age ,name=$myName\") ; // age=20 ,name=aivin } // age 和 myName 在函数中已经定义了，相当于直接初始化，此处 age 不能写成其他 age1等 enableFlags( age: 20, myName: \"aivin\"); // 位置参数 void say(String from, String msg, [ int time]) { var result = '$from says $msg $time'; // aivin says 现在时间是: null print(result) ; } say('aivin' ,'现在时间是:' ) ; // 级联操作符 ，跟Java的链式调用差不多 Address address = Address(); address ..street = '北京市' ..number = '12' ..name = '西城区' 所有函数都返回一个值。如果没有指定返回值，则语句返回null;隐式附加到函数体。 // 匿名函数 Function showMsg = (int x, String y) { print(\"$x \"); }; 列表、数组 var list = [1, 2, 3]; // 可变列表、数组 var list2 = const [1, 2, 3]; // 常量列表 构造函数 // 构造函数 class Point { num x, y; Point(num x, num y) { this.x = x; this.y = y; } } 可以简写成 ---> class Point { num x, y; Point(this.x, this.y); // 语法糖，构造函数的简写 } --------------------------------------------------- class Point { num x, y; // 类名构造函数 Point(this.x, this.y); // 命名构造函数 Point.order(this.x,this.y); // 重定向构造函数， origin构造函数将外界的传值，指向给了order构造函数。 Point.origin(num a,num b):this.order(a,b); } --------------------------------------------------- class Person { String firstName; Person.fromJson(Map data) { print('in Person'); } } class Employee extends Person { // 调用父类构造函数， 语法与Java不一样。 // 先打印 in Person ， 后打印 in Employee Employee.fromJson(Map data) : super.fromJson(data) { print('in Employee'); } } main() { var emp = new Employee.fromJson({}); } 闭包 // java 闭包 ，用接口 和匿名函数 实现。-- 所谓闭包从表面看就是返回一个 函数 interface AaddFunc{ int addBy(int value); } public static AaddFunc createNewFunction(final int value){ return new AaddFunc() { @Override public int addBy(int addBy) { return value + addBy; } } ; } AaddFunc func = createNewFunction(1) ; int result =func.addBy(10) ; // dart 闭包 Function makeAdder( int addBy) { return (int value) { return addBy + value; } ; } var func1 = makeAdder(10); var result =func1(1); //11 三目运算符 dart 支持三目运算符。 参考Java mixin 特性 mixin 并不是一个关键字，只是一个普通的单词，意思是混合 Dart中，每个类（除了Object类）都只有一个超类。 但是我们有时需要多个父类的特性，可以用 with 来实现 minxin 特性。 class Walker { void walk() { print(\"I'm walking\"); } } class Fish { void swim() { print(\"I'm swimming\"); } } /** Person person = Person() ; person.walk() ; person.swim() ; */ class Person with Walker , Fish { } 异步函数 async await // 异步函数 async await Dart是单线程的语言， 在Dart1.9中加入了async和await关键字，有了这两个关键字， 我们可以更简洁的编写异步代码，而不需要调用Future相关的API（这种方法相对繁琐）。 用async标记，表示函数内部包含有需要延迟执行的代码。 有await标记的运算，其结果值都是一个Future对象 （马上返回）。 // 举个例子 就会明白 func(String callType) async { print('$callType = 方法内部 await 语句之前 '); await print('$callType = await 执行的语句 '); print('$callType = 方法内部 await 语句之后 '); } /* 1 方法 通过 awiat 调用 = 方法内部 await 语句之前 1 方法 通过 awiat 调用 = await 执行的语句 1 方法 通过 awiat 调用 = 方法内部 await 语句之后 1 --------------------------- 2 方法直接调用 = 方法内部 await 语句之前 2 方法直接调用 = await 执行的语句 2 ---------------------------- 2 方法直接调用 = 方法内部 await 语句之后 */ main( ) async { // await 方式调用异步方法 , 则会等异步方法执行完成后再执行后续的代码 await func('1 方法 通过 awiat 调用'); print('1 ---------------------------'); // 没有使用 await 方式调用异步方法，则异步方法执行到 await 处后等待 ( await所在的语句会调用，是在等待返回结果)，程序继续执行异步方法外的后续代码 func('2 方法直接调用'); print('2 ----------------------------'); } 生成器 // 同步生成器 Iterable 、 sync* 、yield Iterable getSyncGenerator(int n ) sync* { int k = n; while (k > 0) { yield k--; } } //异步生成器： Stream 、 async* 、 yield Stream getAsyncGenerator(int n) async* { int k = 0; while (k call 函数 类的 特殊函数 call () 。 实现call()方法可以让你的Dart类像函数一样被调用。 不习惯这样。暂仅做了解。 class Person { call(String a, String b ) { return '$a $b ' ; } } main() { var person = new Person(); var out = person(\"Hi\", \"aivin\" ); print('$out'); } “多进程”机制 Isolate // “多进程”机制 Isolate isolate是Dart平台对线程的实现方案，但和普通Thread不同的是，isolate拥有独立的内存，isolate由线程和独立内存构成。 由于isolate线程之间的内存不共享，所以isolate线程之间并不存在资源抢夺的问题，所以也不需要锁。 isolate线程之间的通信主要通过port来进行，这个port消息传递的过程是异步的。 isolate看起来其实和进程比较相似，之前请教阿里架构师宗心问题时， 宗心也说过“isolate的整体模型我自己的理解其实更像进程，而async、await更像是线程”。 如果对比一下isolate和进程的定义，会发现确实isolate很像是进程。 （这段话来自网络，我暂时没有用到过 Isolate ） 注解 // immutable 被 @immutable 注解标明的类或者子类都必须是不可变的 . 随机数 // 随机数 weatherType = WeatherType.values[Random().nextInt(WeatherType.values.length)]; ( no Copyright，enjoy youself ! ) all right reserved，powered by GitbookThe file was updated at : 2021-06-07 13:46:13 "},"chinese/native/ccpp.html":{"url":"chinese/native/ccpp.html","title":"native部分","keywords":"","body":"c语言 数据类型 c基础数据类型 字节 说明 char 1 unsigned char 1 signed char 1 int 2 或4 unsigned int 2 或4 short 2 unsigned short 2 long 4 unsigned long 4 float 4 double 8 long double 16 没有 boolean 0假 , 非0真 没有 byte unsigned char signed int value; // 有符号类型 int value; // 不写就默认为有符号类型 unsigned int value;// 无符号类型 printf 输出格式 、占位符 类型type 对应类型 说明 示例 d/i int 输出十进制有符号32bits整数，i是老式写法 printf(\"%i\",123); 输出123 u unsigned int 无符号10进制整数 printf(\"%u\",123); 输出123 o unsigned int 无符号8进制整数(不输出前缀0) printf(\"0%o\",123);输出0173 x/X unsigned int 无符号16进制整数，x对应的小写，X对应的是大写（不输出前缀0x) printf(\"0x%x 0x%X\",123,123);输出0x7b 0x7B f/lf float(double) 单精度浮点数用f,双精度浮点数用lf(printf可混用，但scanf不能混用) printf(\"%.9f %.9lf\",0.000000123,0.000000123);输出0.000000123 0.000000123。注意指定精度，否则printf默认精确到小数点后六位 F float(double) 与f格式相同，只不过 infinity 和 nan 输出为大写形式。 printf(\"%f %F %f %F\\n\",INFINITY,INFINITY,NAN,NAN);输出结果为inf INF nan NAN e/E float(double) 科学计数法，使用指数(Exponent)表示浮点数 此处”e”的大小写代表在输出时“e”的大小写 printf(\"%e %E\",0.000000123,0.000000123);输出1.230000e-07 1.230000E-07 g float(double) 根据数值的长度，选择以最短的方式输出，%f或%e printf(\"%g %g\",0.000000123,0.123);输出1.23e-07 0.123 G float(double) 根据数值的长度，选择以最短的方式输出，%f或%E printf(\"%G %G\",0.000000123,0.123);输出1.23E-07 0.123 c char 字符型。可以把输入的数字按照ASCII码相应转换为对应的字符 printf(\"%c\\n\",64)输出A s char* 字符串。输出字符串中的字符直至字符串中的空字符（字符串以空字符’\\0‘结尾） printf(\"%s\",\"测试test\");输出：测试test S wchar_t* 宽字符串。输出字符串中的字符直至字符串中的空字符（宽字符串以两个空字符’\\0‘结尾） setlocale(LC_ALL,\"zh_CN.UTF-8\"); wchar_t wtest[]=L\"测试Test\"; printf(\"%S\\n\",wtest); 输出：测试test p void* 以16进制形式输出指针 printf(\"%010p\",\"lvlv\");输出：0x004007e6 n int* 什么也不输出。%n对应的参数是一个指向signed int的指针，在此之前输出的字符数将存储到指针所指的位置 int num=0; printf(\"lvlv%n\",&num); printf(\"num:%d\",num); 输出:lvlvnum:4 % 字符% 输出字符‘%’（百分号）本身 printf(\"%%\");输出:% m 无 打印errno值对应的出错内容 printf(\"%m\\n\"); a/A float(double) 十六进制p计数法输出浮点数，a为小写，A为大写 printf(\"%a %A\",15.15,15.15);输出：0x1.e4ccccccccccdp+3 0X1.E4CCCCCCCCCCDP+3 //函数原型 printf(\"格式化字符串\",输出表列) //格式控制字符串 %[flags][width][.prec][length]type %[标志][最小宽度][.精度][类型长度]类型 int value = 12345; printf(\"右边补空格=%-10d\\n\", value); printf(\"左边补空格=%10d\\n\", value); printf(\"左边补零= %010d\\n\", value); float value2 = 100.123456789; printf(\"精度= %.5f\\n\", value2); 字符串 // '\\0' 终止标记 char greeting[6] = { 'H', 'e', 'l', 'l', 'o', '\\0' }; char greeting[] = \"Hello\"; //复制 str1 到 str3 strcpy(str3, str1); //连接 str1 和 str2 strcat(str1, str2); //字符串长度 len = strlen(str1); char s1[] = \"aivin666@qq.com\"; char ch = '@'; // 返回首次出现目标字符的指针位置 char* location=strchr(s1, ch); if (location) { // qq.com printf(\"%s\\n\", ++location); } else { // 不存在就会返回NULL } char s1[] = \"aivin666@qq.com\"; char s2[] = \"666\"; // 返回首次出现目标字符串的指针位置 char* location= strstr(s1, s2); if (location) { //666@qq.com printf(\"%s\\n\", location); } else { printf(\"匹配失败\\n\"); } // 字符串比较 ,相等表示 字符串内容相同 int memcmp(const void *buf1, const void *buf2, unsigned int count); //匹配字符串，成功则返回第一次匹配到的地址，失败返回空 strcasestr(url, \"rtsp://\") 指针 指针是一个变量，存储了某个变量的内存地址。 void * 表示未确定类型的指针。 int value = 200; int* ip; // ip是一个指向int类型的指针 int *ip // 结果跟 int* ip 完全一样。（建议这样写） ip = &value;// &符号是获得 value 这个变量的地址 int reslut = *ip; // *是获得指针ip指向的变量的值 int* intPtr; int value = 10; intPtr = &value; // &value 获得指向10的指针 *intPtr = 200; // 直接将指针指向的那个值改成 200 二级指针 、多级指针 int **ptr2; //二级指针。 ptr2指向一个地址，这个地址中存放的变量是一个 int指针类型的数据。 int ***ptr3; // 三级指针 数组指针 数组指针 指向数组的首地址 int arr[] = {1 ,2,3,4}; int *ptr = arr; // 指向数组的首地址。数组跟基本类型不一样不需要用&取地址。arr可以认为就是一个指针了。 ptr++; printf(\"%d\\n\" , *ptr); int arr2[] = { 8 ,9 ,10 }; int (*ptr2)[3] = &arr2; // 定义一个指针。 数组指针 。 //int *ptrArr[3]; // 定义一个数组。 指针数组。 printf(\"bbb= %d\\n\", (*ptr2)[0] ); // *ptr2 获得数组，代表数组的首地址 int result = * (*ptr2 +1 ) ; //对地址取值 printf(\"ccc= %d\\n\", result); // 9 函数指针 、 方法指针 系统为函数代码分配一段存储空间，这段存储空间的首地址称为这个函数的地址。 函数名表示的就是这个地址。指向这个地址的指针叫做函数指针。函数指针可以像一般函数一样，用于调用函数、传递参数。 // 定义 int sum(int x, int y) { return x+y; } int main(void){ // 函数返回值类型 (* 指针变量名) (函数参数类型列表) int (*ptrTest) (int, int); //定义函数指针,指针名字可以随意 ptrTest = &sum; // 将函数的地址给指针 ，可以这样理解，函数名就是一个指针 int a = 20, b = 10, c; c = ptrTest(a, b); //通过函数指针调用函数 printf(\"a = %d\\nb = %d\\nmax = %d\\n\", a, b, c); getchar(); return 0; } // 结构体中包含函数指针 struct SLPlayItf { SLresult (*SetPlayState) ( SLPlayItf self, SLuint32 state ); }; (*pcmPlayerPlay)->SetPlayState(xx, xx); //其他地方调用函数SetPlayState 函数回调 int func3(int x ,int y) { return x + y; } // 第三个参数就是函数指针 int handle(int x, int y , int(*funcPtr)(int , int)) { return funcPtr(x , y); } void main(void) { int x = 10, y = 20; int sum = handle(x, y, func3); // 函数名其实就是一个指针 printf(\"sum= %d\" , sum); } 数组 int arr[] = {1 ,2,3,4}; for ( int i : arr) { printf(\"%d \" , i); } int sum = sizeof(arr) / sizeof(arr[0]); for (int i = 0; i 变量 注意c语言的全局变量和java的全局变量是不一样的。 Java是一种面向对象语言，它不允许在类和接口之外声明函数。 C不是面向对象的，所以C中所有全局变量和函数本质上对Java而言都是静态的。 在C中，常会出现在一个文件中定义大量的全局变量， 在其他文件中通过引用声明这些变量来实现共享，但Java不允许有全局变量或函数； 堆栈 、内存 栈的内存最大值比较小，开辟方式用静态开辟。方法结束后会自动回收。 堆的内存最大值较大，用动态方式开辟。不会自动回收，必须通过手动释放才能被回收。 静态内存 int arr[2*1024] ;// 静态开辟 2K内存 动态内存 #include 或者 //若成功就返回指向被分配内存空间的指针，否则就返回NULL int *p = (int *) malloc(sizeof(int) * 10); if (p == NULL) { return ; } memset(p, 0, sizeof(int) * 10); //初始化空间 // 初始化成功后默认初始化为0，无需手动初始化 int* reslut = (int*) calloc(10 , sizeof(int)); // 对申请的内存进行大小的调整 p = (int*)realloc(p, sizeof(int) * 10); // 将大小调整为10 free(p);// 手动释放内存 内存四区模型 一个由c/C++编译的程序占用的内存分为以下几个部分 1、栈区：由编译器自动分配释放 ，存放函数的参数值，局部变量的值等。 2、堆区：由程序员分配释放， 若程序员不释放，程序结束时可能由系统回收 。 3、数据区：主要包括静态全局区和常量区。 初始化的全局变量和静态变量在一块区域， 未初始化的全局变量和未初始化的静态变量在相邻的另一块区域。 程序结束后由系统释放 4、代码区：存放函数体的二进制代码。 结构体 c的结构体与c++的类似，但是不如c++的结构体强大。 // 普通方式 struct student { char name[20]; int age; } stu1, stu2; struct student stu3; stu3.age = 20; printf(\"年纪=%d\\n\" ,stu3.age); //带别名方式,STUDENT是别名 typedef struct student { char name[20]; int age; }STUDENT ; // 别名方式 可以省略 struct STUDENT stu3; // 空结构体 struct URLProtocol11111111111 ; 或 struct URLProtocol11111111111 static 1、C中的static可以修饰局部变量（java不行）， 被static修饰的局部变量表示这个函数执行完后，这个变量不被释放，其值仍然保存着， 然后下次访问该函数时，这个变量的值即为上一次函数执行完后它的值。 2、C中如果用static修饰全局变量或函数，那么就表示该全局变量或函数不能被其他文件访问。 好奇怪。注意和Java中的static的不一样。 集合 fd_set fd_set readSet; FD_ZERO(&readSet); //清空集合中所有的元素 FD_SET(serverSocket,&readSet); //将serverSocket加入readSet集合 联合体 共用体 所有成员变量共享一个内存, 对于Union的不同成员赋值，将会对其他成员重写，原来成员的值就不存在了。 其他的用法参考struct 。 union Data { char name[20]; int age; } data1, data2 ; 控制台 输入 输出 printf(...) // 将指定的内容输出到控制台 scanf(...) // 接收键盘输入的内容,只有按下回车键scanf才会从缓冲区取走数据 int a ; scanf(\"%d\", &a ); printf(\"输入int是= %d\\n\", a ); char str[50] ; scanf(\"%s\", str ); printf(\"输入字符串是= %s\\n\", str ); char c ; c = getchar();// 获得按回车符后的第一个字符。控制台程序测试常用来暂停屏幕 putchar(c);// 输出一个字符到 控制台 // 一个汉字占用两个字节 char c1, c2; c1 = getchar(); c2 = getchar(); putchar(c1); putchar(c2); --------------------------------------------- char c1, c2; //#include // 输入完毕即被读取，无需按回车键 . 屏幕上会显示输入的内容 c1 = getche(); // 输入完毕即被读取，无需按回车键 。屏幕上不会显示输入的内容 c2 = getch(); printf(\"\\nThe character getche()= %c \\n\", c1); printf(\"The character getch() = %c \\n\", c2); --------------------------------------------- char s[50]; // 输入字符串 （可以有空格） gets_s(s); // 输出字符串 puts(s); --------------------------------------------- char c1; c1 =getc(stdin); putc(c1 ,stdout); 常用函数 memcpy(...) // 内存拷贝 void *memcpy(void *dest, const void *src, size_t n) memset(...) // 内存重置 void *memset(void *s, int ch, size_t n); 将s中当前位置后面的n个字节 用 ch 替换并返回 s 文件操作 读写权限 操作类型 特点 文件不存在时 特点 r 只读 报错 读 任意位置 w 只写 新建 清空原文件，写入任意位置 a 只写 新建 不清空 ，只能在尾部写 r+ 读写 报错 不清空， 任意位置读写 w+ 读写 新建 清空，任意位置读写 a+ 读写 新建 不清空 ， 任意位置读 ， 尾部写 打开模式 只读 只写 读写 读写 读写 读写 文本模式 r w a r+ w+ a+ 二进制模式 rb wb ab rb+ , r+b wb+ , w+b ab+ , a+b fseek(FILE *stream, long int offset, int whence) // offset 偏移量 ,origin从哪里开始偏移。 ftell( ) // 得到文件位置指针当前位置相对于文件首的偏移字节数，可以用来表示文件大小。 rewind( ) // 指针重新指向一个文件的开头。 fread( ) // 将文件读取到指定数组中 fwrite( ) // 将数组中的内容写入文件 读文本（有中文） // 此程序读取ANSI编码格式正常，其他格式中文乱码 FILE * fp; if ((fp = fopen(\"D:\\\\data1.txt\", \"r+\")) == NULL) { printf(\"can not open the file\\n\"); exit(0); } char ch = fgetc(fp); while (ch != EOF) { putchar(ch); ch = fgetc(fp); } fclose(fp); 写文本（有中文） //此程序保存的编码格式是ANSI FILE * fp; if ((fp = fopen(\"D:\\\\data1.txt\", \"w+\")) == NULL) { printf(\"文件打开失败\\n\"); } else { char str[] = \"123 a b 中文测试 123 abc abcdefg\"; int len = strlen(str); for (int i = 0; i 复制文件 ，二进制（图片，音频） char *read_path = \"D:\\\\music1.mp3\"; char *write_path = \"D:\\\\music2.mp3\"; FILE *read_fp = fopen(read_path, \"rb\"); FILE *write_fp = fopen(write_path, \"wb\"); //缓冲区域 int buff[50]; //每次读到的数据长度 int len = 0; while ( (len = fread(buff, sizeof(int), 50, read_fp)) != 0) { //将读到的内容写入新的文件 fwrite(buff, sizeof(int), len, write_fp); } fclose(read_fp); fclose(write_fp); socket AF_INET // IPv4 AF_INET6 // IPv6 SOCK_STREAM // TCP流 SOCK_DGRAM // UDP数据报 SOCK_RAW // 原始套接字 SOL_SOCKET // 被设置的选项的级别，套接字级别 。 SO_REUSEADDR // TCP套接字端口复用 SO_RCVBUF 、SO_SNDBUF // 设置缓冲区大小 EINPROGRESS // 正在处理 inet_addr () //将字符串形式的IP地址 -> 网络字节顺序 的整型值 inet_ntoa () // 网络字节顺序的整型值 ->字符串形式的IP地址 htons () // 把整数转换成“网络字节序” //tcp select , 监听套接字，如果有数据到来就返回 int selectResult = select( serverSocket+1, &readSet, &writeSet, NULL, &tv); FD_ISSET(serverSocket,&readSet) // 检测serverSocket是否在readSet集合中 recv () //int recv（SOCKET s，char FAR *buf，int len，int flags） 第一个参数：接收端的套接字描述符，其实就是客户端对应的套接字 第二个参数：指向接受的数据所在的缓冲区 第三个参数：缓冲区的最大尺寸。 第四个参数：一般写0即可。 pthread_rwlock_tryrdlock () //非阻塞读锁定　　 pthread_rwlock_unlock () 其他 #pragma pack (n) // C编译器将按照n个字节对齐。 #pragma pack () // 取消自定义字节对齐方式。 #pragma pack (push,1) // 把原来对齐方式设置压栈，并设新的对齐方式设置为一个字节对齐 #pragma pack(pop) // 恢复对齐状态 C开源库函数一般用 返回0代表执行成功的原因 1、成功用0，失败返回-1 ,-2 ,-3 等错误码。 2、习惯写法，no news is good news , 成功了就不用处理，失败就要处理。 if( xx) { // 处理失败... 因为0 为false ，就不用进来了} cpp C++是面向对象的语言。 是C的超集，兼容大部分C的语法结构 。 数据类型 基本数据类型 字节 说明 char 1 unsigned char 1 signed char 1 int 4 unsigned int 4 signed int 4 short int 2 unsigned short int 2 signed short int 2 long int 8 signed long int 8 unsigned long int 8 float 4 double 8 long double 16 wchar_t 2 或 4 宽字符型 关键字 关键字 说明 auto 自动存储变量的关键字，也就是申明一块临时的变量内存。auto不写则隐含自动变量 。auto int a 和 int a效果一样。或者 auto * result =xx ; 当xx类型暂时无法确定时，可以先表示为auto类型。让编译器根据表达式自动推断变量的类型。 decltype const 定义有类型的常量 define 定义没有类型的常量 cin 键盘输入 cout cerr clog stringstream 提供相关的转换和格式化 inline 为了提高函数的执行效率 operator 运算符重载 friend 友元 explicit // 修饰只有一个参数的类构造函数, 它的作用是表明该构造函数是显示的 implicit // 修饰只有一个参数的类构造函数, 它的作用是表明该构造函数是隐式的 volatile // 类型修饰符，表示可以被某些编译器未知的因素更改。 “箭头 -> ” 和“ 点号 . ”操作符 箭头（->）：左边必须为指针； 点号（.）：左边必须为实体。 前缀 、 后缀 0x或0X表示十六进制，不带前缀则默认表示十进制。 整数常量也可以带一个后缀，后缀是U和L的组合，U表示unsigned，L表示long。 30ul // 无符号长整数 预处理 所有的预处理器指令都是以井号（#）开头，只有空格字符可以出现在预处理指令之前。预处理指令不是 C++ 语句，所以它们不会以分号（;）结尾。 预处理指令用于创建符号常量。该符号常量通常称为宏。 #define PI 3.14159 #define MIN(a,b) (a 常量 可以用 define 、const定义常量 #define LENGTH 10 const int LENGTH = 10; 变量声明 、变量定义 声明不会分配存储空间，只有定义时才会分配存储空间。 可以使用关键字extern在任何地方（多次）声明一个变量。 但变量只能在某个文件、函数或代码块中被定义一次。 #include extern int a;// 变量声明 int main () { int a, b; // 变量定义 a = 10;// 实际初始化 return 0; } 变量初始化 局部变量被定义时，系统不会对其初始化，必须手动赋值初始化。 定义全局变量时，系统会自动初始化它。 左值、右值 指向内存位置的表达式被称为左值表达式。 右值指的是存储在内存中某些地址的数值。 int g = 20;//ok 10 = 20; // wrong 异常 try { throw \"发生异常！\"; } catch ( char * msg) { cout 友元函数 、友元类 采用类的机制后实现了数据的隐藏与封装 。 但是，其他类的某个函数需要频繁地访问类的数据成员， 这时可以将这些函数定义为该函数的友元函数。 友元的作用是提高了程序的运行效率（即减少了类型检查和安全性检查等都需要时间开销）， 但它破坏了类的封装性和隐藏性，使得非成员函数可以访问类的私有成员。 继承 c++ 支持多继承 继承方式可选范围 public(常用)、protected 、 private(默认) class Rectangle: public Shape , { ... } 函数重载 void print(int i) {...} void print(double f) {...} 操作符重载 、 运算符重载 不能被重载的操作符 说明 其他 成员访问运算符 . 成员指针访问运算符 .* 域运算符 :: 长度运算符 sizeof 变量的大小会根据编译器和所使用的电脑而有所不同。 条件运算符 ?: 可以重载的操作符 说明 双目算术运算符 + (加)，-(减)，*(乘)，/(除)，% (取模) 关系运算符 ==(等于)，!= (不等于)， (大于>，=(大于等于) 逻辑运算符 || (逻辑或)，&&(逻辑与)，!(逻辑非) 单目运算符 + (正)，-(负)，*(指针)，&(取地址) 自增自减运算符 ++(自增)，--(自减) 位运算符 | (按位或)，& (按位与)，~(按位取反)，^(按位异或),，>(右移) 赋值运算符 =, +=, -=, *=, /= , % = , &=, |=, ^=, >= 空间申请与释放 new, delete, new[ ] , delete[] 其他运算符 ()(函数调用)，->(成员访问)，,(逗号)， 运算符重载是为了更方便地操作类类型数据而设计的。 重载的运算符参数中至少要有一个类类型或枚举类型.否则编译不过。 public: int whitePeople; int blackPeoople; void display() { ...} // 重载运算符 + Group operator+ (Group & g1 , Group &g2) { Group sum; sum.whitePeople = g1.whitePeople + g2.whitePeople; sum.blackPeoople = g1.blackPeoople + g2.blackPeoople; return sum ; } Group g1 ,g2 , g3; g1.whitePeople = 10; g1.blackPeoople = 10; g2.whitePeople = 100; g2.blackPeoople = 200; g3 = g1 + g2; g3.display(); 指针 int *p ; int* p; // p是指向一个整数类型的指针 x=*p// 把指针p指向的值赋值给x p=&x// 把x的地址赋给p（指针） 。仅仅通过指针无法知道指向数组的大小 引用 引用就是某一变量的一个别名，对引用的操作与对变量直接操作完全一样 。 对引用求地址，就是对目标变量求地址。 int a; int &ra=a; //& 读作引用。 //此处函数的形参p1, p2都是引用 void swap(int &p1, int &p2) { ... } 指针与引用的区别 1、不存在空引用。引用必须连接到一块合法的内存。 2、一旦引用被初始化为一个对象，就不能被指向到另一个对象。指针可以在任何时候指向到另一个对象。 3、引用必须在创建时被初始化。指针可以在任何时间被初始化。 输入输出 int a = 0; // 输入数字 cout > a; cout > mystr; cout 类型转换 string mystr; float price = 0; int quantity = 0; getline(cin, mystr); // 字符串转为 int stringstream(mystr) >> quantity; // 字符串转为 float getline(cin, mystr); stringstream(mystr) >> price; cout static_cast // 类型强制转换，效果就相当于加个括号:int a=(long)b; reinterpret_cast // 类型强制转换，与static_cast 有细微差别。 dynamic_pointer_cast // dynamic_cast // 传值参数 引用参数 // 不会改变原始内容 int func1(int valuea, int value2) { int result = valuea + value2; valuea += 10; return result; } // 会改变最原始的值的内容 int func2(int& valuea, int& value2) { int result = valuea + value2; valuea += 10; return result; } 模板 模板就是实现代码重用机制的一种工具。 函数模板 对函数模板的理解可以参考Java的泛型 template int compare(const T& left, const T& right) { return left+ right ; } int a = 10; int b = 20; float c = 10.6; float d = 20.7; cout 类模板 template class类名｛ ／／类定义．．．．．． ｝; 命名空间 命名空间用来解决 命名冲突的问题。本质上，命名空间就是定义了一个范围。 namespace mSpaceA { int func( int a , int b ) { return a + b; } } namespace mSpaceB { int func(int a, int b) { return a*b; } } int a = 10; int b = 20; cout 数组 int mArray [] = { 5, 10, 15 }; // 长度 cout 字符串 // string 风格的字符串 string str1 = \"aaa\"; string str2 = \"bbb\"; str1 += str2; cout 动态内存 // 开辟空间 int* intArray = new int[5]; intArray[3] = 100; for (int i=0; i 结构体 // 结构体类型 和变量 分开定义 struct student { char name[20]; //姓名 int age; //年龄 }; struct student stu1, stu2; // 结构体类型 和变量 同时定义 struct student { char name[20]; int age; } stu1, stu2; struct student stu3; Union 联合体 所有成员变量共享一个内存, 对于Union的不同成员赋值，将会对其他成员重写，原来成员的值就不存在了。 其他的用法参考struct 。 enum 枚举 //枚举值默认从0依次赋值 enum color { red, green, blue }; color paint = red; // red为0 ， green为5 ， blue为6 enum color { red, green = 5, blue } paint; 别名 类型别名可以用来降低原始类型长度或容易混淆的类型名称。在C++中，任何有效的类型都可以有别名。 // WORD 是 int的别名 typedef unsigned int WORD; 类class 、对象 C++中获得对象有两种方法 1、通过new获得 2、直接申明获得。 这种方法跟java的对象获得区别很大。java是不会分配空间的，此时调用会空指针。 而C++是声明对象并为其分配了空间的。 new出来的对象类似于申请空间，因此需要delete销毁，而直接声明的对象则在使用完直接销毁。 new出来的对象需要使用指针接收，而直接声明的不用。 c++ 可以直接调用外部文件的函数，为什么还要类和对象？ （Java只能调用static类型的外部文件函数） 答：c++ 虽然可以直接调用外部文件的函数，但是函数如果很多的话，不能直观地知道是属于哪个文件的，所以用类来进行来管理。 这也是c++比c更方便的地方。 类的属性和方法 默认访问级别是private。 class Student{ char *name; int age; public: void showInfo() { cout STL C++ STL(标准模板库)是一套功能强大的模板类，提供了通用的模板类和函数， 这些模板类和函数可以实现多种流行和常用的算法和数据结构，如向量、链表、队列、栈。 格式化时间 // time_t 只能精确到秒 time_t t = time(0); char tmp[64]; strftime(tmp, sizeof(tmp), \"%Y-%m-%d %H:%M:%S\",localtime(&t) ); LOGI(\"当前时间是：%s\" , tmp) ; 析构函数 c++中函数前加 ~ 是表示此函数是析构函数。 用来释放程序运行中没有delete或者free的变量，完成扫尾工作， 一般的创建类如果不写析构函数会调用系统默认的析构函数， 如果用户有声明和定义，则调用用户的 /***构造函数*/ WlJavaCall(_JavaVM *javaVM, JNIEnv *env, jobject *jobj); /***析构函数*/ ~WlJavaCall(); std::string 字符串 std::string::npos // 常数, 等于size_type类型可以表示的最大值,用来表示一个不存在的位置。 std::string audio_codec_name(\"aaaaaa\") // 新建变量audio_codec_name，初始化为aaaaaa。 std::pair // 键值对 可以用过 first和second访问第一个和第二个元素 std::map insert( ) // 插入元素 find( ) // 根据key 查找， end( ) // 指向map的末尾 , 表示没有找到 erase( ) // 删除一个元素 链表 std::list push_back( ) //在末尾插入元素 sort( ) // 以自定义规则排序 begin() //返回指向容器最开始位置数据的指针 c.end() // 返回指向容器最后一个数据单元+1的指针 clear( ) // 移除所有元素，容器清空。 c++队列 std::deque 一种先进先出(FIFO)的数据结构。 队列使用 #include \"queue\" std::queue queue; // 创建队列 ，不需要alloc之类操作 queue.push(t);//入队 AVFrame *avFrame1 = queueFrame.front();// 返回队列中第一个元素。不会删除。 queueFrame.pop();// 删除第一个元素。没有返回 AVFrame *avFrame2=queueFrame.back();// 返回队列中最后一个元素 push_back( ) // 在末尾位置插入元素 at() // 返回索引为pos的位置的元素 置空操作 (void) SLresult result; (void) result; // 这样的写法是将result结果置空？ 多线程 #include void func(int a, string msg) { this_thread::sleep_for(chrono::seconds(2));// 线程休眠 cout 文件操作 权限说明 文件打开模式 说明 ios::in 只读 ios::out 只写 ios::app 从文件末尾开始写，防止丢失文件中原来就有的内容 ios::binary 二进制模式 ios::nocreate 打开一个文件时，如果文件不存在，不创建文件 ios::noreplace 打开一个文件时，如果文件不存在，创建该文件 ios::trunc 打开一个文件，然后清空内容 ios::ate 打开一个文件时，将位置移动到文件尾 读取 txt // #include // 解决中文乱码 string UTF8ToGB(const char* str) { string result; WCHAR *strSrc; LPSTR szRes; //获得临时变量的大小 int i = MultiByteToWideChar(CP_UTF8, 0, str, -1, NULL, 0); strSrc = new WCHAR[i + 1]; MultiByteToWideChar(CP_UTF8, 0, str, -1, strSrc, i); //获得临时变量的大小 i = WideCharToMultiByte(CP_ACP, 0, strSrc, -1, NULL, 0, NULL, NULL); szRes = new CHAR[i + 1]; WideCharToMultiByte(CP_ACP, 0, strSrc, -1, szRes, i, NULL, NULL); result = szRes; delete[]strSrc; delete[]szRes; return result; } string path = \"D:\\\\hello.txt\"; ifstream infile; infile.open(path , ios::in); char mBuffer[100]; string msg; if (infile.is_open()) { while (!infile.eof()) { // buffer 大小 infile.getline(mBuffer, 200); msg = UTF8ToGB(mBuffer); cout 写入 txt string path = \"D:\\\\hello2.txt\"; ofstream outfile; // 追加模式 ios::app , 覆盖模式 ios::out outfile.open(path, ios::app); if (!outfile.is_open()) { cout 二进制文件 复制 /** 目标文件路径 ， 原文件路径*/ bool copy_binary_file(const char * szDestFile, const char * szOrigFile) { bool bRet = true; std::ofstream fout(szDestFile, std::ios::binary | std::ios::app); std::ifstream fin(szOrigFile, std::ios::binary); if (fin.bad()) { bRet = false; } else { while (!fin.eof()) { char szBuf[256] = { 0 }; fin.read(szBuf, sizeof(char) * 256); if (fout.bad()) { bRet = false; break; } fout.write(szBuf, sizeof(char) * 256); } } fin.close(); fout.close(); return bRet; } // 测试 string originPath = \"D:\\\\music.mp3\"; string destPath = \"D:\\\\music2.mp3\"; bool reslut = copy_binary_file( destPath.c_str() , originPath.c_str()); 混合编程 C编译器 和 C++编译器对编译函数符号的生成规则是不一样的。所以不能直接互相调用，必须要显示地申明。 c++ 文件中使用 c代码 //__cplusplus是cpp中的自定义宏， 若果定义了这个宏 则表示这是一段cpp代码。 //cfun.h #ifdef __cplusplus extern \"C\" { #endif void cfun(); #ifdef __cplusplus } #endif //cfun.c #include \"cfun.h\" #include void cfun() { printf(\"hello world...我是c写的...\\n\"); } // main.cpp #include #include \"cfun.h\" using namespace std; int main() { cout c 文件中使用 c++ 代码 // cppfun.h #ifdef __cplusplus extern \"C\" { #endif void cppfunc( ); #ifdef __cplusplus } #endif //cppfun.cpp #include \"cppfun.h\" #include using namespace std; void cppfunc( ) { cout #include \"cppfun.h\" int main() { printf(\"我在c文件中发起调用\\n\"); cppfunc(); return 0; } 网络访问 一般用curl ？？ 其他 printf( ) // 输出到屏幕，用来做打印信息 sprintf() // 输出到指定的字符串或数组中，用来格式化字符串。 char* config = new char[strlen(filter_config) + 1]; sprintf(config, \"%s%c\", filter_config, 0); ( no Copyright，enjoy youself ! ) all right reserved，powered by GitbookThe file was updated at : 2021-01-21 15:10:30 "},"chinese/native/Linux.html":{"url":"chinese/native/Linux.html","title":"Linux","keywords":"","body":"linux - Ubuntu Ubuntu下载地址 获得su的密码 Ubuntu刚安装后，不能在终端中运行su命令，因为root没有默认密码，需要手动设定。 以安装ubuntu时输入的用户名登陆，该用户在admin组中，有权限给root设定密码。 sudo passwd xxx //xx是账号 ， xx为空就默认是root账号 更换新密码后 就获得了 root的密码。 从而进入su账号。 ubuntu 常用目录 名字 说明 其他 bin 系统启动需要的命令和大部分普通用户平常所需的可执行命令。 都是二进制文件 sbin 存放系统管理员可执行的命令。 sys 系统中的设备和文件层次结构。 etc 程序的配置文件目录 boot 存放Ubuntu内核文件及引导加载器相关的文件 dev 设备列表文件夹，鼠标、键盘、硬盘等。 关于设备驱动文件都在这里 配置文件 /etc/profile /etc/bash.bashrc /etc/environment cdrom 光盘目录，如果插入光盘会出现光盘内容 mnt 所有挂载在系统中的设备。比如U盘设备 root 超级管理员的家目录 home 所有普通用户都有一个以自己名字命名的文件夹存放在这个目录中。 配置文件 /home/aivin/.profile /home/aivin/.bashrc /home/aivin/.bash_logout /home/aivin/.bash_history usr 　和用户有关的文件系统都存放在这个目录。 var 存放类似日志这样随时间变化的文件。 opt 机额外安装软件所摆放的目录。默认是空的。 一般安装软件的时候，可以自己指定安装到这个目录下，便于查找和管理 run 保存从系统诞生到当前的关于系统信息的文件。 srv 一般是系统存储的服务相关数据。 tmp 　存放系统或者用户的临时文件的目录。 lib 各种程序所需的共享动态链接库 lib64 64位支持库 snap snap应用框架的程序文件 media 存放所有关于媒体信息的文件。 proc 存放的是系统信息和进程信息。 swapfile vmlinuz 内核文件 initrd.img initrd是在系统引导过程中挂载的一个临时根文件系统，用来支持两阶段的引导过程。 Ubuntu 配置文件 Linux系统严格的权限管理造成系统有多个环境变量配置文件，如果不了解其调用顺序，很有可能遇到配置了环境变量，而看不到其发生作用。 /etc/environment 系统在读取用户的profile前,设置环境文件的环境变量。 /home/aivin/.bash_logout 当每次退出系统(退出bash shell)时,执行该文件 /home/aivin/.bash_history 是bash shell的历史记录文件，里面记录了你在bash shell中输入的所有命令。 /etc/profile 为系统的每个用户设置环境信息, 当用户第一次登录时,该文件被执行。 修改后重启生效、或者source /etc/profile立即生效 。 /home/aivin/.profile /home/aivin/.bashrc /etc/bash.bashrc 用终端打开、关闭软件 xx & // 打开xx软件， 注意后面的 & , 否则终端关了 软件也会跟着关闭 killall xx // 关闭xx这个软件 注意：前提是xx这个软件的安装路径已经加入到环境变量中了 NDK配置 1、ubuntu 查看当前工作目录：pwd //路径至关重要 2、配置环境变量命令：$sudo gedit ~/.bashrc 在打开的文件中添加以下代码： export NDK=/home/aivin/Downloads/myNDKr13b/android-ndk-r13b export PATH=${PATH}:$NDK 3、保存关闭刚刚修改过的文件。 4、source ~/.bashrc使其修改的文件生效。 5、配置好后可通过 echo $PATH查看配置环境 输入ndk-build -v ,出现一下信息说明ndk配置ok。 虚拟内存 直接从内存读写数据要比从硬盘读写数据快得多，因此更希望所有数据的读取和写入都在内存中完成， 然而内存是有限的，这样就引出了物理内存与虚拟内存的概念。 物理内存就是系统硬件提供的内存大小，是真正的内存。 相对于物理内存，在 Linux 下还有一个虚拟内存的概念， 虚拟内存是为了满足物理内存的不足而提出的策略，它是利用磁盘空间虚拟出的一块逻辑内存。 用作虚拟内存的磁盘空间被称为swap空间。 Linux会在物理内存不足时，使用交换分区的虚拟内存， 更详细地说，就是内核会将暂时不用的内存块信息写到交换空间， 这样一来，物理内存得到了释放，这块内存就可以用于其他目的， 当需要用到原始的内容时，这些信息会被重新从交换空间读入物理内存。 Linux的内存管理采取的是分页存取机制， 为了保证物理内存能得到充分的利用， 内核会在适当的时候将物理内存中不经常使用的数据块自动交换到虚拟内存中， 而将经常使用的信息保留到物理内存。 常见错误 ubuntu 报错Syntax error: \"(\" unexpected解决方法。 因为Ubuntu为了加快开机速度，用dash代替了传统的bash，是dash在捣鬼。 解决方法是 取消dash， sudo dpkg-reconfigure dash 在选择项中选No，即可。 ubuntu 重启时，提示 A STOP JOB IS RUNNING FOR UNATTENDED UPGRADES SHUTDOWN A stop job is running for snappy daemon 编辑system.conf文件 vim /etc/systemd/system.conf 修改以下两个地方 DefaultTimeoutStartSec=10s DefaultTimeoutStopSec=10s systemctl daemon-reload // 执行使得配置生效 linux常用命令 命令 说明 reboot 重启系统 shutdown -h now 立刻关机 pwd 显示当前的路径 find aa.x 在当前目录下查找aa开头的文件 sudo chmod 777 XXX目录 修改权限 sudo chmod -R 777 xxx目录 修改目录下所有的文件 sudo su 获取root权限 dpkg -l xx 查询这个xx软件是否安装 dpkg -L xx 查看详细的安装路径， 简洁查询可以用 whereis xx dpkg -i xx.deb 安装deb包 。 如果deb没有打包好依赖包，需要自己手动安装依赖包 。 apt-get 方式会自动解决依赖问题 dpkg -r xx 删除包 dpkg -P xx 删除包（包括配置文件） apt list --upgradable 查看可升级的软件信息 apt list --upgradable -a 查看可升级的软件的全部版本信息 apt --fix-broken install 修正软件包的依赖错误 apt-get -f -y install 安装需要的依赖包 apt-get install xxx 安装xxx软件 apt-get update 同步软件源， 获得最新的软件包 apt-get upgrade 将本地所有的软件更新到apt支持的最新版本。只是简单的更新包。 不建议这样更新 ，可能会导致软件版本兼容问题。 建议指定更新某个软件 apt-get upgrade xx 更新指定的软件到最新版本 apt-get dist-upgrade 作用跟apt-get upgrade 类似，更智能， 可以根据依赖关系的变化，添加或删除依赖包。 apt-cache show xx 获取包的相关信息，如说明、大小、版本等 aptitude show xx 获取包的相关信息，如说明、大小、版本等 。 需要先安装 sudo apt-get install aptitude apt-get remove --purge xxx 卸载软件并且删除配置 apt-get autoclean 清除已卸载软件的备份。 apt默认会把已安装和已卸载的软件都备份起来 apt-get clean 清除已安装软件的备份 arch 显示机器的处理器架构 cat /proc/version 显示内核的版本 ifconfig 查看IP信息 cat>>test.txt 创建文件 mkdir xx 创建目录 rm -f xx 删除文件 rmdir xx 删除空文件夹 rm -rf xx 删除非空文件夹 cp file1 file2 复制文件到当前路径 cp file1 dir1 复制文件夹到指定路径 cp -a dir1 dir2 复制目录 到指定文职 mv a/ b/ 从 a 移动到 b mv 源文件名 目标文件名 移动文件跟重命名都是同一个命令 zip -r a.zip test.txt test2.txt 多个文件压缩成zip unzip xx.zip -d dir unzip -O CP936 xxxx.zip 解决解压后乱码问题 解压zip到指定目录 rar a 3.rar test.txt test2.2 多个文件压缩成rar unrar e 3.rar dir rar解压到指定目录 Linux查看所有用户 cat /etc/passwd cat /etc/passwd |cut -f 1 -d : uname -a | 查看系统架构 dpkg --print-architecture | 64还是32位的 cpu详细信息 cat /proc/cpuinfo | head -20 内存信息 cat /proc/meminfo 或 free 磁盘使用情况 df -hT vim 常用命令 esc // 进入正常模式 i // 进入编辑模式 v // 进入可视模式 vim + fileName // 新建或打开一个文件 :w 保存 :q 退出 :wq 保存并退出 :q! 强制退出 :set number // 显示行号 u //撤销上一步的操作 Ctrl+r //恢复上一步被撤销的操作 在可视模式下 ，按键盘左右键 可以选中内容。 y // 复制选中的内容 p // 粘贴剪切板中的内容 文件上传 ftp ``` ## 文件上传 sz rz ```text 安装 lrzsz sz xxx.zip // 下载服务器上的文件 rz // 将指定的文件 上传到 服务器当前的目录下 rz -be // 批量上传 查找软件的安装路径 whereis 1、先运行这个程序 2、在终端中输入命令 ps -e 3、在打印出来的正在运行程序的列表中找到这个程序的具体名字 ,例如叫做 atom 3、 whereis atom 就会输出 atom: /usr/bin/atom /usr/share/atom 第一个路径就是安装路径 设置自定义分辨率 1920*1080 1、添加1920*1080选项 sudo xrandr --newmode \"1920x1080_60.00\" 173.00 1920 2048 2248 2576 1080 1083 1088 1120 -hsync +vsync sudo xrandr --addmode Virtual1 \"1920x1080_60.00\" 2、设置开机自启 打开 etc/profile 文件 添加 xrandr --newmode \"1920x1080_60.00\" 173.00 1920 2048 2248 2576 1080 1083 1088 1120 -hsync +vsync xrandr --addmode Virtual1 \"1920x1080_60.00\" 默认开启小键盘 Windows下虚拟机中安装Ubuntu 1、安装一个软件 sudo apt-get install numlockx 2、找到并打开配置文件 sudo gedit /usr/share/lightdm/lightdm.conf.d/50-unity-greeter.conf 3、修改并保存 greeter-setup-script=/usr/bin/numlockx on ubuntu下常用软件 网易云音乐播放器 、火狐浏览器 、 搜狗输入法、 wps 、 Unity Tweak Tool 桌面美化工具 、 第三方终端 Guake Terminal atom 、 git 、 FillZilla Ftp 、tomcat 、 进程查看工具 htop 、 截图软件 flameshot 树莓派相关 需要用到的软件 SDFormatter // 格式化sd卡 Win32DiskImager // 烧录系统到sd卡 WiFi共享精灵 // 创建wifi 。方便查看ip 。如有路由器，这个软件就不需要。 WinSCP // 图形化界面，上传文件。 Xshell 、putty // ssh 命令行工具 VNC Viewer // 图形化桌面 ExtFS for Windows // 在window下直接打开装有linux的分区 官方系统 2018-11-13-raspbian-stretch-full.img https://www.raspberrypi.org/downloads/ ubuntu系统也可以，但是没有HDMI外接显示器 安装ubunt有点不方便，所以选择官方系统。 （官方镜像烧录完成 系统就可以直接用，ubuntu还需要一些后续操作才能用） JuiceSSH // 在安卓上连接树莓派 修改密码 和启用 root账号 系统装好之后的默认账号和密码 pi raspberry sudo passwd xxx //更新 xxxx账号的密码 sudo passwd root //修改root密码 sudo passwd --unlock root // 解锁root账号 // 开启 root 登录 打开配置文件 /etc/ssh/sshd_config 注释掉这一行：PermitRootLogin prohibit-password 新建一行添加：PermitRootLogin yes 重启服务 sudo service ssh restart 通过wifi连接网络 在烧录好系统的 sd卡根目录放置一个 ssh文件。（空文件 ，不用写后缀名） wpa_supplicant.conf country=GB ctrl_interface=DIR=/var/run/wpa_supplicant GROUP=netdev update_config=1 network={ ssid=\"AAIVINPC\" psk=\"1234567890\" } 然后接入电源，就会自动去连接指定wifi 。 挂载 NTFS 格式的移动硬盘 一般情况下，Linux是识别不了NTFS格式移动硬盘的， 可以使用 ntfs-3g 来帮助挂载 NTFS格式的硬盘 。 //安装 ntfs-3g apt-get install ntfs-3g fdisk -l | grep NTFS 得到NTFS分区的信息， 类似 /dev/sda5 4096 976773119 976769024 465.8G 7 HPFS/NTFS/exFAT // 挂载之前先 取消挂载 umount /dev/sda5 // 挂载 ， 将 /dev/sda5 挂载到你自己指定的位置 /mnt/aivin-fun-data mount -t ntfs-3g /dev/sda5 /mnt/aivin-fun-data 如果以前挂载过，然后在window上复制了文件到硬盘中 但是树莓派上没法看到。就重新挂载即可。 我的树莓派 好像会自动挂载到 /media 目录下。 将这个文件夹设置为 777 权限。tomato的虚拟目录设置成到这里即可。 不需要指定挂载目录 进行挂载等操作了。 ` 安装tomcat https://tomcat.apache.org/download-90.cgi xxx.zip解压即可 设置 tomcat 开机自启 修改etc目录下的 rc.local文件 cd /home/pi/aivinSpace/tomcat9/bin ./startup.sh 设置tomcat访问webapps之外的路径 修改 tomcat的 server.xml 文件 ，在 Host 节点下 添加 。然后重启tomcat 说明： path 这里代表项目路径 ， docBase 代表Root的路径 例如： 我们的Test.war还是放在 tomcat 的webApp 目录下。 最后的访问路径就是 htpp://xxx:8080/ (这个路径已经达到xyData目录了) 安装 mysql 卸载mysql apt-ge autoremove --purge mysql-server //安装sql apt-get install mysql-server //设置root密码 mysql -u root -p // 密码输入 root密码即可 use mysql; update user set plugin='mysql_native_password' where user='root'; UPDATE user SET password=PASSWORD('123456') WHERE user='root'; flush privileges; exit; 设置 root登录 mysql -uroot -p use mysql; GRANT ALL PRIVILEGES ON *.* TO 'root'@'%' IDENTIFIED BY '123456' WITH GRANT OPTION; flush privileges; exit; // 设置root远程登录 修改mysql配置文件，允许远程登录 ，将bind-address这行注释掉 vim /etc/mysql/mariadb.conf.d/50-server.cnf 然后重启 sudo /etc/init.d/mysql restart //不知道mysql的root账号密码，可以使用 系统的 debian-sys-maint 账号和密码 vim/etc/mysql/debian.cnf //添加账号 ，并允许在所有ip登录 CREATE USER 'aivin'@'%' IDENTIFIED BY '123456'; //授予所有权限（增删改查） GRANT ALL ON *.* TO 'aivin'@'%'; //然后刷新权限 flush privileges; python 扫描本地文件夹 更新数据库 # -*- coding: utf-8 -*- import os import datetime import pymysql conn = pymysql.connect(host='127.0.0.1', # host='127.0.0.1', 192.168.23.2 port=3306, user='root', passwd='123456', db='xyDb', charset='UTF8') print(\"获得数据库连接:\") print(conn) cursor = conn.cursor() sql = \" DROP TABLE IF EXISTS `xyTable`; \" cursor.execute( sql ) print(\"删除表 ok\") sql =\" CREATE TABLE `xyTable` ( `mId` int(100) NOT NULL AUTO_INCREMENT, \" \\ \"`mType` varchar(10) NOT NULL, \\ `mName` varchar(100) NOT NULL, \\ `mDir` varchar(100) NOT NULL,\\ `mDesc` varchar(1000) NOT NULL,\\ `mUrl1` varchar(1000) NOT NULL,\\ `mUrl2` varchar(1000) NOT NULL,\\ `mLrc` varchar(1000) NOT NULL, \\ `mVisiable` varchar(10) NOT NULL, \\ `mTime` varchar(100) NOT NULL, \\ PRIMARY KEY (`mId`) \\ ) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4; \" cursor.execute( sql ) print(\"创建表 ok\") def getFileList(dir, fileList): newDir = dir if os.path.isfile(dir): # 如果是文件则添加进 fileList fileList.append(dir) elif os.path.isdir(dir): for s in os.listdir(dir): # 如果是文件夹 newDir = os.path.join(dir, s) getFileList(newDir, fileList) return fileList # dir = \"D:\\\\xyData\\\\\" dir = \"/mnt/aivin-fun-data/xyData/\" list = getFileList( dir, []) print(\"扫描资料库 ok , 数据总量为：\" , len(list)) for path in list: mType = os.path.basename(os.path.dirname(os.path.dirname(path))) mUrl1 = os.path.basename(path) mName = mUrl1.split(\".\")[0] mDir = os.path.basename(os.path.dirname(path)) mDesc =\"\" mUrl2= \"\" mLrc = mName+\".lrc\" mVisiable =\"1\" mTime = datetime.datetime.now().strftime('%Y-%m-%d') sql = \" insert into xyTable( mType , mName, mDir , mDesc , mUrl1 , mUrl2 , mLrc , mVisiable , mTime )\" \\ \" values( '%s','%s','%s','%s','%s','%s' ,'%s','%s','%s' ) \" \\ % (mType, mName, mDir, mDesc, mUrl1, mUrl2, mLrc, mVisiable, mTime) cursor.execute(sql) newId = int(conn.insert_id()) conn.commit() print(\"插入成功 id: \", newId) print(\"更新完毕 !!! \") cursor.close() conn.commit() conn.close() 安装文件共享 Samba https://www.jianshu.com/p/0fb0638fa061 apt-get install samba apt-get install samba samba-common-bin apt-get install samba-client 配置 /etc/samba/smb.conf 在文件末尾加上如下内容 [public] comment = public storage path = /mnt/udisk valid users = pi read only = no create mask = 0777 directory mask = 0777 guest ok = no browseable = yes public : 这是对外显示的文件名字，可以改成其他ABCD comment：共享文件夹说明 path：共享文件夹目录 valid users：有效用户 read only：是否只读 create mask：创建文件的权限 directory mask：创建文件夹的权限 guest ok：是否允许访客访问 browseable：是否可见 valid users 即 pi 为有效用户 将用户添加到 Samba中 smbpasswd -a pi 重启samba samba restart 注：Samba 默认开机自启，无需为重启担心。 wifi 断线重连 将脚本放入随意一个目录，开机自己执行就可以。 import os, time while True: if '192' not in os.popen('ifconfig | grep 192').read(): print( '\\n****** wifi is down, restart... ******\\n') os.system('sudo /etc/init.d/networking restart') else: print(\"\\nwifi is ok !! \\n\") time.sleep(1 * 60) # n minutes // 在 rc.local文件中加入 cd /home/pi/ python WiFi_Check.py & 树莓派硬件说明 引脚 GPIO GPIO（GeneralPurposeI/OPorts）意思为通用输入/输出端口，通俗地说，就是一些引脚， 可以通过它们输出高低电平或者通过它们读入引脚的状态-是高电平或是低电平。 针脚编号方案 BOARD编号 使用这种编号的好处是，你的硬件将是一直可以使用的，不用担心树莓派的版本问题。 因此，在电路板升级后，你不需要重写代码。 BCM编号 是更底层的工作方式。在使用一个引脚时，你需要查找信道号和物理引脚编号之间的对应规则。 对于不同的树莓派版本，编写的脚本文件也可能是无法通用的。 WPI编号 编号侧重实现逻辑，把扩展GPIO端口从0开始编号，这种编号方便编程。 40个PIN中，有固定输出的5V（2、4号PIN）、3.3V（1、17号PIN）和地线（Ground，6、9、14、20、25、30、34、39）。 如果一个电路两端接在，5V和地线之间，该电路就会获得5V的电压输入。 27和28号PIN标着ID_SD和ID_SC。它们是两个特殊的PIN，用于和拓展树莓派功能的附加电路板通信。 其他的PIN大多编程GPIOX的编号，如GPIO14 等 用户用来给用户编程使用。 控制引脚的第三方库 RPi.GPIO 是Python的一个模块。 通过它可以控制和获取引脚的状态。 gpio readall // 读取树莓派gpio的信息 PWM ( Pulse Width Modulation ) 脉冲宽度调制 是指用微处理器的数字输出来对模拟电路进行控制， 是一种对模拟信号电平进行数字编码的方法。 在树莓派上，可以通过对GPIO的编程来实现PWM。 ( no Copyright，enjoy youself ! ) all right reserved，powered by GitbookThe file was updated at : 2021-02-23 16:14:06 "},"chinese/native/NDK.html":{"url":"chinese/native/NDK.html","title":"NDK","keywords":"","body":"NDK 交叉编译 就是在一个平台上生成另一个平台上的可执行代码。 例如在window平台下编译生成Apk 。 动态库 .so 、 .dll 静态库 .a 、 .lib 将所依赖的文件都编译到同一个文件中。体积大。 window下 MinGW 模拟 linux编译环境 MinGW(Minimalist GNUfor Windows) 可以在window下模拟linux环境。当你没有linux环境或者在linux下遇到奇葩问题的时候，可以用这个替代一下。 1、将默认的那些编译器等都安装好。 2、然后点击 xxx\\msys\\1.0\\msys.bat 即可使用 传统编译方式 build 常用命令 命令 作用 ndk-build 编译 ndk-build V=1 编译并打印出它所执行的详细编译命令 ndk-build NDK_DEBUG=1 编译为调试版本 ndk-build NDK_DEBUG=0 编译为 正式版本 ndk-build NDK_OUT=./mydir 指定编译生成的文件的存放位置 ndk-build -B 强制重新编译已经编译完成的代码 ndk-build clean 清除所有编译出来的临时文件和目标文件 Android.mk 模板 android_mk 官方参考 Android.mk 配置示例 LOCAL_PATH := $(call my-dir) include $(CLEAR_VARS) LOCAL_C_INCLUDES += $(LOCAL_PATH)/../libffmpeg \\ $(LOCAL_PATH)/hardCodec LOCAL_MODULE := libhiesproto ALL_DEFAULT_INSTALLED_MODULES += $(LOCAL_MODULE) LOCAL_STATIC_LIBRARIES := libyuv2rgb_neon LOCAL_SRC_FILES += Hies_proto.c \\ comm_utils.c \\ mbuffer/HiMbuffer.c include $(BUILD_STATIC_LIBRARY) include $(CLEAR_VARS) LOCAL_MODULE := libh265decoder LOCAL_SRC_FILES := hardCodec/H265/lib/libHW_H265dec_Andr.a include $(PREBUILT_STATIC_LIBRARY) include $(CLEAR_VARS) LOCAL_CFLAGS := -D__STDC_CONSTANT_MACROS -DHI_OS_ANDROID -DHI_MEDIA_CODEC_DECODING WITH_ANDROID_VECTOR := true include $(LOCAL_PATH)/../utils.mk LOCAL_C_INCLUDES += \\ $(LOCAL_PATH)/../libffmpeg \\ $(LOCAL_PATH)/../arm_neon \\ $(LOCAL_PATH)/../jni \\ LOCAL_SRC_FILES := \\ mediaplayer.cpp \\ nativeWindow.cpp \\ mbuffer/HiMbuffer.c \\ RTSP_PROTO_INC := \\ $(LOCAL_PATH)/hardCodec/protocol/HiRtspClient \\ $(LOCAL_PATH)/hardCodec/protocol/HiRtspClient/rtspclient/include \\ $(LOCAL_PATH)/hardCodec/protocol/HiRtspClient/rtspclient/src RTSP_PROTO_SRC := $(wildcard $(LOCAL_PATH)/hardCodec/protocol/HiRtspClient/rtspclient/src/*.c) LOCAL_C_INCLUDES += $(RTSP_PROTO_INC) LOCAL_SRC_FILES += $(patsubst $(LOCAL_PATH)/%, %, $(RTSP_PROTO_SRC)) LOCAL_PRELINK_MODULE := false LOCAL_SHARED_LIBRARIES := libffmpeg libmpp libvpu LOCAL_STATIC_LIBRARIES :=libHWAHStreaming libyuv2rgb_neon libhiesproto libh265decoder LOCAL_LDLIBS += -llog -lz -lm -ldl LOCAL_MODULE := libahplayer ALL_DEFAULT_INSTALLED_MODULES += $(LOCAL_MODULE) include $(BUILD_STATIC_LIBRARY) Android.mk 部分解释 LOCAL_PATH := $(call my-dir) 表示源文件在开发树中的位置。 在这里，构建系统提供的宏函数 my-dir 将返回当前目录（即Android.mk文件所在的目录）的路径。 include $(CLEAR_VARS) CLEAR_VARS 变量 其值由构建系统提供。指向特殊 GNU Makefile，可为您清除许多 LOCAL_XXX 变量， 例如 LOCAL_MODULE、LOCAL_SRC_FILES 和 LOCAL_STATIC_LIBRARIES。 请注意，它不会清除 LOCAL_PATH。此变量必须保留其值，因为系统在单一 GNU Make 执行环境（其中所有变量都是全局的）中解析所有构建控制文件。 在描述每个模块之前，必须声明（重新声明）此变量。 LOCAL_MODULE := hello-jni LOCAL_MODULE 变量 将存储您要构建的模块的名称。每个模块名称必须唯一，且不含任何空格。 LOCAL_SRC_FILES := hello-jni.c 最后一行帮助系统将所有内容连接到一起。 include $(BUILD_SHARED_LIBRARY) BUILD_SHARED_LIBRARY 变量 指向 GNU Makefile 脚本，用于收集您自最近 include 后在 LOCAL_XXX 变量中定义的所有信息。 变量和宏 系统提供许多可用于 Android.mk 文件中的变量。 除了这些变量之外，您还可以定义自己的任意变量。 为了便于辨认，自定义变量建议在名称前附加 MY_。 系统自带的变量 NDK 定义的变量 含义 CLEAR_VARS 取消定义LOCAL_XXX 变量。 BUILD_SHARED_LIBRARY 构建动态库 BUILD_STATIC_LIBRARY 构建静态库 PREBUILT_SHARED_LIBRARY 引用另一个模块中的预建库 PREBUILT_STATIC_LIBRARY TARGET_ARCH CPU 架构的名称 TARGET_ARCH_ABI 使用空格作为多个目标之间的分隔符 TARGET_PLATFORM 作为构建系统目标的 Android API 级别号 TARGET_ABI LOCAL_PATH 指定当前文件的路径 LOCAL_MODULE 模块的名称 LOCAL_MODULE_FILENAME 强制改变.so的文件名 LOCAL_SRC_FILES 源文件列表 LOCAL_CPP_EXTENSION 为 C++ 源文件指明 .cpp 以外的文件扩展名 LOCAL_CPP_FEATURES 指明您的代码依赖于特定 C++ 功能 LOCAL_C_INCLUDES 指定相对于 NDK root 目录的路径列表 LOCAL_CFLAGS 设置在构建 C 和 C++ 源文件时要传递的编译器标志。 LOCAL_CPPFLAGS LOCAL_STATIC_LIBRARIES 存储当前模块依赖的静态库模块列表 LOCAL_SHARED_LIBRARIES 依赖的共享库模块列表 LOCAL_WHOLE_STATIC_LIBRARIES 表示链接器应将相关的库模块视为整个存档 LOCAL_LDLIBS 其他链接器标志列表 LOCAL_LDFLAGS 其他链接器标志列表 LOCAL_ALLOW_UNDEFINED_SYMBOLS 捕获“未定义的符号”错误 LOCAL_ARM_MODE LOCAL_ARM_NEON LOCAL_DISABLE_NO_EXECUTE LOCAL_DISABLE_RELRO LOCAL_DISABLE_FORMAT_STRING_CHECKS LOCAL_EXPORT_CFLAGS LOCAL_EXPORT_CPPFLAGS LOCAL_EXPORT_C_INCLUDES LOCAL_EXPORT_LDFLAGS LOCAL_EXPORT_LDLIBS LOCAL_SHORT_COMMANDS LOCAL_THIN_ARCHIVE LOCAL_FILTER_ASM 系统自带的函数宏 NDK 提供的函数宏 含义 my-dir 返回最后包含的 makefile 的路径，通常是当前 Android.mk 的目录 all-subdir-makefiles 返回位于当前 my-dir 路径所有子目录中的 Android.mk 文件列表 this-makefile 返回当前 makefile 的路径 parent-makefile 返回包含树中父 makefile 的路径 grand-parent-makefile 返回包含树中祖父 makefile 的路径 import-module 按模块的名称查找和包含模块的 Android.mk 其他 if [ $? -eq 0 ] $?是shell变量,表示\"最后一次执行命令\"的退出状态.0为成功,非0为失败. Application.mk模板 Application.mk官方参考资料 Application.mk不是必须的。如果没有找到，就会执行一套自己的默认规则。 自定义的Application.mk文件 放在project/jni/目录下 （project代表你所写程序的项目目录），这样ndk-build命令可以自动搜索到它。 Application.mk 配置的作用和范围 1、指明 目标平台的ABI类型 2、指明 工程是 release/debug模式 3、指明 C++标准库类型 4、指定 Toolchains(工具链) Application.mk 简单示例 LOCAL_PATH := $(call my-dir) include $(CLEAR_VARS) LOCAL_MODULE = libhellos LOCAL_CFLAGS = $(L_CFLAGS) LOCAL_SRC_FILES = hellos.c LOCAL_C_INCLUDES = $(INCLUDES) LOCAL_SHARED_LIBRARIES := libcutils LOCAL_COPY_HEADERS_TO := libhellos LOCAL_COPY_HEADERS := hellos.h include $(BUILD_STATIC_LIBRARY) #编译动态库 LOCAL_PATH := $(call my-dir) include $(CLEAR_VARS) LOCAL_MODULE = libhellod LOCAL_CFLAGS = $(L_CFLAGS) LOCAL_SRC_FILES = hellod.c LOCAL_C_INCLUDES = $(INCLUDES) LOCAL_SHARED_LIBRARIES := libcutils LOCAL_COPY_HEADERS_TO := libhellod LOCAL_COPY_HEADERS := hellod.h include $(BUILD_SHARED_LIBRARY) #使用静态库 LOCAL_PATH := $(call my-dir) include $(CLEAR_VARS) LOCAL_MODULE := hellos LOCAL_STATIC_LIBRARIES := libhellos LOCAL_SHARED_LIBRARIES := LOCAL_LDLIBS += -ldl LOCAL_CFLAGS := $(L_CFLAGS) LOCAL_SRC_FILES := mains.c LOCAL_C_INCLUDES := $(INCLUDES) include $(BUILD_EXECUTABLE) #使用动态库 LOCAL_PATH := $(call my-dir) include $(CLEAR_VARS) LOCAL_MODULE := hellod LOCAL_MODULE_TAGS := debug LOCAL_SHARED_LIBRARIES := libc libcutils libhellod LOCAL_LDLIBS += -ldl LOCAL_CFLAGS := $(L_CFLAGS) LOCAL_SRC_FILES := maind.c LOCAL_C_INCLUDES := $(INCLUDES) include $(BUILD_EXECUTABLE) 系统自带的变量 NDK 定义的变量 含义 APP_PROJECT_PATH 指定应用项目根目录的绝对路径。 Application.mk 文件放如果在 $PROJECT/jni/ 下，此变量可选。 APP_OPTIM 默认release APP_CFLAGS 为任何模块编译任何 C 或 C++ 源代码时传递到编译器的一组 C 编译器标志 APP_CPPFLAGS 在仅构建 C++ 源文件时传递到编译器的一组 C++ 编译器标志 APP_LDFLAGS 构建系统在链接应用时传递的一组链接器标志。 APP_BUILD_SCRIPT 指定Android.mk的默认路径 APP_ABI APP_PLATFORM 包含目标 Android 平台的名称 APP_STL APP_SHORT_COMMANDS NDK_TOOLCHAIN_VERSION 定义为 4.9 或 4.8 以选择 GCC 编译器的版本 APP_PIE APP_THIN_ARCHIVE cmake 编译方式 Android 对 CMake的说明请参考 CMake API 、 CMake官网 androidStudio 在2.2之前对 C/C++ 支持不是很友好，没有语法提示，配置编译也不方便 。 从androidStudio 2.2正式版开始 ，采用了cmake方式编译，简化了编译配置 。 可以不用再手动输入 javac、javah命令等。 CMake Android Studio 默认使用 CMake 编译原生库，如果你只打算用ndk-build来编译的话，你就不需要这个组件。CMake是AndroidStudio2.2提供的构建C项目的工具 LLDB 使用它来调试本地代码。 androidstudio2.2+ 输出c代码log信息 1、 error: undefined reference to '__android_log_print' app层的 gradle 中 defaultConfig 标签下 进行配置 ndk { //就是依赖ndk工具包中的一个liblog.so文件 ldLibs \"log\" } 2、cmake中对log的配置使用默认的即可 。 3、//导入log包 #include //定义log标签，名字随意 #define LOG_TAG \"C_TAG\" //定义日志级别 #define LOGD(...) __android_log_print (ANDROID_LOG_DEBUG, LOG_TAG, __VA_ARGS__) //打印log jint value = 1000 ; LOGD(\"value=%d\", value); LOGD(\"value=%d\", 100); 4、有些手机能输出Java中的log，却不能输出c代码中的log 。 原因可能跟手机的设置有关系。 在开发者选项中进行相关设置即可。 build.gradle 部分配置 // 指明项目中需要用到的 第三方的 .so , .a 文件 sourceSets { main { // 如果不配置，android就默认使用这个路径 jniLibs.srcDirs = ['src/main/jniLibs'] // 如果喜欢放 libs目录，可以直接这样写 //jniLibs.srcDirs = ['libs'] } } ndk{ // 指明只编译的对应的cpu类型 abiFilters \"armeabi-v7a\" } cmake { cppFlags \"-std=c++11 -frtti -fexceptions\" // 让CMake构建原生库时支持“NEON”,默认的是不支持 arguments \"-DANDROID_ARM_NEON=TRUE\" } packagingOptions // 用来对 gradle做一些配置 exclude //过滤掉某些文件或者目录不添加到APK中 pickFirst // 匹配到多个相同文件，只提取第一个 。 merge // 匹配的文件都添加到APK中，和pickFirst有些相反，会合并所有文件。 doNotStrip //设置某些动态库不被优化压缩。 CMakeLists.txt 部分配置 #这里设定工程路径 ， 等同于 CMAKE_SOURCE_DIR # set(PROGRAM_PATH \"E:/test-fffffmpeg/WkNative/app\") # 批量导入rtsp 相关代码 file( GLOB_RECURSE wkrtsp_cpp \"src/main/cpp/rtspclient/src/*.cpp\") file( GLOB_RECURSE wkrtsp_c \"src/main/cpp/rtspclient/src/*.c\") add_library(wkrtsp-lib SHARED ${wkrtsp_c} ${wkrtsp_cpp}) #导入已经编译好的opencv库-头文件 include_directories( src/main/cpp/OpenCV/include ) # 导入 opencv 的so add_library(libopencv_world SHARED IMPORTED ) set_target_properties( libopencv_world PROPERTIES IMPORTED_LOCATION ${CMAKE_SOURCE_DIR}/src/main/jniLibs/armeabi-v7a/libopencv_world.so ) CMakeLists.txt 说明 # 添加了c++11的支持 set(CMAKE_CXX_FLAGS \"${CMAKE_CXX_FLAGS} -std=gnu++11\") # 此标志在链接成共享库时有效 set(CMAKE_SHARED_LINKER_FLAGS \"${CMAKE_SHARED_LINKER_FLAGS} -Wall -v -Wl,--no-warn-shared-textrel\") # 系统库，打印日志 find_library( log-lib log ) # 系统库 ，压缩库 find_library( z-lib z ) # 数学计算 find_library( m-lib m ) 其他配置 enable_language(ASM) //支持汇编 configure_file () // 代码文件中可以使用CMake中的变量 set( KEY, value) // 键值对, 设置KEY的值为value。获取方式为 ${KEY} unset () //取消键值对设置 list () // 用来做一些操作，例如LENGTH 、APPEND 、FIND 、REMOVE_AT 等 add_definitions () // 增加编译参数 add_custom_command () // 添加自定义命令 add_subdirectory () // 将指定的文件夹加到build任务列表中。 install () // 用于定义安装规则，安装的内容可以包括目标二进制、动态库、静态库以及 文件、目录、脚本等 include_directories () //导入头文件 add_library () //添加一个库 add_executable () // 引入一个可执行文件 set_target_properties () // 将各种 so 文件的路径转化成简单的值 find_library () // 寻找本地存在的库的路径,例如日志打印库log link_directories () // 添加动态连接库的路径 target_link_libraries ()// 将目标文件与库文件进行链接. target_include_directories () // 也是用来配置头文件 target_compile_options () // 指定编译选项 file(GLOB xxx \"${PATH_TO_MEDIACORE}/camera/*.cc\") // file函数，自动将指定目录下的符合后缀的文件加入到xxx变量中，GLOB/GLOB_RECURSE 是一种加入策略， project (XXX) // 这个项目的名字叫xxx message ([] \"message to display\" ...) //输出打印信息 ， mode= none / STATUS /WARNING /FATAL_ERROR 等 add_executable (xxx bbb.cpp) //为 xxx这个 project 添加一个可执行的文件bbb.cpp option( \"\" [value]) //变量名 + 描述信息 + 初始值(只能是ON或OFF) if 、foreach、while // 条件判断 macro (xx bb) // 开始宏定义 endmacro () // 结束宏定义 function () // 开始函数定义 endfunction () //结束函数定义 CMAKE_SOURCE_DIR // 内置常量 ， 表示当前项目根目录 CMAKE_CURRENT_LIST_DIR // 内置常量 ， 当前文件所在的目录 PROJECT_SOURCE_DIR // 内置常量 ，表示的是源代码的路径。 PROJECT_BINARY_DIR //内置常量 ，表示的是cmake build 的路径 ANDROID_PLATFORM_LEVEL //系统版本 ANDROID_ABI // 设备cpu架构类型 STRLESS、STRGREATER、STREQUAL // 字符串比较 LESS、GREATER、EQUAL //数字比较 CMAKE_BUILD_TYPE //cmake的编译方式 ，调试版还是正式版 Debug ，Release PROPERTIES //用来指定库的一些编译属性 IMPORTED_LOCATION // 库的地址 CMAKE_SYSTEM // 系统全名 CMAKE_SYSTEM_NAME //系统名称 CMAKE_SYSTEM_VERSION // 系统版本 CMAKE_SYSTEM_PROCESSOR //CPU名称 MATCHES // 用正则表达式去匹配到给定的内容 jni 基于 Androidstudio 、cmake 、 c/c++ 。注意：jni层去读取SD卡的文件，需要在AndroidManifest.xml配置权限。 JNI 使用场景 1、提高代码安全性。因为.so文件反编译困难。（加密一些算法等） 2、方便使用已经存在的c/c++库。可以加载 .dll 和 .so 格式的动态库。 3、提高某些特定情况下的执行效率。（c/c++的效率比java高。不过并不能明显提升android程序的性能） JNI语法 #ifdef __cplusplus extern \"C\" #endif // 如果是c++代码，也统一用c的语法去编译。 #ifdef __cplusplus extern \"}\" #endif extern \"C\" JNIEXPORT void JNICALL Java_com_xxx_nPlay(JNIEnv *env, jobject instance, jstring url_) { ... } extern \"C\" JNIEXPORT void JNICALL Java_com_kgdwbb_jnistudy_MainActivity_helloJNI(JNIEnv* env, jobject thiz,jstring msg) { //do something } extern \"C\" // 代码是用C++语言写的就需要用这个， C语言编写则不需要。 JNIEXPORT // 标记为该方法可以被外部调用，类似Java的public函数和private函数的区别。 JNICALL // 说明这个函数是一个JNI函数，用来和普通的C/C++函数进行区别。 JNIEnv JNIEnv是 JavaVM 在线程中的代表, 每个线程都有一个, JNI 中可能有很多个 JNIEnv; 每个JNIEnv 都是线程专有的, 其它线程不能使用本线程中的 JNIEnv, 线程 A 不能调用 线程 B 的 JNIEnv; 但是，一个本地方法可被不同的 Java 线程所调用，因此可以接受不同的 JNIEnv。 //JNIEnv 作用 1、调用Java函数 JNIEnv代表Java运行环境,可以使用JNIEnv调用Java中的代码; 2、操作Java对象 Java对象传入JNI层就是Jobject对象, 需要使用JNIEnv来操作这个Java对象; JNI 动态注册 、静态注册 无论是动静态注册还是动态注册， Java端代码都是一样的， 区别在于 C/C++里面的代码形式 // 静态注册，简单易懂，Androidstudio 自动生成就采用这种方式 extern \"C\" JNIEXPORT jstring JNICALL Java_com_mirkowu_jintest_jni_JniTest_stringFromJNI(JNIEnv *env, jclass clazz) { std::string hello = \"Hello from C++ by 静态注册\"; return env->NewStringUTF(hello.c_str()); } // 动态注册，事先维护好一张表，将 Java和 native 端的方法名对应起来，效率相对高一点 static JNINativeMethod method_table[] = { // 第一个参数a 是java native方法名， // 第二个参数 是native方法参数,括号里面是传入参的类型，外边的是返回值类型， // 第三个参数 是c/c++方法参数,括号里面是返回值类型， {\"a\", \"()Ljava/lang/String;\", (jstring *) aaa}, {\"b\", \"(Ljava/lang/Object;Ljava/lang/String;)Ljava/lang/String;\", (jstring *) getStringWithDynamicReg}, }; JNI的数据类型 java基本类型 JNI类型 bit - java基本类型 JNI类型 bit boolean jboolean 8 int jint 32 byte jbyte 8 long jlong 64 char jchar 16 float jfloat 32 short jshort 16 double jdouble 64 void void 无 java引用类型 JNI类型 - java引用类型 JNI类型 Object jobject short[ ] jshortArray Class jclass int[ ] jintArray String jstring long[ ] jlongArray Object[ ] jobjectArray float[ ] jfloatArray boolean[ ] jbooleanArray double[ ] jdoubleArray byte[ ] jbyteArray Throwable jthrowable char[ ] jcharArray 字符串 std::string helloCpp = \"Hello from C++ , aivin\"; showLog(\"--> %s\" ,helloCpp.c_str()) ; JNI签名 java中，对于某一个对象来说， 可以用过方法名和参数 就可以确定唯一的一个方法。在JNI中，通过函数名和 签名信息 可以确定唯一的方法。 基本数据签名的规则 java类型 JNI类型 - java类型 JNI类型 boolean Z long J byte B float F char C double D short S void V int I 签名详解 // 类的签名（注意末尾的分号） L+包名+类名+； java.lang.String -> Ljava/lang/String; // 对象签名 跟它所属的类的签名一样。 // 一维数组签名 格式： [类型 double[ ] -> [ D // 多维数组签名 格式： n个 [ + 类型签名 int[ ] [ ] -> [[I // 方法签名 (跟方法名无关) 格式： （参数类型签名） + 返回值类型签名 boolean fun( int a , double b , int[ ] c) -> (ID[I)Z void fun(int i) -> (I)V 引用类型 //全局引用 全局引用可以跨方法、跨线程使用，直到被显式释放。 NewGlobalRef() //新建全局变量 DeleteGlobalRef() //删除全局引用 //局部引用 局部引用仅在创建它的native函数及该函数调用的函数中有效。局部引用将在该函数返回时被释放。 DeleteLocalRef() //删除引用 // 弱全局引用 与全局引用类似，弱引用可以跨方法、线程使用。但弱引用不会阻止GC回收它引用的对象， 它所引用的对象可能是不存在的或者已经被回收。在内存不足时可能会被收回了。使用前先判断一下。 global_weakRef_str= (jstring) env->NewWeakGlobalRef(str2); if(! env->IsSameObject(NULL , global_weakRef_str)){ showLog(\"this global_weakRef_str is usefully\") ; } env->DeleteWeakGlobalRef(global_weakRef_str) ; Java 和 C 函数的映射表 // { java中函数名字 , 参数和返回值 , 对应的c函数} { \"setUsbLinkVideoData\", \"(Ljava/nio/ByteBuffer;I)V\", (void*)com_media_ffmpeg_FFMpegPlayer_setUsbLinkVideoData } 常用函数 函数名 说明 FindClass CallIntMethod CallVoidMethod GetStaticMethodID CallStaticIntMethod NewObject CallStaticObjectMethod NewStringUTF GetStringUTFChars 得到一个UTF-8编码的字符串 GetStringChars 得到UTF-16编码的字符串 ReleaseStringUTFChars JNI_OnLoad so库加载时调用。 如果你的*.so档没有提供JNI_OnLoad()函数，VM会默认使用最老的JNI 1.1版本。 JNI_OnUnload - SetByteArrayRegion 将本地的数组数据拷贝到了 Java 端的数组中 env->ThrowNew 抛出异常信息 jclass exceptionClazz = env->FindClass(\"java/lang/RuntimeException\"); env->ThrowNew(exceptionClazz, \"自错误信息\"); reinterpret_cast 类型强制转换MyParcel parcel = reinterpret_cast >(nativePtr); GetStaticFieldID SetStaticFieldID GetBooleanField( ) // 返回对象的实例(非静态)域的值 GetByteField( ) GetCharField( ) GetShortField( ) GetIntField( ) GetLongField( ) GetFloatField( ) GetDoubleField( ) GetObjectClass( ) // 根据 对象 获取类 GetMethodID( ) // 根据名字获取Java中指定类的指定函数 CallVoidMethod( ) // 调用返回值为void的Java函数 CallBooleanMethod ( ) // 调用返回值为boolean的Java函数 AttachCurrentThread //当前线程获取JNI环境 DetachCurrentThread( ) // 退出当前JNI环境 GetBooleanArrayElements( ) // 获得数组指针 GetByteArrayElements( ) // GetCharArrayElements( ) GetShortArrayElements( ) GetIntArrayElements( ) GetLongArrayElements( ) GetFloatArrayElements( ) GetDoubleArrayElements( ) JNI_OnLoad(...) JavaVM* java_vm = NULL; JNIEXPORT jint JNI_OnLoad(JavaVM* vm, void* reserved) { JNIEnv *env; if (vm->GetEnv( (void**) &env, JNI_VERSION_1_4) != JNI_OK) { return JNI_ERR ; } java_vm = vm; return JNI_VERSION_1_4; } 打印日志 #include #define LogTag \"WK_LOGER\" #define LOGI(...) __android_log_print(ANDROID_LOG_INFO, LogTag ,__VA_ARGS__); 异常定位 // androidsudio JNI崩溃 报错定位： xxx \\app\\build\\intermediates\\cmake\\debug\\obj 请进入正确的目录 , 该目录下有各种架构类型的文件夹， arm64-v8a、armeabi-v7a、x86_64等。 找到有XX.so 的文件夹。例如我的就是 arm64-v8a 里面有so。 输入命令：adb shell logcat | ndk-stack -sym arm64-v8a 。 会提示是具体哪一行代码报错，不过仍然不能像Java代码点击就会跳转的。 //cmake编译错误定位： 当CMakeLists.txt 配置文件配置错误时，会提示编译不过，错误定位方法。 CMake的错误输出不在console窗口中，而是在 本工程的 cmake_server_log.txt文件中。 打开该文件搜索error关键字，可以看到具体的错误信息。 缓存策略 直接用全局变量也可以（但是可能会被其他类的程序修改），所以建议用静态static较安全。 Java_com_xxx_staticLocalCache(JNIEnv *env, jclass jclz, jstring name) { static jfieldID j_fid = NULL; //局部缓存 if (j_fid == NULL) { j_fid = (*env)->GetStaticFieldID(env, jclz, \"name\", \"Ljava/lang/String;\") } } static jfieldID j_fid = NULL;// 全局缓存 Java_com_xxx_initStaticCache (JNIEnv *env, jclass jclz){ j_fid = (*env)->GetStaticFieldID(env, jclz, \"name\", \"Ljava/lang/String;\"); } // 这也叫缓存？乱七八糟。 java调用native 注意文件夹路径要和native中的签名一样 static { System.loadLibrary(\"music-player\"); } private native void nPlay(String url); native 调用 java C++主线程调用Java方法 1、根据jobject获取jclass jclass jlz = env->GetObjectClass(instance);//jobject instance 2、获取 jmethodID jmethodID jmid_error= jniEnv->GetMethodID(jlz, \"onError\", \"(ILjava/lang/String;)V\"); 3、调用方法 jniEnv->CallVoidMethod(jobj, jmid_error, code, jmsg);// jobject,jmethodID , 参数... C++子线程调用Java方法 JniEnv是线程相关的，所以子线程中不能使用创建线程的JniEnv； JVM是进程相关的，可以通过JVM来获取当前线程的JniEnv，然后才能调用Java的方法。 JNIEnv *jniEnv; if (javaVM->AttachCurrentThread(&jniEnv, 0) != JNI_OK) { return; } // 如果获取成功，AttachCurrentThread 就会返回一个属于当前线程的JNIEnv指针。 jniEnv->CallVoidMethod(...); //执行相关操作... javaVM->DetachCurrentThread(); POSIX线程 Android NDK的线程是通过POSIX标准实现的，所以也叫POSIX线程。 POSIX 使用 //头文件 #include // 创建线程锁对象 pthread_mutex_t mutex; // 用来申明一个线程对象 pthread_t thread //创建线程条件对象 pthread_cond_t cond; pthread_attr_t：线程属性 Thread-local storage（或者以Pthreads术语，称作线程特有数据）： POSIX 常用方法 常用方法 说明 pthread_create(...) 创建线程. pthread_create(&playThreadT, NULL, threadPlay, this);最后一个参数是运行函数的参数。 pthread_detach() 即主线程与子线程分离，子线程结束后，子线程资源自动回收 pthread_exit() 终止当前线程 pthread_join() 阻塞当前的线程，直到另外一个线程运行结束 pthread_attr_init() 初始化线程的属性 pthread_attr_setdetachstate() 决定这个线程在终止时是否可以被结合 pthread_attr_getdetachstate() 获取脱离状态的属性 pthread_attr_destroy() 删除线程的属性 pthread_kill() 向线程发送一个信号 pthread_mutex_init(...) 初始化互斥锁 pthread_mutex_destroy(...) 删除互斥锁 pthread_mutex_lock(...) 占有互斥锁（阻塞操作） pthread_mutex_trylock() 试图占有互斥锁 pthread_mutex_unlock() 释放互斥锁 pthread_cond_init(...) 初始化条件对象 pthread_cond_destroy(...) 销毁条件对象 pthread_cond_signal(...) 发出条件信号，唤醒第一个调用pthread_cond_wait()而进入睡眠的线程 pthread_cond_wait() 用于线程阻塞等待，直到 pthread_cond_signal 发出条件信号后才执行后续操作 pthread_key_create() 分配用于标识进程中线程特定数据的键 pthread_setspecific() 为指定线程特定数据键设置线程特定绑定 pthread_getspecific() 获取调用线程的键绑定，并将该绑定存储在 value 指向的位置中 pthread_key_delete() 销毁现有线程特定数据键 pthread_attr_getschedparam() 获取线程优先级 pthread_attr_setschedparam() 设置线程优先级 pthread_equal() 对两个线程的线程标识号进行比较 pthread_self() 查询线程自身线程标识号 pthread_cancel() 在安卓NDK中已经被删除。因为比较危险。 pthread_create(...) pthread_create(&pthread,NULL,threadCallBack,NULL); 其总共接收4个参数， 第一个参数为pthread_t对象， 第二个参数为线程的一些属性我们一般传NULL就行， 第三个参数为线程执行的函数， 第四个参数是传递给线程的参数 pthread_exit(...) pthread_exit(&thread) ; 参数也可以传NULL。 java与native共享内存 大概原理，在native开辟一块内存。将这块内存的首地址传给java层，以后的相关操作就通过这个地址获得这块内存，用native代码直接操作内存。 暂时用得少，以后再补充。 android中的应用有 Parcel，因为直接操作内存的，所以比操作IO的Serializable 效率高。 其他 RegisterNatives(clazz, methods, size) // 将clazz类中的 所有方法methods全部注册为本地方法。 jlong id= reinterpret_cast(record); // c++ 对象与对象句柄进行互相转换 auto *record = reinterpret_cast(id); jni Demo jniSample 演示效果： [x] java调用c++ [x] c++回调Java函数 [x] c++获取并修改Java静态变量 [x] Java开启子线程让c++执行耗时操作，并更新Java ui [x] 传递并修改数组 [x] c++创建Java定义的对象并返回 [ ] c++调用第三方库实现加密解密 [ ] c++读取文件 [ ] c++接收Java传递的控件 并绘制图像 [x] c++获取apk包名 [x] c++获取apk签名 哈希值 (签名校验) JNI函数签名生成工具 public class SignatureGen { private static final HashMap Primitives = new HashMap(); static { Primitives.put(Void.class.getName(),\"V\"); Primitives.put(Boolean.class.getName(),\"Z\"); Primitives.put(Byte.class.getName(),\"B\"); Primitives.put(Character.class.getName(),\"C\"); Primitives.put(Short.class.getName(),\"S\"); Primitives.put(Integer.class.getName(),\"I\"); Primitives.put(Long.class.getName(),\"J\"); Primitives.put(Float.class.getName(),\"F\"); Primitives.put(Double.class.getName(),\"D\"); } /** * @param 返回值的类型 * @param params 参数类型 * @return 签名 */ public static String getSignature( Class ret, Class...params ) { StringBuilder builder = new StringBuilder(); builder.append(\"(\"); for( Class param : params ) { builder.append(getSignature(param)); } builder.append(\")\"); builder.append(getSignature(ret)); return builder.toString(); } private static String getSignature( Class param ) { StringBuilder builder = new StringBuilder(); String name = \"\"; if( param.isArray() ) { name = param.getComponentType().getName(); builder.append(\"[\"); }else { name = param.getName(); } if( Primitives.containsKey(name) ) { builder.append(Primitives.get(name)); } else { builder.append(\"L\"+name.replace(\".\",\"/\")+\";\"); } return builder.toString(); } } //使用方法 //第一个参数是返回值类型 ，后面的参数是参数类型 例如需要获得这个函数的签名： int func(boolean a,String b) //参数应该这样填写 SignatureGen.getSignature(Integer.class,Boolean.class,String.class)); //获得签名如下 (ZLjava/lang/String;)I POSIX 简单示例 #include #include \"wkplayer.h\" #include #include JavaVM* java_vm = NULL; pthread_mutex_t mutex; // 全局 回调对象 jobject callback = NULL; // 全局回调函数 jmethodID gOnNativeMessage = NULL; //传递pthread参数用的结构体 struct NativeWorkerArgs { jint id; char reslut[20]; }; extern \"C\" JNIEXPORT void JNICALL Java_com_walkera_cn_ffmpegforandoriddemo_FFmpegPlayer_playMyMedia(JNIEnv *env, jobject instance, jstring url_) { const char *url = env->GetStringUTFChars( url_, 0); LOGI(\"url:%s\", url); env->ReleaseStringUTFChars( url_, url); // 在逻辑需要的时候开启子线程，并在子线程中回调java函数 pthread_t handle ; //传到子线程中的参数 NativeWorkerArgs* nativeWorkArgs = new NativeWorkerArgs(); nativeWorkArgs->id = 100; strcpy(nativeWorkArgs->reslut , \"登录成功！\"); //创建线程 0 代表成功 int result = pthread_create(&handle, NULL, nativeWorkerThread, (void*) nativeWorkArgs); } //子线程 执行的函数 void* nativeWorkerThread(void* args) { JNIEnv* env = NULL; if ( 0 == java_vm->AttachCurrentThread(&env, NULL)) { //lock if (0 != pthread_mutex_lock(&mutex)) { jclass exceptionClazz = env->FindClass(\"java/lang/RuntimeException\"); env->ThrowNew(exceptionClazz, \"Unable to lock mutex--\"); } NativeWorkerArgs* nativeWorkerAgrs = (NativeWorkerArgs*) args; // 模拟延时 ，3秒 sleep(2); LOGI(\"参数=== %d , %s \" ,nativeWorkerAgrs->id ,nativeWorkerAgrs->reslut); env->CallVoidMethod( callback, gOnNativeMessage, nativeWorkerAgrs->id , env->NewStringUTF(nativeWorkerAgrs->reslut) ); delete nativeWorkerAgrs; java_vm->DetachCurrentThread(); if (0 != pthread_mutex_unlock(&mutex)) { jclass exceptionClazz = env->FindClass(\"java/lang/RuntimeException\"); env->ThrowNew(exceptionClazz, \"Unable to unlock mutex--\"); } } return NULL; } extern \"C\" JNIEXPORT void JNICALL Java_com_walkera_cn_ffmpegforandoriddemo_FFmpegPlayer_setNativeCallback(JNIEnv *env, jobject instance, jobject callback0) { if (NULL == callback) { callback = env->NewGlobalRef(callback0); } //初始java回调 if (NULL == gOnNativeMessage) { jclass clazz = env->GetObjectClass(callback); gOnNativeMessage = env->GetMethodID(clazz, \"callbackForNative\", \"(ILjava/lang/String;)V\"); } } extern \"C\" JNIEXPORT void JNICALL Java_com_walkera_cn_ffmpegforandoriddemo_FFmpegPlayer_initNative(JNIEnv *env, jobject instance) { //初始化互斥量 if (0 != pthread_mutex_init(&mutex, NULL)) { jclass exceptionClazz = env->FindClass(\"java/lang/RuntimeException\"); env->ThrowNew(exceptionClazz, \"Unable to init mutex\"); } } extern \"C\" JNIEXPORT void JNICALL Java_com_walkera_cn_ffmpegforandoriddemo_FFmpegPlayer_freeNative(JNIEnv *env, jobject instance) { if (NULL != callback) { env->DeleteGlobalRef(callback); callback = NULL; } //释放互斥量 if (0 != pthread_mutex_destroy(&mutex)) { jclass exceptionClazz = env->FindClass(\"java/lang/RuntimeException\"); env->ThrowNew(exceptionClazz, \"Unable to destroy mutex--\"); } } TCP socket 简单示例 记得在子线程中进程网络耗时操作。 用 ByteBuffer 方式测试失败。还没找到原因。 // java端定义接口 public native boolean createSocket(); public native boolean connectSocket(String ip, int port); public native int recvSocket(byte[] buffer, int offset, int count); public native boolean sendStringData(String sendData); public native boolean sendBytesData(byte[] byteBuffer); public native boolean closeSocket(); #include #include #include #include #include #include JavaVM* java_vm = NULL; int sockId; // 创建socket extern \"C\" JNIEXPORT jboolean JNICALL Java_com_walkera_cn_ffmpegforandoriddemo_TcpClinet_createSocket(JNIEnv *env, jobject instance) { sockId = socket(AF_INET, SOCK_STREAM, 0) ; if(sockIdGetStringUTFChars( ip_, 0); struct sockaddr_in servaddr; memset(&servaddr, 0, sizeof(servaddr)); servaddr.sin_family = AF_INET; servaddr.sin_port = htons(port); if (inet_pton(AF_INET, ip, &servaddr.sin_addr) ReleaseStringUTFChars( ip_, ip); return JNI_TRUE; } // 发送 String 类型的数据 // 发送中文 会有乱码 。 extern \"C\" JNIEXPORT jboolean JNICALL Java_com_walkera_cn_ffmpegforandoriddemo_TcpClinet_sendStringData(JNIEnv *env, jobject instance, jstring sendData_) { const char *sendData = env->GetStringUTFChars( sendData_, 0); if (!sockId) { jclass exceptionClazz = env->FindClass(\"java/lang/RuntimeException\"); env->ThrowNew(exceptionClazz, \"socket已经断开\"); return JNI_FALSE; } //LOGI(\"发送%s=\" ,sendData); fgets((char *) sendData, 1024, stdin); if (send(sockId, sendData, strlen(sendData), 0) ReleaseStringUTFChars( sendData_, sendData); return JNI_TRUE; } // 发送 byte[] 类型的数据 extern \"C\" JNIEXPORT jboolean JNICALL Java_com_walkera_cn_ffmpegforandoriddemo_TcpClinet_sendBytesData(JNIEnv *env, jobject instance, jbyteArray byteBuffer_) { if (!sockId) { jclass exceptionClazz = env->FindClass(\"java/lang/RuntimeException\"); env->ThrowNew(exceptionClazz, \"socket已经断开\"); return JNI_FALSE; } jbyte* pBuffer = env-> GetByteArrayElements(byteBuffer_ , NULL); jint legth = env->GetArrayLength(byteBuffer_) ; if (send(sockId, pBuffer, legth , 0) ReleaseByteArrayElements(byteBuffer_, pBuffer, 0); return JNI_TRUE ; } // 接收byte[]信息 extern \"C\" JNIEXPORT jint JNICALL Java_com_walkera_cn_ffmpegforandoriddemo_TcpClinet_recvSocket(JNIEnv *env, jobject instance, jbyteArray buffer_, jint offset, jint count) { if (!sockId) { jclass exceptionClazz = env->FindClass(\"java/lang/RuntimeException\"); env->ThrowNew(exceptionClazz, \"socket已经断开\"); return 0; } jbyte buf[count - offset]; int rec_len; if ((rec_len = (int) recv(sockId, buf, sizeof(buf), 0)) == -1) { jclass exceptionClazz = env->FindClass(\"java/lang/RuntimeException\"); env->ThrowNew(exceptionClazz, \"native接收异常\"); return 0; } buf[rec_len] = '\\0'; // 将本地数据拷贝到java端的数组中 env->SetByteArrayRegion( buffer_, offset, count, buf); env->DeleteLocalRef(buffer_); return rec_len; } // 关闭连接 extern \"C\" JNIEXPORT jboolean JNICALL Java_com_walkera_cn_ffmpegforandoriddemo_TcpClinet_closeSocket(JNIEnv *env, jobject instance) { int reslut = close(sockId); // 返回0 ，关闭成功 return JNI_TRUE; } JNIEXPORT jint JNI_OnLoad(JavaVM* vm, void* reserved) { JNIEnv *env; if (vm->GetEnv( (void**) &env, JNI_VERSION_1_4) != JNI_OK) { return JNI_ERR ; } java_vm = vm; return JNI_VERSION_1_4; } ( no Copyright，enjoy youself ! ) all right reserved，powered by GitbookThe file was updated at : 2021-06-07 10:50:50 "},"chinese/native/系统编译剪裁.html":{"url":"chinese/native/系统编译剪裁.html","title":"系统编译剪裁","keywords":"","body":"系统编译 RK3288/RK3399 启动后有三种模式：normal模式、 loader模式、MASKROM模式 normal模式： 正常的启动模式，这个模式无法刷固件 . 一般板子通电就是这个模式。 loader模式： 刷固件模式，这个模式可以刷各种image。 按住recover按键再通电，通过bootloader/uboot的检测进入这个模式 MASKROM模式： 这种模式用于拯救砖头机器，比如bootloader/uboot 无法启动，无法进入loader模式正常下载。 常用命 打开终端 CTRL+ALT+T cd ..是返回上一层目录, cd -是返回到上一次的工作目录 linux tree命令 sudo apt install tree //安装 tree // 显示目录和文件 tree -a //显示目录和文件 包括隐藏的 tree -L 3 // 只显示三层 tree -L 3 > log.txt //将信息转到txt中 //只显示目录。abc.abc 是我假想的不存在的文件。找不到文件所以只显示目录。 tree -P -L 3tree -P abc.abc -L 4 > 4.txt linux14.04 ,虚拟机创建共享文件夹后没有/mnt/hgfs 1、先尝试重新安装 vmtools ，并重启虚拟机 2、如果还是没有，可以安装补丁 安装完vmware-tools工具后，执行sudo apt-get install open-vm-dkms 后 使用sudo mount -t vmhgfs .host:/ /mnt/hgfs命令提示 \"Error: cannot mount filesystem: No such device\" 解决方法： $ git clone https://github.com/rasa/vmware-tools-patches.git $ cd vmware-tools-patches $ ./patched-open-vm-tools.sh Linux解压文件到指定目录 . tar 格式 tar zxvf test.tgz -C 指定目录 比如将/source/kernel.tgz解压到 /source/linux-2.6.29 目录 tar zxvf /source/kernel.tgz -C /source/ linux-2.6.29 linux下的source命令（.命令）解释及应用 source filename # filename必须是可执行的脚本文件 或者 . filename # 注意“.”号后面还有一个空格 通知当前shell读入路径为filename的文件并依次执行文件中的所有语句。 android下m、mm、mmm编译命令的使用 要想使用这些命令，首先需要在android源码根目录执行. build/envsetup.sh m：编译所有的模块 mm：编译当前目录下的模块，当前目录下要有Android.mk文件 mmm：编译指定路径下的模块，指定路径下要有Android.mk文件 make 根据Makefile编译源代码，连接，生成目标文件，可执行文件。 make clean 清除上次的make命令所产生的object文件（后缀为“.o”的文件）及可执行文件。 make install 将编译成功的可执行文件安装到系统目录中，一般为/usr/local/bin目录。 make distclean 类似make clean，但同时也将configure生成的文件全部删除掉，包括Makefile。 make dist 产生发布软件包文件（即distribution package）。 这个命令将会将可执行文件及相关文件打包成一个tar.gz压缩的文件用来作为发布软件的软件包。 android5.1.1源码目录 ├── rk3288 ├── abi //应用程序二进制接口 ├── art ART运行环境 ├── bionic 系统C库 ├── bootable 启动引导相关代码 ├── build 存放系统编译规则及generic等基础开发包配置 ├── build-20180423.sh ├── build.sh ├── build.sh~ ├── buildspec.mk ├── cts Android兼容性测试套件标准 ├── dalvik dalvik虚拟机 ├── developers 开发者目录 ├── development 应用程序开发相关 ├── device 设备相关配置 ├── docs 参考文档目录 ├── external 开源模组相关文件 ├── frameworks 应用程序框架，Android系统核心部分，由Java和C++编写 ├── hardware 主要是硬件抽象层的代码 ├── kernel ├── kernel_20181226thouchok.tar.gz ├── kernel.tar.gz ├── kernel_testmipi.tar.gz ├── libcore 核心库相关文件 ├── libnativehelper 动态库，实现JNI库的基础 ├── Makefile 全局Makefile文件，用来定义编译规则 ├── manifest.xml ├── mkimage.sh ├── ndk NDK相关代码，帮助开发人员在应用程序中嵌入C/C++代码 ├── out 编译完成后代码输出在此目录 ├── packages 应用程序包 ├── packages.tar.gz ├── pdk Plug Development Kit 的缩写，本地开发套件 ├── prebuilts x86和arm架构下预编译的一些资源 ├── RKDocs ├── rkst ├── RKTools ├── rockdev ├── sdk sdk和模拟器 ├── system 底层文件系统库、应用和组件 ├── tools 工具文件 ├── u-boot └── vendor framwork层目录结构 ├── rk3288/frameworks/base ├── Android.mk ├── api //android应用框架层声明类、属性、资源 ├── CleanSpec.mk ├── cmds //android系统启动时用到的commands ├── core // framework的核心（框架组件） ├── data // android下的资源（字体、声音、视频等） ├── docs // 项目说明文档 ├── drm // 实现权限管理、数字内容解密等工作的模块 ├── graphics // 图像渲染模块 ├── include ├── keystore // 密匙库 ├── libs // 库信息（界面、存储、usb） ├── location // 位置信息 ├── media // 手机媒体管理（音频视频） ├── modify_alarm_filter.patch ├── MODULE_LICENSE_APACHE2 ├── multiwindow ├── native ├── nfc-extras // nfc模块 ├── NOTICE ├── obex // 蓝牙模块 ├── opengl // opengl模块 ├── packages // 框架层的实现（界面、服务、存储） ├── policy // 手机状态控制（静音、振动） ├── preloaded-classes ├── rs ├── samples // 官方的小demo ├── sax // 解析xml ├── services // 基于手机的服务（复制粘贴、输入输出、手势、wifi） ├── stereo ├── telecomm ├── telephony //手机操作（电话、短信的操作） ├── test-runner // 测试 ├── tests // 测试 ├── third-party ├── tools // 工具包（打包、布局） └── wifi // wifi模块 镜像文件说明 resource.img 资源映像，内含开机图片和内核的设备树信息。 kernel.img 内核映像。 ramdisk.img 根文件系统。 在kernel 启动的时候，以只读的方式被 mount ， 这个文件中只是包含了 /init以及一些配置文件， 这个ramdisk 被用来调用init，以及把真正的root file system mount起来。 boot.img 里面包含了ramdisk.img 、kernel.img 和 其他一些文件 。 Android 的初始文件映像，负责初始化并加载 system 分区 system.img Android 的 system 分区映像，ext4 文件系统格式。 包括了主要的包、库等文件。它包含了整个系统，android 的framework，application 等等。放着android的应用程序、配置文件和字体等。 userdata.img 将会被挂接到 /data 下，包含了所有应用相关的配置文件，以及用户相关的数据 。 misc.img Miscellaneous的简称，cpu加电之后，启动bootloader，就会读取MISC分区获得来自Main system和Recovery的消息， 并以此决定做何种操作。misc 分区映像，负责启动模式切换和急救模式的参数传递。 pcba_small_misc.img misc 分区映像，负责启动模式切换和急救模式的参数传递。 ？？ pcba_whole_misc.img misc 分区映像，负责启动模式切换和急救模式的参数传递。？？ recovery.img 为了具有恢复系统的能力。实现恢复出厂设置、OTA 升级、patch 升级及firmware 升级 RK3288UbootLoader_V2.30.10.bin 引导文件 将开发好的apk内置到系统中 不需要用到so的app 在rk3288/out/target/product/rk3288/system/app 下新建一个文件夹xx ,放入xx.apk 即可。 重新打包。 make snod , ./mkimage.sh 需要用到so的app 新建一个跟app名字一样的文件夹放 xxx/packages/apps 目录下。 文件夹中放 一个Android.mk xx.apk , 和需要的so文件 。 需要 mm 进行重新编译。 make snod , ./mkimage.sh LOCAL_PATH := $(call my-dir) include $(CLEAR_VARS) LOCAL_MODULE := zhun LOCAL_MODULE_CLASS := APPS LOCAL_MODULE_TAGS := optional LOCAL_BUILT_MODULE_STEM := package.apk LOCAL_MODULE_SUFFIX := $(COMMON_ANDROID_PACKAGE_SUFFIX) LOCAL_CERTIFICATE := platform LOCAL_SRC_FILES := $(LOCAL_MODULE).apk LOCAL_PREBUILT_JNI_LIBS := \\ @lib/armeabi-v7a/libffmpeg.so \\ @lib/armeabi-v7a/libgdinamapv4sdk752.so \\ @lib/armeabi-v7a/libgdinamapv4sdk752ex.so \\ @lib/armeabi-v7a/libhi_camplayer_ffmpeg.so \\ @lib/armeabi-v7a/libhi_camplayer_mediacodec.so \\ @lib/armeabi-v7a/libopencv.so \\ @lib/armeabi-v7a/libopencv_java3.so include $(BUILD_PREBUILT) 下载源码后的初次编译 整体编译 1 、每次重启虚拟机后 都要运行 source build/envset.sh ，然后终端不要关 2、在根目录下执行 make -j4 // 3、在根目下执行 ./mkimage.sh 3、rockdev 目录下有img 烧录就可 修改launcher3源码 单独对launcher3编译 1、每次重启虚拟机后 都要运行 source build/envset.sh ，终端保持开启。然后修改源码 2、在launcher3 根目录下执行 mm 3、在rk3288根目录下 make snod 4、在rk3288根目录下 ./mkimage.sh 5、rockdev 目录下有img 烧录就可 需要修改的地方。否则单独编译会报错。*** No rule to make target host-libprotobuf-java-2.3.0-nano.jar 打开Android.mk文件 屏蔽 include $(BUILD_HOST_JAVA_LIBARY) 屏蔽 include $(BUILD_SYSTEM)/base_rules.mk 再去掉TEST 里面的Android.mk文件 补充： 如果自己在java工程中新增了文件（修改没关系），一定要对android.mk文件随意修改一下， 再保存，否则编译执行mm命令后，系统并不会把你的新增的java文件打包进apk中。（这个坑我踩了很久） 调试package 下的APP java部分 假如你想调试和修改系统APP launcher3 。 1、在Androidstudio上新建一个新工程，包名要跟 launcher3 一模一样 。 2、将launcher3中的源码复制到新工程中。（新建的这个工程因为缺少环境和其他资源，是编译不过的。但是不会影响调试） 3、连接上adb ，点击Androidstudio 菜单的Run-->Attach Debugger to Android Process或者上方工具条的Attach Debugger to Android Process图标 。 4、将 launcher3 包名 Attach 到Androidstudio上。 然后使用launcher3，程序运行到debug打点处就会停住的。 注： 调试时如果调试信息和代码行数对应不上，请将sdk版本改成和你手机系统版本一致。 ( no Copyright，enjoy youself ! ) all right reserved，powered by GitbookThe file was updated at : 2021-01-21 15:38:06 "},"chinese/native/音视频.html":{"url":"chinese/native/音视频.html","title":"音视频","keywords":"","body":"AAC详解 ADTS (Audio Data Transport Stream) 有的时候当你编码AAC裸流的时候，会遇到写出来的AAC文件并不能播放， 很大的可能就是AAC文件的每一帧里缺少了ADTS头信息文件的包装拼接。 只需要加入头文件ADTS即可。 aac数据流格式 AAC ES : Elementary Streams (原始流) ADTS Heads ADTS的头信息都是7个字节，分为2部分： adts_fixed_header(); // 28bit adts_variable_header(); // 28bit adts_fixed_header的字段 占用bit数 意义 syncword 12 同步头 总是0xFFF 。代表着一个ADTS帧的开始 ID 1 MPEG Version 0 代表 MPEG-4, 1代表 MPEG-2 Layer 2 always: '00' protection_absent 1 Warning, 1:没有CRC , 0:有CRC profile 2 使用的AAC级别 0: main profile 1:low complexity profile (LC) 2: scalable sampling rate profile (SSR) 3:保留字段 reserved sampling_frequency_index 4 使用的采样率下标// 下标对应 的采样率 0: 96000 Hz 1: 88200 Hz 2: 64000 Hz 3: 48000 Hz 4: 44100 Hz 5: 32000 Hz 6: 24000 Hz 7: 22050 Hz 8: 16000 Hz 9: 12000 Hz 10: 11025 Hz 11: 8000 Hz 12: 7350 Hz 13: Reserved 14: Reserved 15: frequency is written explictly private_bit 1 固定为0 channel_configuration 3 声道数0: Defined in AOT Specifc Config 1: 1 声道: front-center 2: 2 声道: front-left, front-right 3: 3 声道: front-center, front-left, front-right 4: 4 声道: front-center, front-left, front-right, back-center 5: 5 声道: front-center, front-left, front-right, back-left, back-right 6: 6 声道: front-center, front-left, front-right, back-left, back-right, LFE-channel 7: 8 声道: front-center, front-left, front-right, side-left, side-right, back-left, back-right, LFE-channel 8-15: 保留Reserved original_copy 1 固定为0 home 1 固定为0 adts_variable_header的字段 占用bit数 意义 copyright_identification_bit 1 固定为0 copyright_identification_star 1 固定为0 aac_frame_length 13 一个ADTS帧的长度包括ADTS头和raw data block adts_buffer_fullness 11 固定为0x7ff ,说明是码率可变的码流 number_of_raw_data_blocks_in_frame 2 固定为00 。表示ADTS帧中有1个AAC数据块 （注意：不是没有AAC数据块） h264 1、从4.1.2开始支持java层的mediacodec 2、从5.0开始支持 native层的mediacodec h264常用的帧类型 类型 说明 00 00 00 01 06 增强 帧 00 00 00 01 41 61和41其实都是P帧（type值为1），只是重要级别不一样 00 00 00 01 61 P帧 00 00 00 01 65 IDR 、I帧 00 00 00 01 67 SPS 00 00 00 01 68 PPS H264查看工具 以二进制方式查看H264文件的工具可以用 sublime_text 以图形化方式查看H264文件的I帧P帧等可以用Elecard StreamEye java层解码 显示 H264方案 自己解析 H264协议，然后将数据作为一帧一帧地送给 java层的 mediacodec 解码 。 然后给 mediacodec 进行渲染显示 。 /** @param surface Specify a surface on which to render the output of this decoder. Pass {@code null} as {@code surface} if the codec does not generate raw video output (e.g. not a video decoder) and/or if you want to configure the codec for {@link ByteBuffer} output. */ mMeidaCodec.configure(mediaFormat, mSurfaceView.getHolder().getSurface(), null, 0); H264转MP4 Java实现方案 基于mp4parser （ isoviewer-1.0-RC-35.jar）实现。 /** 此方案遇到Bug : Attempt to read from field 'boolean com.googlecode.mp4parser. h264.model.SeqParameterSet.residual_color_transform_flag' on a null object reference 解决办法:在我的应用场景中，我是确保H264的头部保存了SPS 和 PPS . 鉴于转换速度和此Bug 我后来放弃了这个方案，转用 C层使用ffmpeg的方案。 * @param h264Path h264文件绝对路径 * @param mp4Path mp4绝对路径 * @return 是否转码成功 */ @Deprecated public static boolean h264ToMp4Parse(String h264Path , String mp4Path ){ try { H264TrackImpl h264Track = new H264TrackImpl(new FileDataSourceImpl(h264Path)); Movie movie = new Movie(); movie.addTrack(h264Track); Container mp4file = new DefaultMp4Builder().build(movie); FileChannel fc = new FileOutputStream(new File(mp4Path)).getChannel(); mp4file.writeContainer(fc); fc.close(); return true ; }catch (Exception exception){ //转码异常 return false ; } }// RTMP RTMP（Real Time Messaging Protocol） 是Adobe的私有协议,未完全公开。基于TCP协议 。 为什么网络直播一般采用 rtmp 而安防等采用 RTSP ？ 因为Adobe的flash一统天下的时候，RTMP是web平台的直播唯一方案。 各大CDN厂商付出了较多的努力实现了对RTMP比较稳定的支持。 后续的公司为了稳定会继续沿用。 同理安防方面很多程序都是基于RTSP，因为生态也继续沿用。 RTP RTP封包情况 单个NAL包单元 对于 NALU 的长度小于 MTU 大小的包, 一般采用单一 NAL 单元模式. 组合封包模式 当 NALU 的长度特别小时, 可以把几个 NALU 单元封在一个 RTP 包中. （这种情况用的少） FU-A的分片格式 而当 NALU 的长度超过 MTU 时, 就必须对 NALU 单元进行分片封包. 也称为 Fragmentation Units (FUs). 现存两个版本FU-A，FU-B。 RTP 固定头结构 前 12 （第一排4个byte +第二排 4byte +第三排 4byte ）个字节出现在每个 RTP 包中。仅仅在被混合器插入时，才出现 CSRC 识别符列表。（如果CC为0，就代表没有CSRC） RTP头定义说明 NALU头 、FU indicator 个人理解 NALU头和 FU indicator差不多 。 在单个封包模式下 RTP头后面跟着就是NALU头；在分片封包模式下，RTP头后面跟着的就是FU indicator。 NALU头和 FU indicator结构是一样的，只是Type(后五个bit)对应的意义不一样。 NALU头 、FU indicator 结构 由一个字节组成 FU header 解析示例 WkDrone项目用到的是 单个NAL包单元封装+ FUA分片封装模式。所以以此为例进行分析 。 1、客户端每次从服务器接收一个RTP包 。 RTP头 + 数据data 2、根据data[0] 判断是什么封包模式。 3、如果是单个NAL 就直接判断拿到整个NALU. 如果是FU_A模式 就根据data[1]判断是当前NALU单元是否开始、结束还是中间。 如果是开头就需要在开始接收前手动添加当前NALU类型（rtpPackage.data[0] & 0xE0)|(rtpPackage.data[1]&0x1F) --> 最后获得F 、NRI 、Type 这三个信息 ，F可以忽略， NRI标记这个NALU的重要性 ，Type标记帧类型）。 4、最后获得整个NAUL后 在前面00 00 00 01 传给解码器解码。 //关键代码： /** * 将 rtp包 组成 NALU 格式的数据 * 返回一帧H264数据(一个NALU) */ public byte[] rtpPackage2NALU(byte[] rtpData) { if(rtpData.length == 0) { return null ; } RtpPackage rtpPackage = new RtpPackage(); rtpPackage.V=(rtpData[0]&0xFF)>>6 ; rtpPackage.PT = rtpData[1] & 0x7F; rtpPackage.data = new byte[rtpData.length-12]; System.arraycopy(rtpData, 12, rtpPackage.data, 0, rtpData.length - 12); if( (rtpPackage.V != 2)&&(rtpPackage.PT!=96) || rtpPackage.data.length 0001 1111 int fuIndicatorTypeFlag = rtpPackage.data[0] & 0x1F; // FU head中的 S、E标记 用来判断NALU的开始、结束 0xCO -> 1100 0000 取S、E int fuHeadSEFlag = rtpPackage.data[1] & 0xC0; switch (fuIndicatorTypeFlag) { case NAL_UNIT_TYPE_STAP_A: break; case NAL_UNIT_TYPE_STAP_B: break; case NAL_UNIT_TYPE_MTAP16: break; case NAL_UNIT_TYPE_MTAP24: break; case NAL_UNIT_TYPE_FU_B: break; case NAL_UNIT_TYPE_FU_A: switch (fuHeadSEFlag) { //NAL Unit start packet 0x80-> 1000 0000 case 0x80: NALEndFlag = false; bufferLength = rtpPackage.data.length-1 ; buffer[0] = new byte[rtpPackage.data.length-1]; /* 每一帧开始的时候要加上表示这个帧类型的信息。 0xE0 ->1110 0000 0x1F -> 0001 1111 取FU indicator的前三位和FU Header的后五位。 最后这个byte包含了 F 、NRI 、Type 这三个信息 F可以忽略， NRI标记这个NALU的重要性 ，Type标记帧类型 buffer[0][0] 帧类型数据 41、61、65、67、68等 */ buffer[0][0] = (byte)((rtpPackage.data[0] & 0xE0)|(rtpPackage.data[1]&0x1F)); System.arraycopy(rtpPackage.data,2,buffer[0],1,rtpPackage.data.length-2); packetNum = 1; break; //NAL Unit middle packet 0x00->0000 0000 case 0x00: NALEndFlag = false; bufferLength += rtpPackage.data.length-2; buffer[packetNum] = new byte[rtpPackage.data.length-2]; System.arraycopy(rtpPackage.data,2,buffer[packetNum],0,rtpPackage.data.length-2); packetNum++; break; //NAL Unit end packet 0x40 -->0100 0000 case 0x40: NALEndFlag = true; //+4 是因为多了 00 00 00 01 NALUnit = new byte[bufferLength + rtpPackage.data.length- 2 + 4]; //因为打包发送的时候是去掉了00 01这种标记位的，为了处理后续的H264，需要手动加上 NALUnit[0] = 0x00; NALUnit[1] = 0x00; NALUnit[2] = 0x00; NALUnit[3] = 0x01; int tmpLen = 4; //第一片 + 中间片 数据 for(int i = 0; i 个人经验 1、以java为例，加入你不知道当前数据要与0X1F进行与运算，你可以先想想用哪个二进制可以达到想要的目的，然后将这个二进制转为十六进制就可以了。// rtp封包方式，单一封包、组合封包、分片封包等 0x1F -> 0001 1111 int fuIndicatorTypeFlag = rtpPackage.data[0] & 0x1F; rtsp RTSP被用于建立的控制媒体流的传输 。 Rtp协议提供了时间戳和序列号。发送端在采样时设置时间戳，接收端收到后，会按照时间戳依次播放。 RTP本身只保证实时数据的传输，并不能为按顺序传送的数据包提供可靠的传送机制，也不提供流量和拥塞控制， 它依靠RTCP来提供这些服务。 RTCP通常与RTP配合使用，用以管理传输质量在当前进程之间的交换信息。 在RTP会话期间，各参与者周期性的传送RTCP包，RTCP包中包含已发送数据包的数量、丢失的数据包的数量等统计资料。 服务器可以利用这些信息动态的改变传输速率，甚至改变有效载荷的类型。 RTSP通常使用RTP协议来传送实时流，RTP一般使用偶数端口，而RTCP使用相邻的奇数端口，即RTP端口号+1。 注意: RTP 本身没有提供任何的机制来确保实时的传输或其他的服务质量保证，而是由底层的服务来完成。 它不保证传输或防止乱序传输,它不假定下层网络是否可靠,是否按顺序传送数据包。 RTP、RTSP、RTCP的区别 Rtsp 进行服务端和客户端的信息交流。 例如客户端询问服务器支持哪些方法、协议、sps、pps等。沟通以什么方式建立连接，是否要开始发送数据了等。 Rtp 服务器以约定好的格式往客户端进行发送封装好的数据。 RTCP 当客户端发现RTP丢包的时候，可以通过约定好的格式往服务器发送数据，要求服务器重发数据。 注：虽然UDP是单向通信的， 但是 RTP + RTCP 其实相当于建立起了一个双向对话的机制了。 rtsp 的交互过程 （客户端和服务端） 1、OPTIONS（可选） RTSP客户端 —> RTSP服务器端 OPTIONS命令 //询问服务器端有哪些方法可使用 RTSP服务器端 —> RTSP客户端 回复OPTIONS命令 //回复客户端服务器支持的方法 2、DESCRIBE （可选） RTSP客户端 —> RTSP服务器端 DESCRIBE命令 //请求对媒体资源的描述信息 RTSP服务器端 —> RTSP客户端 　　回复DESCRIBE命令　//回复客户端某个媒体资源的描述信息（即SDP） 3、SETUP（必选） RTSP客户端 —> RTSP服务器端　SETUP命令 //请求建立对某个媒体资源的连接 RTSP服务器端 —> RTSP客户端　 回复SETUP命令　 //回复建立连接的结果 　　 4、PLAY（必选） RTSP客户端 —> RTSP服务器端　 PLAY命令　　　 //请求播放媒体资源 RTSP服务器端 —> RTSP客户端　　 回复PLAY命令　　 //回复播放的结果 5、其他的交互方法，请自行查阅 。 例如 TEARDOWN、PAUSE、SCALE、 GET_PARAMETER、SET_PARAMETER 搭建、测试rtsp交互 可以采用以下方案搭建一套系统。 采集、推流 用EasyPusher , 商业需要授权。 流媒体服务器 用EasyDarwin ， 完全免费。 解码播放 用 VLC ，完全免费。 解rtsp协议获得H264 ，java实现demo public class RtspClient{ private final String TAG=\"RtspClient\" ; /**是否是tcp方式*/ private boolean isTCPtranslate; private String hostIp; private int port; private String rtspUrl ; /**rtsp版本号，必须是1.0? 还不确定！*/ private static final String VERSION = \" RTSP1.0\\r\\n\"; /**rtsp服务器正确反应标记*/ private static final String RTSP_OK = \"RTSP/1.0 200 OK\"; /**请求回应对的序列*/ private int seq=1; /**会话 Session在setup请求后返回 */ private String sessionid=null; /**trackID 在 请求Descrbe 之后返回*/ private String trackInfo; /**转换账号和密码*/ private String authorBase64; /**客户端代理名称随意填*/ private final static String UserAgent = \"RtspWalkera/1.0\"; private Socket mSocket; private BufferedReader mBufferreader; private OutputStream mOutputStream; /** * 构造函数 ， 进行参数初始化 * @param isTCPtranslate tcp方式还是 udp方式 * @param hostIp 服务器ip * @param port 服务器端口 * @param rtspUrl rtsp播放地址 * @param authorName 登录账号 * @param authorPassword 登录密码 */ public RtspClient(boolean isTCPtranslate, String hostIp,int port, String rtspUrl ,String authorName,String authorPassword) { this.isTCPtranslate = isTCPtranslate; this.rtspUrl = rtspUrl; this.hostIp = hostIp ; this.port = port; if(authorName == null && authorPassword == null) { authorBase64 = null; } else { // 返回Base64编码过的字节数组字符串 authorBase64 = Base64.encodeToString((authorName+\":\"+authorPassword).getBytes(),Base64.DEFAULT); } } private String addHeaders(){ return \"CSeq: \" + (seq++) + \"\\r\\n\" + ((authorBase64 == null)?\"\":(\"Authorization: Basic \" +authorBase64 +\"\\r\\n\")) + \"User-Agent: \" + UserAgent + \"\\r\\n\" + ((sessionid == null)?\"\":(\"Session: \" + sessionid + \"\\r\\n\")) + \"\\r\\n\"; } /** * option请求 * 此步骤非必须 */ public void doOption(){ StringBuilder sb = new StringBuilder(); sb.append(\"OPTIONS \"); sb.append(this.rtspUrl.substring(0, rtspUrl.lastIndexOf(\"/\"))); sb.append(VERSION); sb.append(addHeaders()); try{ outQueue.put(sb.toString()); }catch (Exception e) {} } /** * Describe 请求 * sps 和 pps 会在这个阶段返回 * sprop-parameter-sets= Z0IAKpY1QMgEvTcBAQEC,aM48gA== * 将 sprop-parameter-sets 对应的值用base64 解码即可 67 和68 * 分别对应sps 和pps . * 不过有的rtsp服务器如果没有按标准写的话 ，sprop-parameter-sets 返回的值可能为空。 * 此时 如果想获取sps 和pps 只能通过rtsp服务器返回的 帧数据中去获取了。 */ public void doDescribe() { StringBuilder sb = new StringBuilder(); sb.append(\"DESCRIBE \"); sb.append(this.rtspUrl); sb.append(VERSION); sb.append(addHeaders()); try { outQueue.put(sb.toString()); }catch (Exception e) {} } /** * 请求setup 。 * RTP/AVP/TCP : RTP采用TCP方式 * unicast表示单播 * client_port=55640-55641 ：前一个是RTP端口 ，后一个是RTCP端口 * */ public void doSetup( ) { StringBuilder sb = new StringBuilder(); if ( isTCPtranslate ) { sb.append(\"SETUP \"); sb.append(this.rtspUrl); sb.append(\"/\"); sb.append(trackInfo); sb.append(VERSION); sb.append(\"Transport: RTP/AVP/TCP;unicast;client_port=55640-55641\" + \"\\r\\n\"); sb.append(addHeaders()); } else { sb.append(\"SETUP \"); sb.append(this.rtspUrl); sb.append(\"/\"); sb.append(trackInfo); sb.append(VERSION); sb.append(\"Transport: RTP/AVP/UDP;unicast;client_port=55640-55641\" + \"\\r\\n\"); sb.append(addHeaders()); } try { outQueue.put(sb.toString()); }catch (Exception e) { } } /** * play 请求 */ public void doPlay(){ StringBuilder sb = new StringBuilder(); sb.append(\"PLAY \"); sb.append(this.rtspUrl); sb.append(VERSION); //设置播放的时间范围 sb.append(\"Range: npt=0.000-\\r\\n\"); sb.append(addHeaders()) ; try { outQueue.put(sb.toString()); }catch (Exception e) { } } /** * Pause 暂停请求 */ public void doPause() { StringBuilder sb = new StringBuilder(); sb.append(\"PAUSE \"); sb.append(this.rtspUrl); sb.append(\"/\"); sb.append(VERSION); sb.append(addHeaders()) ; try{ outQueue.put(sb.toString()); }catch (Exception e) { } } /** * 关闭连接 */ public void doTeardown(){ StringBuilder sb = new StringBuilder(); sb.append(\"TEARDOWN \"); sb.append(this.rtspUrl); sb.append(\"/\"); sb.append(VERSION); sb.append(addHeaders()) ; try { outQueue.put(sb.toString()); }catch (Exception e){ } } /** * 往服务器发送数据 */ private void sendBytes(String questStr) { try { byte[] buffer= questStr.getBytes(\"UTF-8\"); mOutputStream.write(buffer); mOutputStream.flush(); Log.i(TAG ,\"请求服务器：\"+questStr +\" \"+outQueue.size()); }catch (Exception e) { Log.i(TAG ,\"请求服务器异常：\"+e.getMessage()); } } private boolean isStopReceive =false ; /*** * rtsp 接收子线程 */ private class ReceiveThread extends Thread{ @Override public void run() { while(!isStopReceive) { try { if(mBufferreader!=null) { String line ; if( (line = mBufferreader.readLine()) != null) { Log.i(TAG ,\"收到服务器返回=\" + line); }else { Log.i(TAG ,\"收到服务器返回 line==null\" ); } } //休眠一段时间 Thread.sleep(60); }catch (Exception e) { Log.i(TAG ,\"接收服务器异常\" +e.getLocalizedMessage()); } } } } private LinkedBlockingDeque rtpDataBuffer = new LinkedBlockingDeque<>(); private DatagramSocket mUdpSocket; private DatagramPacket mUdpPackets; int udpPort = 55640; //55640- 55641 private byte[] message = new byte[2048]; /*** * upd rtp 接收子线程 */ private class ReceiveRTPUdpThread extends Thread { @Override public void run(){ while(!isStopReceive) { try { if(mUdpSocket==null) { mUdpSocket = new DatagramSocket(udpPort); mUdpPackets = new DatagramPacket(message,message.length); }else{ mUdpSocket.receive(mUdpPackets); byte[] buffer = new byte[mUdpPackets.getLength()]; System.arraycopy(mUdpPackets.getData(), 0, buffer, 0, mUdpPackets.getLength()); try { rtpDataBuffer.put(buffer); } catch (InterruptedException e) { Log.e(TAG,\"The buffer queue is full , wait for the place..\"); } } //休眠一段时间 Thread.sleep(0); }catch (Exception e) { Log.i(TAG ,\"udp接收服务器异常\" +e.getLocalizedMessage()); } } } } public byte[]getRtpData(){ byte[] nalu =null; if(rtpDataBuffer !=null && rtpDataBuffer.size()>0){ try { nalu = rtpDataBuffer.take(); }catch (Exception e) { } } return nalu ; } /**发送队列*/ private BlockingQueue outQueue = new LinkedBlockingQueue(Integer.MAX_VALUE);; /** * 发送子线程 */ private class SendThread extends Thread { @Override public void run() { while(!isStopReceive) { try { String buffer = outQueue.poll(); if (buffer != null){ sendBytes(buffer); } //休眠一段时间 Thread.sleep(60); }catch (Exception e) {} } } } /** * 开启rtsp客户端 */ public void openRtspCline() { isStopReceive = false ; Thread thread = new Thread(new Runnable() { @Override public void run() { try{ mSocket = new Socket(hostIp, port); mBufferreader = new BufferedReader(new InputStreamReader(mSocket.getInputStream())); mOutputStream = mSocket.getOutputStream(); }catch (IOException e) { Log.i(TAG,\"创建socket出现异常=\"+e.getLocalizedMessage()) ; } } }); thread.start(); ReceiveThread receiveThread = new ReceiveThread(); receiveThread.start(); SendThread sendThread = new SendThread() ; sendThread.start(); ReceiveRTPUdpThread receiveRTPUdpThread = new ReceiveRTPUdpThread(); receiveRTPUdpThread.start(); } /** * 关闭rtsp客户端 */ public void shutDownRtspClient() { isStopReceive = true ; } } /** * RTP 数据包 结构 */ public class RtpPackage{ /**版本是 2*/ public int V ; /**填充标志*/ public int P ; /**拓展标志*/ public int X ; /**csrc计数器*/ public int CC ; /**音频、视频标记*/ public int M ; /**多媒体的类型 H.264的类型为96*/ public int PT; /**序列号*/ public int sequenceNumber; /**时间戳*/ public long timestamp; /**ssrc*/ public long ssrcIdentifier; /**csrc列表*/ public int csrcIdentiferList ; /**rtp 包数据*/ public byte[] data; } public class RTP2NaluTools{ private final String TAG=\"RTP2NaluTools\" ; private final static int NAL_UNIT_TYPE_STAP_A = 24; private final static int NAL_UNIT_TYPE_STAP_B = 25; private final static int NAL_UNIT_TYPE_MTAP16 = 26; private final static int NAL_UNIT_TYPE_MTAP24 = 27; private final static int NAL_UNIT_TYPE_FU_A = 28; private final static int NAL_UNIT_TYPE_FU_B = 29; /**一帧数据（一个NALU）*/ private byte[] NALUnit; /**NALU结束标记*/ private boolean NALEndFlag; /**临时变量 buffer[i] 存储每一片数据 */ private byte[][] buffer = new byte[1024][]; /**当前已经接收的NALU的数据长度*/ private int bufferLength; /**当前已经接收的数据片数量*/ private int packetNum; public RTP2NaluTools() { NALEndFlag = false; bufferLength= 0; packetNum =0; } /** * 将 rtp包 组成 NALU 格式的数据 * 返回一帧H264数据(一个NALU) */ public byte[] rtpPackage2NALU(byte[] rtpData) { if(rtpData.length == 0) { return null ; } RtpPackage rtpPackage = new RtpPackage(); rtpPackage.V=(rtpData[0]&0xFF)>>6 ; rtpPackage.PT = rtpData[1] & 0x7F; rtpPackage.data = new byte[rtpData.length-12]; System.arraycopy(rtpData, 12, rtpPackage.data, 0, rtpData.length - 12); if( (rtpPackage.V != 2)&&(rtpPackage.PT!=96) || rtpPackage.data.length 0001 1111 int fuIndicatorTypeFlag = rtpPackage.data[0] & 0x1F; // FU head中的 S、E标记 用来判断NALU的开始、结束 0xCO -> 1100 0000 取S、E int fuHeadSEFlag = rtpPackage.data[1] & 0xC0; switch (fuIndicatorTypeFlag) { case NAL_UNIT_TYPE_STAP_A: break; case NAL_UNIT_TYPE_STAP_B: break; case NAL_UNIT_TYPE_MTAP16: break; case NAL_UNIT_TYPE_MTAP24: break; case NAL_UNIT_TYPE_FU_B: break; case NAL_UNIT_TYPE_FU_A: switch (fuHeadSEFlag) { //NAL Unit start packet 0x80-> 1000 0000 case 0x80: NALEndFlag = false; bufferLength = rtpPackage.data.length-1 ; buffer[0] = new byte[rtpPackage.data.length-1]; /* 每一帧开始的时候要加上表示这个帧类型的信息。 0xE0 ->1110 0000 0x1F -> 0001 1111 取FU indicator的前三位和FU Header的后五位。 最后这个byte包含了 F 、NRI 、Type 这三个信息 F可以忽略， NRI标记这个NALU的重要性 ，Type标记帧类型 buffer[0][0] 帧类型数据 41、61、65、67、68等 */ buffer[0][0] = (byte)((rtpPackage.data[0] & 0xE0)|(rtpPackage.data[1]&0x1F)); System.arraycopy(rtpPackage.data,2,buffer[0],1,rtpPackage.data.length-2); packetNum = 1; break; //NAL Unit middle packet 0x00->0000 0000 case 0x00: NALEndFlag = false; bufferLength += rtpPackage.data.length-2; buffer[packetNum] = new byte[rtpPackage.data.length-2]; System.arraycopy(rtpPackage.data,2,buffer[packetNum],0,rtpPackage.data.length-2); packetNum++; break; //NAL Unit end packet 0x40 -->0100 0000 case 0x40: NALEndFlag = true; //+4 是因为多了 00 00 00 01 NALUnit = new byte[bufferLength + rtpPackage.data.length- 2 + 4]; //因为打包发送的时候是去掉了00 01这种标记位的，为了处理后续的H264，需要手动加上 NALUnit[0] = 0x00; NALUnit[1] = 0x00; NALUnit[2] = 0x00; NALUnit[3] = 0x01; int tmpLen = 4; //第一片 + 中间片 数据 for(int i = 0; i 使用方法 boolean isTCPtranslate = false ; //false true String hostIp =\"192.168.1.235\"; int port= 554 ; String rtspUrl =\"rtsp://192.168.1.235:554/\"; String authorName=null ; String authorPassword=null ; RtspClient rtspClient = new RtspClient( isTCPtranslate, hostIp, port, rtspUrl , authorName, authorPassword); rtspClient.openRtspCline(); //请求options rtspClient.doOption(); //请求describe rtspClient.doDescribe(); //请求建立连接(此阶段指明用Tcp或UDP建立连接) rtspClient.doSetup(); //请求开始下发Rtp包 rtspClient.doPlay(); //开启子线程接收RTP数据 byte[] rtpData =rtspClient.getRtpData() ; //对Rtp数据进行解析，获得H264数据 byte[] nalu= rtp2NaluTools.rtpPackage2NALU(rtpData) ; YUV 与RGB类似，YUV是一种颜色编码方法，它将亮度信息（Y）与色彩信息（UV）分离，没有UV信息一样可以显示完整的（黑白的）图像。 YUV图像查看工具 yuvplayer.exe Y ： 明亮度（Luminance或Luma），也就是灰度值； U和V ： 色度（Chrominance或Chroma），描述影像色彩及饱和度，用于指定像素的颜色。 YUV数据的采集方式 采集方式 特点 其他 YUV 4:4:4 每一个Y对应一组UV分量 YUV444 YUV 4:2:2 每两个Y共用一组UV分量 YUV422 YUV 4:2:0 每四个Y共用一组UV分量 YUV420 yuv格式类型 YUV 格式 排列 所属大类 YU12 YYYY YYYY UU VV YUV420 I420 YYYY YYYY UU VV YUV420 YV12 YYYY YYYY VV UU YUV420 NV12 YYYY YYYY UV UV YUV420 NV21 YYYY YYYY VU VU YUV420 YUYV YUYV YUYV YUYV YUYV YUV422 YUY2 YUYV YUYV YUYV YUYV YUV422 UYVY UYVY UYVY UYVY UYVY YUV422 YUV422P YYYY YYYY UUUU VVVV YUV422 音视频 开发要点 音频开发的主要内容 1、音频采集/播放 2、音频算法处理 去噪、静音检测、回声消除、音效处理、功放/增强、混音/分离 3、音频的编解码和格式转换 4、音频传输协议的开发 SIP，A2DP、AVRCP 音频开发的延时标准 ITU-TG.114规定，对于高质量语音可接受的时延是300ms。 一般来说，如果时延在300～400ms，通话的交互性比较差，但还可以接受。 时延大于400ms时，则交互通信非常困难。 音频开发的难点 延时敏感、卡顿敏感、噪声抑制（Denoise）、 回声消除（AEC）、静音检测（VAD）、混音算法 常用显示控件 // SurfaceView Android 1.0 , extends View 。本质上是一个View。与普通View不同的是，它有自己的Surface。 // GLSurfaceView Android 1.5 ， extends SurfaceView 。 在SurfaceView的基础上，它加入了EGL的管理， 并自带了渲染线程。另外它定义了用户需要实现的Render接口。 // SurfaceTexture Android 3.0 ， extends 无 。 它对图像流的处理并不直接显示，而是转为GL外部纹理， 因此可用于图像流数据的二次处理（如Camera滤镜，桌面特效等） // TextureView Android 4.0 ，extends View 。 普通View，可以和其它普通View一样进行移动，旋转，缩放，动画等变化。 TextureView必须在硬件加速的窗口中。 android:hardwareAccelerated=\"true\" // Surface Android 1.0 ， extends 无 。 Surface 内部维护了图像 buffer 对象，最终交由 SufaceFlinger 合成显示。 音视频术语 采样率（samplerate） 采样频率越高，记录这一段音频信号所用的数据量就越大，同时音频质量也就越高。 根据奈奎斯特理论，采样频率只要不低于音频信号最高频率的两倍，就可以无损失地还原原始的声音。 为了保证声音不失真，采样频率应在40kHz以上。 常用的音频采样频率有： 8kHz、11.025kHz、22.05kHz、16kHz、37.8kHz、44.1kHz、48kHz、96kHz、192kHz 量化精度（位宽） 位数越多，表示得就越精细，声音质量就越好，数据量也会越大。 数据类型大小可以是： 4bit、8bit、16bit、32bit 常见的位宽是：8bit 或者 16bit 复用/解复用： 将音频、视屏、字幕数据放在一条链路上传过来，然后再想办法分开。 声道数（channels） 由于，音频的采集和播放是可以叠加的， 因此可以同时从多个音频源采集声音，并分别输出到不同的扬声器， 故声道数一般表示声音录制时的音源数量或回放时相应的扬声器数量。 单声道（Mono）和双声道（Stereo）比较常见。 重采样 把目标音频按照一定的格式重新采样编码成新的音频数据， 方便统一处理，一般的采样标准是：44100HZ、16bit、双声道 。 因为需要播放的音频并不是一样的， 我们也不可能为每一种音频写一个处理程序，所以要按照自己的标准重新采样。 声道布局 当有多个发音源时，多个扬声器的摆放位置可以组成那种前后、左右、环绕等布局... 音频帧 音频数据是流式的，本身没有明确的一帧帧的概念， 在实际的应用中，为了音频算法处理/传输的方便，一般约定俗成取2.5ms~60ms为单位的数据量为一帧音频。 这个时间被称之为“采样时间”，其长度没有特别的标准，它是根据编解码器和具体应用的需求来决定的， 我们可以计算一下一帧音频帧的大小： 假设某音频信号是采样率为8kHz、双通道、位宽为16bit，20ms一帧，则一帧音频数据的大小为： int size = 8000 x 2 x 16bit x 0.02s = 5120 bit = 640 byte 音调 、音速 音调(Pitch)：音调与声音的频率有关 ， 声音频率越大时，音调就越高 。 音速 ：播放速度。 解协议 就是将流媒体协议的数据，解析为标准的相应的封装格式数据。 视音频在网络上传播的时候，常常采用各种流媒体协议，例如HTTP，RTMP，或是MMS等等。 这些协议在传输视音频数据的同时，也会传输一些信令数据。 这些信令数据包括对播放的控制（播放，暂停，停止），或者对网络状态的描述等。 解协议的过程中会去除掉信令数据而只保留视音频数据。例如，采用RTMP协议传输的数据，经过解协议操作后，输出FLV格式的数据。 解封装 就是将输入的封装格式的数据，分离成为音频流压缩编码数据和视频流压缩编码数据。 封装格式种类很多，例如MP4，MKV，RMVB，TS，FLV，AVI等等，它的作用就是将已经压缩编码的视频数据和音频数据按照一定的格式放到一起。 例如，FLV格式的数据，经过解封装操作后，输出H.264编码的视频码流和AAC编码的音频码流。 解码 解码是整个系统中最重要也是最复杂的一个环节。 就是将视频/音频压缩编码数据，解码成为非压缩的视频/音频原始数据。 音频的压缩编码标准包含AAC，MP3，AC-3等等，视频的压缩编码标准则包含H.264，MPEG2，VC-1等等。 通过解码，压缩编码的视频数据输出成为非压缩的颜色数据， 例如YUV420P，RGB等等；压缩编码的音频数据输出成为非压缩的音频抽样数据，例如PCM数据。 视音频同步 就是根据解封装模块处理过程中获取到的参数信息， 同步解码出来的视频和音频数据，并将视频音频数据送至系统的显卡和声卡播放出来。 网络抖动 抖动是指最大延迟与最小延迟的时间差，如最大延迟是20毫秒，最小延迟为5毫秒，那么网络抖动就是15毫秒，它主要标识一个网络的稳定性。 MTU Maximum Transmission Unit 。大部分设备的是1500byte。 如果本机的MTU比网关的MTU大，大的数据包就会被拆开来传送，这样会产生很多数据包碎片，增加丢包率，降低网络速度。 把本机的MTU设成比网关的MTU小或相同，就可以减少丢包。 I帧 关键帧。 数据量较大。 这一帧单独存在，不需要依赖其他的帧就可以完整显示。 P帧 、差别帧 记录这一帧跟之前的一个帧 （I帧或P帧）的差别，解码时需要用之前缓存的画面叠加上本帧定义的差别，生成最终画面。 P帧没有完整画面数据，只有与前一帧的画面差别的数据。 B帧 、双向差别帧 B帧记录的是本帧与前后帧的差别。 要解码B帧，不仅要取得之前的缓存画面，还要解码之后的画面，通过前后画面的与本帧数据的叠加取得最终的画面。 B帧压缩率高，但是解码耗资源、算法相对复杂。 音视频格式 音频格式相关 格式 说明 类型 pcm 录音后直接得到的未经压缩的数据流，没有头信息或者帧信息 可以使用 AUDACITY这个软件 播放pcm 文件 编码格式 WAV 由文件头部分和音频数据体组成。微软开发的一种无损的音频文件格式 封装格式 MP3 每个帧之间相互独立，各帧相互独立。是有损压缩 封装格式 m4a 封装格式 AAC 是有损压缩 封装格式 AMR 封装格式 CAF 苹果的一种音频封装格式 当前主要的流媒体协议 名称 推出机构 传输层协议 客户端 目前使用领域 RTSP + RTP IETF TCP+UDP VLC ,WMP IPTV RTMP Adobe Inc TCP flash 互联网直播 RTMFP Adobe Inc UDP flash 互联网直播 MMS microsoft Inc TCP/UDP WMP 互联网直播 +点播 HTTP WWW+IETF TCP flash 互联网点播 视频封装格式 名称 推出机构 流媒体 支持的视频编码 支持的音频编码 目前使用领域 AVI microsoft Inc 不支持 几乎所有格式 几乎所有格式 BT下载影视 MP4 MPEG 支持 MPEG-2 , MPEG-4 H.264,H.263 AAC ,MPEG-1 Layers Ⅰ, Ⅱ,Ⅲ AC-3 互联网视频网站 TS MPEG 支持 MPEG-1 ,MPEG-2 ,MPEG-4 ,H.264 MPEG-1 Layers Ⅰ, Ⅱ,Ⅲ AAC IPTV，数字电视 FLV adobe inc 支持 sorenson,VP6 ,H.264 MP3,ADPCM ,Linear PCM ,AAC 互联网视频网站 MKV corecodec inc 支持 几乎所有格式 几乎所有格式 互联网视频网站 RMVB real networks inc 支持 RealVideo 8,9,10 AAC ,Cook Codec ,RealAudio Lossless BT下载影视 视频编码格式 名称 推出机构 推出时间 目前使用领域 H.264 MPEG/ITU-T 2003 各个领域 HEVC(H.265) MPEG/ITU-T 2013 研发中 MPEG2 MPEG 1994 数字电视 MPEG4 MPEG 2001 不温不火 VP8 Google 2008 不普及 VP9 Google 2013 研发中 VC-1 Microsoft Inc. 2006 微软平台 wmv wav文件格式 在文件的前44字节放置标头，使播放器或编辑器能够简单掌握文件的基本信息，其内容以区块(chunk)为最小单位，每一区块长度为4字节。 名称 字节 端序 内容 ChunkID 区块编号 4 大端 \"RIFF\" ChunkSize 总区块大小 4 小端 Format 文件格式 4 大端 WAVE Subchunk1Id 子区块1编号 4 大端 \"fmt \" Subchunk1Size 子区块1大小 4 小端 16 AudioFormat 音频格式 2 小端 1 pcm NumChannels 声道数量 2 小端 1 单声道 ，2 立体声 SampleRate 采样率 4 小端 常用的采样频率有 11025, 22050 和 44100 kHz ByteRate 每秒数据字节数。码率？ 4 小端 BlockAlign 区块对齐 2 小端 声道数 * 每个采样需要的bit / 8 BitsPerSample 采样位数 2 小端 Subchunk2ID 子区块2编号 4 大端 Subchunk2Size 子区块2大小 4 小端 data 音频数据 n 小端 ( no Copyright，enjoy youself ! ) all right reserved，powered by GitbookThe file was updated at : 2021-01-27 14:47:58 "},"chinese/native/音视频第三方库.html":{"url":"chinese/native/音视频第三方库.html","title":"音视频第三方库","keywords":"","body":"QT QT是一套UI解决方案。一般用来开发桌面程序或者嵌入式。 读者经常将MFC和Qt进行对比，MFC只能应用 Windows平台，而Qt是跨平台的。 另外，Qt已经封装了底层细节，学习Qt将会非常简单；而MFC只是 Windows API加了一层包装，不了解WindowsAPI也学不好 MFC。 SDL SDL通过不同平台（例如Windows、linux、android）的屏幕驱动，封装成一套对外统一的API调用。 让使用者可以不关注具体某个平台，可以快速开发图像的绘制操作。SDL的核心，便是如此。 SDL的主要任务，便是完成图像的加载，渲染显示，其他方向都比较单薄。 OpenCV OpenCV 采用C及C++语言编写，可以在windows, linux, mac OSX系统上面运行。完全是免费的。 opencv官网 opencv中文网站 ffmpeg ffmpeg官网 ffmpeg Github 官方英文文档 ffmpeg参数 文档 FFmpeg主要模块 libavcodec： 用于各种类型声音/图像编解码； libavdevice： 用于视频采集访问摄像头等 libavfilter： 用做滤镜处理 libavformat： 用于各种音视频封装格式的生成和解析，包括获取解码所需信息以生成解码 上下文结构和读取音视频帧等功能； libswresample： 用于重采样； libavutil： 包含一些公共的工具函数； libswscale： 用于视频场景比例缩放、色彩映射转换； libpostproc： 用于后期效果处理； 移植ffmpeg到安卓 参考资料 编译ffmpeg得到so等相关文件 1、在ubuntu下配置好ndk环境 2、下载合适的版本下载(ffmpeg-3.3.7.tar.gz) http://ffmpeg.org/download.html#releases 3、解压，赋予最高权限 4、由于ffmpeg默认生成的格式是 xxx.so.版本号, android只能识别 xxx.版本号.so 所以需要修改 configure 这个文件 # 修改前 #SLIBNAME_WITH_MAJOR='$(SLIBNAME).$(LIBMAJOR)' #LIB_INSTALL_EXTRA_CMD='$$(RANLIB) \"$(LIBDIR)/$(LIBNAME)\"' #SLIB_INSTALL_NAME='$(SLIBNAME_WITH_VERSION)' #SLIB_INSTALL_LINKS='$(SLIBNAME_WITH_MAJOR) $(SLIBNAME)' # 修改后 SLIBNAME_WITH_MAJOR='$(SLIBPREF)$(FULLNAME)-$(LIBMAJOR)$(SLIBSUF)' LIB_INSTALL_EXTRA_CMD='$$(RANLIB) \"$(LIBDIR)/$(LIBNAME)\"' SLIB_INSTALL_NAME='$(SLIBNAME_WITH_MAJOR)' SLIB_INSTALL_LINKS='$(SLIBNAME)' 5、在 相同目录下新建一个文件build_android.sh #!/bin/bash make clean export NDK=/home/aivin/aivinSpace/ndk-r10e/android-ndk-r10e export SYSROOT=$NDK/platforms/android-9/arch-arm/ export TOOLCHAIN=$NDK/toolchains/arm-linux-androideabi-4.8/prebuilt/linux-x86_64 export CPU=arm export PREFIX=$(pwd)/android/$CPU export ADDI_CFLAGS=\"-marm\" ./configure --target-os=linux \\ --prefix=$PREFIX --arch=arm \\ --enable-shared \\ --disable-static \\ --disable-yasm \\ --disable-symver \\ --enable-gpl \\ --enable-ffmpeg \\ --disable-ffplay \\ --disable-ffprobe \\ --disable-ffserver \\ --disable-doc \\ --disable-symver \\ --cross-prefix=$TOOLCHAIN/bin/arm-linux-androideabi- \\ --enable-cross-compile \\ --sysroot=$SYSROOT \\ --extra-cflags=\"-Os -fpic $ADDI_CFLAGS\" \\ --extra-ldflags=\"$ADDI_LDFLAGS\" \\ $ADDITIONAL_CONFIGURE_FLAG make clean make make install 6、在build_android.sh 目录下用终端输入 ./build_android.sh 执行完毕后在当前目录下生成 android文件夹。 以下是网友给的一个脚本 先修改 configure文件 然后直接执行 build_android.sh文件（不用执行configure文件） //在3.3.7 、3.3.8版本中可以编译通过，在3.4.4通不过 --target-os=linux // 所以我全部改用 android配置 --target-os=android #!/bin/bash export NDK_HOME=/home/aivin/aivinSpace/ndk-r10e/android-ndk-r10e export PLATFORM_VERSION=android-9 function build { echo \"start build ffmpeg for $ARCH\" ./configure --target-os=android \\ --prefix=$PREFIX --arch=$ARCH \\ --disable-doc \\ --enable-shared \\ --disable-static \\ --disable-yasm \\ --disable-asm \\ --disable-symver \\ --enable-gpl \\ --disable-ffmpeg \\ --disable-ffplay \\ --disable-ffprobe \\ --disable-ffserver \\ --cross-prefix=$CROSS_COMPILE \\ --enable-cross-compile \\ --sysroot=$SYSROOT \\ --enable-small \\ --extra-cflags=\"-Os -fpic $ADDI_CFLAGS\" \\ --extra-ldflags=\"$ADDI_LDFLAGS\" \\ $ADDITIONAL_CONFIGURE_FLAG make clean make make install echo \"build ffmpeg for $ARCH finished\" } #arm ARCH=arm CPU=arm PREFIX=$(pwd)/android/$ARCH TOOLCHAIN=$NDK_HOME/toolchains/arm-linux-androideabi-4.9/prebuilt/linux-x86_64 CROSS_COMPILE=$TOOLCHAIN/bin/arm-linux-androideabi- ADDI_CFLAGS=\"-marm\" SYSROOT=$NDK_HOME/platforms/$PLATFORM_VERSION/arch-$ARCH/ build #x86 ARCH=x86 CPU=x86 PREFIX=$(pwd)/android/$ARCH TOOLCHAIN=$NDK_HOME/toolchains/x86-4.9/prebuilt/linux-x86_64 CROSS_COMPILE=$TOOLCHAIN/bin/i686-linux-android- ADDI_CFLAGS=\"-march=i686 -mtune=intel -mssse3 -mfpmath=sse -m32\" SYSROOT=$NDK_HOME/platforms/$PLATFORM_VERSION/arch-$ARCH/ build build_android_armeabi-v7a 针对armeabi-V7a平台 使用 neon 进行优化 -mfpu=neon #!/bin/bash make clean export NDK=/usr/work/ndk/android-ndk-r14b export SYSROOT=$NDK/platforms/android-9/arch-arm/ export TOOLCHAIN=$NDK/toolchains/arm-linux-androideabi-4.9/prebuilt/linux-x86_64 export CPU=armeabi-v7a export PREFIX=$(pwd)/android/$CPU export ADDI_CFLAGS=\"-march=armv7-a -mfloat-abi=softfp -mfpu=neon\" export ADDI_LDFLAGS=\"-Wl,--fix-cortex-a8\" ./configure --target-os=android \\ --prefix=$PREFIX --arch=arm \\ --enable-shared \\ --disable-static \\ --disable-yasm \\ --disable-symver \\ --enable-gpl \\ --enable-ffmpeg \\ --disable-ffplay \\ --disable-ffprobe \\ --disable-doc \\ --disable-symver \\ --cross-prefix=$TOOLCHAIN/bin/arm-linux-androideabi- \\ --enable-cross-compile \\ --sysroot=$SYSROOT \\ --extra-cflags=\"-Os -fpic $ADDI_CFLAGS\" \\ --extra-ldflags=\"$ADDI_LDFLAGS\" \\ $ADDITIONAL_CONFIGURE_FLAG make clean make make install androidStudio 集成ffmpeg 1、将需要的so文件和头文件复制到工程中。 2、进行相关配置，以便生成适用于对应的cpu的最后的so。 3、CMakeLists.txt 配置示例 # cmake版本最低要求 cmake_minimum_required(VERSION 3.4.1) add_library( # 将指定的cpp文件生成so文件 wkplayer SHARED src/main/cpp/wkplayer.cpp ) # 导入 ffmpeg需要的头文件 include_directories(src/main/cpp/ffmpeg/include) #添加libavcodec-57.so # 指定so文件和引入方式等信息，最后生成 指定名字的 so add_library( avcodec-57 SHARED IMPORTED) set_target_properties( avcodec-57 PROPERTIES IMPORTED_LOCATION ${CMAKE_SOURCE_DIR}/src/main/cpp/ffmpeg/armeabi/libavcodec-57.so) #添加libavdevice-57.so add_library( avdevice-57 SHARED IMPORTED) set_target_properties( avdevice-57 PROPERTIES IMPORTED_LOCATION ${CMAKE_SOURCE_DIR}/src/main/cpp/ffmpeg/armeabi/libavdevice-57.so) add_library( avfilter-6 SHARED IMPORTED) set_target_properties( avfilter-6 PROPERTIES IMPORTED_LOCATION ${CMAKE_SOURCE_DIR}/src/main/cpp/ffmpeg/armeabi/libavfilter-6.so) add_library( avformat-57 SHARED IMPORTED) set_target_properties( avformat-57 PROPERTIES IMPORTED_LOCATION ${CMAKE_SOURCE_DIR}/src/main/cpp/ffmpeg/armeabi/libavformat-57.so) add_library( avutil-55 SHARED IMPORTED) set_target_properties( avutil-55 PROPERTIES IMPORTED_LOCATION ${CMAKE_SOURCE_DIR}/src/main/cpp/ffmpeg/armeabi/libavutil-55.so) add_library( swresample-2 SHARED IMPORTED) set_target_properties( swresample-2 PROPERTIES IMPORTED_LOCATION ${CMAKE_SOURCE_DIR}/src/main/cpp/ffmpeg/armeabi/libswresample-2.so) add_library( swscale-4 SHARED IMPORTED) set_target_properties( swscale-4 PROPERTIES IMPORTED_LOCATION ${CMAKE_SOURCE_DIR}/src/main/cpp/ffmpeg/armeabi/libswscale-4.so) add_library( postproc-54 SHARED IMPORTED) set_target_properties( postproc-54 PROPERTIES IMPORTED_LOCATION ${CMAKE_SOURCE_DIR}/src/main/cpp/ffmpeg/armeabi/libpostproc-54.so) find_library( # 调用系统日志库 log-lib log ) target_link_libraries( # 将所有的库打包到一起 wkplayer avcodec-57 avdevice-57 avfilter-6 avformat-57 avutil-55 swresample-2 swscale-4 postproc-54 ${log-lib} ) 4、如果要给其他工程使用，提供 wkplayer.so 即可。不用提供ffmpeg的那些文件。 版本兼容 #if LIBAVCODEC_VERSION_INT ffmpeg 常用结构体 AVIOContext // 用于从文件中读取数据，送去解析 AVStream | 存储每一个视频/音频流信息的结构体 AVOutputFormat | AVInputFormat | AVSampleFormat |音频采样率的格式 SwrContext | 一般用于音频重采样，比如采样率转换，声道转换。 AVFrame | 存储一帧的数据。例如yuv数据，是否关键帧、像素类型等 AVFormatContext |数据的封装格式、视音频流的个数、文件名、比特率、元数据等 AVCodecContext | 记录编解码的一些信息。例如 采样格式、平均比特率、采样率等 AVCodec | 存储编解码器信息 。编解码器的名字、支持的帧率、类型（视频/音频/字幕）等 ANativeWindow| opengl工作的绘图画布本地窗口 SwsContext | 主要用于视频图像的转换 AVPicture | AVPacket | 存储压缩编码数据相关信息 AVBSFContext // The bitstream filter state AVCodecParameters // 描述一个解码后的流的属性。 AVRational // 是一个有结构体，包含了分子和分母两个值 AVBitStreamFilter // AVDictionaryEntry //键值对存储类 ffmpeg常用函数 ANativeWindow_fromSurface //创建播放窗口 av_register_all //注册所有组件 avformat_network_init //初始化网络库 avformat_network_deinit // avformat_open_input |打开输入视频文件 av_find_best_stream | 查找音频流的 index avformat_find_stream_info //获取视频文件信息 av_format_inject_global_side_data ()// avcodec_find_decoder |查找解码器 avcodec_open| avcodec_open2 | 打开解码器 avcodec_alloc_context3 | avcodec_parameters_to_context | av_packet_alloc | av_frame_alloc | 给AVFrame 分配内存 av_frame_free | 释放 AVFrame av_packet_free | avcodec_send_packet |送去解码 avcodec_receive_frame () // 从解码队列中取出一帧,AVFrame avFrame->data[0] data[1] data[2] ，y、u、v avformat_alloc_context () // 创建解复用上下文 swr_alloc_set_opts | swr_init | swr_convert |重采样 sws_getContext | 初始化 sws_scale | 转换像素格式 sws_freeContext | av_get_channel_layout_nb_channels | av_samples_get_buffer_size | av_packet_unref // av_read_frame | 从输入文件读取一帧压缩数据 avcodec_close() | 关闭解码器 avformat_close_input | 关闭输入视频文件 av_open_input_file | av_find_stream_info| av_find_input_format | av_close_input_file | avcodec_register_all|注册编解码器 avdevice_register_all |注册设备 avcodec_alloc_frame | avpicture_get_size | avpicture_fill | img_convert | avcodec_alloc_context( | av_free_packet | av_free | avnew_steam | av_write_frame | dump_format | avpicture_deinterlace | ImgReSampleContext | avformat_open_input| 尝试打开连接 ，失败返回值 常用常量和变量 AV_PIX_FMT_YUV420P // YUV420P格式 AV_NOPTS_VALUE // 表示获取pts失败 AVERROR_EOF // 解码结束 AVMEDIA_TYPE_AUDIO // 音频类型 AVMEDIA_TYPE_VIDEO // 视屏类型 AV_TIME_BASE //时间基 1000000 stream_index // 用来匹配音视频流的索引 xx.interrupt_callback.callback // 设置 读取超时回调 xx.interrupt_callback.opaque // 常与interrupt_callback.callback一起写 xx.skip_initial_bytes //偏移量 Skip initial bytes when opening stream // 健值存储和查找配置 AV_DICT_MATCH_CASE // 匹配大小写 AV_DICT_IGNORE_SUFFIX //匹配时忽略后缀) AV_DICT_DONT_STRDUP_KEY //不对key进行拷贝 AV_DICT_DONT_STRDUP_VAL //不对value进行拷贝 AV_DICT_DONT_OVERWRITE //不覆盖现有条目 AV_DICT_APPEND //如果目已经存在，则value值直接拼接到之前的值的后面。 AV_DICT_MULTIKEY //允许在字典中存储相等的key。 //标记常量 AVFMT_FLAG_GENPTS // Generate missing pts even if it requires parsing future frames. AVFMT_FLAG_IGNIDX // Ignore index. AVFMT_FLAG_NONBLOCK // Do not block when reading packets from input. AVFMT_FLAG_IGNDTS // Ignore DTS on frames that contain both DTS & PTS AVFMT_FLAG_NOFILLIN // Do not infer any values from other values, just return what is stored in the container AVFMT_FLAG_NOPARSE // Do not use AVParsers, you also must set AVFMT_FLAG_NOFILLIN as the fillin code works on frames and no parsing -> no frames. Also seeking to frames can not work if parsing to find frame boundaries has been disabled AVFMT_FLAG_NOBUFFER // Do not buffer frames when possible AVFMT_FLAG_CUSTOM_IO // The caller has supplied a custom AVIOContext, don't avio_close() it. AVFMT_FLAG_DISCARD_CORRUPT // Discard frames marked corrupted AVFMT_FLAG_FLUSH_PACKETS // Flush the AVIOContext every packet. AVFMT_FLAG_BITEXACT // AVFMT_FLAG_MP4A_LATM // Enable RTP MP4A-LATM payload AVFMT_FLAG_SORT_DTS // try to interleave outputted packets by dts (using this flag can slow demuxing down) AVFMT_FLAG_PRIV_OPT // Enable use of private options by delaying codec open (this could be made default once all code is converted) AVFMT_FLAG_KEEP_SIDE_DATA // Don't merge side data but keep it separate. AVFMT_FLAG_FAST_SEEK // Enable fast, but inaccurate seeks for some formats AVFMT_TS_DISCONT // 视音视频同步 为什么会出现音频不同步？ 理想状态下视音频是同步的，不过在现实场景下，由于机器性能、计算精度偏差等会导致音频和视频的同步性会慢慢地出现偏差。 DTS（Decoding Time Stamp）: 解码时间戳 PTS（Presentation Time Stamp）： 显示时间戳 音频、只有I帧和P帧的视频中 ，DTS和PTS是一样的。 当视频帧中有B帧的时候， DTS 和 PTS 是不一样的。 因为B帧跟前后帧都有关系，所以解码和显示顺序并不是一样的。 视音频同步方案 1、将视频同步到音频上 以音频的播放速度为基准来同步视频。视频比音频播放慢了，加快其播放速度；快了，则延迟播放。 由于某些生物学的原理，人对声音的变化比较敏感，但是对视觉变化不太敏感。所以一般采用这种方案。 2、将音频同步到视频上 3、选择一个外部时钟为基准，视频和音频的播放速度都以该时钟为标准 视音频同步原理 视音频的同步过程是一个动态过程，快则等待，慢则加快播放，在这样的过程中实现同步播放。 时间戳和时间基的理解 Unix 时间戳 是一种时间表示方式，定义为从格林威治时间1970年01月01日00时00分00秒起至现在的总秒数。 ffmpeg中的时间戳概念跟 Unix的时间戳概念是有区别的，我的理解如下： 时间基可以理解为刻度或步长，例如时间基为1时，时间戳每加1就代表增加一秒钟， 时间基为2时，时间戳每加1就代表增加2秒，时间基为 1/25 时，时间戳每加1就代表增加 1/25 秒 。 如果以视频开始点开始计时 ，时间基为 2， 时间戳为2的时候 ，此时的播放时长就是 4秒 。 ---------------------------------------------------------------- ffmpeg内部定义了一个时间基 AV_TIME_BASE #define AV_TIME_BASE 1000000 #define AV_TIME_BASE_Q (AVRational){1, AV_TIME_BASE} timestamp(ffmpeg内部时间戳) = AV_TIME_BASE * time(秒) time(秒) = AV_TIME_BASE_Q * timestamp(ffmpeg内部时间戳) ---------------------------------------------------------------- 不同时间基下的时间戳转换 若 t代表时间 ，base1, base2 代表 时间基 ， stamps1 ,stamps2 代表时间戳 转换公式为 stamps1 = (stamps2 * base2 ) / base1 在ffmpeg中可以直接使用内置函数 将在stream->time_base时间基下的时间戳pts 转为 AV_TIME_BASE时间戳下的时间戳time int64_t time = av_rescale_q(pts, stream->time_base, AV_TIME_BASE_Q); Windows 上使用 ffmpeg 安装ffmpeg 1、 下载对应的版本 https://ffmpeg.zeranoe.com/builds/ 2、 解压到本地 3、 将 xxx\\ffmpeg\\bin 配置到环境变量 。 如果不配置就不能全局使用命令。 4、测试是否成功 ffmpeg –version ffmpeg 常用命令 以下只是基本命令，高级应用请查阅文档 ffmpeg -i [输入文件名] [参数选项] -f [格式] [输出文件] // H264 转 mp4 ffmpeg -i test1.h264 -vcodec copy -f mp4 test.mp4 // .ts 转 mp4 ffmpeg -i test1.ts -vcodec copy -f mp4 test2.mp4 // mp4 转 flv ffmpeg -i test1.mp4 -acodec copy -vcodec copy -f flv test1.flv // 提取视频关键帧 ffmpeg -i test1.mp4 -vf select='eq(pict_type\\,I)' -vsync 2 -s 1920*1080 -f image2 core-%03d.jpeg // 视频截取 ffmpeg -i ./test2.mp4 -vcodec copy -acodec copy -ss 00:00:08 -to 00:00:30 ./cutout1.mp4 -y // 修改视频播放速度 // -an禁用声音 setpts范围[0.25, 4]，0.5是一倍速度 ffmpeg -i test2.mp4 -an -filter:v \"setpts=0.5*PTS\" out2.mp4 // 添加文字水印 ffmpeg -i test2.mp4 -vf \"drawtext=fontfile=simhei.ttf: text='版权申明':x=200:y=100:fontsize=24:fontcolor=yellow:shadowy=2\" out3.mp4 // 添加图片水印 ffmpeg -i test2.mp4 -i mark.png -filter_complex \"[1:v]colorkey=0x000000:0.6:1.0[ckout];[0:v][ckout]overlay=x=W-w-10:y=0[out]\" -map \"[out]\" -movflags faststart out4.mp4 // 视频转gif // 从25秒开始，截取5秒 生成gif ffmpeg -ss 25 -t 5 -i aa.mp4 -f gif aa.gif // 提取音频为mp3 ffmpeg -i aa.mp4 -f mp3 a.mp3 // 提取视频 （删除声音） ffmpeg -i aa.mp4 -vcodec copy -an bb.avi ffmpeg -i aa.mp4 -vcodec copy -an bb.mp4 // 屏幕录制 // 全局录制 ffmpeg -f gdigrab -i desktop out.mp4 // 局部录制 ffmpeg -f gdigrab -framerate 25 -offset_x 10 -offset_y 20 -video_size 640x480 -i desktop out2.mp4 // 图片合成视频 （带声音） 未测试。 // 图片合成视频 （不带声音） 未测试。 //视频拼接 将两个视频 水平拼接 或者垂直拼接。 未测试。 rtsp服务器Windows window下搭建rtsp测试服务器可以用 live555 、vlc 等。 后来我发现用EasyScreenLive更简单。 备用下载地址 OpenGLES OpenGL Shading Language 、Open Graphics Library 数据类型 空类型 // void 标量 向量 矩阵 采样器 结构体 数组 //只可以使用一维的数组 标量数据类型 bool // true 、false int //和C一样，可以写为十进制（16）、八进制（020）或者十六进制（0x10） float // 向量数据类型 vec2 // 包含2个成分的向量。 bvec2 // 包含2个 boolean 变量 bvec3 // 包含3个 boolean 变量 bvec4 // 包含4个 boolean 变量 ivec2 // 包含2个 int 变量 ivec3 // 包含3个 int 变量 ivec4 // 包含4个 int 变量 矩阵数据类型 mat2x2 、mat2 // 2x2的浮点数矩阵类型 mat3x3 、mat3 // 3x3的浮点数矩阵类型 mat4x4 // 4x4的浮点数矩阵 mat2x3 // 2列3行的浮点数矩阵 mat2x4 // 2列4行的浮点数矩阵 mat3x2 // 3列2行的浮点数矩阵 mat3x4 // 3列4行的浮点数矩阵 mat4x2 // 4列2行的浮点数矩阵 mat4x3 // 4列3行的浮点数矩阵 采样器数据类型 sampler1D // 用于内建的纹理函数中引用指定的1D纹理的句柄。只可以作为一致变量或者函数参数使用 sampler2D // 二维纹理句柄 sampler3D // 三维纹理句柄 samplerCube // cube map纹理句柄 sampler1DShadow // 一维深度纹理句柄 sampler2DShadow // 二维深度纹理句柄 修饰符 const | 只读 ,不可修改 attribute |只读的顶点数据。可以是浮点数类型的标量，向量，或者矩阵。不可以是数组或则结构体 uniform |一致变量。在着色器执行期间一致变量的值是不变的 varying | 顶点着色器的输出。可以是浮点数类型的标量，向量，矩阵。不能是数组或者结构体 centorid varying| 在没有多重采样的情况下，与varying是一样的意思。在多重采样时，centorid varying在光栅化的图形内部进行求值而不是在片段中心的固定位置求值 invariant |表示顶点着色器的输出和任何匹配片段着色器的输入 in // 用在函数的参数中，表示这个参数是输入的 out //用在函数的参数中，表示该参数是输出参数 inout //用在函数的参数，表示这个参数即是输入参数也是输出参数 顶点着色器 内置变量 类型 说明 gl_Color vec4 输入属性。表示顶点的主颜色 gl_SecondaryColor vec4 输入属性。表示顶点的辅助颜色 gl_Normal vec3 输入属性。表示顶点的法线值 gl_Vertex vec4 输入属性。表示物体空间的顶点位置 gl_MultiTexCoordn vec4 输入属性。表示顶点的第n个纹理的坐标 gl_FogCoord float 输入属性。表示顶点的雾坐标 gl_Position vec4 是一个内置变量，用于指定顶点 ， 因为涉及到矩阵操作，所以用一个四维向量来赋值。 gl_ClipVertex vec4 输出坐标。用于用户裁剪平面的裁剪 gl_PointSize float 是内置变量 ,用于指定点的大小 gl_FrontColor vec4 正面的主颜色的varying输出 gl_BackColor vec4 背面主颜色的varying输出 gl_FrontSecondaryColor vec4 正面的辅助颜色的varying输出 gl_BackSecondaryColor vec4 背面的辅助颜色的varying输出 gl_TexCoord[] vec4 纹理坐标的数组varying输出 gl_FogFragCoord float 雾坐标的varying输出 片段着色器 内置变量 类型 说明 gl_Color vec4 包含主颜色的插值只读输入 gl_SecondaryColor vec4 包含辅助颜色的插值只读输入 gl_TexCoord[] vec4 包含纹理坐标数组的插值只读输入 gl_FogFragCoord float 包含雾坐标的插值只读输入 gl_FragCoord vec4 只读输入。窗口的x,y,z和1/w gl_FrontFacing bool 只读输入。如果是窗口正面图元的一部分，则这个值为true gl_PointCoord vec2 点精灵的二维空间坐标范围在(0.0, 0.0)到(1.0, 1.0)之间。仅用于点图元和点精灵开启的情况下。 gl_FragData[] vec4 使用glDrawBuffers输出的数据数组。不能与gl_FragColor结合使用。 gl_FragColor vec4 片元颜色,是内置变量， 四个分量（r, g, b, a） gl_FragDepth float 输出的深度用于随后的像素操作。如果这个值没有被写，则使用固定功能管线的深度值代替 常用内置函数 all |在所有为真的时候，返回为真； any |在任一变量为真的时候，返回为真； dot |向量点乘 cross |向量的叉积 ceil(x) |向上取整 如：ceil(3.5) 值为4 floor(x) |向下取整 如：floor(3.5) 值为3 pow(x,y) |求x的y次方 exp(x) |自然指数e的x次方 exp2(x) |2的x次方 transpose |矩阵求转置矩阵 determinant |求行列式 inverse |矩阵求逆矩阵 distance |计算两点的距离 length |求解向量的长度 normalize |对一个向量进行标准化 clamp |将一个值截取到两个值之间 matrixCompMult |在两个矩阵之间执行一个逐分量的操作 outerProduct |提取两个向量的外积。就是将一个n*1的向量与1* m的向量相乘，得到一个n*m的矩阵 dot ( ) // 点乘 返回两个单位向量之间夹角的cos值 cross ( ) // 叉乘 texture2D ( ) // 用于纹理采样 normalize ( ) //:对⼀一个向量量规格化 clamp ( ) //将⼀个向量固定在一个最小值和最大值之间 pow() //幂函数 exp() // log() 指数函数 对数函数 sqrt() // 平方根 max() // min() // 最大值 最小值 ceil() floor() // 取大于实参的最小整数，取小于实参的最大整数 sin() cos() tan() // 三角函数 asin() acos() atan() // 反三角函数 sinh() cosh() tanh() // 双曲正弦 双曲余弦 双曲正切 asinh() acosh() atanh() // 反双曲正弦 反双曲余弦 反双曲正切 length () // 向量长度 distance () // 两个向量的距离 matrixCompMult () // 矩阵对应元素分别相乘 transpose () determinant() inverse() // 矩阵转置 行列式 逆 lessThan () greaterThan() equal() // 小于 大于 等于 精度级别 说明 lowp mediump highp precision highp float; 定义在 float 类型默认使用 highp 级别的精度 关键字 precision // 系统关键字 ，用来指定数据类型的精度 const // 变量类型，编译过程常量，或者函数的只读参数。 只读 ,不可修改。 attribute // 变量类型 ， 表示只读的顶点数据，只用在顶点着色器中。用于连接顶点着色器和 OpenGL ES 。 uniform // 变量类型 ， 链接在一起的顶点着色器和片段着色器共享同一个统一变量空间 varying // 变量类型 ， 顶点着色器的输出。 用于连接顶点着色器和片段着的输出。 其他 samplerExternalOES //安卓上我们只能用samplerExternalOES类型的纹理去接收摄像头的画面 #extension GL_OES_EGL_image_external : require // android中使用samplerExternalOES ， 需要开启 专业名词 名词 作用 OpenGL 一个跨平台的图形API，提供了软件操作３Ｄ图形硬件的接口。OpenGL 的基本形状是三角形。 OpenGLES 一个专用于嵌入式设备的阉割版的OpenGL。 [Android 1.0 , +∞) 支持 OpenGL ES 1.0 [Android 2.2 , +∞) 支持 OpenGL ES 2.0 [Android 4.3 , +∞) 支持 OpenGL ES 3.0 [Android 5.0 , +∞) 支持OpenGL ES 3.1 GLSL (OpenGL Shader Language) 着色器语言。面向过程。 顶点着色器 Vertex shader 把顶点在虚拟空间中的三维坐标变换为在屏幕上的二维坐标。 并带有用于z-buffer的深度信息。 片元着色器 Fragment shader 针对每个片元(像素)，用于确定每个片元的颜色。 EGL(Embedded Graphics Library) 连接OpenGL ES和本地窗口系统的接口，屏蔽不同平台上的区别。从而实现跨平台。 渲染管线 指的是一堆原始图形数据途经一个输送管道，期间经过各种变化处理最终出现在屏幕的过程 投影矩阵Projection Matrix 在OpenGL中，投影矩阵用来改变场景在屏幕上的显示方式（近大远小、平行投影等） 正交投影 投影线是平行的。物体不会随距离观测点的位置而大小发生变化。 投影 让3D世界呈现在2D世界的过程。 透视投影 模仿人眼观察3D世界的规律，让物体近大远小。 光栅化 即像素化。把点、线、三角形映射到屏幕上的像素点的过程。 光照 1、环境光 2、镜面光 3、散射光 VBO 顶点缓冲对象（Vertex Buffer Objects，VBO）保存了一个模型的顶点属性信息 VAO 顶点数组对象（Vertex Arrary Object，VAO）VAO相当于是对很多个VBO的引用 EBO 索引缓冲对象（Element Buffer Object，EBO）存储顶点位置的索引 FBO Frame Buffer Object 帧缓冲对象 纹理 可以将纹理看做应用在物体表面的像素颜色。 纹理映射 将2D的纹理映射到3D场景中的立体物体上。 贴图 阴影 粒子 混合与雾 标志板 天空盒 天空穹 相机UP方向 理解为相机顶端指向的方向。斜着、倒着之类的 .STL文件 3D模型文件 .sh 着色器语言文件 .obj 3D模型文件 .mtl 材质、贴图文件 坐标系类型 类型 特点 局部坐标系(Local Space) / (Object Space) 以自身为参照点 世界坐标系(World Space) [ -1 , 1 ]标。 相机坐标系(View Space) / (Eye Space) 相机所在的位置为原点。XYZ轴的方向 根据情况而定。 裁剪坐标系(Clip Space) ？ 屏幕坐标系(Screen Space) 就是呈现在屏幕上的大小 纹理坐标系 [ -1 , 1 ] 注：纹理坐标的y轴的方向和图片的Y轴方向相反。所以是要进行y轴反转的 。？？ GLES20 常用变量 GLES20 常用变量 意义 GL_DEPTH_BUFFER_BIT 清空 深度缓冲区 GL_COLOR_BUFFER_BIT 清空 颜色缓冲区 GL_ACCUM_BUFFER_BIT 清空 累积缓冲区 GL_STENCIL_BUFFER_BIT 清空模板缓冲区 GL_FLOAT GL_TRIANGLES 每三个顶点绘制一个三角形 GL_TRIANGLE_STRIP 绘制三角形的一种顺序 GL_TRIANGLE_FAN 绘制三角形的一种顺序 GL_TEXTURE0 GL_TEXTURE_2D GL_UNSIGNED_SHORT GL_VERTEX_SHADER GL_FRAGMENT_SHADER GL_LINK_STATUS GL_TRUE GL_COMPILE_STATUS GLES20 常用函数 意义 glGetUniformLocation ( int program,String name) 根据name获取uniform类型变量的id glGetAttribLocation( int program, String name) 根据name获取attribute类型变量的id glUseProgram 将程序加入到OpenGLES环境 glEnableVertexAttribArray 启用顶点坐标数组启动顶点纹理数组 glVertexAttribPointer 准备顶点位置数据 glDrawArrays 图形绘制 glClear 清除缓冲区 glCreateProgram 创建一个空的OpenGLES程序 glUniformMatrix4fv 将最终变换矩阵传入shader程序 glDisableVertexAttribArray 禁止顶点数组的句柄 glDrawElements 索引法绘制 glUniform4fv 设置绘制三角形的颜色 glUniform1i glUniform1f glBindTexture 绑定纹理 glActiveTexture 选择活动纹理单元 glShaderSource 将资源加入到着色器中 glCompileShader 编译着色器 glGetShaderiv glDeleteShader glCreateShader 根据type创建着色器 glAttachShader 将着色器加入到程序 glLinkProgram 连接到着色器程序 glGetProgramiv glDeleteProgram glClearColor 清屏时，使用该颜色填充整个屏幕 glViewport 确定绘制区域 glReadPixels 获取正在显示的像素 glGenTextures 生成纹理 glTexParameterf 纹理过滤函数 texImage2D 生成2D纹理 EGL10 常用函数 EGL10 常用函数 意义 glMatrixMode 使用的矩阵类型 glFrustumf 三维用二维显示出来需要指定的一些参数 glLoadIdentity 设置为单位矩阵 glDepthFunc 深度比较 GL_MODELVIEW 观察矩阵 GL_PROJECTION 投影矩阵 glClearDepthf 给深度缓存设定默认值 glHint 希望进行最好的透视修正 glEnableClientState 启用顶点数组等 glShadeModel 设置着色器模式 glVertexPointer 指向顶点数组 glColorPointer 指向颜色数组的指针 glDrawArrays 绘制数组里面所有点构成的各个三角片 EGLConfig常用函数 意义 Matrix 常用函数 意义 参数 orthoM 正交投影 orthoM (float[] m,//接收正交投影的变换矩阵int mOffset,//变换矩阵的起始位置（偏移量）float left,//相对观察点近面的左边距float right,//相对观察点近面的右边距float bottom,//相对观察点近面的下边距float top,//相对观察点近面的上边距float near,//相对观察点近面距离float far//相对观察点远面距离) frustumM 透视投影 Matrix.frustumM (float[] m,//接收透视投影的变换矩阵int mOffset,//变换矩阵的起始位置（偏移量）float left,//相对观察点近面的左边距float right,//相对观察点近面的右边距float bottom, //相对观察点近面的下边距float top, //相对观察点近面的上边距float near,//相对观察点近面距离float far //相对观察点远面距离) setLookAtM 设置观察矩阵(相机位置) setLookAtM (float[] rm,//接收相机变换矩阵 int rmOffset,//变换矩阵的起始位置（偏移量） float eyeX,float eyeY, float eyeZ, //相机位置float centerX,float centerY,float centerZ, //观测点位置float upX,float upY,float upZ//up向量在xyz上的分量 ) multiplyMM 矩阵相乘 multiplyMM(float[] result, //接收相乘结果 int resultOffset,//接收矩阵的起始位置（偏移量） float[] lhs, //左矩阵 int lhsOffset, //左矩阵的起始位置（偏移量） float[] rhs, //右矩阵 int rhsOffset//右矩阵的起始位置（偏移量）) 常用函数 glFlush () // 强制刷新缓冲，保证绘图命令将被执行 eglSwapBuffers () ;// 提交当前的帧 glDisable (GL_DITHER); // 取消抖动 glEnable (GL_CULL_FACE) // 开启剔除操作效果 glDeleteTextures () // 删除纹理 glDeleteFramebuffers () // eglGetDisplay() // 获取EGLDisplay eglInitialize() // 初始化EGL,并回传支持的版本 eglChooseConfig () // 选择config eglCreateContext () // eglGetConfigAttrib () // ANativeWindow_setBuffersGeometry () // 设置 ANativeWindow 绘制窗口属性 ANativeWindow_release () // eglCreateWindowSurface () // eglMakeCurrent () // 把EGLContext和EGLSurface关联起来 eglDestroySurface () // eglDestroyContext () // glBindFramebuffer () // 绑定一个命名的帧缓冲区对象 glGenFramebuffers () // 生成framebuffer 的id glTexImage2D () // 生成一个2D纹理 glFramebufferTexture2D () // 绑定2D纹理 glTexParameteri() // 图象从纹理图象空间映射到帧缓冲图象空间 glUniform1f () //为当前程序对象指定Uniform变量的值。 void glUniform1f ( ); void glUniform2f ( ); void glUniform3f ( ); void glUniform4f ( ); void glUniform1i ( ); // 保证每个uniform采样器对应着正确的纹理单元。 void glUniform2i ( ); void glUniform3i ( ); void glUniform4i ( ); void glUniform1fv ( ); void glUniform2fv ( ); void glUniform3fv ( ); void glUniform4fv (); void glUniform1iv ( ); void glUniform2iv ( ); void glUniform3iv ( ); void glUniform4iv ( ); void glUniformMatrix2fv ( ); void glUniformMatrix3fv ( ); void glUniformMatrix4fv ( ); EGLBoolean // EGL_TRUE =1, EGL_FALSE=0 EGLint // int 数据类型 EGLDisplay // 系统显示 ID 或句柄，可以理解为一个前端的显示窗口 EGLConfig //Surface的EGL配置，可以理解为绘制目标framebuffer的配置属性 EGLSurface //系统窗口或 frame buffer 句柄 ，可以理解为一个后端的渲染目标窗口。 EGLContext //OpenGL ES 图形上下文，它代表了OpenGL状态机；如果没有它，OpenGL指令就没有执行的环境。 GL_FALSE // EGL_NO_DISPLAY // EGL_NO_SURFACE // EGL_NO_CONTEXT // EGL_DEFAULT_DISPLAY // EGL_NO_DISPLAY // EGL_NO_SURFACE // EGL_RED_SIZE //指定RGB中的R大小（bits） EGL_GREEN_SIZE //指定G大小 EGL_BLUE_SIZE //指定B大小 EGL_RENDERABLE_TYPE EGL_OPENGL_ES3_BIT_KHR // EGL_SURFACE_TYPE // EGL_WINDOW_BIT // EGL_NONE // EGL_CONTEXT_CLIENT_VERSION // context 版本 EGL_NO_CONTEXT // 表示不向其它的context共享资源 EGL_NATIVE_VISUAL_ID // 显示设备的原始图像编号 NO_TEXTURE // ON_DRAWN // GL_FRAMEBUFFER // GL_RGBA // GL_UNSIGNED_BYTE // GL_TEXTURE_MIN_FILTER // 缩小过滤 GL_TEXTURE_MAG_FILTER // 放大过滤 GL_TEXTURE_WRAP_S // S方向上的贴图模式 GL_TEXTURE_WRAP_T // T 方向上的贴图模式 GL_LINEAR // GL_NEAREST // GL_CLAMP_TO_EDGE // GL_COLOR_ATTACHMENT0 // GLES20.GL_REPEAT // GLES20.GL_LINEAR // 常用类与常量变量 GLuint // 无符号四字节整型，包含数值从0 到 4,294,967,295 GL_DEPTH_TEST // 深度比较和更新深度缓冲 补充细节 1、在OpenGL中提到的浮点数都是指float类型。 2、在OpenGL中，数组是row-major (行优先)的。 3、绘制三角形取顶点的顺序 是逆时针的。 4、OpenGL中使用的是列向量 索引绘制 这个多边形由2个三角形组成。 蓝色和绿色三角形的 组成顶点依次是 (V0 , V1 ,V2) ,( V3 ,V4, V5) 。 注意：绘制三角形 是 逆时针绘制的规则。 //顶点数组如下。 有重叠的点 [ (0,0), (2,0), (1,2), (1,2), (2,0), (3,2)] //对应的索引数组如下。 分别代表顶点数组中的 第 0,1,2,2,1,5个数据 [ 0, 1,2, 2,1,5]    长宽比例变形问题 opengl的坐标系是 1:1的比例 ，然而手机等设备是 16:9 等长方形比例。所以一个正方形直接显示在屏幕后就是一个长方形。 此时，我们可以通过 计算设备的长宽比，然后根据比例重新计算在opengl中的坐标 ，最终可以获得正方形效果。 但是，如果绘制的图形比较复杂，我们通过这种方式去计算，会很繁琐。此时，我们可以通过 变换矩阵 ，让opengl库帮我们完成这些工作。 矩阵转换的推导和具体转换原理，以后再详细展示，此处略过。 球面绘制 将图片绘制到球面体 ，形成 全景效果 。 ?????????????? 而我们的视角在是在球的中心点，这样就可以向四面八方去观看了。 android 配置OpenGL ES 环境 // 使用 opengl es 版本 //使用纹理压缩 // EGL 版本 glSurfaceView.setEGLContextClientVersion(2); glSurfaceView.setRenderer(new MyGLRenderer(this)); // 渲染模式 glSurfaceView.setRenderMode(GLSurfaceView.RENDERMODE_CONTINUOUSLY); /** 是否支持 opengl2.0 + */ private boolean checkSupported() { ActivityManager activityManager = (ActivityManager) getSystemService(ACTIVITY_SERVICE); if (activityManager != null) { ConfigurationInfo configurationInfo = activityManager.getDeviceConfigurationInfo(); boolean supportsEs2 = configurationInfo.reqGlEsVersion >= 0x2000; boolean isEmulator = Build.VERSION.SDK_INT > Build.VERSION_CODES.ICE_CREAM_SANDWICH_MR1 && (Build.FINGERPRINT.startsWith(\"generic\") || Build.FINGERPRINT.startsWith(\"unknown\") || Build.MODEL.contains(\"google_sdk\") || Build.MODEL.contains(\"Emulator\") || Build.MODEL.contains(\"Android SDK built for x86\")); supportsEs2 = supportsEs2 || isEmulator; return supportsEs2 ; }else{ return false; } } final float mTriangleArray[] = { -1.0f,1.0f,1.0f, -1.0f,-1.0f,1.0f, 1.0f,-1.0f,1.0f }; public void test(float[] data) { // 分配本地内存块 , 一个float占4个字节 ByteBuffer bb = ByteBuffer.allocateDirect(data.length * 4); //以本机字节顺序来修改此缓冲区的字节顺序 bb.order(ByteOrder.nativeOrder()); FloatBuffer mTriangleBuffer = bb.asFloatBuffer(); //将给定float[]数据从当前位置开始，依次写入此缓冲区 mTriangleBuffer.put(mTriangleArray); //设置此缓冲区的位置。 mTriangleBuffer.position(0); } openglES示例 全景 全景视频类型 特点 Sphere Skybox Cubemap Cylinder 彩色三角形 public class MyRenderer implements GLSurfaceView.Renderer { private Context context ; private float[] mViewMatrix=new float[16]; private float[] mProjectMatrix=new float[16]; private float[] mMVPMatrix=new float[16]; private int mProgram; private FloatBuffer vertexBuffer; private FloatBuffer colorBuffer; /**顶点坐标*/ private float triangleCoords[] = { 0.5f, 0.5f, 0.0f, -0.5f, -0.5f, 0.0f, 0.5f, -0.5f, 0.0f }; float color[] = { 0.0f, 1.0f, 0.0f, 1.0f , 1.0f, 0.0f, 0.0f, 1.0f, 0.0f, 0.0f, 1.0f, 1.0f }; public MyRenderer( Context context){ this.context = context; init(); } private void init() { ByteBuffer bb = ByteBuffer.allocateDirect( triangleCoords.length * 4); bb.order(ByteOrder.nativeOrder()); vertexBuffer = bb.asFloatBuffer(); vertexBuffer.put(triangleCoords); vertexBuffer.position(0); ByteBuffer dd = ByteBuffer.allocateDirect( color.length * 4); dd.order(ByteOrder.nativeOrder()); colorBuffer = dd.asFloatBuffer(); colorBuffer.put(color); colorBuffer.position(0); } @Override public void onSurfaceCreated(GL10 gl, EGLConfig config) { String vertexShaderCode = MyAssetsTool.loadFromAssetsFile(\"vertex.sh\" ,context); String fragmentShaderCode = MyAssetsTool.loadFromAssetsFile(\"fragment.sh\" ,context); int vertexShader = loadShader(GLES20.GL_VERTEX_SHADER, vertexShaderCode); int fragmentShader = loadShader(GLES20.GL_FRAGMENT_SHADER, fragmentShaderCode); mProgram = GLES20.glCreateProgram(); GLES20.glAttachShader(mProgram, vertexShader); GLES20.glAttachShader(mProgram, fragmentShader); GLES20.glLinkProgram(mProgram); } @Override public void onSurfaceChanged(GL10 gl, int width, int height) { //计算宽高比 float ratio=(float)width/height; Matrix.frustumM(mProjectMatrix, 0, -ratio, ratio, -1, 1, 3, 7); Matrix.setLookAtM(mViewMatrix, 0, 0, 0, 7.0f, 0f, 0f, 0f, 0f, 1.0f, 0.0f); Matrix.multiplyMM(mMVPMatrix,0,mProjectMatrix,0,mViewMatrix,0); } @Override public void onDrawFrame(GL10 gl) { GLES20.glClear(GLES20.GL_COLOR_BUFFER_BIT | GLES20.GL_DEPTH_BUFFER_BIT); GLES20.glUseProgram(mProgram); int mMatrixHandler= GLES20.glGetUniformLocation(mProgram,\"vMatrix\"); GLES20.glUniformMatrix4fv(mMatrixHandler,1,false,mMVPMatrix,0); // 坐标 int mPositionHandle = GLES20.glGetAttribLocation(mProgram, \"vPosition\"); GLES20.glEnableVertexAttribArray(mPositionHandle); GLES20.glVertexAttribPointer(mPositionHandle, 3, GLES20.GL_FLOAT, false, 3*4, vertexBuffer); // 颜色 int mColorHandle = GLES20.glGetAttribLocation(mProgram, \"aColor\"); GLES20.glEnableVertexAttribArray(mColorHandle); GLES20.glVertexAttribPointer(mColorHandle,4, GLES20.GL_FLOAT,false, 0,colorBuffer); // 绘制 GLES20.glDrawArrays(GLES20.GL_TRIANGLES, 0, 3); GLES20.glDisableVertexAttribArray(mPositionHandle); } private int loadShader(int type, String shaderCode){ int shader = GLES20.glCreateShader(type); GLES20.glShaderSource(shader, shaderCode); GLES20.glCompileShader(shader); return shader; } } /** * 从 assets 目录中加载 文件 转为 String * @param fname 基于assets的绝对路径 * @param context context * @return String */ public static String loadFromAssetsFile(String fname, Context context){ StringBuilder result=new StringBuilder(); try{ InputStream is=context.getResources().getAssets().open(fname); int ch; byte[] buffer=new byte[1024]; while (-1!=(ch=is.read(buffer))){ result.append(new String(buffer,0,ch)); } }catch (Exception e){ return null; } return result.toString().replaceAll(\"\\\\r\\\\n\",\"\\n\"); } // fragment.sh precision mediump float; varying vec4 vColor; void main() { gl_FragColor = vColor; } // vertex.sh attribute vec4 vPosition; uniform mat4 vMatrix; varying vec4 vColor; attribute vec4 aColor; void main() { gl_Position = vMatrix * vPosition; vColor= aColor; } 正方形 可以看做由两个三角形组成。 public class MyRenderer implements GLSurfaceView.Renderer { private Context context ; private float[] mViewMatrix=new float[16]; private float[] mProjectMatrix=new float[16]; private float[] mMVPMatrix=new float[16]; private int mProgram; /**顶点坐标数据*/ private FloatBuffer vertexBuffer; /**顶点索引数据*/ private ShortBuffer indexBuffer; /**顶点坐标*/ private float triangleCoords[] = { -0.5f, 0.5f, 0.0f, -0.5f, -0.5f, 0.0f, 0.5f, -0.5f, 0.0f, 0.5f, 0.5f, 0.0f }; /**索引法*/ private short index[]={ 0,1,2,0,2,3 }; float color[] = { 0.0f, 1.0f, 0.0f, 1.0f , 1.0f, 1.0f, 0.0f, 1.0f, 0.0f, 0.0f, 1.0f, 1.0f }; public MyRenderer( Context context){ this.context = context; init(); } private void init() { ByteBuffer bb = ByteBuffer.allocateDirect( triangleCoords.length * 4); bb.order(ByteOrder.nativeOrder()); vertexBuffer = bb.asFloatBuffer(); vertexBuffer.put(triangleCoords); vertexBuffer.position(0); ByteBuffer dd = ByteBuffer.allocateDirect( color.length * 4); dd.order(ByteOrder.nativeOrder()); indexBuffer=dd.asShortBuffer(); indexBuffer.put(index); indexBuffer.position(0); } @Override public void onSurfaceCreated(GL10 gl, EGLConfig config) { String vertexShaderCode = MyAssetsTool.loadFromAssetsFile(\"vertex.sh\" ,context); String fragmentShaderCode = MyAssetsTool.loadFromAssetsFile(\"fragment.sh\" ,context); int vertexShader = loadShader(GLES20.GL_VERTEX_SHADER, vertexShaderCode); int fragmentShader = loadShader(GLES20.GL_FRAGMENT_SHADER, fragmentShaderCode); mProgram = GLES20.glCreateProgram(); GLES20.glAttachShader(mProgram, vertexShader); GLES20.glAttachShader(mProgram, fragmentShader); GLES20.glLinkProgram(mProgram); } @Override public void onSurfaceChanged(GL10 gl, int width, int height) { //计算宽高比 float ratio=(float)width/height; Matrix.frustumM(mProjectMatrix, 0, -ratio, ratio, -1, 1, 3, 7); Matrix.setLookAtM(mViewMatrix, 0, 0, 0, 7.0f, 0f, 0f, 0f, 0f, 1.0f, 0.0f); Matrix.multiplyMM(mMVPMatrix,0,mProjectMatrix,0,mViewMatrix,0); } @Override public void onDrawFrame(GL10 gl) { GLES20.glClear(GLES20.GL_COLOR_BUFFER_BIT | GLES20.GL_DEPTH_BUFFER_BIT); GLES20.glUseProgram(mProgram); int mMatrixHandler= GLES20.glGetUniformLocation(mProgram,\"vMatrix\"); GLES20.glUniformMatrix4fv(mMatrixHandler,1,false,mMVPMatrix,0); int mPositionHandle = GLES20.glGetAttribLocation(mProgram, \"vPosition\"); GLES20.glEnableVertexAttribArray(mPositionHandle); GLES20.glVertexAttribPointer(mPositionHandle, 3, GLES20.GL_FLOAT, false, 3*4, vertexBuffer); int mColorHandle = GLES20.glGetUniformLocation(mProgram, \"vColor\"); GLES20.glUniform4fv(mColorHandle, 1, color, 0); GLES20.glDrawElements(GLES20.GL_TRIANGLES,index.length, GLES20.GL_UNSIGNED_SHORT,indexBuffer); GLES20.glDisableVertexAttribArray(mPositionHandle); } private int loadShader(int type, String shaderCode){ int shader = GLES20.glCreateShader(type); GLES20.glShaderSource(shader, shaderCode); GLES20.glCompileShader(shader); return shader; } } attribute vec4 vPosition; uniform mat4 vMatrix; void main() { gl_Position = vMatrix * vPosition; } precision mediump float; uniform vec4 vColor; void main() { //片元颜色 gl_FragColor = vColor; } 圆 可以把圆形看成一个正多边形，边越多，圆越平滑。 A点的横坐标为： r x cos θ A点的纵坐标为： r x sin θ //设置圆心坐标 data.add(0.0f); data.add(0.0f); data.add(0f); float angDegSpan=360f/count; for(float i=0;i public class MyRenderer implements GLSurfaceView.Renderer { private Context context; private FloatBuffer vertexData; /**圆的半径*/ private float r = 0.5f; /**将圆分成n份*/ private int count = 100; private int program; private int uColorLocation; private int aPositionLocation; private final float[] projectionMatrix = new float[16]; private int uMatrixLocation; public MyRenderer(Context context){ this.context = context; init(); } private void init(){ ArrayList data=new ArrayList<>(); //设置圆心坐标 data.add(0.0f); data.add(0.0f); data.add(0f); float angDegSpan=360f/count; for(float i=0;i height ? (float) width / (float) height : (float) height / (float) width; if(width > height){ Matrix.orthoM(projectionMatrix, 0, -aspectRatio, aspectRatio, -1f, 1f, -1f, 1f); }else{ Matrix.orthoM(projectionMatrix, 0, -1f, 1f, -aspectRatio, aspectRatio, -1f, 1f); } } @Override public void onDrawFrame(GL10 gl) { GLES20.glClearColor(0,0,0,0); GLES20.glUniform4f(uColorLocation, 0.0f, 0.0f, 1.0f, 1.0f); GLES20.glUniformMatrix4fv(uMatrixLocation, 1, false, projectionMatrix,0); GLES20.glDrawArrays(GLES20.GL_TRIANGLE_FAN, 0, count +2); } private int loadShader(int type, String shaderCode){ int shader = GLES20.glCreateShader(type); GLES20.glShaderSource(shader, shaderCode); GLES20.glCompileShader(shader); return shader; } } precision mediump float; uniform vec4 vColor; void main() { gl_FragColor = vColor; } uniform mat4 u_Matrix; attribute vec4 a_Position; void main() { gl_Position = u_Matrix * a_Position; } openSLES OpenSL ES (Open Sound Library for Embedded Systems) C 语言接口，兼容 C++ 。 是一个嵌入式、跨平台、免费的、音频处理库。 android NDK 已经内嵌， 位于类似 xxx\\ndk-bundle\\platforms\\android-9\\arch-x86\\usr\\lib Android 2.3 (API 9) 开始支持 OpenSL ES 标准， Android实现的 OpenSL ES 只是 OpenSL 1.0.1 的子集，并且进行了扩展。 OPenSL ES 常用功能 1、支持 PCM 数据的采集 支持的配置：16bit 位宽，16000 Hz采样率，单通道。（其他的配置不能保证兼容所有平台） 2、支持 PCM 数据的播放 支持的配置：8bit/16bit 位宽，单通道/双通道，小端模式， 采样率（8000, 11025, 12000, 16000, 22050, 24000, 32000, 44100, 48000 Hz） 3、支持播放的音频数据来源： res 文件夹下的音频、 assets 文件夹下的音频、 sdcard 目录下的音频、 在线网络音频、 代码中定义的音频二进制数据等 OPenSL ES 的缺点 1、不支持版本低于 Android 2.3 (API 9) 的设备 2、没有全部实现 OpenSL ES 定义的特性和功能 3、不支持 MIDI 4、不支持直接播放 DRM 或者 加密的内容 5、不支持音频数据的编解码 OPenSL ES 状态机制 1、任何一个 OpenSL ES 的对象，创建成功后，都进入 SL_OBJECT_STATE_UNREALIZED 状态， 这种状态下，系统不会为它分配任何资源，直到调用 Realize 函数为止。 2、Realize 后的对象，就会进入 SL_OBJECT_STATE_REALIZED 状态， 这是一种“可用”的状态，只有在这种状态下，对象的各个功能和资源才能正常地访问。 3、当一些系统事件发生后，比如出现错误或者 Audio 设备被其他应用抢占， OpenSL ES 对象会进入 SL_OBJECT_STATE_SUSPENDED 状态， 如果希望恢复正常使用，需要调用 Resume 函数。 4、当调用对象的 Destroy 函数后，则会释放资源， 并回到 SL_OBJECT_STATE_UNREALIZED 状态。 OPenSL ES 重要概念 ： Objects 和 Interfaces 1、每个 Object 可能会存在一个或者多个 Interface， 官方为每一种 Object 都定义了一系列的 Interface 2、每个 Object 对象都提供了一些最基础的操作 比如：Realize 、Destroy 等等， 但是想使用该对象支持的功能函数，则必须通过其 GetInterface 函数拿到 Interface 接口， 然后通过 Interface 来访问功能函数 。 3、心中保持一个概念，就是在 OpenSL ES 中，一切 API 的访问和控制都是通过 Interface 来完成的。 以引擎接口为例： ①、先通过 SLObjectItf 获得 引擎对象 ②、再通过 引擎对象 获得 这个对象对应的引擎接口。 ③、最后通过这个引擎接口实现具体功能。 常用的接口 在OpenSL ES中所有的操作都是通过接口来完成，和java的接口类似，接口提供底层的方法调用。 SLObjectItf ：对象接口 SLEngineItf ：引擎接口 SLPlayItf：播放接口 SLBufferQueueItf :缓冲队列接口 SLVolumeItf : 声量接口 引擎接口 SLEngineItf // 引擎对象 SLObjectItf engineObject = NULL; // 创建对象 SLresult result = slCreateEngine(&engineObject, 0, 0, 0, 0, 0); //初始化对象 SLresult result2 = (*engineObject)->Realize(engineObject, SL_BOOLEAN_FALSE); // 销毁对象 (*engineObject)->Destroy(engineObject); // 引擎接口 SLEngineItf engineEngine = NULL; // 获取对象的功能接口 SLresult result3 = (*engineObject)->GetInterface(engineObject, SL_IID_ENGINE, &engineEngine); // 调用接口实现具体功能 ，例如 创建音频播放器对象 SLresult result4 = (*engineEngine)->CreateAudioPlayer(engineEngine, &pcmPlayerObject, &slDataSource, &audioSnk, 3, ids, req); 混音器 //混音器对象 SLObjectItf outputMixObject = NULL; //创建混音器对象 SLresult result = (*engineEngine)->CreateOutputMix(engineEngine, &outputMixObject, 1, mids, mreq); //实现混音器对象 result = (*outputMixObject)->Realize(outputMixObject, SL_BOOLEAN_FALSE); // 跟进对象获取对应的功能接口 result = (*outputMixObject)->GetInterface(outputMixObject, SL_IID_ENVIRONMENTALREVERB, &outputMixEnvironmentalReverb); 常用函数 SetPlayState () // 设置播放器状态 slCreateEngine () // 创建对象 Realize () // 分配资源 GetInterface () // 通过对象，拿到接口 CreateOutputMix () // 创建混音器 SetEnvironmentalReverbProperties () // CreateAudioPlayer() // 创建播放器 常用类和常量 SLEnvironmentalReverbItf // 一个结构体 ， SLEnvironmentalReverbSettings // 一个结构体 ， SLAndroidSimpleBufferQueueItf // 队列 SLInterfaceID // SLDataLocator_OutputMix // SLDataSink // SLDataSource // nb_samples // 每个轨道的样本数 channels //音频通道数 channel_layout // 音频通道格式类型 ,如 单通道 双通道 sample_rate // 采样率，Audio only. The number of bytes per coded audio frame AV_SAMPLE_FMT_S16 // 一种音频格式 AV_CH_LAYOUT_STEREO // 双声道 AV_CH_LAYOUT_SURROUND // 三声道 SL_DATALOCATOR_OUTPUTMIX // 0x00000004 SLDataLocator_AndroidSimpleBufferQueue // SL_DATALOCATOR_ANDROIDSIMPLEBUFFERQUEUE // SLDataFormat_PCM // SL_DATAFORMAT_PCM // pcm格式的数据 SL_PCMSAMPLEFORMAT_FIXED_16 // 位数16位 SL_SPEAKER_FRONT_LEFT // 立体声,前左 SL_SPEAKER_FRONT_RIGHT //立体声 ,前右 SL_BYTEORDER_LITTLEENDIAN // SL_PLAYSTATE_PAUSED // glsl的暂停状态常量 SL_PLAYSTATE_STOPPED // SL_PLAYSTATE_PLAYING // SL_IID_BUFFERQUEUE // SL_IID_PLAYBACKRATE // SL_RESULT_SUCCESS // 0 SL_BOOLEAN_FALSE //false SL_BOOLEAN_TRUE // SL_IID_ENGINE // 一个常量，获取接口用到 SL_IID_ENVIRONMENTALREVERB // SL_IID_PLAY // SL_SAMPLINGRATE_8 // opensl中的采样率常量 SL_SAMPLINGRATE_11_025 SL_SAMPLINGRATE_12 SL_SAMPLINGRATE_16 SL_SAMPLINGRATE_22_05 SL_SAMPLINGRATE_24 SL_SAMPLINGRATE_32 SL_SAMPLINGRATE_44_1 SL_SAMPLINGRATE_48 SL_SAMPLINGRATE_64 SL_SAMPLINGRATE_88_2 SL_SAMPLINGRATE_96 SL_SAMPLINGRATE_192 播放器 SLObjectItf pcmPlayerObject = NULL; //创建对象 result = (*engineEngine)->CreateAudioPlayer(engineEngine, &pcmPlayerObject, &slDataSource, &audioSnk, 3, ids, req); //实现对象 (*pcmPlayerObject)->Realize(pcmPlayerObject, SL_BOOLEAN_FALSE); // 跟进对象获取 播放功能接口 SLPlayItf pcmPlayerPlay = NULL; (*pcmPlayerObject)->GetInterface(pcmPlayerObject, SL_IID_PLAY, &pcmPlayerPlay); // 使用功能接口 (*pcmPlayerPlay)->SetPlayState(pcmPlayerPlay, SL_PLAYSTATE_PAUSED); //获得 音量接口 SLVolumeItf pcmPlayerVolume = NULL; (*pcmPlayerObject)->GetInterface(pcmPlayerObject, SL_IID_VOLUME, &pcmPlayerVolume); 使用 OPenSL ES 流程 1、创建接口对象 2、设置混音器 3、创建播放器（录音器） 4、设置缓冲队列和回调函数 5、设置播放状态 6、启动回调函数 Android 配置 opengSL ES 1、cmakelist中引入 OpenSLES 2、引入头文件 extern \"C\" { include include }; 声道切换 /* chan ： 0 左声道 ，1 右声道 mute : true 开启声道 立体声：左声道右声道都关闭 */ (*pcmMutePlay)->SetChannelMute(pcmMutePlay, 1, SL_BOOLEAN_FALSE); (*pcmMutePlay)->SetChannelMute(pcmMutePlay, 0, SL_BOOLEAN_TRUE); 暂停、播放 (*pcmPlayerPlay)->SetPlayState(pcmPlayerPlay, SL_PLAYSTATE_PAUSED); (*pcmPlayerPlay)->SetPlayState(pcmPlayerPlay, SL_PLAYSTATE_PLAYING); seek 修改播放进度 对直播无效 int64_t rel = secds * AV_TIME_BASE; avformat_seek_file(avFormatContext, -1, INT64_MIN, rel, INT64_MAX, 0); 修改音量 SLmillibel level =50; (*pcmVolumePlay)->SetVolumeLevel(pcmVolumePlay, level); 边播边录 利用 Android（api>=16）MediaCodec 将原始的PCM 数据 编码成 AAC 格式的数据 直接保存即可。 求PCM的分贝值 Pref：就是声音总的振幅最大值； Prms：就是当前声音的振幅值； Lp：就是我们需要的声音分贝值了。 根据公式我们可以得知把一段时间的振幅相加然后去平均值，就可以得到当前 时间段的振幅值，就可以求出分贝值了 SoundTouch OpenSL ES可以实现变速播放，但是再改变速度的同时也改变了音调 。 SoundTouch http://www.surina.net/soundtouch/ 一个开源的声音处理库，可以直接对PCM数据进行处理， 可单独改变声音的音调和播放速度。 移植 SoundTouch 1、下载 soundtouch-soundtouch-2.0.0.zip 2、提取 头文件 和源码 放到 android工程中的cpp文件夹中 3、配置cmakelist 具体的文件和配置可以参考我的工程wkplayer 变速、变调 soundTouch->setPitch(pitch);//SoundTouch //变速 soundTouch->setTempo(speed);// 变调 ( no Copyright，enjoy youself ! ) all right reserved，powered by GitbookThe file was updated at : 2021-01-21 15:55:53 "},"chinese/native/相关代码.html":{"url":"chinese/native/相关代码.html","title":"相关代码","keywords":"","body":"音视频相关代码 SurfaceView 绘制图片 SurfaceView surfaceView = findViewById(R.id.surface); surfaceView.getHolder().addCallback(new SurfaceHolder.Callback() { @Override public void surfaceCreated(SurfaceHolder surfaceHolder) { Canvas canvas = surfaceHolder.lockCanvas(); canvas.drawBitmap(bitmap, 0, 0, paint); surfaceHolder.unlockCanvasAndPost(canvas); } @Override public void surfaceChanged(SurfaceHolder surfaceHolder, int i, int i1, int i2) { } @Override public void surfaceDestroyed(SurfaceHolder surfaceHolder) { } }); AudioRecord 采集并保存PCM /** * 采样率，现在能够保证在所有设备上使用的采样率是44100Hz, * 但是其他的采样率（22050, 16000, 11025）在一些设备上也可以使用。 */ public static final int SAMPLE_RATE_INHZ = 44100; /** * 声道数。CHANNEL_IN_MONO and CHANNEL_IN_STEREO. * 其中CHANNEL_IN_MONO是可以保证在所有设备能够使用的。 */ public static final int CHANNEL_CONFIG = AudioFormat.CHANNEL_IN_MONO; /** * 返回的音频数据的格式。 ENCODING_PCM_8BIT, ENCODING_PCM_16BIT, and ENCODING_PCM_FLOAT. */ public static final int AUDIO_FORMAT = AudioFormat.ENCODING_PCM_16BIT; private AudioRecord audioRecord = null; private boolean isRecording = false; public void onstart(View view) { // 一次读取多少内容 final int minBufferSize = AudioRecord.getMinBufferSize(SAMPLE_RATE_INHZ, CHANNEL_CONFIG, AUDIO_FORMAT); audioRecord = new AudioRecord(MediaRecorder.AudioSource.MIC, SAMPLE_RATE_INHZ, CHANNEL_CONFIG, AUDIO_FORMAT, minBufferSize); final byte data[] = new byte[minBufferSize]; audioRecord.startRecording(); isRecording = true; new Thread(new Runnable() { @SuppressWarnings(\"AlibabaAvoidManuallyCreateThread\") @Override public void run() { FileOutputStream os = null; try { File file = new File(Environment.getExternalStorageDirectory(), \"testttttttt.pcm\"); os = new FileOutputStream(file); } catch (FileNotFoundException e) { e.printStackTrace(); } if (null != os) { while (isRecording) { Log.i(\"aivin\" ,\"正在录制\") ; int read = audioRecord.read(data, 0, minBufferSize); // 如果读取音频数据没有出现错误，就将数据写入到文件 if (AudioRecord.ERROR_INVALID_OPERATION != read) { try { os.write(data); } catch (IOException e) { e.printStackTrace(); } } } try { os.close(); } catch (IOException e) { e.printStackTrace(); } } } }).start(); } AudioTrack 播放PCM AudioTrack有两种数据加载模式 MODE_STREAM ：通过write一次次把音频数据写到AudioTrack中。每次都需要把数据从用户提供的Buffer中拷贝到AudioTrack内部的Buffer中，这在一定程度上会使引入延时。适合大文件。 MODE_STATIC ：把所有数据通过一次write调用传递到AudioTrack中的内部缓冲区，后续就不必再传递数据了。 这种模式适用于像铃声这种内存占用量较小，延时要求较高的文件。 /** * 采样率，现在能够保证在所有设备上使用的采样率是44100Hz, * 但是其他的采样率（22050, 16000, 11025）在一些设备上也可以使用。 */ public static final int SAMPLE_RATE_INHZ = 44100; /** * 返回的音频数据的格式。 ENCODING_PCM_8BIT, ENCODING_PCM_16BIT, and ENCODING_PCM_FLOAT. */ public static final int AUDIO_FORMAT = AudioFormat.ENCODING_PCM_16BIT; /** * 播放，使用stream模式 */ public void onplay(View view) { final int minBufferSize = AudioTrack.getMinBufferSize(SAMPLE_RATE_INHZ, AudioFormat.CHANNEL_OUT_MONO, AUDIO_FORMAT); final AudioTrack audioTrack = new AudioTrack( new AudioAttributes.Builder() .setUsage(AudioAttributes.USAGE_MEDIA) .setContentType(AudioAttributes.CONTENT_TYPE_MUSIC) .build(), new AudioFormat.Builder().setSampleRate(SAMPLE_RATE_INHZ) .setEncoding(AUDIO_FORMAT) .setChannelMask(AudioFormat.CHANNEL_OUT_MONO) .build(), minBufferSize, AudioTrack.MODE_STREAM, AudioManager.AUDIO_SESSION_ID_GENERATE); audioTrack.play(); File file = new File(Environment.getExternalStorageDirectory(), \"testttttttt.pcm\"); try { final FileInputStream fileInputStream = new FileInputStream(file); new Thread(new Runnable() { @Override public void run() { try { byte[] tempBuffer = new byte[minBufferSize]; while (fileInputStream.available() > 0) { int readCount = fileInputStream.read(tempBuffer); if (readCount == AudioTrack.ERROR_INVALID_OPERATION || readCount == AudioTrack.ERROR_BAD_VALUE) { continue; } if (readCount != 0 && readCount != -1) { audioTrack.write(tempBuffer, 0, readCount); } } } catch (IOException e) { e.printStackTrace(); } } }).start(); } catch (IOException e) { e.printStackTrace(); } } pcm转 wav 在pcm数据前加上wav文件头即可 https://www.jianshu.com/p/f7863638acbe wav 转 pcm 去掉文件头即可 https://www.jianshu.com/p/3f80fb907bd5 Camera2 API 预览并获得YUV数据 public class GetCameraActivity extends Activity { private Context context; private TextureView mPreviewView; private Handler mHandler; private Size mPreviewSize; private static final SparseIntArray ORIENTATIONS = new SparseIntArray(); public ImageReader mImageReader; private CaptureRequest.Builder mCaptureRequest; /** * 0-->后置相机 1---> 前置相机 */ private String mCameraId = \"1\"; @Override protected void onCreate( ... ) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_getcamera); context = this; ORIENTATIONS.append(Surface.ROTATION_0, 90); ORIENTATIONS.append(Surface.ROTATION_90, 0); ORIENTATIONS.append(Surface.ROTATION_180, 270); ORIENTATIONS.append(Surface.ROTATION_270, 180); mPreviewView = findViewById(R.id.textureview); mPreviewView.setSurfaceTextureListener(surfaceTextureListener); HandlerThread mThreadHandler = new HandlerThread(\"CAMERA2\"); mThreadHandler.start(); mHandler = new Handler(mThreadHandler.getLooper()); } private void startPreview(CameraDevice camera) throws CameraAccessException { try { // 请求预览 mCaptureRequest = camera.createCaptureRequest(CameraDevice.TEMPLATE_PREVIEW); } catch (CameraAccessException e) { e.printStackTrace(); } // 自动对焦 mCaptureRequest.set(CaptureRequest.CONTROL_AF_MODE, CaptureRequest.CONTROL_AF_MODE_CONTINUOUS_PICTURE); //设置方向 CameraManager manager = (CameraManager) getSystemService(Context.CAMERA_SERVICE); CameraCharacteristics characteristics = manager.getCameraCharacteristics(mCameraId); //摄像头传感器方向 int mSensorOrientation = characteristics.get(CameraCharacteristics.SENSOR_ORIENTATION); // 获取设备方向 int rotation = getWindowManager().getDefaultDisplay().getRotation(); // 根据设备方向计算设置摄像头的方向 int value = (ORIENTATIONS.get(rotation) + mSensorOrientation + 270) % 360; mCaptureRequest.set(CaptureRequest.JPEG_ORIENTATION, value); // yuv数据回调 mImageReader = ImageReader.newInstance(mPreviewSize.getWidth(), mPreviewSize.getHeight(), ImageFormat.YUV_420_888, 2); mImageReader.setOnImageAvailableListener(mOnImageAvailableListener, mHandler); // 使预览和yuv回调生效 SurfaceTexture texture = mPreviewView.getSurfaceTexture(); texture.setDefaultBufferSize(mPreviewSize.getWidth(), mPreviewSize.getHeight()); Surface surface = new Surface(texture); mCaptureRequest.addTarget(surface); mCaptureRequest.addTarget(mImageReader.getSurface()); // 创建相机捕获会话，第一个参数是捕获数据的输出Surface列表， // 第二个参数是CameraCaptureSession的状态回调接口，当它创建好后会回调 onConfigured 方法 // 第三个参数用来确定Callback在哪个线程执行，为null的话就在当前线程执行 camera.createCaptureSession(Arrays.asList(surface, mImageReader.getSurface()), mSessionStateCallback, mHandler); } /** * textureView 状态 回调 */ TextureView.SurfaceTextureListener surfaceTextureListener = new TextureView.SurfaceTextureListener() { @Override public void onSurfaceTextureAvailable(SurfaceTexture surface, int width, int height) { try { CameraManager cameraManager = (CameraManager) context.getSystemService(Context.CAMERA_SERVICE); //获得指定摄像头的特征，支持的参数 CameraCharacteristics characteristics = cameraManager.getCameraCharacteristics(mCameraId); StreamConfigurationMap streamConfigurationMap = characteristics.get(CameraCharacteristics.SCALER_STREAM_CONFIGURATION_MAP); //摄像头支持的预览Size数组 List list = Arrays.asList(streamConfigurationMap.getOutputSizes(ImageFormat.YUV_420_888)); Size size4 = new Size(640, 480); if (!list.contains(size4)) { // 根据TextureView的尺寸设置预览尺寸 mPreviewSize = streamConfigurationMap.getOutputSizes(SurfaceTexture.class)[0]; } else { mPreviewSize = size4; } for (String cameraId : cameraManager.getCameraIdList()) { CameraCharacteristics characteristic = cameraManager.getCameraCharacteristics(cameraId); Integer facing = characteristic.get(CameraCharacteristics.LENS_FACING); if (facing != null && facing == CameraCharacteristics.LENS_FACING_BACK) { mCameraId = cameraId; break; } } //打开相机 if (ActivityCompat.checkSelfPermission(context, Manifest.permission.CAMERA) != PackageManager.PERMISSION_GRANTED) { return; } cameraManager.openCamera(mCameraId, mCameraDeviceStateCallback, mHandler); } catch (CameraAccessException e) { e.printStackTrace(); } } @Override public void onSurfaceTextureSizeChanged(SurfaceTexture surface, int width, int height) { } @Override public boolean onSurfaceTextureDestroyed(SurfaceTexture surface) { return false; } @Override public void onSurfaceTextureUpdated(SurfaceTexture surface) { } }; /** * 相机打开状态回调 */ private CameraDevice.StateCallback mCameraDeviceStateCallback = new CameraDevice.StateCallback() { @Override public void onOpened(CameraDevice camera) { try { startPreview(camera); } catch (CameraAccessException e) { e.printStackTrace(); } } @Override public void onDisconnected(CameraDevice camera) { camera.close(); } @Override public void onError(CameraDevice camera, int error) { camera.close(); } }; /** * 数据回调接口 */ private ImageReader.OnImageAvailableListener mOnImageAvailableListener = new ImageReader.OnImageAvailableListener() { @Override public void onImageAvailable(ImageReader reader) { Image image = reader.acquireNextImage(); //YUV_420_888格式 ---->获取到的三个通道 getPlanes 分别对应YUV Image.Plane[] planes = image.getPlanes(); ByteBuffer byteBufferY = planes[0].getBuffer() ; byte[] dataY = new byte[ byteBufferY.remaining()]; byteBufferY.get(dataY) ; Log.i(\"aivin\" ,\"收到数据回调 Y分量： \" + dataY.length); image.close(); } }; /** * 相机会话状态接口 */ private CameraCaptureSession.StateCallback mSessionStateCallback = new CameraCaptureSession.StateCallback() { @Override public void onConfigured(CameraCaptureSession session) { try { //设置反复捕获数据的请求，这样预览界面就会一直有数据显示 session.setRepeatingRequest(mCaptureRequest.build(), null, mHandler); } catch (CameraAccessException e) { e.printStackTrace(); } } @Override public void onConfigureFailed(CameraCaptureSession session) { } }; } MediaMuxer 分离 音频、视频 private void extractorVideo() throws IOException { String inputFilePath = Environment.getExternalStorageDirectory().getPath()+\"/input.mp4\" ; String outputVideoFilePath = Environment.getExternalStorageDirectory().getPath()+\"/output.mp4\" ; MediaMuxer mMediaMuxer =null; MediaExtractor mMediaExtractor = new MediaExtractor(); mMediaExtractor.setDataSource(inputFilePath); int mVideoTrackIndex = -1; int framerate = 0; for (int i = 0; i 0) { info.offset = 0; info.size = dataSize; info.flags = MediaCodec.BUFFER_FLAG_SYNC_FRAME; info.presentationTimeUs += 1000 * 1000 / framerate; mMediaMuxer.writeSampleData(mVideoTrackIndex, buffer, info); // 继续读取下一帧数据 mMediaExtractor.advance(); } mMediaExtractor.release(); mMediaMuxer.stop(); mMediaMuxer.release(); } private void extractorAudio() throws IOException { String inputFilePath = Environment.getExternalStorageDirectory().getPath()+\"/input.mp4\" ; String outputVideoFilePath = Environment.getExternalStorageDirectory().getPath()+\"/output.mp3\" ; MediaMuxer mMediaMuxer =null; MediaExtractor mMediaExtractor = new MediaExtractor(); mMediaExtractor.setDataSource(inputFilePath); int mVideoTrackIndex = -1; int framerate = 0; for (int i = 0; i 0) { info.offset = 0; info.size = dataSize; info.flags = MediaCodec.BUFFER_FLAG_SYNC_FRAME; info.presentationTimeUs += 1000 * 1000 / framerate; mMediaMuxer.writeSampleData(mVideoTrackIndex, buffer, info); // 继续读取下一帧数据 mMediaExtractor.advance(); } mMediaExtractor.release(); mMediaMuxer.stop(); mMediaMuxer.release(); } MediaMuxer 将音频、视频混合 private void mixVedioAndAudio() { String inputVedioPath = Environment.getExternalStorageDirectory().getPath()+\"/input.mp4\" ; String inputAudioPath = Environment.getExternalStorageDirectory().getPath()+\"/input.mp3\" ; String outputVideoFilePath = Environment.getExternalStorageDirectory().getPath()+\"/output.mp4\" ; MediaExtractor videoExtractor ; MediaExtractor audioExtractor ; MediaMuxer mixMediaMuxer ; int framerate = 0; try { videoExtractor = new MediaExtractor(); videoExtractor.setDataSource(inputVedioPath); int videoIndex = -1; MediaFormat videoTrackFormat = null; int trackCount = videoExtractor.getTrackCount(); for (int i = 0; i MediaCodec 常用 API return the output image, or null if ... or if the codec was configured with an output surface. mMeidaCodec.getOutputImage(outputBufferIndex) ; // 注意： 如果配置了 surfaceview， 数据就被消耗掉了 ，就拿不到解码后的数据了 。 mMeidaCodec.configure(mediaFormat, mSurfaceView.getHolder().getSurface(), null, 0); MediaCodec + camera + SurfaceView 预览并保存 H264 文件 java实现 https://gitee.com/hnyer/codeSnippet/tree/master/onlyh264 camera + SurfaceView + AudioRecord+ MediaCodec+ MediaMuxer 预览并生成 mp4文件 java实现 https://gitee.com/hnyer/codeSnippet/tree/master/muxer 常用ffmpeg代码片段 导入头文件 extern \"C\" { #include } 遍历 AVCodec av_register_all(); AVCodec * codec= av_codec_next(NULL) ; while(codec !=NULL) { LOGI(\"信息 codec->type =%s\" , codec->name) ; // 获取下一个 codec = codec->next ; } 配置信息 const char* configuration = avcodec_configuration() ; LOGI(\"配置信息configuration =%s\" , configuration) ; 遍历AVInputFormat av_register_all(); char * info = (char * )malloc(40000); memset(info,0,40000); AVInputFormat *if_temp = av_iformat_next(NULL ); while(if_temp!=NULL){ sprintf(info, \"===%s \", if_temp->name ); LOGI(\"信息 AVInputFormat =%s\" , info ) ; if_temp=if_temp->next ; } 遍历AVOutputFormat av_register_all(); char *info=(char * )malloc(40000); memset(info,0,40000); AVOutputFormat *of_temp = av_oformat_next(NULL); while(of_temp!=NULL){ sprintf(info, \"===%s \", of_temp->name); LOGI(\"信息 AVOutputFormat =%s\" , info) ; of_temp=of_temp->next; } 遍历 AVFilter avfilter_register_all(); char *info=(char * )malloc(40000); memset(info,0,40000); AVFilter * f_temp = (AVFilter * )avfilter_next(NULL); while (f_temp != NULL){ sprintf(info, \"%s\", f_temp->name); LOGI(\"信息 AVFilter =%s\" , info) ; f_temp=f_temp->next; } mp3 转 aac // 转换命令 ffmpeg -i xxx.mp3 xxx.aac JNIEXPORT jint xxxxxxxxxxxMp3ToAAC (JNIEnv * env, jclass obj, jobjectArray commands) { int argc = ( * env)->GetArrayLength(env, commands); char **argv = (char * * )malloc(argc * sizeof(char* )); int i; int result; for (i = 0; i GetObjectArrayElement(env, commands, i); char* temp = (char* ) (* env)->GetStringUTFChars(env, jstr, 0); argv[i] = malloc(1024); strcpy(argv[i], temp); (*env)->ReleaseStringUTFChars(env, jstr, temp); } //执行ffmpeg命令 , 将源码中的 main() 改成run() result = run(argc, argv); //释放内存 for (i = 0; i 音频解码 + 播放 native ffmpeg 实现解码 ， java层的 AudioTrack 实现播放 #define MAX_AUDIO_FRAME_SIZE 48000 * 4 JNIEXPORT void JNICALL Java_xxxx_play (JNIEnv *env, jobject jthiz, jstring input_jstr){ const char* input_cstr = (*env)->GetStringUTFChars(env,input_jstr,NULL); //注册组件 av_register_all(); AVFormatContext *pFormatCtx = avformat_alloc_context(); //打开音频文件 if(avformat_open_input(&pFormatCtx,input_cstr,NULL,NULL) != 0) { return; } //获取输入文件信息 if(avformat_find_stream_info(pFormatCtx,NULL) nb_streams;i++) { if(pFormatCtx->streams[i]->codec->codec_type == AVMEDIA_TYPE_AUDIO) { audio_stream_idx = i; break; } } //获取音频解码器 AVCodecContext *codecCtx = pFormatCtx->streams[audio_stream_idx]->codec; AVCodec *codec = avcodec_find_decoder(codecCtx->codec_id); if(codec == NULL) { return; } //打开解码器 if(avcodec_open2(codecCtx,codec,NULL) sample_fmt; //输出采样格式16bit PCM enum AVSampleFormat out_sample_fmt = AV_SAMPLE_FMT_S16; //输入采样率 int in_sample_rate = codecCtx->sample_rate; //输出采样率 int out_sample_rate = in_sample_rate; //声道布局（2个声道，默认立体声stereo） uint64_t in_ch_layout = codecCtx->channel_layout; //输出的声道布局（立体声） uint64_t out_ch_layout = AV_CH_LAYOUT_STEREO; //输出的声道个数 int out_channel_nb = av_get_channel_layout_nb_channels(out_ch_layout); //音频重采样 SwrContext *swrCtx = swr_alloc(); swr_alloc_set_opts(swrCtx, out_ch_layout,out_sample_fmt,out_sample_rate, in_ch_layout,in_sample_fmt,in_sample_rate, 0, NULL); swr_init(swrCtx); // 获取调用这个c文件的java文件类 jclass player_class = (*env)->GetObjectClass(env,jthiz); if(!player_class){ return; } //找到 java代码中的 public AudioTrack createAudioTrack(int sampleRate, int channels) 方法 jmethodID audio_track_method = (*env)->GetMethodID(env,player_class,\"createAudioTrack\",\"(II)Landroid/media/AudioTrack;\"); if(!audio_track_method){ return; } // 使用java中对应的方法 jobject audio_track = (*env)->CallObjectMethod(env,jthiz,audio_track_method,out_sample_rate,out_channel_nb); //调用AudioTrack 的 play() 方法 jclass audio_track_class = (*env)->GetObjectClass(env,audio_track); jmethodID audio_track_play_mid = (*env)->GetMethodID(env,audio_track_class,\"play\",\"()V\"); (*env)->CallVoidMethod(env,audio_track,audio_track_play_mid); //转换格式后的数据 uint8_t *out_buffer = (uint8_t *)av_malloc(MAX_AUDIO_FRAME_SIZE); int got_frame = 0 ; //不断读取编码数据 while (av_read_frame(pFormatCtx, packet) >= 0) { if (packet->stream_index == audio_stream_idx) { //音频解码 int ret = avcodec_decode_audio4(codecCtx, frame, &got_frame, packet); if (ret 0) { //音频格式转换 swr_convert(swrCtx, &out_buffer, MAX_AUDIO_FRAME_SIZE, (const uint8_t **) frame->data, frame->nb_samples); int out_buffer_size = av_samples_get_buffer_size(NULL, out_channel_nb, frame->nb_samples, out_sample_fmt, 1); jbyteArray audio_sample_array = (*env)->NewByteArray(env, out_buffer_size); jbyte *sample_byte_array = (*env)->GetByteArrayElements(env, audio_sample_array, NULL); //拷贝缓冲数据 memcpy(sample_byte_array, out_buffer, (size_t) out_buffer_size); //释放数组 (*env)->ReleaseByteArrayElements(env, audio_sample_array, sample_byte_array, 0); //调用AudioTrack 的 获取write(...)方法进行播放 jmethodID audio_track_write_mid = (*env)->GetMethodID(env, audio_track_class, \"write\", \"([BII)I\"); (*env)->CallIntMethod(env, audio_track, audio_track_write_mid, audio_sample_array, 0, out_buffer_size); //释放局部引用 (*env)->DeleteLocalRef(env, audio_sample_array); usleep(1000 * 16); } } av_free_packet(packet); } av_frame_free(&frame); av_free(out_buffer); swr_free(&swrCtx); avcodec_close(codecCtx); avformat_close_input(&pFormatCtx); (*env)->ReleaseStringUTFChars(env,input_jstr,input_cstr); } public AudioTrack createAudioTrack(int sampleRate, int channels){ int audioFormat = AudioFormat.ENCODING_PCM_16BIT; int channelConfig; if(channels == 1){ // 单声道 channelConfig = AudioFormat.CHANNEL_OUT_MONO; }else if(channels == 2){ // 输出声道为双声道立体声 channelConfig = AudioFormat.CHANNEL_OUT_STEREO; }else{ channelConfig = AudioFormat.CHANNEL_OUT_STEREO; } // sampleRate 采样率 int bufferSizeInBytes = AudioTrack.getMinBufferSize(sampleRate, channelConfig, audioFormat); return new AudioTrack(AudioManager.STREAM_MUSIC, sampleRate, channelConfig, audioFormat,bufferSizeInBytes, AudioTrack.MODE_STREAM); } native ffmpeg 实现解码 ， native 层的 opensl 实现播放 //OpenSLES - 对象接口- SLObjectItf engineObject = NULL; // OpenSLES - 引擎接口- SLEngineItf engineEngine; //输出混音器接口 SLObjectItf outputMixObject = NULL; // 混音器环境接口 SLEnvironmentalReverbItf outputMixEnvironmentalReverb = NULL; //缓冲播放器接口 SLObjectItf bqPlayerObject = NULL; // 播放接口 SLPlayItf bqPlayerPlay; SLAndroidSimpleBufferQueueItf bqPlayerBufferQueue; SLEffectSendItf bqPlayerEffectSend; SLVolumeItf bqPlayerVolume; //音效设置 const SLEnvironmentalReverbSettings reverbSettings = SL_I3DL2_ENVIRONMENT_PRESET_STONECORRIDOR; void *buffer; size_t bufferSize; uint8_t *outputBuffer; // 分配PCM数据缓存 size_t outputBufferSize; //FFmpeg相关 AVPacket packet; //音频流索引位置 int audioStream; AVFrame *aFrame; SwrContext *swr; AVFormatContext *aFormatCtx; AVCodecContext *aCodecCtx; int frame_count = 0; int createAudioPlayer(int *rate, int *channel, const char *file_name) ; int releaseAudioPlayer(); int getPCM(void **pcm, size_t *pcmSize) ; //播放回调方法 void bqPlayerCallback(SLAndroidSimpleBufferQueueItf bufferQueueItf, void *context) { bufferSize = 0; getPCM(&buffer, &bufferSize); //如果buffer不为空，入待播放队列 if (NULL != buffer && 0 != bufferSize) { SLresult result; result = (*bqPlayerBufferQueue)->Enqueue(bqPlayerBufferQueue, buffer, bufferSize); if(result Realize(engineObject, SL_BOOLEAN_FALSE); //获取引擎接口 result = (*engineObject)->GetInterface(engineObject, SL_IID_ENGINE, &engineEngine); //创建输出混音器 result = (*engineEngine)->CreateOutputMix(engineEngine, &outputMixObject, 0, 0, 0); //关联输出混音器 result = (*outputMixObject)->Realize(outputMixObject, SL_BOOLEAN_FALSE); //获取reverb接口 result = (*outputMixObject)->GetInterface(outputMixObject, SL_IID_ENVIRONMENTALREVERB, &outputMixEnvironmentalReverb); if (SL_RESULT_SUCCESS == result) { result = (*outputMixEnvironmentalReverb)->SetEnvironmentalReverbProperties( outputMixEnvironmentalReverb, &reverbSettings); } } void createBufferQueueAudioPlayer(int rate, int channel, int bitsPerSample) { SLresult result; //配置音频源 SLDataLocator_AndroidSimpleBufferQueue buffer_queue = {SL_DATALOCATOR_ANDROIDSIMPLEBUFFERQUEUE, 2}; SLDataFormat_PCM format_pcm; format_pcm.formatType = SL_DATAFORMAT_PCM; format_pcm.numChannels = (SLuint32) channel; format_pcm.bitsPerSample = (SLuint32) bitsPerSample; format_pcm.samplesPerSec = (SLuint32) (rate * 1000); format_pcm.containerSize = 16; if (channel == 2) { format_pcm.channelMask = SL_SPEAKER_FRONT_LEFT | SL_SPEAKER_FRONT_RIGHT; } else{ format_pcm.channelMask = SL_SPEAKER_FRONT_CENTER; } format_pcm.endianness = SL_BYTEORDER_LITTLEENDIAN; SLDataSource audioSrc = {&buffer_queue, &format_pcm}; //配置音频池 SLDataLocator_OutputMix loc_outmix = {SL_DATALOCATOR_OUTPUTMIX, outputMixObject}; SLDataSink audioSnk = {&loc_outmix, NULL}; //创建音频播放器 const SLInterfaceID ids[3] = {SL_IID_BUFFERQUEUE, SL_IID_EFFECTSEND, SL_IID_VOLUME}; const SLboolean req[3] = {SL_BOOLEAN_TRUE, SL_BOOLEAN_TRUE, SL_BOOLEAN_TRUE}; result = (*engineEngine)->CreateAudioPlayer(engineEngine, &bqPlayerObject, &audioSrc, &audioSnk, 3, ids, req); //关联播放器 result = (*bqPlayerObject)->Realize(bqPlayerObject, SL_BOOLEAN_FALSE); //获取播放接口 result = (*bqPlayerObject)->GetInterface(bqPlayerObject, SL_IID_PLAY, &bqPlayerPlay); //获取缓冲队列接口 result = (*bqPlayerObject)->GetInterface(bqPlayerObject, SL_IID_BUFFERQUEUE, &bqPlayerBufferQueue); //注册缓冲队列回调 result = (*bqPlayerBufferQueue)->RegisterCallback(bqPlayerBufferQueue, bqPlayerCallback, NULL); //获取音效接口 result = (*bqPlayerObject)->GetInterface(bqPlayerObject, SL_IID_EFFECTSEND, &bqPlayerEffectSend); //获取音量接口 result = (*bqPlayerObject)->GetInterface(bqPlayerObject, SL_IID_VOLUME, &bqPlayerVolume); //开始播放音乐 result = (*bqPlayerPlay)->SetPlayState(bqPlayerPlay, SL_PLAYSTATE_PLAYING); } int createAudioPlayer(int *rate, int *channel, const char *file_name) { av_register_all(); aFormatCtx = avformat_alloc_context(); if (avformat_open_input(&aFormatCtx, file_name, NULL, NULL) != 0) { return -1; } if (avformat_find_stream_info(aFormatCtx, NULL) nb_streams; i++) { if (aFormatCtx->streams[i]->codec->codec_type == AVMEDIA_TYPE_AUDIO && audioStream streams[audioStream]->codec; AVCodec *aCodec = avcodec_find_decoder(aCodecCtx->codec_id); if (aCodec==NULL) { return -1; } if (avcodec_open2(aCodecCtx, aCodec, NULL) channel_layout, 0); av_opt_set_int(swr, \"out_channel_layout\", aCodecCtx->channel_layout, 0); av_opt_set_int(swr, \"in_sample_rate\", aCodecCtx->sample_rate, 0); av_opt_set_int(swr, \"out_sample_rate\", aCodecCtx->sample_rate, 0); av_opt_set_sample_fmt(swr, \"in_sample_fmt\", aCodecCtx->sample_fmt, 0); av_opt_set_sample_fmt(swr, \"out_sample_fmt\", AV_SAMPLE_FMT_S16, 0); swr_init(swr); outputBufferSize = 8196; outputBuffer = (uint8_t *) malloc(sizeof(uint8_t) * outputBufferSize); // 返回sample rate和channels *rate = aCodecCtx->sample_rate; *channel = aCodecCtx->channels; return 0; } // 获取PCM数据, 自动回调获取 int getPCM(void **pcm, size_t *pcmSize) { while (av_read_frame(aFormatCtx, &packet) >= 0) { int frameFinished = 0; //音频流 if (packet.stream_index == audioStream) { avcodec_decode_audio4(aCodecCtx, aFrame, &frameFinished, &packet); //解码完一帧数据 if (frameFinished) { // data_size为音频数据所占的字节数 int data_size = av_samples_get_buffer_size( aFrame->linesize, aCodecCtx->channels, aFrame->nb_samples, aCodecCtx->sample_fmt, 1); if (data_size > outputBufferSize) { outputBufferSize = (size_t) data_size; outputBuffer = (uint8_t *) realloc(outputBuffer, sizeof(uint8_t) * outputBufferSize); } // 音频格式转换 swr_convert(swr, &outputBuffer, aFrame->nb_samples, (uint8_t const **) (aFrame->extended_data), aFrame->nb_samples); // 返回pcm数据 *pcm = outputBuffer; *pcmSize = (size_t) data_size; return 0; } } } return -1; } // 释放相关资源 int releaseAudioPlayer() { av_packet_unref(&packet); av_free(outputBuffer); av_free(aFrame); avcodec_close(aCodecCtx); avformat_close_input(&aFormatCtx); return 0; } // 对外播放接口 ，传入 mp3 绝对地址 JNIEXPORT void JNICALL Java_com_frank_ffmpeg_AudioPlayer_playAudio (JNIEnv * env, jclass jobject, jstring filePath) { int rate, channel; const char *file_name = (*env)->GetStringUTFChars(env, filePath, NULL); // 创建音频解码器 createAudioPlayer(&rate, &channel, file_name); // 创建OpenSLES引擎 createEngine(); // 创建带有缓冲队列的音频播放器 createBufferQueueAudioPlayer(rate, channel, SL_PCMSAMPLEFORMAT_FIXED_16); // 启动音频播放 bqPlayerCallback(bqPlayerBufferQueue, NULL); } //停止播放，释放相关资源 JNIEXPORT jint JNICALL Java_com_frank_ffmpeg_AudioPlayer_stop (JNIEnv * env, jclass jobject) { if (bqPlayerObject != NULL) { (*bqPlayerObject)->Destroy(bqPlayerObject); bqPlayerObject = NULL; bqPlayerPlay = NULL; bqPlayerBufferQueue = NULL; bqPlayerEffectSend = NULL; bqPlayerVolume = NULL; } if (outputMixObject != NULL) { (*outputMixObject)->Destroy(outputMixObject); outputMixObject = NULL; outputMixEnvironmentalReverb = NULL; } if (engineObject != NULL) { (*engineObject)->Destroy(engineObject); engineObject = NULL; engineEngine = NULL; } // 释放解码器相关资源 releaseAudioPlayer(); } 播放本地MP4 #define MAX_AUDIO_FRAME_SIZE 48000 * 4 #define PACKET_SIZE 50 #define MIN_SLEEP_TIME_US 1000ll #define AUDIO_TIME_ADJUST_US -200000ll typedef struct MediaPlayer{ AVFormatContext* format_context; int video_stream_index; int audio_stream_index; AVCodecContext* video_codec_context; AVCodecContext* audio_codec_context; AVCodec* video_codec; AVCodec* audio_codec; ANativeWindow* native_window; uint8_t* buffer; AVFrame* yuv_frame; AVFrame* rgba_frame; int video_width; int video_height; SwrContext* swrContext; int out_channel_nb; int out_sample_rate; enum AVSampleFormat out_sample_fmt; jobject audio_track; jmethodID audio_track_write_mid; uint8_t* audio_buffer; AVFrame* audio_frame; AVPacketQueue* packets[2]; pthread_mutex_t mutex; pthread_cond_t cond; int64_t start_time; int64_t audio_clock; pthread_t write_thread; pthread_t video_thread; pthread_t audio_thread; }MediaPlayer; typedef struct Decoder{ MediaPlayer* player; int stream_index; }Decoder; JavaVM* javaVM; MediaPlayer* player; jint JNICALL JNI_OnLoad(JavaVM* vm, void* reserved) { javaVM = vm; return JNI_VERSION_1_6; } int init_input_format_context(MediaPlayer* player, const char* file_name) { av_register_all(); player->format_context = avformat_alloc_context(); if(avformat_open_input(&player->format_context, file_name, NULL, NULL)!=0) { return -1; } //查找是否有音频 或 视频信息 if(avformat_find_stream_info(player->format_context, NULL)video_stream_index = -1; player->audio_stream_index = -1; for (int i = 0; i format_context->nb_streams; i++) { if (player->format_context->streams[i]->codec->codec_type == AVMEDIA_TYPE_VIDEO && player->video_stream_index video_stream_index = i; } else if (player->format_context->streams[i]->codec->codec_type == AVMEDIA_TYPE_AUDIO && player->audio_stream_index audio_stream_index = i; } } if(player->video_stream_index==-1) { // 没有视频信息 return -1; } if(player->audio_stream_index==-1) { // 没有音频信息 return -1; } return 0; } //打开音视频解码器 int init_condec_context(MediaPlayer* player) { //获取codec上下文指针 player->video_codec_context = player->format_context->streams[player->video_stream_index]->codec; //寻找视频流的解码器 player->video_codec = avcodec_find_decoder(player->video_codec_context->codec_id); if(player->video_codec == NULL) { return -1; } // 打开解码器 if(avcodec_open2(player->video_codec_context, player->video_codec, NULL) audio_codec_context = player->format_context->streams[player->audio_stream_index]->codec; player->audio_codec = avcodec_find_decoder(player->audio_codec_context->codec_id); if( player->audio_codec == NULL) { return -1; } if(avcodec_open2(player->audio_codec_context, player->audio_codec, NULL) video_width = player->video_codec_context->width; player->video_height = player->video_codec_context->height; return 0; } // 获得 ANativeWindow surface void video_player_prepare(MediaPlayer* player, JNIEnv* env, jobject surface) { player->native_window = ANativeWindow_fromSurface(env, surface); } //获取当前播放时间 int64_t get_play_time(MediaPlayer* player){ return (int64_t)(av_gettime() - player->start_time); } // 音视频同步 void player_wait_for_frame(MediaPlayer *player, int64_t stream_time) { pthread_mutex_lock(&player->mutex); for(;;){ int64_t current_video_time = get_play_time(player); int64_t sleep_time = stream_time - current_video_time; if (sleep_time start_time - sleep_time; player->start_time = new_value; pthread_cond_broadcast(&player->cond); } if (sleep_time 500000ll) { // if sleep time is bigger then 500ms just sleep this 500ms // and check everything again sleep_time = 500000ll; } //等待指定时长 pthread_cond_timeout_np(&player->cond, &player->mutex, (unsigned int) (sleep_time / 1000ll)); } pthread_mutex_unlock(&player->mutex); } //视频解码 int decode_video(MediaPlayer* player, AVPacket* packet) { ANativeWindow_setBuffersGeometry(player->native_window, player->video_width, player->video_height, WINDOW_FORMAT_RGBA_8888); ANativeWindow_Buffer windowBuffer; player->yuv_frame = av_frame_alloc(); player->rgba_frame = av_frame_alloc(); if(player->rgba_frame == NULL || player->yuv_frame == NULL) { return -1; } // buffer中数据用于渲染,且格式为RGBA int numBytes=av_image_get_buffer_size(AV_PIX_FMT_RGBA, player->video_width, player->video_height, 1); player->buffer = (uint8_t *)av_malloc(numBytes*sizeof(uint8_t)); av_image_fill_arrays(player->rgba_frame->data, player->rgba_frame->linesize, player->buffer, AV_PIX_FMT_RGBA, player->video_width, player->video_height, 1); // 由于解码出来的帧格式不是RGBA的,在渲染之前需要进行格式转换 struct SwsContext *sws_ctx = sws_getContext( player->video_width, player->video_height, player->video_codec_context->pix_fmt, player->video_width, player->video_height, AV_PIX_FMT_RGBA, SWS_BILINEAR, NULL, NULL, NULL); int frameFinished; //解码 int ret = avcodec_decode_video2(player->video_codec_context, player->yuv_frame, &frameFinished, packet); if(ret native_window, &windowBuffer, 0); // 格式转换 sws_scale(sws_ctx, (uint8_t const * const *)player->yuv_frame->data, player->yuv_frame->linesize, 0, player->video_height, player->rgba_frame->data, player->rgba_frame->linesize); // 获取stride uint8_t * dst = windowBuffer.bits; int dstStride = windowBuffer.stride * 4; uint8_t * src = player->rgba_frame->data[0]; int srcStride = player->rgba_frame->linesize[0]; // 由于window的stride和帧的stride不同,因此需要逐行复制 int h; for (h = 0; h video_height; h++) { memcpy(dst + h * dstStride, src + h * srcStride, (size_t) srcStride); } //计算延迟 int64_t pts = av_frame_get_best_effort_timestamp(player->yuv_frame); AVStream *stream = player->format_context->streams[player->video_stream_index]; //转换（不同时间基时间转换） int64_t time = av_rescale_q(pts, stream->time_base, AV_TIME_BASE_Q); //音视频帧同步 player_wait_for_frame(player, time); ANativeWindow_unlockAndPost(player->native_window); } return 0; } //音频解码初始化 void audio_decoder_prepare(MediaPlayer* player) { //frame->16bit 44100 PCM 统一音频采样格式与采样率 player->swrContext = swr_alloc(); //输入的采样格式 enum AVSampleFormat in_sample_fmt = player->audio_codec_context->sample_fmt; //输出采样格式16bit PCM player->out_sample_fmt = AV_SAMPLE_FMT_S16; //输入采样率 int in_sample_rate = player->audio_codec_context->sample_rate; //输出采样率 player->out_sample_rate = in_sample_rate; //声道布局（2个声道，默认立体声stereo） uint64_t in_ch_layout = player->audio_codec_context->channel_layout; //输出的声道布局（立体声） uint64_t out_ch_layout = AV_CH_LAYOUT_STEREO; swr_alloc_set_opts(player->swrContext, out_ch_layout, player->out_sample_fmt, player->out_sample_rate, in_ch_layout, in_sample_fmt, in_sample_rate, 0, NULL); swr_init(player->swrContext); //输出的声道个数 player->out_channel_nb = av_get_channel_layout_nb_channels(out_ch_layout); } //音频播放器 void audio_player_prepare(MediaPlayer* player, JNIEnv* env, jclass jthiz) { jclass player_class = (*env)->GetObjectClass(env,jthiz); if(!player_class) { return ; } // 根据自定义的java方法 createAudioTrack 获取 android 自带的 AudioTrack 对象 jmethodID audio_track_method = (*env)->GetMethodID(env,player_class,\"createAudioTrack\",\"(II)Landroid/media/AudioTrack;\"); if(!audio_track_method) { return ; } jobject audio_track = (*env)->CallObjectMethod( env,jthiz,audio_track_method, player->out_sample_rate, player->out_channel_nb); //调用 AudioTrack 的play()方法 jclass audio_track_class = (*env)->GetObjectClass(env, audio_track); jmethodID audio_track_play_mid = (*env)->GetMethodID(env,audio_track_class,\"play\",\"()V\"); (*env)->CallVoidMethod(env, audio_track, audio_track_play_mid); player->audio_track = (*env)->NewGlobalRef(env, audio_track); //获取 AudioTrack 的 write()方法 player->audio_track_write_mid = (*env)->GetMethodID(env,audio_track_class,\"write\",\"([BII)I\"); //16bit 44100 PCM 数据 player->audio_buffer = (uint8_t *)av_malloc(MAX_AUDIO_FRAME_SIZE); //解码后的音频数据 player->audio_frame = av_frame_alloc(); } //音频解码 + 播放 int decode_audio(MediaPlayer* player, AVPacket* packet) { int got_frame = 0, ret; //解码 ret = avcodec_decode_audio4(player->audio_codec_context, player->audio_frame, &got_frame, packet); if(ret 0) { //音频格式转换 swr_convert(player->swrContext, &player->audio_buffer, MAX_AUDIO_FRAME_SIZE, (const uint8_t **)player->audio_frame->data, player->audio_frame->nb_samples); int out_buffer_size = av_samples_get_buffer_size(NULL, player->out_channel_nb, player->audio_frame->nb_samples, player->out_sample_fmt, 1); //音视频帧同步 int64_t pts = packet->pts; // AV_NOPTS_VALUE 无效的pts 标记 if (pts != AV_NOPTS_VALUE) { AVStream *stream = player->format_context->streams[player->audio_stream_index]; // av_rescale_q AV_TIME_BASE_Q player->audio_clock = av_rescale_q(pts, stream->time_base, AV_TIME_BASE_Q); player_wait_for_frame(player, player->audio_clock + AUDIO_TIME_ADJUST_US); } if(javaVM != NULL) { JNIEnv * env; (*javaVM)->AttachCurrentThread(javaVM, &env, NULL); jbyteArray audio_sample_array = (*env)->NewByteArray(env,out_buffer_size); jbyte* sample_byte_array = (*env)->GetByteArrayElements(env,audio_sample_array,NULL); memcpy(sample_byte_array, player->audio_buffer, (size_t) out_buffer_size); (*env)->ReleaseByteArrayElements(env,audio_sample_array,sample_byte_array,0); //调用AudioTrack的write方法进行播放 (*env)->CallIntMethod(env, player->audio_track, player->audio_track_write_mid, audio_sample_array,0,out_buffer_size); (*env)->DeleteLocalRef(env,audio_sample_array); } } if(javaVM != NULL) { (*javaVM)->DetachCurrentThread(javaVM); } return 0; } //初始化队列 void init_queue(MediaPlayer* player, int size) { for (int i = 0; i packets[i] = queue; } } //释放队列 void delete_queue(MediaPlayer* player){ int i; for (i = 0; i packets[i]); } } //读取AVPacket线程(生产者) ， 获得解码之前的音频数据+视频数据 void* write_packet_to_queue(void* arg) { MediaPlayer* player = (MediaPlayer*)arg; AVPacket packet ; AVPacket *pkt = &packet; for(;;) { int ret = av_read_frame(player->format_context, pkt); if(ret stream_index == player->video_stream_index || pkt->stream_index == player->audio_stream_index) { // 将 每一帧 解码前的 数据 分别存到 音频 和视频的缓冲队列中 AVPacketQueue *queue = player->packets[pkt->stream_index]; pthread_mutex_lock(&player->mutex); AVPacket* data = queue_push(queue, &player->mutex, &player->cond); pthread_mutex_unlock(&player->mutex); *data = packet; } } } //根据参数 解码音频 或 视频 void* decode_func(void* arg) { Decoder *decoder_data = (Decoder*)arg; MediaPlayer *player = decoder_data->player; int stream_index = decoder_data->stream_index; AVPacketQueue *queue = player->packets[stream_index]; for(;;) { pthread_mutex_lock(&player->mutex); AVPacket *packet = (AVPacket*)queue_pop(queue, &player->mutex, &player->cond); pthread_mutex_unlock(&player->mutex); int ret = 0; if(stream_index == player->video_stream_index) { // 解码 视频 ret = decode_video(player, packet); } else if(stream_index == player->audio_stream_index) { // 解码 音频 ret = decode_audio(player, packet); } av_packet_unref(packet); if(ret GetStringUTFChars(env, filePath, JNI_FALSE); player = malloc(sizeof(MediaPlayer)); if(player == NULL) { return -1; } //初始化输入格式上下文 int ret = init_input_format_context(player, file_name); if(ret mutex, NULL); pthread_cond_init(&player->cond, NULL); // 获得解码前的 音频数据 和视频数据 ， 子线程 pthread_create(&player->write_thread, NULL, write_packet_to_queue, (void*)player); sleep(1); player->start_time = 0; //解码视频 ， 子线程 Decoder data1 = {player, player->video_stream_index} ; Decoder *decoder_data1 = &data1; pthread_create(&player->video_thread, NULL, decode_func, (void*)decoder_data1); // 解码音频 ， 子线程 Decoder data2 = {player, player->audio_stream_index} ; Decoder *decoder_data2 = &data2; pthread_create(&player->audio_thread,NULL,decode_func,(void*)decoder_data2); pthread_join(player->write_thread, NULL); pthread_join(player->video_thread, NULL); pthread_join(player->audio_thread, NULL); return 0; } // 释放资源 JNIEXPORT void JNICALL Java_com_frank_ffmpeg_MediaPlayer_release (JNIEnv * env, jclass clazz) { //释放内存以及关闭文件 free(player->audio_track); free(player->audio_track_write_mid); av_free(player->buffer); av_free(player->rgba_frame); av_free(player->yuv_frame); av_free(player->audio_buffer); av_free(player->audio_frame); avcodec_close(player->video_codec_context); avcodec_close(player->audio_codec_context); avformat_close_input(&player->format_context); ANativeWindow_release(player->native_window); delete_queue(player); pthread_cond_destroy(&player->cond); pthread_mutex_destroy(&player->mutex); free(player); (*javaVM)->DestroyJavaVM(javaVM); } public AudioTrack createAudioTrack(int sampleRate, int channels){ int audioFormat = AudioFormat.ENCODING_PCM_16BIT; int channelConfig; if(channels == 1){ channelConfig = android.media.AudioFormat.CHANNEL_OUT_MONO; }else if(channels == 2){ channelConfig = android.media.AudioFormat.CHANNEL_OUT_STEREO; }else{ channelConfig = android.media.AudioFormat.CHANNEL_OUT_STEREO; } // 返回音轨所需的估计最小缓冲区大小 int bufferSizeInBytes = AudioTrack.getMinBufferSize(sampleRate, channelConfig, audioFormat); return new AudioTrack(AudioManager.STREAM_MUSIC, sampleRate, channelConfig, audioFormat, bufferSizeInBytes, AudioTrack.MODE_STREAM); } ffmpeg软解rtsp简单直播 所需so include include include include include extern \"C\" { include include include include include include include include \"libswresample/swresample.h\" include \"libavutil/opt.h\" include \"libavutil/imgutils.h\" } static AVPacket *pPacket; static AVFrame *pAvFrame, *pFrameBGR; static AVCodecContext *pCodecCtx; struct SwsContext *pImgConvertCtx; static AVFormatContext *pFormatCtx; ANativeWindow* nativeWindow; ANativeWindow_Buffer windowBuffer; uint8_t *v_out_buffer; bool stop; extern \"C\" JNIEXPORT jint JNICALL Java_com_nazhi_testlive555_FfmpegUtils_openVideo(JNIEnv *env, jclass type, jstring url, jobject surface) { stop = false; // 版本兼容 if LIBAVCODEC_VERSION_INT GetStringUTFChars(url, NULL)); //绑定surface 和 ANativeWindow nativeWindow = ANativeWindow_fromSurface(env, surface); if (0 == nativeWindow){ return -1; } //注册编解码器 avcodec_register_all(); //注册所有组件 av_register_all(); // 初始化网络库 avformat_network_init(); // 注册设备 avdevice_register_all(); pFormatCtx = avformat_alloc_context(); // 打开rtsp流 if (avformat_open_input(&pFormatCtx, input_str, NULL, NULL) nb_streams; i++) { // 找到视频流 if (pFormatCtx->streams[i]->codec->codec_type == AVMEDIA_TYPE_VIDEO) { videoIndex = i; break; } } // 获得解码需要的相关信息 pCodecCtx = pFormatCtx->streams[videoIndex]->codec; // 获得 编码器相关信息 AVCodec *pCodec = avcodec_find_decoder(pCodecCtx->codec_id); //为各种结构体分配内存 和一些必要的检查 avcodec_open2(pCodecCtx, pCodec, NULL); int width = pCodecCtx->width; int height = pCodecCtx->height; // 计算缓冲区填充所需的大小 int numBytes = av_image_get_buffer_size(AV_PIX_FMT_RGBA, width, height, 1); v_out_buffer = (uint8_t *)av_malloc(numBytes*sizeof(uint8_t)); // 给像素数据分配空间 av_image_fill_arrays(pFrameBGR->data, pFrameBGR->linesize, v_out_buffer, AV_PIX_FMT_RGBA, width, height, 1); //SwsContext 主要用于视频图像的转换 ，sws_getContext初始化 pImgConvertCtx = sws_getContext( pCodecCtx->width, //原始宽度 pCodecCtx->height, //原始高度 pCodecCtx->pix_fmt, //原始格式 pCodecCtx->width, //目标宽度 pCodecCtx->height, //目标高度 AV_PIX_FMT_RGBA, //目标格式 SWS_BICUBIC, //算法类型 NULL, NULL, NULL); // 设置 ANativeWindow 的缓存大小 ,返回值 = 0) { if ((pPacket)->stream_index != videoIndex) { continue; } int gotPicCount = 0; //解码 , 解码失败 gotPicCount 返回值为0 avcodec_decode_video2(pCodecCtx, pAvFrame, &gotPicCount, pPacket); if (gotPicCount != 0) { // 转换像素 sws_scale( pImgConvertCtx, (const uint8_t *const *) pAvFrame->data, pAvFrame->linesize, 0, pCodecCtx->height, pFrameBGR->data, pFrameBGR->linesize); // 锁定 ANativeWindow , 返回值 小于0 代表失败 if (ANativeWindow_lock(nativeWindow, &windowBuffer, NULL) >= 0) { uint8_t *dst = (uint8_t *) windowBuffer.bits; for (int h = 0; h linesize[0], pFrameBGR->linesize[0]); } // 释放锁定 ANativeWindow ANativeWindow_unlockAndPost(nativeWindow); } } } // 重置 AVPacket av_packet_unref(pPacket); } // 释放 SwsContext sws_freeContext(pImgConvertCtx); //释放 av_free(pPacket); av_free(pFrameBGR); // 关闭 AVCodecContext avcodec_close(pCodecCtx); // 关闭 AVFormatContext avformat_close_input(&pFormatCtx); return 1; } extern \"C\" JNIEXPORT void JNICALL Java_com_nazhi_testlive555_FfmpegUtils_stop(JNIEnv *env, jclass type) { stop = true; } ( no Copyright，enjoy youself ! ) all right reserved，powered by GitbookThe file was updated at : 2021-06-07 13:46:13 "},"chinese/server/服务器部分.html":{"url":"chinese/server/服务器部分.html","title":"服务器部分","keywords":"","body":"服务器部分 tomcat 1、外网访问 tomcat，需要防火墙对 8080 端口放行。 2、tomcat 需要 jdk 的支持才能启动 tomcat 配置 https 用了腾讯云的免费证书 + tomcat9 。 https://cloud.tencent.com/document/product/400/4143 按照提示修改就行了。 并没有手动修改过tomcat的8080端口为80. 也没有手动对443端口放行 。 配置完之后可以检测一下443端口是否可用。 https://cloud.tencent.com/product/ssl linux 部署 多个 tomcat 修改server.xml配置文件, 三个地方 1 、port=\"18005\" port=\"18006\" 2、port=\"18080\" port=\"18081\" 3、port=\"18009\" port=\"18008\" 指定的服务未安装 unable to open the service tomcat7 进入Tomcat安装目录下的bin目录 输入 service.bat install 即可 在MyEclipse上点击部署按钮没反应 找到MyEclipse的工作路径，去“\\.metadata\\.plugins\\org.eclipse.core.runtime\\.settings” 找一个含有deploy的.prefs文件。 删除即可 (com.genuitec.eclipse.ast.deploy.core.prefs)。 重新启动MyEclipse。 springBoot 可以用 springBoot 快速搭建一个服务api 。 直接使用 IntelliJ 的 spring Initializr 引导新建项目。 1、IntelliJ IDEA 2、Tomcat 3、springBoot 4、mysql 5、mybatis // 项目发布war 本地调试jar https://blog.csdn.net/mimica247706624/article/details/60765730 因为我外网的tomcat配置了https，而且项目不大，所以所有的项目部署在同一个tomcat中。 但是本地仍然用内置的tomcat进行运行调试。 // 集成mybatis https://blog.csdn.net/gebitan505/article/details/54929287 springBoot 项目xml 配置 更加详细的配置可以参考托管在码云上的项目 4.0.0 com.aivin AivinInfo 1.0.0 war AivinInfo AivinInfo project for Spring Boot org.springframework.boot spring-boot-starter-parent 2.0.2.RELEASE UTF-8 UTF-8 1.8 org.springframework.boot spring-boot-starter-web org.mybatis.spring.boot mybatis-spring-boot-starter 1.3.2 mysql mysql-connector-java runtime org.springframework.boot spring-boot-starter-test test org.springframework.boot spring-boot-starter-tomcat provided--> javax.servlet javax.servlet-api com.github.pagehelper pagehelper 4.1.0 org.springframework.boot spring-boot-maven-plugin // 设置访问的端口 server.port=80 // mysql配置信息 spring.datasource.url=jdbc:mysql://xxxxx:3306/xxx?useUnicode=true&characterEncoding=UTF-8&useSSL=true spring.datasource.username=aivin spring.datasource.password=xxxxx spring.datasource.driver-class-name=com.mysql.jdbc.Driver // 拦截404 ，500等错误 spring.mvc.throw-exception-if-no-handler-found=true spring.resources.add-mappings=false redis redis 是一种数据库。 将常用数据存储在内存中(也支持持久化存储),提高查询速度 。 // Linux 安装 redis https://redis.io/download 下载安装包 tar -zxvf xxx cd 文件夹 make make install cd src redis-server // 用默认配置启动redis redis-server ./xxxx // 用指定的配置启动redis 验证是否启动成功 用另一个终端输入 redis-cli ，如果成功进入redis客户端 ，就说明启动正常 nginx nginx 的主要作用是反向代理 和负载均衡 。 ubuntu 下可以用 apt-get 的方式进行安装。 也可以去官网下载自己想要版本的源码，自己编译安装。 在linux上需要安装一些依赖库才能正确安装nginx。 安装依赖 apt-get update // 安装gcc g++的依赖库 apt-get install build-essential apt-get install libtool //安装pcre依赖库 apt-get install libpcre3 libpcre3-dev //安装zlib依赖库 apt-get install zlib1g-dev ///安装SSL依赖库 apt-get install openssl 安装 Nginx // 去官网找到最版本的下载链接 下载并解压 wget http://nginx.org/download/nginx-xxx.tar.gz tar -zxvf nginx-xxx.gz //进入解压目录 并配置配置 cd nginx-xxx ./configure --prefix=/usr/local/nginx make //编译 sudo make install //安装 //配置软链接 sudo ln -s /usr/local/nginx/sbin/nginx /usr/bin/nginx // 启动 nginx nginx -c /usr/local/nginx/conf/nginx.conf (注意：-c 指定配置文件的路径，不加的话，nginx会自动加载默认路径的配置文件) nginx -s stop //停止nginx ps -ef | grep nginx // 查看nginx进程 , 验证nginx是否启动成功了。 nginx的默认端口是80 ，可以用浏览器访问服务器地址 ， 如果有welcome信息 说明启动成功。 nginx 配置 指向 tomcat http{}节点之间添加upstream配置。 myServerHost 这个随便写，后面要用到。 upstream myServerHost { server 127.0.0.1:18080; server 127.0.0.1:18081; } 然后在 location 节点中配置 proxy_pass location / { root html; index index.html index.htm; proxy_pass http://myServerHost; } 然后重启 nginx 即可。 jenkins jenkins官网 https://jenkins.io/index.html //启动时指定端口 java -jar jenkins.war --httpPort=8082 //停止jenkins net stop jenkins 持续集成（Continuous integration，CI） 指的是频繁地（一天多次）将代码集成到主干。 它的好处主要有两 1、快速发现错误。 每完成一点更新，就集成到主干，可以快速发现错误，定位错误也比较容易。 \"持续集成并不能消除Bug，而是让它们非常容易发现和改正。\" 2、防止分支大幅偏离主干。 如果不是经常集成，主干又在不断更新，会导致以后集成的难度变大，甚至难以集成。 持续交付（Continuous delivery） 可以看作持续集成的下一步。 不管怎么更新，软件是随时随地可以交付的。 持续部署的目标是，代码在任何时刻都是可部署的，可以进入生产阶段。 mysql 复制表数据到新表 sql INSERT INTO 新表(字段1,字段2,…….) SELECT 字段1,字段2,…… FROM 旧表 CREATE TABLE 新表 LIKE 旧表 INSERT INTO recommendpicvdebug SELECT * FROM recommendpicv3 多表合并去重 sql InnoDB 和 MyISAM。选择为MyISAM。 INSERT INTO userall SELECT t.uid, t.userName FROM starbeaninfo4 t WHERE t.uid NOT IN ( SELECT uid FROM userall ) 让id从1开始自动增长 sql truncate table test 分页查询 sql SELECT * FROM newsentity_table WHERE (usertype = 'base' OR usertype = 'salse') AND logindate IS NOT NULL ORDER BY logindate DESC LIMIT 起始行, 每页多少行 增加记录 public class DBUtil{ public static void closeConection(Connection conn, ResultSet rs, PreparedStatement pstm) throws SQLException{ if (rs != null) { rs.close(); } if (pstm != null) { pstm.close(); } if ((conn != null) && (!conn.isClosed())) try { conn.close(); } catch (Exception e) { e.printStackTrace(); } } public static Connection getConnection() { Connection conn = null; String URL = \"jdbc:mysql://114.67.234.65:3306/aivininfo?useUnicode=true&characterEncoding=UTF-8&useSSL=true\"; try{ Class.forName(\"org.gjt.mm.mysql.Driver\"); conn = DriverManager.getConnection(URL, \"aivin\", \"Hnyer88888888\"); } catch (Exception e) { e.printStackTrace(); } return conn; } } public class MyDbHelper { Connection conn; PreparedStatement pstm = null; ResultSet rs = null; String sqlStr; public int addRecommendPicRecord(String title, String content) { boolean addUserSuccess = true; long addedRecodeId = -1L; this.conn = DBUtil.getConnection(); this.sqlStr = \"insert into aivinblog ( blogTitle , blogContent ,updateTime) values ( ? ,? ,?)\"; try { this.pstm = this.conn.prepareStatement(this.sqlStr, Statement.RETURN_GENERATED_KEYS); this.pstm.setString(1, title); this.pstm.setString(2, content); this.pstm.setString(3, getCurrentDataStr()); addUserSuccess = this.pstm.executeUpdate() > 0; ResultSet rs = this.pstm.getGeneratedKeys(); if (rs.next()) addedRecodeId = rs.getLong(1); } catch (SQLException e) { e.printStackTrace(); } finally { } try { DBUtil.closeConection(this.conn, this.rs, this.pstm); } catch (SQLException e) { e.printStackTrace(); } return (int) addedRecodeId; } public String getCurrentDataStr() { DateFormat dateFormat = new SimpleDateFormat(\"yyyy-MM-dd\", Locale.getDefault()); String reslut = dateFormat.format(new Date()); return reslut; }// } ( no Copyright，enjoy youself ! ) all right reserved，powered by GitbookThe file was updated at : 2020-12-24 08:42:30 "},"chinese/webDev/web部分.html":{"url":"chinese/webDev/web部分.html","title":"web部分","keywords":"","body":"html5 标签元素 名字 说明 abbr 用来指明这是简称或缩写，比如 \"WWW\" 。 标记后能够为浏览器、搜索引擎提供有用的信息。 acronym 标签定义首字母缩写。标记后能够为浏览器、搜索引擎提供有用的信息。 address 定义文档或文章的作者/拥有者的联系信息 applet 一个嵌入的 Java applet 。 HTML5 中不支持 applet 标签。请使用 object 元素 标签代替。 area 标签定义图像映射中的区域 article 标签规定独立的自包含内容。一篇文章应有其自身的意义，应该有可能独立于站点的其余部分对其进行分发。 aside 定义其所处内容之外的内容。 aside 的内容应该与附近的内容相关 audio 定义声音 b 粗体文本 base 为页面上的所有链接规定默认地址或默认目标。 basefont 标签定义基准字体。该标签可以为文档中的所有文本定义默认字体颜色、字体大小和字体系列。 bdi 允许设置一段文本，使其脱离其父元素的文本方向设置 bdo 定义文字的方向 big 大号字体效果 blockquote 定义块引用 body 定义文档的主体 br 换行 button 按钮 canvas 画布 ，可以在这上面绘制内容 caption 定义表格标题 center 对其所包括的文本进行水平居中 cite 定义引用 code 定义计算机代码文本 col 用在表格中，设置每一列的样式 ,一个表格里面只写一次 colgroup 用于对表格中的列进行组合，以便对其进行格式化 command 表示用户能够调用的命令 datalist 定义选项列表。 与 input 元素配合使用该元素，来定义 input 可能的值。 dd 在定义列表中定义条目的定义部分 del 定义文档中已被删除的文本 dfn 定义一个定义项目 dialog 定义对话框或窗口 dir 定义目录列表 。 不赞成使用这个标签 div 层 。把文档分割为独立的、不同的部分。它可以用作严格的组织工具，并且不使用任何格式与其关联。 dl 定义了定义列表 dt 定义了定义列表中的项目 em 把文本定义为强调的内容 embed 定义嵌入的内容，比如插件 fieldset 将表单内的相关元素分组 figcaption 定义 figure 元素的标题 figure 规定独立的流内容（图像、图表、照片、代码等等）。 figure 元素的内容应该与主内容相关，但如果被删除，则不应对文档流产生影响。 font 规定文本的字体、字体尺寸、字体颜色 footer 定义文档或节的页脚 form 表单 frame 定义 frameset 中的一个特定的窗口（框架） frameset 用来包含 frame h1 ... h6 不同级别的 标题 head 文档的头部 header 定义文档的页眉（介绍信息） hr 创建一条水平线 html 告知浏览器其自身是一个 HTML 文档 i 斜体文本效果 iframe 创建包含另外一个文档的内联框架（即行内框架） img 嵌入一幅图像 input 标签用于搜集用户信息。 根据不同的 type 属性值，输入字段拥有很多种形式。 文本字段、复选框 、单选按钮、按钮等 ins 大多数浏览器会改写为删除文本和下划线文本。 一些老式的浏览器会把删除文本和下划线文本显示为普通文本。 kbd 定义键盘文本 keygen 用于表单的密钥对生成器字段 label label 不会向用户呈现任何特殊效果。不过，它为鼠标用户改进了可用性。如果你在 label 元素内点击文本，就会触发此控件。 legend 为 fieldset 元素定义标题 li 定义列表项目 ， 可用在有序列表 ol 和无序列表 ul 中 link 导入外部资源 ，css等 main 规定文档的主要内容 map 带有可点击区域的图像映射 。例如指定图片的哪些区域可以点击就跳转 mark 定义带有记号的文本 menu 用于上下文菜单、工具栏以及用于列出表单控件和命令 menuitem 定义用户可以从弹出菜单调用的命令/菜单项目 meta 可提供有关页面的元信息 ，比如针对搜索引擎和更新频度的描述和关键词。 meter 进度条 nav 定义导航链接的部分 noframes 为那些不支持框架的浏览器显示文本 noscript 用来定义在脚本未被执行时的替代内容 object 定义一个嵌入的对象 ol 有序列表 optgroup 定义选项组 option 定义下拉列表中的一个选项 output 定义不同类型的输出 p 定义段落 param 为object标签提供嵌入内容的运行时参数的name与value对 pre 定义预格式化的文本 progress 有动画的进度条 q 定义短的引用 rp 在 ruby 注释中使用，以定义不支持 ruby 元素的浏览器所显示的内容。 rt 定义字符（中文注音或字符）的解释或发音。 ruby 定义 ruby 注释（中文注音或字符） samp 定义样本文本 script 插入一段 JavaScript section HTML 5 中的新标签。 定义文档中的节（section、区段）。比如章节、页眉、页脚或文档中的其他部分。 select 单选或多选菜单 small 小号字体效果 source 音频播放器 span span随内容而占用高宽空间（紧贴内容），而一对div标签却占用一行。 strike 加删除线文本 s 是 strike 标签的缩写版本 ， 定义加删除线文本定义 strong 定义为语气更强的强调的内容 style 定义样式 details 当与标记配合使用时，在单击标记后才会显示元素中设置的内容。 summary 当与标记配合使用时，在单击标记后才会显示元素中设置的内容。 textarea 多行的文本输入控件 sub 上标 sup 下标 table 表格 tbody 表格主体 thead 定义表格的表头 tfoot 定义表格的页脚（脚注或表注） tr 定义简单的表格，行 th 定义简单的表格， 表头的列 td 定义简单的表格， 普通行的列 time 不会在任何浏览器中呈现任何特殊效果。为搜索引擎提供有用信息 title 文档的标题 track 播放带有字幕的视频 tt 呈现类似打字机或者等宽的文本效果 u 为文本添加下划线 ul 无序列表 var 定义变量 video 定义视频 wbr br 表示必须换行。 而 wbr 表示在浏览器宽度足够的情况下，不换行；在宽度不足的情况下，在加了wbr 处主动换行。 HTML 全局属性 属性名字 说明 accesskey 规定激活元素的快捷键。 class 规定元素的一个或多个类名（引用样式表中的类）。 contenteditable 规定元素内容是否可编辑。 contextmenu 规定元素的上下文菜单。上下文菜单在用户点击元素时显示。 data-* 用于存储页面或应用程序的私有定制数据。 dir 规定元素中内容的文本方向。 draggable 规定元素是否可拖动。 dropzone 规定在拖动被拖动数据时是否进行复制、移动或链接。 hidden 规定元素仍未或不再相关。 id 规定元素的唯一 id。 lang 规定元素内容的语言。 spellcheck 规定是否对元素进行拼写和语法检查。 style 规定元素的行内 CSS 样式。 tabindex 规定元素的 tab 键次序。 title 规定有关元素的额外信息。 translate 规定是否应该翻译元素内容。 HTML 事件属性 Window 事件属性 名字 说明 onafterprint 文档打印之后运行的脚本。 onbeforeprint 文档打印之前运行的脚本。 onbeforeunload 文档卸载之前运行的脚本。 onerror 在错误发生时运行的脚本。 onhaschange 当文档已改变时运行的脚本。 onload 页面结束加载之后触发。 onmessage 在消息被触发时运行的脚本。 onoffline 当文档离线时运行的脚本。 ononline 当文档上线时运行的脚本。 onpagehide 当窗口隐藏时运行的脚本。 onpageshow 当窗口成为可见时运行的脚本。 onpopstate 当窗口历史记录改变时运行的脚本。 onredo 当文档执行撤销（redo）时运行的脚本。 onresize 当浏览器窗口被调整大小时触发。 onstorage 在 Web Storage 区域更新后运行的脚本。 onundo 在文档执行 undo 时运行的脚本。 onunload 一旦页面已下载时触发（或者浏览器窗口已被关闭）。 Form 事件 名字 说明 onblur 元素失去焦点时运行的脚本。 onchange 在元素值被改变时运行的脚本。 oncontextmenu 当上下文菜单被触发时运行的脚本。 onfocus 当元素获得焦点时运行的脚本。 onformchange 在表单改变时运行的脚本。 onforminput 当表单获得用户输入时运行的脚本。 oninput 当元素获得用户输入时运行的脚本。 oninvalid 当元素无效时运行的脚本。 onreset 当表单中的重置按钮被点击时触发。HTML5 中不支持。 onselect 在元素中文本被选中后触发。 onsubmit 在提交表单时触发。 Keyboard 事件 名字 说明 onkeydown 在用户按下按键时触发。 onkeypress 在用户敲击按钮时触发。 onkeyup 当用户释放按键时触发。 Mouse 事件 名字 说明 onclick 元素上发生鼠标点击时触发。 ondblclick 元素上发生鼠标双击时触发。 ondrag 元素被拖动时运行的脚本。 ondragend 在拖动操作末端运行的脚本。 ondragenter 当元素元素已被拖动到有效拖放区域时运行的脚本。 ondragleave 当元素离开有效拖放目标时运行的脚本。 ondragover 当元素在有效拖放目标上正在被拖动时运行的脚本。 ondragstart 在拖动操作开端运行的脚本。 ondrop 当被拖元素正在被拖放时运行的脚本。 onmousedown 当元素上按下鼠标按钮时触发。 onmousemove 当鼠标指针移动到元素上时触发。 onmouseout 当鼠标指针移出元素时触发。 onmouseover 当鼠标指针移动到元素上时触发。 onmouseup 当在元素上释放鼠标按钮时触发。 onmousewheel 当鼠标滚轮正在被滚动时运行的脚本。 onscroll 当元素滚动条被滚动时运行的脚本。 Media 事件 名字 说明 onabort 在退出时运行的脚本。 oncanplay 当文件就绪可以开始播放时运行的脚本（缓冲已足够开始时）。 oncanplaythrough 当媒介能够无需因缓冲而停止即可播放至结尾时运行的脚本。 ondurationchange 当媒介长度改变时运行的脚本。 onemptied 当发生故障并且文件突然不可用时运行的脚本（比如连接意外断开时）。 onended 当媒介已到达结尾时运行的脚本（可发送类似“感谢观看”之类的消息）。 onerror 当在文件加载期间发生错误时运行的脚本。 onloadeddata 当媒介数据已加载时运行的脚本。 onloadedmetadata 当元数据（比如分辨率和时长）被加载时运行的脚本。 onloadstart 在文件开始加载且未实际加载任何数据前运行的脚本。 onpause 当媒介被用户或程序暂停时运行的脚本。 onplay 当媒介已就绪可以开始播放时运行的脚本。 onplaying 当媒介已开始播放时运行的脚本。 onprogress 当浏览器正在获取媒介数据时运行的脚本。 onratechange 每当回放速率改变时运行的脚本（比如当用户切换到慢动作或快进模式）。 onreadystatechange 每当就绪状态改变时运行的脚本（就绪状态监测媒介数据的状态）。 onseeked 当 seeking 属性设置为 false（指示定位已结束）时运行的脚本。 onseeking 当 seeking 属性设置为 true（指示定位是活动的）时运行的脚本。 onstalled 在浏览器不论何种原因未能取回媒介数据时运行的脚本。 onsuspend 在媒介数据完全加载之前不论何种原因终止取回媒介数据时运行的脚本。 ontimeupdate 当播放位置改变时（比如当用户快进到媒介中一个不同的位置时）运行的脚本。 onvolumechange 每当音量改变时（包括将音量设置为静音）时运行的脚本。 onwaiting 当媒介已停止播放但打算继续播放时（比如当媒介暂停已缓冲更多数据）运行脚本 HTML 5 视频/音频 API HTML5 DOM 为 和 元素提供了方法、属性和事件。 这些方法、属性和事件允许你使用 JavaScript 来操作 和 元素。 HTML5 Audio/Video 属性 名字 说明 audioTracks 返回表示可用音轨的 AudioTrackList 对象 autoplay 设置或返回是否在加载完成后随即播放音频/视频 buffered 返回表示音频/视频已缓冲部分的 TimeRanges 对象 controller 返回表示音频/视频当前媒体控制器的 MediaController 对象 controls 设置或返回音频/视频是否显示控件（比如播放/暂停等） crossOrigin 设置或返回音频/视频的 CORS 设置 currentSrc 返回当前音频/视频的 URL currentTime 设置或返回音频/视频中的当前播放位置（以秒计） defaultMuted 设置或返回音频/视频默认是否静音 defaultPlaybackRate 设置或返回音频/视频的默认播放速度 duration 返回当前音频/视频的长度（以秒计） ended 返回音频/视频的播放是否已结束 error 返回表示音频/视频错误状态的 MediaError 对象 loop 设置或返回音频/视频是否应在结束时重新播放 mediaGroup 设置或返回音频/视频所属的组合（用于连接多个音频/视频元素） muted 设置或返回音频/视频是否静音 networkState 返回音频/视频的当前网络状态 paused 设置或返回音频/视频是否暂停 playbackRate 设置或返回音频/视频播放的速度 played 返回表示音频/视频已播放部分的 TimeRanges 对象 preload 设置或返回音频/视频是否应该在页面加载后进行加载 readyState 返回音频/视频当前的就绪状态 seekable 返回表示音频/视频可寻址部分的 TimeRanges 对象 seeking 返回用户是否正在音频/视频中进行查找 src 设置或返回音频/视频元素的当前来源 startDate 返回表示当前时间偏移的 Date 对象 textTracks 返回表示可用文本轨道的 TextTrackList 对象 videoTracks 返回表示可用视频轨道的 VideoTrackList 对象 volume 设置或返回音频/视频的音量 HTML5 Audio/Video 方法 名字 说明 addTextTrack() 向音频/视频添加新的文本轨道 canPlayType() 检测浏览器是否能播放指定的音频/视频类型 load() 重新加载音频/视频元素 play() 开始播放音频/视频 pause() 暂停当前播放的音频/视频 HTML5 Audio/Video 事件 名字 | 说明 -|- abort | 当音频/视频的加载已放弃时 canplay | 当浏览器可以播放音频/视频时 canplaythrough | 当浏览器可在不因缓冲而停顿的情况下进行播放时 durationchange | 当音频/视频的时长已更改时 emptied | 当目前的播放列表为空时 ended| 当目前的播放列表已结束时 error | 当在音频/视频加载期间发生错误时 loadeddata| 当浏览器已加载音频/视频的当前帧时 loadedmetadata | 当浏览器已加载音频/视频的元数据时 loadstart | 当浏览器开始查找音频/视频时 pause | 当音频/视频已暂停时 play | 当音频/视频已开始或不再暂停时 playing | 当音频/视频在已因缓冲而暂停或停止后已就绪时 progress| 当浏览器正在下载音频/视频时 ratechange| 当音频/视频的播放速度已更改时 seeked | 当用户已移动/跳跃到音频/视频中的新位置时 seeking | 当用户开始移动/跳跃到音频/视频中的新位置时 stalled | 当浏览器尝试获取媒体数据，但数据不可用时 suspend | 当浏览器刻意不获取媒体数据时 timeupdate| 当目前的播放位置已更改时 volumechange | 当音量已更改时 waiting | 当视频由于需要缓冲下一帧而停止 HTML 5 Canvas API HTML5 标签用于绘制图像 ，用JavaScript等脚本 。 canvas仅仅是图形的容器 ，你必须使用脚本来完成实际的绘图任务。 Internet Explorer 8 以及更早的版本不支持 元素。 颜色、样式和阴影 名字 说明 fillStyle 设置或返回用于填充绘画的颜色、渐变或模式 strokeStyle 设置或返回用于笔触的颜色、渐变或模式 shadowColor 设置或返回用于阴影的颜色 shadowBlur 设置或返回用于阴影的模糊级别 shadowOffsetX 设置或返回阴影距形状的水平距离 shadowOffsetY 设置或返回阴影距形状的垂直距离 createLinearGradient() 创建线性渐变（用在画布内容上） createPattern() 在指定的方向上重复指定的元素 createRadialGradient() 创建放射状/环形的渐变（用在画布内容上） addColorStop() 规定渐变对象中的颜色和停止位置 线条样式 名字 说明 lineCap 设置或返回线条的结束端点样式 lineJoin 设置或返回两条线相交时，所创建的拐角类型 lineWidth 设置或返回当前的线条宽度 miterLimit 设置或返回最大斜接长度 矩形 名字 说明 rect() 创建矩形 fillRect() 绘制“被填充”的矩形 strokeRect() 绘制矩形（无填充） clearRect() 在给定的矩形内清除指定的像素 路径 名字 说明 fill() 填充当前绘图（路径） stroke() 绘制已定义的路径 beginPath() 起始一条路径，或重置当前路径 moveTo() 把路径移动到画布中的指定点，不创建线条 closePath() 创建从当前点回到起始点的路径 lineTo() 添加一个新点，然后在画布中创建从该点到最后指定点的线条 clip() 从原始画布剪切任意形状和尺寸的区域 quadraticCurveTo() 创建二次贝塞尔曲线 bezierCurveTo() 创建三次方贝塞尔曲线 arc() 创建弧/曲线（用于创建圆形或部分圆） arcTo() 创建两切线之间的弧/曲线 isPointInPath() 如果指定的点位于当前路径中，则返回 true，否则返回 false 转换 名字 说明 scale() 缩放当前绘图至更大或更小 rotate() 旋转当前绘图 translate() 重新映射画布上的 (0,0) 位置 transform() 替换绘图的当前转换矩阵 setTransform() 将当前转换重置为单位矩阵。然后运行 transform() 文本 名字 说明 font 设置或返回文本内容的当前字体属性 textAlign 设置或返回文本内容的当前对齐方式 textBaseline 设置或返回在绘制文本时使用的当前文本基线 fillText() 在画布上绘制“被填充的”文本 strokeText() 在画布上绘制文本（无填充） measureText() 返回包含指定文本宽度的对象 图像绘制 名字 说明 drawImage() 向画布上绘制图像、画布或视频 像素操作 名字 说明 width 返回 ImageData 对象的宽度 height 返回 ImageData 对象的高度 data 返回一个对象，其包含指定的 ImageData 对象的图像数据 createImageData() 创建新的、空白的 ImageData 对象 getImageData() 返回 ImageData 对象，该对象为画布上指定的矩形复制像素数据 putImageData() 把图像数据（从指定的 ImageData 对象）放回画布上 合成 名字 说明 globalAlpha 设置或返回绘图的当前 alpha 或透明值 globalCompositeOperation 设置或返回新图像如何绘制到已有的图像上 其他 名字 说明 save() 保存当前环境的状态 restore() 返回之前保存过的路径状态和属性 createEvent() getContext() toDataURL() js 是一种动态类型语言，变量没有类型限制。 变量的类型没法在编译阶段就知道，必须等到运行时才能知道。 各种运算符对数据类型是有要求的。 如果运算符发现，运算子的类型与预期不符，就会自动转换类型。 js严格模式 ECMAscript 5添加了“严格模式”。 这种模式使得JavaScript在更合理，更安全、更严禁的条件下执行。 //f1.js 'use strice'; //指明使用 严格模式运行 数据类型 // 数值 整数和小数（比如1和3.14） // 字符串 比如Hello World // 布尔值 true、false // undefined 表示“未定义”或不存在，即由于目前没有定义，所以此处暂时没有任何值 // null 表示空值，即此处的值为空。 // 对象 可以分成三个子类型。狭义的对象、数组、函数 。 类型转换 自动转换具有不确定性，而且不易除错，建议在预期为布尔值、数值、字符串的地方， 使用Boolean、Number和String函数进行显式转换。 //Number函数强制转换 Number(324) // 324 Number('324') // 324 Number('324abc') // NaN Number('') // 0 Number(true) // 1 Number(false) // 0 Number(undefined) // NaN Number(null) // 0 Number({a: 1}) // NaN Number([1, 2, 3]) // NaN Number([5]) // 5 Number({}) // NaN //String 函数强制转换 String(123) // \"123\" String('abc') // \"abc\" String(true) // \"true\" String(undefined) // \"undefined\" String(null) // \"null\" String({a: 1}) // \"[object Object]\" String([1, 2, 3]) // \"1,2,3\" //Boolean 函数强制转换 Boolean(undefined) // false Boolean(null) // false Boolean(0) // false Boolean(NaN) // false Boolean('') // false Boolean({}) // true Boolean([]) // true Boolean(new Boolean(false)) // true 变量提升 js 中，函数及变量的声明都会被系统提升到函数的最顶部。 也就是说变量可以先使用再声明。 x = 5; // 先使用 var x; // 再声明 区块 使用大括号，将多个相关的语句组合在一起，称为“区块” 。 对于var命令来说，JavaScript 的区块不构成单独的作用域 。 { var a = 1; } 表达式、语句 JavaScript中的表达式和语句是有区别的。 一个表达式会产生一个值 。 语句可以理解成一个行为，循环语句和if语句就是典型的语句。 运算符 指数运算符 ** 2 ** 4 // 16 比较 // == 两边值类型不同的时候，先进行类型转换，再比较； // === 严格比较运算符，不做类型转换，类型不同就是不等； // Object.is('a', 'a') 行为与===基本一致。 除了： +0不等于-0 ， NaN等于自身。 if else 条件语句 if (m === 3) { } else { } switch 语句 var x = 1; switch (x) { case 1: break ; default: break ; } for 循环 for (var i = 0; i while 循环 var i = 0; while (i do ... while 循环 do { ... } while (条件); break 、continue break语句用于跳出代码块或循环。 continue语句用于立即终止本轮循环，返回循环结构的头部，开始下一轮循环。 三元运算符 var myVar; console.log( myVar ? 'myVar has a value' : 'myVar does not have a value' ) label标签 标签通常与break语句和continue语句配合使用，跳出特定的循环。 top: for (var i = 0; i 异常捕捉 var txt=\"\"; function message() { try { adddlert(\"Welcome guest!\"); } catch(err) { txt+=\"错误 \" + err.message ; } } 表单验证 onsubmit=\"return validateForm()\" method=\"post\" function validateForm() { var x = document.forms[\"myForm\"][\"fname\"].value; if (x == null || x == \"\") { alert(\"需要输入名字。\"); return false; } } typeof 用来确定一个值的类型 typeof 123 // \"number\" typeof '123' // \"string\" typeof false // \"boolean\" function f() {} typeof f // \"function\" typeof undefined // \"undefined\" v // 没有被声明过 typeof v // \"undefined\" typeof window // \"object\" typeof {} // \"object\" typeof [] // \"object\" 对象 对象就是一组“键值对”的集合， 是一种无序的复合数据集合。 对象 和代码块 都采用大括号表示。 为了避免这种歧义，V8 引擎规定， 如果行首是大括号，一律解释为对象。 不过，为了避免歧义，最好在大括号前加上圆括号。 ({ foo: 123}) var obj = { foo: 'Hello', bar: 'World' }; //with 语句 操作同一个对象的多个属性时，简化代码 with (document.links[0]){ console.log(href); console.log(title); console.log(style); } 函数 如果同一个函数被多次声明，后面的声明就会覆盖前面的声明。 注意： 定义函数时，是不需要指定参数的类型的 js有三种声明函数的方法。 1、 function 命令 function print(s) { } 2、函数表达式（采用变量赋值的写法） var print = function(s) { }; 或 var print = function x(){ // 这种写法的用处有两个，一是可以在函数体内部调用自身， //二是方便除错（除错工具显示函数调用栈时，将显示函数名， //而不再显示这里是一个匿名函数 }; 3、 利用关键字 Function 构造函数 不建议使用这种方式 var add = new Function( 'x', 'y', 'return x + y' ); function f1() {} // name属性返回函数名字 f1.name // length属性 返回 函数定义时的参数个数。 f.length // 函数参数不是必需的， js 允许省略参数。 function f(a, b) { return a; } f(1, 2, 3) // 1 f(1) // 1 f() // undefined f(undefined, 1) // undefined f( , 1) // 报错 // 在函数内部可以使用 arguments对象来获得所有的参数 var f = function(a, b) { console.log(arguments[0]); console.log(arguments[1]); console.log(arguments[2]); return a + b; } IIFE 立即执行函数 Immediately-Invoked Function Expression 在 js 中， ()是一种运算符，跟在函数名之后，表示调用该函数。 最外层加一个小括号是为了保护变量的作用域 (function(a, b){ console.log(a + b); })(1, 2) // 最后的小括号是表示立即执行这个函数，并传入参数 函数闭包 函数内部可以访问外部变量，函数外部不能访问函数内的变量 。 为了实现 外部代码可以访问函数内部的局部变量，我们设计了闭包机制。 function f1(){ var n=100 ; function f2(){ // 拿着f1的局部变量n做一些事情... } // 将内部函数返回 return f2 ; } // 使用闭包 var f3 = f1() ; // 注意，不是 f3= f1 f3() ; // 相当于执行了 f2() 题外话： 个人感觉闭包这个东西设计的有点反人类。 eval 命令 eval命令接受一个字符串作为参数，并将这个字符串当作语句执行。 eval没有自己的作用域，都在当前作用域内执行 。 //eval 的别 var m = eval; m('var x = 1'); 为了保证eval的别名不影响代码优化 , js 的标准规定，凡是使用别名执行eval，eval内部一律是全局作用域。 Object 对象 JavaScript 的所有其他对象都继承自Object对象 。 //返回空对象 var obj = Object();// undefined / null 如果Object方法的参数是一个对象，它总是返回该对象，即不用转换。 // 返回对象的所有属性名 Object.keys(obj) ; Object.getOwnPropertyNames(obj) // 获取某个属性的描述对象 Object.getOwnPropertyDescriptor(obj, 'p') //属性描述对象 attributes object js 提供了一个内部数据结构，用来描述对象的属性 。每个属性都有自己对应的属性描述对象。 { value: 123, // 该属性的属性值，默认为undefined。 writable: false, // value 是否可改变 ，默认 true。 enumerable: true, // 是否可遍历，默认 true。如果 为false，会使for循环操作等跳过该属性。 configurable: false, // 控制了属性描述对象的可写性 get: undefined, // 该属性的取值函数 set: undefined // 该属性的存值函数 } Array 数组 Array构造函数有一个很大的缺陷: 就是不同的参数，会导致它的行为不一致。 因此，不建议使用构造函数生成新数组。 var arr = new Array(1, 2);// bad var arr = [1, 2];// good Array.isArray(arr); // 判断是否是数组类型 var arr = []; arr.push(1) // 添加元素 arr.pop() // 删除最后一个元素，并返回该元素。 arr.shift() // 删除数组的第一个元素，并返回该元素 arr.shift() // 遍历并清空一个数组 arr.unshift('x'); // 在数组的第一个位置添加元素 arr.join(' | ') // 指定参数作为分隔符，将所有数组成员连接为一个字符串返回。 ['hello'].concat(['world']) // 用于多个数组的合并 arr.reverse() // 颠倒排列数组元素 arr.slice(start, end); // 提取目标数组的一部分，返回一个新数组 arr.splice(start, count, addElement1, addElement2, ...); // 删除原数组的一部分成员，并可以在删除的位置添加新的数组成员 [11, 101].sort() ;// 按照字典顺序排序 // 将数组的所有成员依次传入指定函数，然后把每一次的执行结果组成一个新数组返回。 arr.map(function (n) { return n + 1; }); 字符串 String // 是否匹配某个子字符串，返回一个数组 'cat, bat, sat, fat'.match('at') // [\"at\"] // 小于0: 一个字符串 第二个字符串。 'apple'.localeCompare('banana') // -1 JSON 转换 // 将一个值转为 JSON 字符串 JSON.stringify({ name: \"张三\" }) // 将 json 字符串转换成对应的值 var o = JSON.parse('{\"name\": \"张三\"}'); o.name // 张三 其他 表示url的内容通过js执行。void(0)表示不作任何操作，这样会防止链接跳转到其他页面。 这么做往往是为了保留链接的样式，但不让链接执行实际操作， 点击 点击后会回到网面顶部 //刷新 location.reload() ; window.location.reload() ; 事件监听 // 添加 监听函数 button.addEventListener('click', hello, false); // 移除监听函数 button.removeEventListener('click', listener, false); // 在当前节点上触发指定事件，从而触发监听函数的执行 xx.dispatchEvent(event); 鼠标事件 名称 说明 click 单击 dblclick 双击 mousedown 按下鼠标键时触发。 mouseup 释放按下的鼠标键 mousemove 当鼠标在一个节点内部移动时触发 mouseenter 进入一个节点时触发 ，进入子节点不会触发这个事件 mouseover 进入一个节点时触发 ， 进入子节点会再一次触发这个事件 mouseout 离开一个节点时触发，离开父节点也会触发这个事件 mouseleave 离开一个节点时触发 ，离开父节点不会触发这个事件 contextmenu 按下鼠标右键时 wheel 滚动鼠标的滚轮时触发 键盘事件 名称 说明 keydown 按下键盘 keypress 按下有值的键时触发， 即按下 Ctrl、Alt、Shift、Meta 这样无值的键，这个事件不会触发。 keyup 松开键盘时触发该事件 表单事件 名称 说明 input 只要值发生变化，也会触发 select Change invalid reset submit 触摸事件 Touch ：一个触摸点 . TouchList：多个触摸点的集合 TouchEvent：触摸引发的事件实例 其他事件 名称 说明 beforeunload 在窗口、文档、各种资源将要卸载前触发 unload 在窗口关闭或者document对象将要卸载时触发 load 在页面或某个资源加载成功时触发 error 在页面或资源加载失败时触发 pageshow 在页面加载时触发 pagehide 当用户通过“前进/后退”按钮，离开当前页面时触发 popstate hashchange readystatechange scroll 在文档或文档元素滚动时触发 resize 在改变浏览器窗口大小时触发 fullscreenchange 进入或退出全屏状态时触发 fullscreenerror 在浏览器无法切换到全屏状态时触发 cut 将选中的内容从文档中移除，加入剪贴板时触发。 copy 进行复制动作时触发。 paste 剪贴板内容粘贴到文档后触发 focus 元素节点获得焦点后触发，该事件不会冒泡。 blur 元素节点失去焦点后触发，该事件不会冒泡。 focusin 元素节点将要获得焦点时触发，发生在focus事件之前。该事件会冒泡。 focusout 元素节点将要失去焦点时触发，发生在blur事件之前。该事件会冒泡。 拖拉事件 拖拉指的是，用户在某个对象上按下鼠标键不放， 拖动它到另一个位置，然后释放鼠标键，将该对象放在那里。 draggable属性可用于任何元素节点 。图片和链接默认可以拖拉。 一旦某个元素节点 draggable=true，就无法再用鼠标选中该节点内部的文字或子节点了。 css cssref css 引入 // 外部样式表 // 内部样式表 hr {color: sienna;} ... // 内联样式 内联样式会损失掉样式表的许多优势。请慎用。 This is a paragraph css 优先级 同一元素同时使用Style,ID,Class来指定样式. style > id > class 如果是不同元素,还需要看元素父层级的样式: 1.子元素自身有样式,以自身的为准. 2.子元素未设定样式,此时如果父元素有定义的话套用父元素的样式否则以默认显示 css 选择器 // 单个元素选择器 body { // 颜色声明 color: #000; // 背景声明 background: #fff; } // 元素分组 选择器 h1,h2,h3,h4,h5,h6 { color: green; } // 派生选择器 常与id选择器、类选择器一起使用，可以更方便地定义局部的css. 重新定义id为sidebar下的 strong属性 sidebar strong { font-style: italic; font-weight: normal; } // id 选择器 ,用 # 来定义 ..... #sidebar p { font-style: italic; text-align: right; margin-top: 0.5em; } // 类选择器 , 用 . 来定义 .center { text-align: center ; } // 属性选择器 [title] { color:red; } [属性] //用于选取带有指定属性的元素。 [属性=value] //用于选取带有指定属性和值的元素。 [属性~=value] //用于选取属性值中包含指定词汇的元素。 [属性|=value] //用于选取带有以指定值开头的属性值的元素，该值必须是整个单词。 [属性^=value] //匹配属性值以指定值开头的每个元素。 [属性$=value] //匹配属性值以指定值结尾的每个元素。 [属性*=value] //匹配属性值中包含指定值的每个元素。 // css 其他常用选择器 选择所有元素，并设置它们的背景色： * { background-color:yellow; } 选择未被访问的链接，并设置其样式： a:link { background-color:yellow; } 选择已访问的链接，并设置其样式： a:visited { background-color:yellow; } 选择活动链接，并设置其样式： a:active { background-color:yellow; } 选择鼠标指针浮动在其上的元素，并设置其样式： a:hover { background-color:yellow; } 选择获得焦点的输入字段，并设置其样式： input:focus { background-color:yellow; } 为所有 type=\"text\" 的已启用的 input 元素设置背景色： input[type=\"text\"]:enabled { background-color: #ff0000; } 为所有 type=\"text\" 的被禁用的 input 元素设置背景色： input[type=\"text\"]:disabled { background-color: #dddddd; } 为所有被选中的 input 元素设置背景色： input:checked { background-color: #ff0000; } css 定位 关键字 说明 position //元素框正常生成。块级元素生成一个矩形框，作为文档流的一部分，行内元素则会创建一个或多个行框，置于其父元素中。 static //元素框偏移某个距离。元素仍保持其未定位前的形状，它原本所占的空间仍保留。 relative //元素框从文档流完全删除，并相对于其包含块定位。包含块可能是文档中的另一个元素或者是初始包含块。元素原先在正常文档流中所占的空间会关闭，就好像元素原来不存在一样。元素定位后生成一个块级框，而不论原来它在正常流中生成何种类型的框。 absolute //元素框的表现类似于将 position 设置为 absolute，不过其包含块是视窗本身。 fixed top 定义了一个定位元素的上外边距边界与其包含块上边界之间的偏移。 right 定义了定位元素右外边距边界与其包含块右边界之间的偏移。 bottom 定义了定位元素下外边距边界与其包含块下边界之间的偏移。 left 定义了定位元素左外边距边界与其包含块左边界之间的偏移。 overflow 设置当元素的内容溢出其区域时发生的事情。 clip 设置元素的形状。元素被剪入这个形状之中，然后显示出来。 vertical-align 设置元素的垂直对齐方式。 z-index 设置元素的堆叠顺序 clear 规定元素的哪一侧不允许其他浮动元素。 cursor 规定要显示的光标的类型（形状）。 display 规定元素应该生成的框的类型。 float 规定框是否应该浮动。 visibility 规定元素是否可见 css 尺寸 关键字 说明 height 设置元素的高度。 width 设置元素的宽度。 min-height 设置元素的最小高度。 min-width 设置元素的最小宽度。 max-height 设置元素的最大高度。 max-width 设置元素的最大宽度。 line-height 设置行高 css border 边距 关键字 说明 border 简写属性，用于把针对四个边的属性设置在一个声明。 border-style 用于设置元素所有边框的样式，或者单独地为各边设置边框样式。 border-width 简写属性，用于为元素的所有边框设置宽度，或者单独地为各边边框设置宽度。 border-color 简写属性，设置元素的所有边框中可见部分的颜色，或为 4 个边分别设置颜色。 border-bottom 简写属性，用于把下边框的所有属性设置到一个声明中。 border-bottom-color 设置元素的下边框的颜色。 border-bottom-style 设置元素的下边框的样式。 border-bottom-width 设置元素的下边框的宽度。 border-left 简写属性，用于把左边框的所有属性设置到一个声明中。 border-left-color 设置元素的左边框的颜色。 border-left-style 设置元素的左边框的样式。 border-left-width 设置元素的左边框的宽度。 border-right 简写属性，用于把右边框的所有属性设置到一个声明中。 border-right-color 设置元素的右边框的颜色。 border-right-style 设置元素的右边框的样式。 border-right-width 设置元素的右边框的宽度。 border-top 简写属性，用于把上边框的所有属性设置到一个声明中。 border-top-color 设置元素的上边框的颜色。 border-top-style 设置元素的上边框的样式。 border-top-width 设置元素的上边框的宽度。 css 内边距属性 关键字 说明 padding 简写属性。作用是在一个声明中设置元素的所内边距属性。上、右、下、左 padding-bottom 设置元素的下内边距。 padding-left 设置元素的左内边距。 padding-right 设置元素的右内边距。 padding-top 设置元素的上内边距。 css 外边距属性 关键字 说明 margin 简写属性。在一个声明中设置所有外边距属性。 margin-bottom 设置元素的下外边距。 margin-left 设置元素的左外边距。 margin-right 设置元素的右外边距。 margin-top 设置元素的上外边距。 css 边框 关键字 说明 border 在一个声明中设置所有的边框属性。 border-bottom 在一个声明中设置所有的下边框属性。 border-bottom-color 设置下边框的颜色。 border-bottom-style 设置下边框的样式。 border-bottom-width 设置下边框的宽度。 border-color 设置四条边框的颜色。 border-left 在一个声明中设置所有的左边框属性。 border-left-color 设置左边框的颜色。 border-left-style 设置左边框的样式。 border-left-width 设置左边框的宽度。 border-right 在一个声明中设置所有的右边框属性。 border-right-color 设置右边框的颜色。 border-right-style 设置右边框的样式。 border-right-width 设置右边框的宽度。 border-style 设置四条边框的样式。 border-top 在一个声明中设置所有的上边框属性。 border-top-color 设置上边框的颜色。 border-top-style 设置上边框的样式。 border-top-width 设置上边框的宽度。 border-width 设置四条边框的宽度。 outline 在一个声明中设置所有的轮廓属性。 outline-color 设置轮廓的颜色。 outline-style 设置轮廓的样式。 outline-width 设置轮廓的宽度。 border-bottom-left-radius 定义边框左下角的形状。 border-bottom-right-radius 定义边框右下角的形状。 border-image 简写属性，设置所有 border-image-* 属性。 border-image-outset 规定边框图像区域超出边框的量。 border-image-repeat 图像边框是否应平铺(repeated)、铺满(rounded)或拉伸(stretched)。 border-image-slice 规定图像边框的向内偏移。 border-image-source 规定用作边框的图片。 border-image-width 规定图片边框的宽度。 border-radius 简写属性，设置所有四个 border-*-radius 属性。 border-top-left-radius 定义边框左上角的形状。 border-top-right-radius 定义边框右下角的形状。 box-decoration-break box-shadow 向方框添加一个或多个阴影。 css 背景 关键字 说明 background 在一个声明中设置所有的背景属性 background-attachment 设置背景图像是否固定或者随着页面的其余部分滚动。scroll、fixed、inherit background-color 可以为所有元素设置背景 background-image 背景图像 ， url(/i/eg_bg_03.gif) background-position 设置背景图像的开始位。center,top,bottom,right,left、百分比、具体的px background-repeat 背景重复 ， repeat 、 repeat-x 、 repeat-y、 no-repeat 、inherit background-clip 规定背景的绘制区域。 background-origin 规定背景图片的定位区域。 background-size 规定背景图片的尺寸。 css 动画 关键字 说明 @keyframes 规定动画。 animation 所有动画属性的简写属性，除了 animation-play-state 属性。 animation-name 规定 @keyframes 动画的名称。 animation-duration 规定动画完成一个周期所花费的秒或毫秒。 animation-timing-function 规定动画的速度曲线。 animation-delay 规定动画何时开始。 animation-iteration-count 规定动画被播放的次数。 animation-direction 规定动画是否在下一周期逆向地播放。 animation-play-state 规定动画是否正在运行或暂停。 animation-fill-mode 规定对象动画时间之外的状态。 css Box 属性 关键字 说明 overflow-x 如果内容溢出了元素内容区域，是否对内容的左/右边缘进行裁剪。 overflow-y 如果内容溢出了元素内容区域，是否对内容的上/下边缘进行裁剪。 overflow-style 规定溢出元素的首选滚动方法。 rotation 围绕由 rotation-point 属性定义的点对元素进行旋转。 rotation-point 定义距离上左边框边缘的偏移点。 css 颜色 属性 关键字 说明 color-profile 允许使用源的颜色配置文件的默认以外的规范。 opacity 规定元素的不透明级别。 rendering-intent 允许使用颜色配置文件渲染意图的默认以外的规范。 css Content for Paged Media 属性 关键字 说明 bookmark-label 规定书签的标记。 bookmark-level 规定书签的级别。 bookmark-target 规定书签链接的目标。 float-offset 将元素放在 float 属性通常放置的位置的相反方向。 hyphenate-after 规定连字单词中连字符之后的最小字符数。 hyphenate-before 规定连字单词中连字符之前的最小字符数。 hyphenate-character 规定当发生断字时显示的字符串。 hyphenate-lines 指示元素中连续断字连线的最大数。 hyphenate-resource 规定帮助浏览器确定断字点的外部资源（逗号分隔的列表）。 hyphens 设置如何对单词进行拆分，以改善段落的布局。 image-resolution 规定图像的正确分辨率。 marks 向文档添加裁切标记或十字标记。 string-set css 可伸缩框属性（Flexible Box） 关键字 说明 box-align 规定如何对齐框的子元素。 box-direction 规定框的子元素的显示方向。 box-flex 规定框的子元素是否可伸缩。 box-flex-group 将可伸缩元素分配到柔性分组。 box-lines 规定当超出父元素框的空间时，是否换行显示。 box-ordinal-group 规定框的子元素的显示次序。 box-orient 规定框的子元素是否应水平或垂直排列。 box-pack 规定水平框中的水平位置或者垂直框中的垂直位置。 css 字体属性 关键字 说明 font 在一个声明中设置所有字体属性。 font-family 文本的字体 font-size 规定文本的字体尺寸 font-size-adjust 为元素规定 aspect 值。 font-stretch 收缩或拉伸当前的字体系列。 font-style 规定文本的字体样式。 font-variant 规定是否以小型大写字母的字体显示文本。 font-weight 规定字体的粗细。 css 内容生成 相关属性 关键字 说明 content 与 :before 以及 :after 伪元素配合使用，来插入生成内容。 counter-increment 递增或递减一个或多个计数器。 counter-reset 创建或重置一个或多个计数器。 quotes 设置嵌套引用的引号类型。 crop 允许被替换元素仅仅是对象的矩形区域，而不是整个对象。 move-to 从流中删除元素，然后在文档中后面的点上重新插入。 page-policy 确定元素基于页面的 occurrence 应用于计数器还是字符串值。 css 表格属性 关键字 说明 grid-columns 规定网格中每个列的宽度。 grid-rows 规定网格中每个列的高度。 css 超链接属性 关键字 说明 target 简写属性，设置target-name、target-new以及target-position属性。 target-name 规定在何处打开链接（链接的目标）。 target-new 规定目标链接在新窗口还是在已有窗口的新标签页中打开。 target-position 规定在何处放置新的目标链接。 css 列表属性 关键字 说明 list-style 简写属性。用于把所有用于列表的属性设置于一个声明中 list-style-image 将图象设置为列表项标志 list-style-position 设置列表中列表项标志的位置 list-style-type 设置列表项标志的类型 marker-offset 设置或检索标记容器和主容器之间水平补白。即两个容器靠近的一边的间距 css 走马灯属性 关键字 说明 marquee-direction 设置移动内容的方向。 marquee-play-count 设置内容移动多少次。 marquee-speed 设置内容滚动得多快。 marquee-style 设置移动内容的样式。 css 多列属性 关键字 说明 column-count 规定元素应该被分隔的列数。 column-fill 规定如何填充列。 column-gap 规定列之间的间隔。 column-rule 设置所有 column-rule-* 属性的简写属性。 column-rule-color 规定列之间规则的颜色。 column-rule-style 规定列之间规则的样式。 column-rule-width 规定列之间规则的宽度。 column-span 规定元素应该横跨的列数。 column-width 规定列的宽度。 columns 规定设置 column-width 和 column-count 的简写属性。 css Paged Media 属性 关键字 说明 fit 示意如何对width和height属性均不是auto的被替换元素进行缩放。 fit-position 定义盒内对象的对齐方式。 image-orientation 规定用户代理应用于图像的顺时针方向旋转。 page 规定元素应该被显示的页面特定类型。 size 规定页面内容包含框的尺寸和方向。 css 打印属性 关键字 说明 orphans 设置当元素内部发生分页时必须在页面底部保留的最少行数。 page-break-after 设置元素后的分页行为。 page-break-before 设置元素前的分页行为。 page-break-inside 设置元素内部的分页行为。 widows 设置当元素内部发生分页时必须在页面顶部保留的最少行数。 css 表格属性 关键字 说明 border-collapse 设置是否把表格边框合并为单一的边框 border-spacing 设置分隔单元格边框的距离 caption-side 设置表格标题的位置 empty-cells 设置是否显示表格中的空单元格 table-layout 设置显示单元、行和列的算法 css 文本属性 关键字 说明 color 文本颜色 direction 文本方向 unicode-bidi 对于行内元素，只有当 unicode-bidi 属性设置为 embed 或 bidi-override 时才会应用 direction 属性 line-height 文本行高 letter-spacing 与 word-spacing 的区别在于，字母间隔修改的是字符或字母之间的间隔 word-spacing 字（单词）之间的标准间隔 text-align 对齐元素中的文本 text-decoration 向文本添加下划线、删除线等 text-indent 文本缩进 text-shadow 设置文本阴影 text-transform 处理文本的大小写 white-space 处理空白符 hanging-punctuation 规定标点字符是否位于线框之外 punctuation-trim 规定是否对标点字符进行修剪。 text-align-last 设置如何对齐最后一行或紧挨着强制换行符之前的行。 text-emphasis 向元素的文本应用重点标记以及重点标记的前景色。 text-justify 规定当 text-align 设置为 \"justify\" 时所使用的对齐方法。 text-outline 规定文本的轮廓。 text-overflow 规定当文本溢出包含元素时发生的事情。 text-wrap 规定文本的换行规则。 word-break 规定非中日韩文本的换行规则。 word-wrap 允许对长的不可分割的单词进行分割并换行到下一行。 css 2D/3D 转换属性 关键字 说明 transform 向元素应用 2D 或 3D 转换。 transform-origin 允许你改变被转换元素的位置。 transform-style 规定被嵌套元素如何在 3D 空间中显示。 perspective 规定 3D 元素的透视效果。 perspective-origin 规定 3D 元素的底部位置。 backface-visibility 定义元素在不面对屏幕时是否可见。 css 过渡属性 关键字 说明 transition 简写属性，用于在一个属性中设置四个过渡属性。 transition-property 规定应用过渡的 CSS 属性的名称。 transition-duration 定义过渡效果花费的时间。 transition-timing-function 规定过渡效果的时间曲线。 transition-delay 规定过渡效果何时开始。 css 用户界面属性 关键字 说明 appearance 允许您将元素设置为标准用户界面元素的外观 box-sizing 允许您以确切的方式定义适应某个区域的具体内容。 icon 为创作者提供使用图标化等价物来设置元素样式的能力。 nav-down 规定在使用 arrow-down 导航键时向何处导航。 nav-index 设置元素的 tab 键控制次序。 nav-left 规定在使用 arrow-left 导航键时向何处导航。 nav-right 规定在使用 arrow-right 导航键时向何处导航。 nav-up 规定在使用 arrow-up 导航键时向何处导航。 outline-offset 对轮廓进行偏移，并在超出边框边缘的位置绘制轮廓。 resize 规定是否可由用户对元素的尺寸进行调整。 css 非标准属性 以下内容是非标准的一些属性，各家的浏览器支持效果可能会不一样。 有些是比较新的内容。笔记比较零星和凌乱。 -moz- 代表FireFox浏览器私有属性 -ms- 代表IE浏览器私有属性 -webkit- 代表safari、chrome浏览器私有属性 -o- 代表opera浏览器私有属性 // 对字体的锯齿进行调整 。 inherit、grayscale、antialiased -moz-osx-font-smoothing: grayscale; -webkit-font-smoothing: antialiased; // 告诉渲染引擎工作时如何优化显示文本 , auto | optimizeSpeed | optimizeLegibility | geometricPrecision | inherit text-rendering: optimizeLegibility; 腾讯小程序 小程序官方文档 我的小程序客户端示范代码 我的小程序服务器API代码 其他 css 禁止复制、禁止选择 、无法复制 { -webkit-box-sizing:border-box; user-select:none // 把这个去掉就可以选中并复制了 } ( no Copyright，enjoy youself ! ) all right reserved，powered by GitbookThe file was updated at : 2021-07-05 09:30:53 "},"chinese/人工智能/人工智能相关概念.html":{"url":"chinese/人工智能/人工智能相关概念.html","title":"人工智能","keywords":"","body":"基础概念 熵 就是对信息的不确定性，如果我们对一个信息掌握得好，对应的熵就会低，反之就高。信息熵是表示随机变不确定性的度量。熵越大，信息量越大，也就是越不确定。 拟合 形象的说，拟合就是把平面上一系列的点，用一条光滑的曲线连接起来。 因为这条曲线有无数种可能，从而有各种拟合方法。拟合的曲线一般可以用函数表示. 它是对我们数据点的一个近似表达。在开始阶段, 红线的表达能力不强, 误差很大。 不过通过不断的学习, 预测误差将会被降低. 所以学习到后来. 红线也能近似表达出数据的样子. 张量（Tensor) 零阶张量为 纯量或标量 (scalar) 也就是一个数值. 比如 [1] 一阶张量为 向量 (vector), 比如 一维的 [1, 2, 3] 二阶张量为 矩阵 (matrix), 比如 二维的 [[1, 2, 3],[4, 5, 6],[7, 8, 9]] 以此类推, 还有 三阶 三维的 … TensorFlow 通过 Anaconda 来安装 tensorFlow 和其他依赖的库。 然后用 pycharm 来进行编写代码。 pycharm里面的 python.exe 要指定为 Anaconda 里面的那个 python.exe 。（否则 无法 import tensorflow） ( no Copyright，enjoy youself ! ) all right reserved，powered by GitbookThe file was updated at : 2020-12-23 16:52:42 "},"chinese/面试真题/极飞.html":{"url":"chinese/面试真题/极飞.html","title":"面试真题","keywords":"","body":"广州极飞 1、二进制数 11101 转化为⼗进制数是多少? 2^0 + 0 + 2^2 + 2^3 +2^4 = 29 2、 声明⼀个类不能再被继承的关键字是() A.public B.abstract C.final D.static final 是最终的意思。被final修饰过的类不能被继承， 被final修饰过的函数不能被覆盖，被final修饰过的变量不能改值 3、以下关于Handler机制原理的说法错误的是() A、Android提供了Handler和Looper来满⾜线程间的通信。 B、Handler机制是遵循先进后出的原则。 C、Looper类⽤来管理待定线程内对象之间的消息交换（Message Exchange）， ⽽通过Handler对象可以与 Looper 进⾏沟通，以便push新消息到Message Queue⾥⾯， 或者接收Looper从MeaagesQueue取出的消息。 D、UI Thread通常就是Main Thread，⽽Android启动程序的时候就会替它建⽴⼀个Message Queue。 // B、先进先出 。 4、 以下关于Service的说法错误的是() A. Android中，Service有两种不同的使⽤⽅式： ⼀种是以启动⽅式使⽤Service（Started Service）， 另⼀种是以绑定⽅式使⽤Service（Bound Service）。 B. 需要在AndroidManifest.xml⽂件中注册，否则，Service根本⽆法启动。 C. 以绑定⽅式使⽤Service，能够获取到Service对象， 不仅能够正常启动Service， ⽽且能够调⽤正在运⾏中的Service实现的私有⽅法和属性。 D. 为了使Service⽀持绑定，需要在Service类中重写onBind()⽅法， 并在onBind()⽅法中返回Service对象 // C、无法调用私有方法和属性。 5、 进程间通信的⽅式有哪些？ 1、 Intent + Bundle bundle.putString(KEY ,\"xxxxx\"); 2、socket socket都可以实现网络通信，那么实现跨进程通信自然是ok的。开销大。 3、通过文件 通过对同一个文件进行读写来实现信息交互。 4、ContentProvider 可以让一个应用向其他应用暴露接口，提供数据。，可以说天生就是为进程通信而生的。 底层是Binder实现 。 5、BroadcastReceiver 通过广播播放实现单方面通知。 6、android.os.Messenger + Service 一个 server 运行在一个 apk 中 ， 另一个apk 绑定服务，发送和接收信息。 基于AIDL。串行通信。 7、AIDL 支持并发交互。 使用接口定义语言AIDL 来自定义规则使用Binder 。 例如ContentProvider就是官方给我们提供的一个使用案例，我们也可以使用AIDL来自己实现一个类似的。 补充：当作为客户的一方和要和作为服务器的一方进行通信时，需要指定一些双方都认可的接口， 这样才能顺利地进行通信。 而AIDL就是定义这些接口的一种工具。为什么要借助AIDL来定义，而不直接编写接口呢（比如直接通过Java定义一个Interface）？ 涉及到进程间通信（IPC）的问题。和大多数系统一样，在Android平台下,各个进程都占有一块自己独有的内存空间， 各个进程在通常情况下只能访问自己的独有的内存空间，而不能对别的进程的内存空间进行访问。 进程之间如果要进行通信，就必须先把需要传递的对象分解成操作系统能够理解的基本类型，并根据你的需要封装跨边界的对象。 而要完成这些封装工作，需要写的代码量十分地冗长而枯燥。因此Android提供了AIDL来帮助你完成这些工作。 6、 开启⼀个线程的⽅法有哪些？销毁⼀个线程的⽅法呢？ 不带返回值的方式 new MyThread().start(); new Thread(new Runnable() { @Override public void run() { } }).start(); 带返回值 FutureTask futureTask = new FutureTask(new Callable() { @Override public String call() throws Exception { Thread.sleep(3*1000); return \"I am the result !\"; } }) ; new Thread(futureTask).start(); // 执行子线程 // futrue.get() 去获取线程执行后的返回值。get()函数会导致当前线程阻塞，等待子线程执行完毕再往下走 Object object =futureTask.get(0 , TimeUnit.SECONDS) ; // 如果超时了，不会一直阻塞，挥抛出异常后继续往下走 7、多线程是否⼀定⽐单线程快，为什么？ 不一定比单线程快。如果多个线程需要用到一个公共的变量， 由于多个线程需要消耗更多的资源、切换线程需要时间，有可能还不如单线程快。 8、 什么是死锁？如何避免死锁 多个线程同时被阻塞，因为它们中的一个或者全部都在等待某个资源被释放。 //java 死锁产生的四个必要条件： 1、互斥使用，即当资源被一个线程使用(占有)时，别的线程不能使用。 2、不可抢占，资源请求者不能强制从资源占有者手中夺取资源，资源只能由资源占有者主动释放。 3、请求和保持，即当资源请求者在请求其他的资源的同时保持对原有资源的占有。 4、循环等待，即存在一个等待队列：P1占有P2的资源，P2占有P3的资源，P3占有P1的资源。 当上述四个条件都成立的时候，便形成死锁。当然，死锁的情况下如果打破上述任何一个条件，便可让死锁消失。 9、列举线程同步的⽅式 同步高开销，尽量减少同步的内容。一般同步关键代码（代码块）即可。 1、同步函数方法。 2、同步函数块 3、 使用系统api ReentrantLock //fair为true表示是公平锁 。默认非公平。 boolean fair= false ; ReentrantLock lock = new ReentrantLock(fair) ; if(lock.tryLock()) ;//如果已经被锁定了 就会忽略。不会等待。 if(lock.tryLock(5 , TimeUnit.SECONDS)) ;//如果被锁定了，就会尝试等待指定时长。如果还没有就放弃 lock.lock(); //如果已经被锁定了 ,会在此等待 lock.unlock();//释放锁 //tryLock和lockInterruptibly方法在申请锁的过程中是可以被中断的 . //如果线程被中断，抛出一个InterruptedException异常 lock.lockInterruptibly(); 4、 使用系统API LinkedBlockingQueue 多线程安全，每次只允许 一个线程去队列里面存放对象。 LinkedBlockingQueue outQueue = new LinkedBlockingQueue<>(Integer.MAX_VALUE); outQueue.put(msg); msg = outQueue.poll(); 5、可以使用Java Api AtomicXX 来实现同步。 因为根据java 定义，原子操作是不会被打断地的操作，因此被认为是线程安全的。 //原子更新数组类 int[]arrayInt ={1,30}; AtomicIntegerArray atomicIntArray = new AtomicIntegerArray(arrayInt); atomicIntArray.getAndSet(i, newValue); atomicIntArray.addAndGet(i, delta); //AtomicReferenceFieldUpdater 一个基于反射的工具类，它能对指定类的指定的volatile引用字段进行原子更新。(这个字段不能是private的) AtomicReferenceFieldUpdater updater= AtomicReferenceFieldUpdater.newUpdater(Dog.class,String.class,\"name\"); updater.compareAndSet(dog1,dog1.name,\"test\") ; //AtomicMarkableReference 是为解决CAS操作中潜在的ABA问题 设计的解决方案。 AtomicMarkableReference atomicMarkRef= new AtomicMarkableReference(\"StrMsg\", false) ; if(!atomicMarkRef.isMarked()) { atomicMarkRef.set(\"bbb\", true); }; 10、JVM内存结构。 分为6大块内存空间。 1、JVM栈，存放一个Java线程的运行状态 。 2、本地方法栈，存储本地方法执行过程中的栈数据。 3、程序计数器 当前线程所执行的字节码的行号指示器。 用来记录程序运行到哪里了，下一步又该执行哪一步操作。 4、堆，存放运行时产生的对象的。Java只能在堆中存放对象 。 5、直接内存。 既堆外内存。 内存对象分配在Java虚拟机的堆以外的内存，这些内存直接受操作系统管理，而不是虚拟机。 6、方法区。 方法区主要是用来存类型数据的，与类型相关的东西，比如常量，静态变量。 注：运行时常量池是方法区的一部分，用来存放编译器生成的各种字面量和符号引用。 11、 简单介绍Android平台单元测试的⽅法，列举常⽤的测试框架。 用得少。不太了解。 12、 列举你使⽤过或⽐较熟悉的设计模式。 单例模式、观察者模式等。 13、容量为5升和6升的瓶⼦怎么装出3升的⽔？ 假设A是5升的瓶 ，B是6升的瓶子。 A装满水倒入B，再用A装满水，倒入B，使得B装满。---> 此时A是4升，B是6升。 然后将B清空，---> 此时A是4升，B是0升。 将A中水倒入B，此时A是0，B是4。 继续装满A，从A中拿2升给B装满。---- > 此时A剩下3升。 14、如果让你写⼀个简单的⽂件传输APP，⽤于在两台⼿机之间传输⽂件 ⽐如将⼿机A相册⾥的照⽚，传输到⼿机B指定的⽬录，怎么设计数据传输的协议，说⼀说你的思路。 方案1：搭建ftp服务器。 方案2：利用手机api 开启WiFi热点，组成局域网，然后用socket进行文件传输。系统的api即可实现面对面快传。 如果要实现加密传输，可以基于socket进行自定义协议传输。 15、什么是JNI? 它主要⽤来⼲什么。 JNI (java native interface) , 通过JNI可以实现java和本地代码之间相互调用。 1、提高代码安全性。因为.so文件反编译困难。（加密一些算法等） 2、方便使用已经存在的c/c++库。可以加载 .dll 和 .so 格式的动态库。 3、提高某些特定情况下的执行效率。（c/c++的效率比java高。不过并不能明显提升android程序的性能） 16、输⼊⼀个字符串，打印出该字符串中字符的所有排列。 例如输⼊字符串abc，则输出由字符a、b、c 所能排列出来的所有字符串abc、acb、bac、bca、cab 和cba。 /** * 外部调用 * @param str abcd 等 */ public void permutation(String str) { char[] chars = str.toCharArray(); getResult(chars,0,str.length()-1 ); } /** * 第一步：可以先将字符串分为两部分，第一个字符和后面的字符。 * 第二步：求出所有可能出现在第一个位置的字符，然后再和后面的字符交换 。 * 第三步：固定第一个字符，然后求后面字符的排列，至于后面字符的排列,我们可以看作再次固定第一个字符，以此类推，用递归解决。 */ private void getResult(char[] chars,int start,int end ){ if(start==end){ //递归结束 System.out.println(\"---------stop= \"+ String.valueOf(chars) ); } else{ for(int i=start;i 17、 有⼀个X*Y的⽹格，⼩明要在此⽹格上从左上⻆到右下⻆。 只能⾛格点且只能向右或向下⾛。请设计⼀个算法，计算⼩明有多少种⾛法。 给定两个正整数int x,int y，请返回⼩名的⾛法数⽬。 /** * 若该格子位于第一行，则只能由左边的格子到达； return 1 * 若格子位于第一列，只能由上面的格子到达； return 1 * * 其他未知的格子：网格中的其他格子可以由左边的格子到达，也可以由上面的格子到达。 * f(x , y) = f(x - 1, y) + f(x , y - 1) */ public int getStep(int x,int y){ if( x==1 || y==1 ) { return 1 ; } return getStep(x-1, y) + getStep(x, y-1); } ( no Copyright，enjoy youself ! ) all right reserved，powered by GitbookThe file was updated at : 2021-06-07 11:17:16 "}}