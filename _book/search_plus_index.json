{"./":{"url":"./","title":"首页","keywords":"","body":"﻿本博客不保证完整性和正确性,请自行甄别。 左上角的 搜索功能 进行关键字搜索。 源码托管地址 https://gitee.com/hnyer/androidDev 博客分类 分类 http://hnyer.gitee.io/androidDev http://hnyer.gitee.io/nativeDev //cpp jni http://hnyer.gitee.io/webDev //web 前端 http://hnyer.gitee.io/backDev // 服务器搭建 http://hnyer.gitee.io/gameDev http://hnyer.gitee.io/pythondev http://hnyer.gitee.io/kotlindev http://hnyer.gitee.io/blockchainDev http://hnyer.gitee.io/flutter-dev https://blog.csdn.net/dengpanwen //CSDN https://hnyer.gitee.io //红尘之声 面试常见问题 [x] java 里带$的函数 是什么意思 [x] 非对称加密 、对称加密 [x] 硬件加速 是什么原理 [x] 进程优先级 [x] Android APP的 入口函数 在哪里 [x] 冷启动、热启动优化 [x] activity 启动模式 [x] Activity 生命周期有哪些，知道 onRestart 么； A启动B ，A的 onStop 一定会执行吗；按 Home 按键后的生命周期 [x] activity 启动另外一个activity的时候横屏切换再点击返回，过程中发生的生命周期 [x] Fragment#onHiddenChanged 是生命周期方法么？如何触发？ [x] Service的生命周期，两种启动方法，有什么区别 [x] 有什么工具可以看到 Activity栈信息么？多个栈话，有方法分别得到各个栈的Activity列表么 [x] Android中常用的设计模式，说三个比较高级的 [x] MVVM 、MVP [x] 如果用了一些解耦的策略，怎么管理生命周期的 [x] ANR 是怎么回事？怎么查？Service会引起 ANR 么 [x] TCP和UDP区别，TCP为何是三次握手，为何是四次挥手 [x] 为什么 Activity.finish() 之后 10s 才 onDestroy [ ] recycleview 原理 [ ] RecyclerView的特点和缓存 [ ] activity，Window，view的关系 [ ] activity有几个Window [ ] savedInstanceState知道么，干什么用的，什么时候有值，什么时候为空，平时是怎么用的 [ ] SharedPrefrences的apply和commit有什么区别 [ ] ragment的replace和end？？的区别 [ ] ACTION_CANCEL什么时候触发，触摸button然后滑动到外部抬起会触发点击事件吗，在+ + 滑动回去抬起会么 [ ] 怎么处理嵌套View的滑动冲突问题 [ ] 多模块开发的时候不同的负责人可能会引入重复资源，相同的字符串，相同的icon等但是文件名并不一样，怎样去重？ [ ] canvas lock的缓冲区是怎么回事 [ ] 有什么提高编译速度的方法 [ ] 想改变listview的高度，怎么做 [ ] Synchronize关键字后面跟类或者对象有什么不同。 [ ] 单例的DCL方式下，那个单例的私有变量要不要加volatile关键字，这个关键字有什么用 [ ] SparseArray和ArrayMap各自的数据结构，前者的查找是怎么实现的，与HashMap的区别 [ ] RecyclerView和ListView有什么区别？局部刷新？前者使用时多种type场景下怎么避免滑动卡顿。懒加载怎么实现，怎么优化滑动体验。 [ ] SQLite的数据库升级用过么 [ ] Scroller有什么方法，怎么使用的 [ ] webwiew了解？怎么实现和javascript的通信？相互双方的通信。@JavascriptInterface在？版本有bug，除了这个还有其他调用android方法的方案吗 [ ] Android 中Activity、Window、ViewRoot、DecorView之间的联系 [ ] View的分发机制，滑动冲突 [ ] 多线程如何实现？有哪些方式 线程池的参数 [ ] 你如何自己实现一个LRUCache？Android里面的LRUCache是如何实现的 [ ] synchronized和volatile的区别？为何不用volatile替代synchronized？类锁和对象锁互斥么 [ ] gcroot的类型 [ ] 动态代理的实现。 [ ] MeasureSpec讲一下 [ ] Application中可以显示Dialog么？为什么？ [ ] 泛型擦除，为何会有擦除？擦除的时机。通配符。 [ ] synchronized的同步原语 [ ] 讲一下锁，synchronized和Lock。CAS原理 [ ] IdleHandler调用时机 [ ] glide默认Bitmap的Config配置是ARGB_8888么 [ ] Android11有没有适配 [ ] HashMap讲一下，数据结构、hash过程、扩容、加载因子为何是0.75等。 [ ] 讲下Java的双亲委派 [ ] application中持有静态的用户信息，有何缺点？如何改进？ [ ] 单例的几种实现方式：DCL、enum，静态内部类。还有饿汉式。懒汉式的使用场景：占用内存大、延迟初始化 [ ] hashmap。hash冲突时给链表插入数据，1.7头插法，1.8尾插法。 [ ] ArrayMap和SparseArray的区别，实现。 [ ] 泛型：为何会有协变和逆变，PECS规则。 [ ] 自定义View的几种方式。onMeasure、onLayout、onDraw方法都何时需要重写。 [ ] 滑动冲突如何解决？有几种方式？具体从哪个事件开始拦截？在哪里拦截？比如双层ViewPager嵌套的滑动冲突如何解决。 [ ] Activity#setContentView中的xml文件是如何转化成View并显示到Activity中的。 [ ] PhoneWindow是在哪里初始化的 [ ] LayoutInflater是如何把xml布局文件转换成View对象的（反射）？View树如何生成的？怎么优化？ [ ] 为什么会有R文件这个映射表？直接使用资源的路径不好么？ [ ] dex文件结构了解过么？为何会有65535的限制？mutildex技术了解么？这项技术的目的是什么？ [ ] Window和Activity的对应关系。除了Activity还有别的方式显示Window出来么？ [ ] requestLayout调用后，都会调用哪些方法？ [ ] 绘制的数据是如何提交到远端的SurfaceFlinger [ ] ContentProvider具体实现。 [ ] binderService方法中的回调具体运行在哪个线程？binder线程池最大线程数是多少？自定义的Callback远程调用，运行在哪个线程？为何不是主线程，如果运行在主线程会有哪些问题？ [ ] 线程池如何配置，核心线程数你一般给多少 [ ] hdpi和xxhdpi的手机，分别加载xhdpi下的图片，会缩放图片么？如果会缩放，是如何缩放的，像素点是如何补全或者减少的？图片在内存中的大小会如何变化？ [ ] jetpack组件库使用过么？讲下具体组件 [ ] 函数式编程如何理解？ [ ] t1、t2、t3三个线程，如何让三个线程按照顺序依次打印1-100。 [ ] 悬浮窗如何实现 [ ] 通知的类别 [ ] android aidl oneway用法_ [ ] ANR的log中关键字是什么 [ ] 大图加载优化，原理。 [ ] Activity的onSaveInstance方法何时调用？它跟onPause、onStop的调用顺序如何？ [ ] 讲下你做过的首页优化。 [ ] 讲下leakCanary原理，为什么不用虚引用？引用队列里面存的是什么？ [ ] 方法内部的匿名内部类，比如说给View设置的OnClickListener，它里面相关调用外部方法的形参，必须使用final修饰这个形参，为何？ [ ] Android里面进程间通信方式，ContentProvider可以用file实现么？ [ ] 本地广播为何效率高？ [ ] 讲下synchronized和volatile；读写锁和ReentrantLock，synchronized和读写锁的区别。 [ ] 获取TextView的行数时，StaticLayout原理 [ ] MotionEvent#offsetLocation事件转发。 [ ] 为什么会多次调用onMeasure和onLayout方法？ [ ] 讲下onMeasure方法： [ ] ①如何测量 [ ] ②测量模式 [ ] ③入参为什么是int类型？ [ ] 讲下事件传递： [ ] ①总体流程 [ ] ②DOWN事件拦截后，后续事件如何处理？ [ ] ③dispatchTouchEvent方法返回true后事件如何处理？ [ ] Lock的实现，以及与synchronized的区别 [ ] GCRoot，举例说明。比如说Activity和它的匿名内部类Handler，分析下引用链，对应的gcroot是哪个？ [ ] 图片内存的计算。 [ ] ①在不影响图片质量的前提下，如何减少内存？ [ ] ②图片显示不全、变形怎么处理？ [ ] http和https： [ ] ①它们的区别：https多了tls层。对称加密和非对称加密。 [ ] Application启动流程 [ ] ContentProvider启动流程 [ ] 使用Application#onTrimMemory优化 [ ] 使用ActivityLifecycleCallbacks做了哪些事情？ [ ] 成员变量和局部变量的区别。为何成员变量需要jvm在对象初始话过程中赋默认值？ [ ] 讲下equals和hashcode，他们为何必须一起重写？ [ ] Parcelable和Serializable本质区别，不要说用法，说原理。 [ ] Activity和Fragment的通信方式；系统为何会设计Fragment#setArgument方法。 [ ] View绘制流程；requestLayout和invalidate区别；invalidate每次都会触发onDraw么？View#onLayout每次会触发么？ [ ] 屏幕适配方案；头条适配方案核心原理。 [ ] 如何上传数据？请求头关键字段和请求体格式 [ ] MediaPlayer能同时播放多个音频么？如果需要播放多个提示音，如何实现？ [ ] drawable下所以的格式都能转成webp么？哪些不能转？ [ ] 讲下arraylist、hashmap、linkedlist、linkedhashmap的实现。linkedhashmap为何会有这样的特性(lru)?它有个参数，表示命中率和使用次数。 [ ] lru是通过linkedhashmap实现的么？ [ ] 线程的使用。讲下线程池的类型，线程池对象的参数，线程池最大线程数和核心线程数的关系，task的优先级如何实现？（优先级队列） [ ] 讲下事件分发。如果onInterceptTouchEvent返回true，但是onTouchEvent返回了false，是什么效果？如果还想让其他View接收事件，该怎么做？ [ ] 大图加载；xhdpi的图片放到xxhdp的手机上，内存会如何变化；Bitmap内存复用 [ ] 网络优化，数据库优化 [ ] ThreadLocal，LocalBroadcastReceiver实现 [ ] binder的mmap [ ] Java内存模型 [ ] 说一说Android中如何查看一个对象的回收情况 ？ [ ] Apk的大小如何压缩 [ ] 如何通过Gradle配置多渠道包 [ ] Bitmap高效加载 [ ] 内存泄漏 [ ] 怎么获取view的宽高，如何确定值是准确的，说了view.post()补充 viewTreeObserverOnGlobalLayoutListener [ ] ARouter路由原理 [ ] 看视频的时候网络请求很慢怎么优化？ [ ] 说说HTTP3.0有什么改进？ [ ] 图片的三级缓存中,图片加载到内存中,如果内存快爆了,会发生什么？怎么处理？ [ ] 描述一次跨进程通讯 [ ] 首次 View 的绘制流程是在什么时候触发的？ [ ] ViewRootImpl 创建的时机？ [ ] ViewRootImpl 和 DecorView 的关系是什么？ [ ] DecorView 的布局是什么样的？ [ ] DecorView 的创建时机？ [ ] setContentView 的流程 [ ] LayoutInflate 的流程 [ ] Activity、PhoneWindow、DecorView、ViewRootImpl 的关系？ [ ] PhoneWindow 的创建时机？ [ ] 如何触发重新绘制？ [ ] requestLayout 和 invalidate 的流程 [ ] requestLayout 和 invalidate 的区别 非技术问题 [x] 代码质量如何控制 [x] 技术选型是如何做 [x] 如何提高线上代码质量 [x] 界面卡顿怎么排查和优化 ，何监测应用的 FPS [x] App上线后 用户使用时卡顿 ，怎么查看是什么原因 [ ] 如何进行单元测试，如何保证App稳定 无版权 可以无限制使用！ all right reserved，powered by Gitbook该文件更新时间： 2020-12-22 09:13:55 "},"chinese/doc/常用网站.html":{"url":"chinese/doc/常用网站.html","title":"常用网站","keywords":"","body":"常用网站 androidAPI android官方英文版 android官方中文版 民间组织-安卓中文组 android developer Java8 官方文档 谷歌开发者社区 lantern 蓝灯 翻墙 在线工具 国家企业信用信息公示系统 中国版权保护中心 git标签生成工具 shields.io 在线流程图工具 ProcessOn 代码高亮工具 tool oschina json格式化工具 正则表达式测试 在线图片压缩 Rar暴力破解 文本差异比较 行政区划分 GLSL在线编辑 Everything 电脑全局搜索 Snipaste 截图、贴图 ConEmu 比cmd好用的命令行工具 cports 端口查看工具 EVCapture录屏工具 AdvancedRenamer文件名批量相关 音频、视频、图片测试文件下载 磁力搜索 诗词文学地图 文字对比 数学公式 bmob 后端云 fir app 托管 抖音视屏去水印 二维码在线解析 草料二维码 UEditor 百度 UEditor 富文本 githubd github 代下载 汉字手写输入 小白 网盘搜索 鸠摩搜书 阿里云盘 网盘 \\frac{ h_{x} } { H_{当前设备高度} } = \\frac{600} {1920_{设计稿高度}} 博客、网站 可可英语 干货集中营 王垠的博客 wanandroid 代码家的博客 ~stormzhang的博客 掘金网 伯乐在线 猎云网 太平洋手机 人人都是产品经理 pmcaff python3基础语法 廖雪峰python3基础教程 崔庆才-静觅python博客 大鱼python博客 破解软件 福昕pdf 在阿里云盘 文档模板 mydocuments 无版权 可以无限制使用！ all right reserved，powered by Gitbook该文件更新时间： 2020-12-16 11:18:41 "},"chinese/doc/开发规范.html":{"url":"chinese/doc/开发规范.html","title":"开发规范","keywords":"","body":"开发规范 Android开发规范 阿里巴巴Android开发规范 1.0.0 类型 规范 示例 资源文件 需带模块前缀 layout文件 - Activity 的 layout以 module_activity开头Fragment 的 layout 以 module_fragment 开头Dialog 的 layout 以 module_dialog 开头include 的 layout 以 module_include 开头ListView 的 item layout 以 module_list_item 开头GridView 的 item layout 以 module_grid_item 开头RecyclerView 的 item layout 以 module_recycle_item 开头 drawable 资源 小写单词+下划线 module_tabs_icon_home_normal module_login_btn_pressed anim 资源 - module_fade_out module_push_down_in color 资源 module_colors.xml 《color name=\"module_btn_bg_color\">#33b5e5e5 dimen 资源 module_dimens.xml 《dimen name=\"module_horizontal_line_height\">1dp style 资源 module_styles.xml 《style name=\"ParentTheme.ThisActivityTheme\"》 string 资源 module_strings.xml moudule_login_tips module_homepage_notice_desc 控件Id 资源 驼峰法命名 View 的缩写作为前缀 LinearLayout  ll RelativeLayoutnbsp   rlConstraintLayout   clListView   lvScollView   svTextView   tvButton   btnImageView   ivCheckBox   cbRadioButton   rbEditText   et //其它控件ProgressBar    progress_bar DatePicker    date_picker 代码质量 控制 导致 代码质量问题 的原因 1、新手 ，经验和能力不足 2、人员的调动和更换，导致对业务的理解有偏差 3、没有一个约定的 代码规范 ，导致沟通和维护困难 如何保证代码质量 1、架构师搭建、设置 合理优秀的基础框架。 2、要求 开发者 单元测试、代码自测。bug率跟绩效挂钩。 3、代码 评审、复查、 review 代码提交后，由其他人 一般是水平更高的人来评审代码， 评审点可以放在 代码是否符合约定的代码规范、 设计思路和逻辑、性能 ， 必要时要进行重构，实行老人带动新人成长 一般而言， 采用 以小组为单位，组长责任制的代码复查形式。 小组长不要分配太多的开发任务，而是以指导设计、评审代码为主。 4、定期开总结大会，做分享，团队成员能力共同提高 技术选型 首先要确保一点：技术选型是稳定压倒一切、先验证后使用。 不稳定的技术或框架，在后期会带来很多的麻烦， 此项技术是否要被采纳，可以考虑以下因素 1、该技术是否成熟，是否已经被广泛应用和验证过。 一些技术随着开发版本的推进，API会大幅改变，甚至不再维护旧版本，导致旧版本中的BUG无人修复，逼迫你升级。 新技术可能会有很多未知的BUG，如果你深度使用后遇到一个Bug，你自己无法解决 也没人解决过，你会非常难受。 还有一些新技术可能会影响你的APP上架。 2、该技术是谁发起和主持的，权威性如何，后续更新如何，是否有版权风险。 可能会有一些技术精英会开源一个框架，但是并没有形成一个好的社区来维护，后期可能导致项目更新缓慢，甚至停更。 有些可能会慢慢地演化成开源版和收费版，你想要的功能只在收费版中提供。影响你的预算。 3、该技术的复杂性如何、学习成本 、以后替换的成本如何。 在一些工期比较紧的项目中，如果采用新技术，因为团队成员需要学习成本，可能无法把控开发进度。 4、使用该技术是否带来过多的冗余模块，对程序的健壮性是否有影响。 例如一些工具类想做得大且全，但是你引入它只是为了使用它的一个小模块，此时要好好考虑和验证下。 如果出现 依赖冲突、安装包增大等问题，你又对该技术不太熟悉，无法进行优化和排查， 会给项目带来很多不稳定因素。 5、对技术进行考虑时不仅仅要看到它的优点，更要看到它的不足点，改技术在宣传时，它一般是对缺点避而不谈的， 所以你要留心并验证。 如何 提高 线上代码 质量 1、上线前先做好本地测试，加入 bugly等获取异常信息，以便排查修复 2、支持热更新 ，无感知修复小bug 3、全局异常捕捉，防止APP崩溃。 无版权 可以无限制使用！ all right reserved，powered by Gitbook该文件更新时间： 2020-12-18 15:29:36 "},"chinese/常用软件/常用软件和框架.html":{"url":"chinese/常用软件/常用软件和框架.html","title":"常用软件和框架","keywords":"","body":"androidstudio androidstudio官网 Androidstudio 模板 ctrl + J 快速查看Live Templates 打开 *设置 -> Editor -> Live Templates* ，可以看到默认已经有很多 *Live Templates* 了 ，可以自己自定义。 导入原有的模板： 将文件替换即可 （C:\\Users\\kaifa4k\\.AndroidStudio2.2 是你自己的安装路径） C:\\Users\\kaifa4k\\.AndroidStudio2.2\\config\\templates 我用的模板 androidstudio 插件 安装或更新后插件后都需要重启Androidstudio 。 CodeGlance 代码快速定位 插件 Android-Resource-Usage-Count 显示 Android 资源使用的次数。 翻译插件ECTranslation 原理是调用了有道词典的API 。可以自定义 快捷方式，我目前设置的是 alt + m 快捷键设置 Preferences -> Keymap -> 搜索Translate - > 右键 add Keyboard Shortcut. 输入你想要的快捷键。 Android Parcelable code generator 自动生成 Parcelable接口相关的代码。 public class FtpThumDownListInfo implements Parcelable{ /**当前这个指针 指向的文件需要下载*/ private int gotoDownFileIndex = 0; /**需要下载的文件列表- 这个列表会分批次增加 */ private List ftpNeddLoadList =null ; /**下载好的文件的byte[]*/ private List ftpDowndBytesList =null ; //以下代码是 用插件自动生成的 start protected FtpThumDownListInfo(Parcel in){ this.gotoDownFileIndex = in.readInt(); this.ftpNeddLoadList = new ArrayList(); in.readList(this.ftpNeddLoadList, FTPFile.class.getClassLoader()); this.ftpDowndBytesList = new ArrayList(); in.readList(this.ftpDowndBytesList, FTPFile.class.getClassLoader()); } /** * 内容接口描述，默认返回0就可以了 */ @Override public int describeContents(){ return 0; } /** * 写数据进行保存 */ @Override public void writeToParcel(Parcel dest, int flags){ dest.writeInt(this.gotoDownFileIndex); dest.writeList(this.ftpNeddLoadList); dest.writeList(this.ftpDowndBytesList); } /** 实例化静态内部对象 * 接口对象名必须为CREATOR. * 必须按成员变量声明的顺序读取数据 */ public static final Parcelable.Creator CREATOR = new Parcelable.Creator() { @Override public FtpThumDownListInfo createFromParcel(Parcel source) { return new FtpThumDownListInfo(source); } @Override public FtpThumDownListInfo[] newArray(int size) { return new FtpThumDownListInfo[size]; } }; // 以下代码是 用插件自动生成的 end } //赋值 Bundle mBundle = new Bundle(); mBundle.putParcelable(\"picBean\",picBean); intentToMatch.putExtras(mBundle); //获取： RecommendPicBean picBean = (RecommendPicBean)getIntent().getParcelableExtra(\"picBean\"); 无线调试 ADB WIFI 华为M2 ，无Root 1、 确保电脑和手机在同一个局域网 2、插上USB线 连上adb 3、adb tcpip 5555 ( 5555为端口号，可自由指定） 4、adb connect 192.168.x.x:5555 EventBus、 缺点： 不容易跟踪调试代码。逻辑不是很连贯。 https://github.com/greenrobot/EventBus compile 'org.greenrobot:eventbus:3.1.1' // 绑定 @Override public void onStart() { super.onStart(); EventBus.getDefault().register(this); } // 解绑 @Override public void onStop() { super.onStop(); EventBus.getDefault().unregister(this); } // 发送 EventBus.getDefault().post(new MessageEvent()); // 接收 @Subscribe(threadMode = ThreadMode.MAIN) public void onEventBusMsgCome(WkEventBean bean) { switch (bean.getCode()){ case WkEventBean.CODE_1: String msg = (String) bean.getData() ; WkLog.d(\"UI received = \"+msg); break; default: break; } public class WkEventBean { public static final int CODE_1 = 1; public static final int CODE_2 = 2; public WkEventBean(int code , Object data){ this.code = code ; this.data =data ; } private int code ; private Object data ; public int getCode() { return code; } } git操作 配置全局信息 git config --global user.name \"aivin666@qq.com\" git config --global user.email \"aivin666@qq.com\" //查看当前用户信息 git config --list 添加个人私钥到网站 这种情况下无需配置密码 - window10下测试 1、生成对应的文件 ssh-keygen -t rsa -C 'aivin666@qq.com' 2、将 id_rsa.pub 里面的内容填写到网站上。 3、测试是否成功 。 ssh -T git@gitee.com 配置密码方式 Ubuntu下测试 https模式，每次提交都需要输入密码。 1、在一个新目录 初始化 git init 2、将远程代码拉倒本地 git pull https://gitee.com/hnyer/java_android.git 3、关联远程端仓库 master 是远程端的一个支路。 git remote add master https://gitee.com/hnyer/java_android.git // git remote rm master , 删除关联 4、 将本地指定的版本推送到远程端指定的版本 的一个maser是远程的 ，第二个是本地的 git push -u master master 5、以后不用每次都用参数 u ,直接 git push 即可 Ubuntu下 SSH 配置 码云 1、进入 /home/用户名/.ssh 目录下 生成公钥 ssh-keygen -t rsa -C \"your_email@example.com\" 2、将 id_rsa.pub 文件中的内容填入码云网站中 。 3、即可正常拉取 、提交 gitbook windows 安装gitbook 安装gitbook过程中请优先连接VPN，如果没有请考虑更换淘宝源等方式。 安装过程 可以参考 https://segmentfault.com/a/1190000005859901 npm install gitbook -g npm install -g gitbook-cli gitbook -V gitbook常用的使用命令 // 安装依赖包 gitbook install //新建定义好的文件 gitbook init // 本地服务器测试 gitbook serve // 编译成html格式 gitbook build 安装错误 如果遇到 “ Error: ENOENT: no such file or directory ... ” 这个错误 ， 把.gitbook\\versions\\3.2.2\\lib\\output\\website\\copyPluginAssets.js 修改成 confirm：false ！！！ ps 常用快捷键： 移动工具 V 裁剪工具 C shift+ctrl+alt+s 保存切片 放大视图 Ctrl+【+】 缩小视图 【Ctrl】+【-】 切图： ctrl + alt + shift + a 制作圆角矩形图片 参考资料 图片渐变、透明度渐变 参考资料 PS里怎么样将白色背景去掉，变成透明的背景？ 参考资料 要先解压图层锁定 打开图片，单纯白色背景的话则只需使用工具栏中的魔棒工具在白色部位点一下，跟着delete键删除，此时就是透明的背景图片了，但关键的是要选择合适的保存方式。点文件-存储为web和设备所用格式，在弹窗选择附图红框处的PNG格式就可以了。 方法一:用擦除工具组中的魔棒擦除,点选白色 方法二: 1、用选择工具中的魔棒工具选白色(勾选连续的). 2、然后反选,复制 3、再粘贴成新层 4、册掉背景层 5、完 xUtils https://github.com/wyouflf/xUtils3 compile 'org.xutils:xutils:3.5.0' // 1、在Application 初始化 // import org.xutils.x; x.Ext.init(this); x.Ext.setDebug(false); // get请求 private void loadData( ) { String API = Ipconfig.KEY_WORKNEWS_DetailItem; API = API.replace(\"{pageSize}\" ,\"10\") ; RequestParams params = new RequestParams(API); Callback.Cancelable cancelable = x.http().get(params, new Callback.CommonCallback() { @Override public void onSuccess(String result) { } @Override public void onError(Throwable ex, boolean isOnCallback) { } @Override public void onCancelled(CancelledException cex) { } @Override public void onFinished() { } }); } // post 请求 private void requestHost(String name, String pwd1 ) { String API = Ipconfig.KEY_userRegister; RequestParams params = new RequestParams(API); params.addBodyParameter(\"userName\",name); params.addParameter(\"password\",pwd1); x.http().post(params, new Callback.CommonCallback() { @Override public void onSuccess(String result) { } @Override public void onError(Throwable ex, boolean isOnCallback) { } @Override public void onCancelled(CancelledException cex) { } @Override public void onFinished() { } }); // 文件上传 String api =\"http://xxx\" ; RequestParams params = new RequestParams(api) ; params.setMultipart(true); params.addBodyParameter(\"userId\", MyApplication.getUserId(activity)); params.addBodyParameter(\"file\", new File( filePath)); Callback.Cancelable cancelable = x.http().post(params, new Callback.CommonCallback() { @Override public void onSuccess(String result) { } @Override public void onError(Throwable ex, boolean isOnCallback) { } @Override public void onCancelled(CancelledException cex) { } @Override public void onFinished() { } }); 虚拟机 VMware Workstation 12序列号 5A02H-AU243-TZJ49-GTC7K-3C61N RxJava 2.x 要在Android中使用RxJava2, 需要依赖 Rxjava2.x 、 RxAndroid 异步事件处理框架。 continued support for Java 6+ & Android 2.3+ 基于观察者设计模式。 RxJava1.x 跟 RxJava2.x 不能共存 ，会冲突。 RxJava组成元素 RxJava基本组成元素 说明 被观察者 数据源 发送数据 观察者 接收到（处理后的数据） 建立订阅关系 操作符 可以对数据进行过滤、转换等处理 线程切换 指定发送和接收的线程 RxJava 常用类 常用类 作用 Observable 被观察者 ObservableEmitter 用来发出事件的，它可以发出三种类型的事件 x.onNext() x.onComplete() x.onError() 发射规则如下： 1、上游可以发送无限个onNext ，下游也可以接收无限个onNext 2、当上游发送了一个onComplete后（只能发一次）, 上游onComplete之后的事件将会继续发送, 而下游收到onComplete事件之后将不再继续接收事件 3、当上游发送了一个onError后（只能发一次）, 上游onError之后的事件将继续发送, 而下游收到onError事件之后将不再继续接收事件 4、上游可以不发送onComplete或onError. 5、onComplete 和 onError 只能发送一个 , 不能都发送 ObservableOnSubscribe Observer 观察者 Disposable x.dispose() 切断订阅关系。 调用dispose()后 ，观察者接收不到数据，但是数据源还可以继续发送 CompositeDisposable Disposable 容器 x.add(...) x.clear() Flowable Rxjava2 新增的 。数据发送 。我们可以用Flowable + Subscriber 来解决 收发速度不一致问题 Subscriber 与Flowable搭配， 数据接收。 Subscription 切断订阅关系 Subscription.cancel() 观察者请求数据源发送多少个数据 subscription.request(Long.MAX_VALUE) FlowableEmitter 返回 观察者 能处理多少个数据 flowableEmitter.requested() Action BiConsumer BiFunction Predicate BiPredicate BooleanSupplier Cancellable Consumer Function Function3 Function4 Function5 Function6 Function7 Function8 Function9 IntFunction LongConsumer Schedulers 调度器。 当数据源和观察者在同一个线程时，这是一个同步的订阅关系 。 数据源每发送一个事件后必须等到观察者接收处理完了以后才能接着发送下一个。 当处于不同线程时 ,就是异步的订阅关系, 这个时候数据源可以自由发送数据。 //CPU计算密集型线程 默认线程数等于处理器的数量 Schedulers.computation() // 使用指定的Executor作为调度器 Schedulers.from() // io操作的线程 Schedulers.io() // 常规新线程 Schedulers.newThread() // Android主线程 AndroidSchedulers.mainThread() // 在当前线程执行 ，不过需要等队列中的其他任务完成后才执行 Schedulers.trampoline() BackpressureStrategy 背压策略 抗压力策略 背压是指在异步场景中，数据源发送事件速度远快于观察者的处理速度的情况下， 一种告诉 数据源 需要降低发送速度的策略 。 // 缓存区大小128，超过大小继续发就会报错 BackpressureStrategy.ERROR // 默认128，超过大小继续发就会 提示缓冲满了 BackpressureStrategy.MISSING // 默认大小128 ，大于128时就会修改为无限大。直到OOM BackpressureStrategy.BUFFER // 默认128 ，超过128后来的数据会被丢掉 BackpressureStrategy.DROP // 默认128 ，超过128就会只会保留最后的一个数据。 最后总个数 是 129 BackpressureStrategy.LATEST SingleEmitter 用来发射一条单一的数据，且一次订阅只能调用一次 singleEmitter.onSuccess() // onSuccess与onError只可调用一个 ，否则会报异常 singleEmitter.onError() Subject 主题 , 不支持背压控制 一种特殊的存在 ，同时是 数据接收者 和 发送者 AsyncSubject 无论输入多少参数，永远只输出最后一个参数 , 如果因为发生了错误而终止，AsyncSubject将不会发射任何数据 BehaviorSubject 会发送离订阅最近的上一个值，没有上一个值的时候会发送默认值。 如果遇到错误会直接中断 PublishSubject 一旦一个观察者订阅了该Subject，它会发送所有数据给订阅者。 如果接收者只关系自己订阅的信息 ，可以用ofType来过滤 订阅者只会接受订阅之后的来自PublishSubject发射的数据。 ReplaySubject 无论何时订阅，都会将所有历史订阅内容全部发出 Processor rxjava2.x新增的 ，作用与Subject一样 。 支持背压控制 AsyncProcessor BehaviorProcessor PublishProcessor ReplayProcessor Transformer 转换器 ， 实际上就是Func1， 换句话说就是提供给他一个Observable它会返回给你另一个Observable ObservableTransformer SingleTransformer CompletableTransformer FlowableTransformer MaybeTransformer RxJava2.0中的观察者模式 RxJava2.0中的观察者模式 说明 Observable / Observer 不支持背压，及无法处理发送数据速度不协调的问题。 Flowable/ Subscriber Single/ SingleObserver 只发射一条单一的数据，或者一条异常通知， 不能发射完成通知，其中数据与通知只能发射一个。 // 可以指定Schedulers实现异步处理 ，如果不被订阅是不会被调用的 Single.create // 接收传入的参数 ，是一种特殊的create() ，只会在当前线程里执行 , 不管是否被 订阅均会被调用 Single.just // 仅仅用来连接Single顺序执行的，比如顺序执行检查网络，检查内存 ，注意：如果某个Single调用了onError()会导致被中断 Single.concat // 将多个Single整合为一个 Single.zip // Observable.just().zipWith() //创建一个自定义的操作符，用来处理数据发送者 。 就是对当前Observable进行操作，然后再返回它 Single.compose // Single.subscribe // 返回一个错误， 一般用于调试 Single.error // 用于一对0~多的返回 Single.just( ... ).flatMap() // 一般map()是用于一对一的返回 Single.just( ).map() // 它支持将Single转化为Observable对象，可以返回多个值 Single.just( ).flatMapObservable() // 类似于concat ，如果有中断 ，后面都会中断 Single.merge() // Single.just().mergeWith() // 用于指定异步任务的线程 Single.just().subscribeOn() // 相当于try catch中的return，具体意思就是当函数抛出错误的时候给出一个返回值 Single.just().onErrorReturn() // 指定回调所在线程 Single.just().observeOn() // 超时设置 Single.just().timeout() // Single.just( ).toString() Completable/ CompletableObserver 只发射一条完成通知，或者一条异常通知， 不能发射数据，其中完成通知与异常通知只能发射一个 Maybe/ MaybeObserver 可发射一条单一的数据，以及发射一条完成通知， 或者一条异常通知，其中完成通知和异常通知只能发射一个， 发射数据只能在发射完成通知或者异常通知之前，否则发射数据无效。 RXjava2操作符 所谓的操作符就是一些被Rxjava封装好的方法或API ，使用这些操作符就可以完成线程调度，数据过滤等功能 。 操作符类型 说明 create() 创建被观察者对象 just() 快速的创建被观察者对象 fromArray() 将数组中的数据转换为Observable对象 fromIterable() 将List中的数据转换为Observable对象 empty() 用于测试 ，仅发送Complete事件 error() 用于测试 ，仅发送Error事件 never() 不发射数据，也永远不会结束 defer() 直到有观察者订阅时，才创建被观察者对象&发送事件 每次订阅后，都会得到一个刚创建的最新的Observable对象 timer() 延迟指定时间后，发送1个数值0 interval() 每隔指定时间就加n并发送出去 range() 连续发送一个事件序列，可指定范围 rangeLong() 跟 range()类似，支持数据类型为Long intervalRange() 每隔指定时间 就发送 事件，可指定发送的数据的数量 map() 将传入数据处理后返回 。 输入和输出是一对一 flatMap() 输入和输出可以是 一对多 不能保证 输出的顺序和输入的顺序一致 concatMap 输入和输出可以是一对对 输出和输入顺序 严格一致 buffer() 每次取n个事件放到缓存区中，n可配置 filter() 将符合自定义条件的事件过滤出来 ofType() 过滤 特定数据类型的数据 skip() 跳过正序的前 n 项 skipLast() 跳过正序的后 n 项 distinct() 去掉序列中重复的事件 distinctUntilChanged() 去掉序列中连续重复的事件 take() 指定观察者最多能接收到的事件数量 takeLast() 指定观察者只能接收到被观察者发送的最后几个事件 throttleFirst() 在某段时间内，只发送该段时间内第1次事件 throttleLast() 在某段时间内，只发送该段时间内 最后1次事件 sample() 指定时间内 取一次数据 ，其他的数据就会被丢掉 throttleWithTimeout() 在输出了一个数据后的一段时间内，没有再次输出新的数据， 则把这个数据真正的发送出去； 假如在这段时间内有新的数据输出，则以这个数据作为将要发送的数据项， 并且重置这个时间段，重新计时 debounce () 跟 throttleWithTimeout() 一样 firstElement() 仅选取第1个元素 lastElement() 仅选取最后一个元素 elementAt() 接收指定索引的某个元素 ， 索引越界也不会报异常 elementAtOrError() 接收指定索引的某个元素 ， 索引越界 会报异常 all() 判断发送的所有数据是否都满足自定义的条件 , true false takeWhile() 判断发送的每项数据是否满足 自定义条件 若满足条件则发送 ,不满足不发送 skipWhile() 一直跳过，直到满足自定义条件 skipUntil() - takeUntil() 一直发送 ，直到某个条件 sequenceEqual() 两个数据源的数据是否相同 isEmpty() 数据源的数据是否为空 contains() 数据源中是否包含指定数据 defaultIfEmpty( obj) 在不发送任何有效事件（ Next事件）、仅发送了 Complete 事件的前提下，发送个默认值obj amb() 当有多个数据源需要发送数据时 ， 只发送 先发送数据的Observable的数据，而其余 Observable被丢弃。 concat() 组合多个被观察者一起发送数据，合并后 按发送顺序串行执行 concatArray() 跟concat()类似 merge() 组合多个被观察者一起发送数据，合并后 按时间线并行执行 被观察者数量≤4 mergeArray() 被观察者数量 > 4 mergeWith() delay() 使被观察者延迟一段时间再发送事件 concatDelayError() 使用concat()，一旦某个被观察者发出onError事件，其他被观察者就会终止发送。 为了让其他被观察者继续发送，可以使用这个操作符 concatArrayDelayError() mergeDelayError() combineLatestDelayError() reduce() 把被观察者需要发送的事件聚合成1个事件、发送 collect() 将被观察者发送的数据事件收集到一个数据结构里 startWith() 在被观察者发送事件前，追加发送一些数据 startWithArray() count() 统计被观察者发送事件的数量 subscribe() 订阅， 连接观察者 和 被观察者 zip() 多个数据源Observable 发送数据，经过自定义组合处理后，观察者再收到 。 1、组合数据时严格按照顺序从多个数据源中拿数据。 2、最后观察者收到的数据个数 跟发送最少数据的数据源的数据个数相同。 x.zipWith() combineLatest() 如果子流1在等待其他流发射数据期间又发射了新数据， 则使用子流最新发射的数据进行合并 x.concatMap() x.scan() x.window() subscribeOn() 指定发送事件的线程 只有第一次指定有效，其余的指定线程无效 unsubscribeOn() 取消订阅 observeOn() 指定接收事件的线程 每次指定均有效 doOnEach() 每发送一次就会调用一次 doOnNext () 执行 next之前调用 doAfterNext() 执行 next之后调用 doOnError() doOnComplete() doOnTerminate() doFinally() doOnSubscribe() 观察者订阅时调用 onErrorReturn() 遇到错误时，发送1个特殊事件 & 正常终止 onErrorResumeNext() 拦截的错误 是Throwable 类型 onExceptionResumeNext() 拦截的错误 是 Exception类型 retry() 当捕捉到错误时，被观察者会重新发射数据 retryUntil() 遇到错误，重新发射，直到... retryWhen() repeat() 无条件地、重复发送事件 repeatWhen() repeatUntil() publish() share() connect() 补充知识点 链式调用 MsgInfo msgInfo = new MsgInfo(); // 链式调用 msgInfo.setOwnerId(\"100011002\") .setStatus(MsgInfo.Status.SENDING) .setTime(System.currentTimeMillis()); // 普通调用 msgInfo.setOwnerId(\"100011002\"); msgInfo .setStatus(MsgInfo.Status.SENDING) ; msgInfo .setTime(System.currentTimeMillis()); // 链式调用的关键在于方法的返回值！ public MsgInfo setStatus(int status) { this.status = status; // 注意返回的是 this return this; } Retrofit 2.x 一个支持 RxJava方式调用的网络请求框架 A type-safe HTTP client for Android and Java by Square, Inc. requires at minimum Java 7 or Android 2.3. Retrofit 提供2种风格的网络请求方式： 1、传统风格 (略过不看) 采用Callback 接口 2、RxJava 风格 (流行) 采用Observable接口 Retrofit2 + Rxjava2 依赖 // rxjava核心库 compile 'io.reactivex.rxjava2:rxjava:2.0.1' // Android 支持 Rxjava compile 'io.reactivex.rxjava2:rxandroid:2.0.1' // Android 支持 Retrofit compile 'com.squareup.retrofit2:retrofit:2.1.0' // 衔接 Retrofit & RxJava compile 'com.jakewharton.retrofit:retrofit2-rxjava2-adapter:1.0.0' // 支持Gson解析 compile 'com.squareup.retrofit2:converter-gson:2.1.0' 注解 作用 @GET get请求 @POST post请求 @DELETE delete请求 @HEAD head请求 @OPTIONS options请求 @PATCH patch请求 @Headers 添加请求头 @Path get请求 ，user/{password} 格式 @Query get请求 ， user/password?password=xxx 格式 @FormUrlEncoded 用表单数据提交 @Field post需要 post请求需要 ， 替换参数 //定义请求接口 public interface BlogService { /*** * get 方式 * https://www.aivin666.cn/AivinInfo/getAllMusicInfoGson?pageNum=2 */ @GET(\"getAllMusicInfoGson\") Call getBlogByGet(@Query(\"pageNum\") int pageNum); /*** * post 方式 * https://www.aivin666.cn/AivinInfo/getAllMusicInfoGson * @param pageNum 页码 */ @FormUrlEncoded @POST(\"getAllMusicInfoGson\") Call getBlogByPost(@Field(\"pageNum\") int pageNum); } //简单使用 Retrofit retrofit = new Retrofit.Builder() // url根目录 .baseUrl(\"https://www.aivin666.cn/AivinInfo/\") .build(); BlogService service = retrofit.create(BlogService.class); //Call call = service.getBlogByGet(2);//get方式 Call call = service.getBlogByPost(2);//post方式 call.enqueue(new Callback() { @Override public void onResponse(Call call, Response response) { try { String reslut = response.body().string(); tvHttpResult.setText(reslut); Log.i(TAG , reslut) ; } catch (Exception e) { } } @Override public void onFailure(Call call, Throwable t) { } }); Retrofit_RxJava_OkHttp Retrofit + RxJava + OkHttp Retrofit 负责请求的数据和请求的结果 RxJava 负责异步，各种线程之间的切换 OkHttp 负责请求的过程 添加依赖 // rxjava 核心库 compile 'io.reactivex.rxjava2:rxjava:2.1.14' // Android 支持 Rxjava compile 'io.reactivex.rxjava2:rxandroid:2.0.1' // retrofit 核心库 compile 'com.squareup.retrofit2:retrofit:2.4.0' // retrofit json 转换器 compile 'com.squareup.retrofit2:converter-gson:2.3.0' // 衔接 Retrofit & RxJava compile 'com.squareup.retrofit2:adapter-rxjava2:2.3.0' // okhttp 核心库 compile 'com.squareup.okhttp3:okhttp:3.10.0' // okhttp log 拦截器 compile 'com.squareup.okhttp3:logging-interceptor:3.8.1' 定义 订阅者 public class HttpSubscriber implements Observer { private PicInfoSubscriberListener subscriberOnListener; private Context context; private Disposable disposable; public HttpSubscriber( PicInfoSubscriberListener subscriberOnListener, Context context) { this.subscriberOnListener = subscriberOnListener; this.context = context; } @Override public void onSubscribe(@NonNull Disposable d) { disposable = d; } @Override public void onComplete() { if( (subscriberOnListener == null) || (context == null)) { if(disposable != null && !disposable.isDisposed()){ //切断订阅关系 disposable.dispose(); } } } @Override public void onError(Throwable e) { if(subscriberOnListener != null && context != null) { if (e instanceof SocketTimeoutException) { subscriberOnListener.onError(-1001, \"网络超时，请检查您的网络状态\"); } else if (e instanceof ConnectException) { subscriberOnListener.onError(-1002, \"网络链接中断，请检查您的网络状态\"); } else if(e instanceof MyException){ subscriberOnListener.onError(((MyException)e).getCode(), ((MyException)e).getMsg()); } else { subscriberOnListener.onError(-1003, \"未知错误:\" + e.getMessage()); } } else { if(disposable != null && !disposable.isDisposed()){ disposable.dispose(); } } } @SuppressWarnings(\"unchecked\") @Override public void onNext(T t) { if(subscriberOnListener != null && context != null) { // 收到想要的订阅信息 ，然后通过回到接口 发送到需要数据的地方 subscriberOnListener.onSucceed((List) t); } else { if(disposable != null && !disposable.isDisposed()){ disposable.dispose(); } } } } 定义 发布者 的能力接口 /** * 最终的访问地址是 主地址 + 尾地址 http://xxx/getAllPicInfoGson?pageNum=6 * 此处填写 尾地址 */ @GET(\"getAllPicInfoGson\") Observable> getPicListByGet(@Query(\"pageNum\") int pageNum ); @FormUrlEncoded @POST(\"getAllPicInfoGson\") Observable> getPicListByPost( @Field(\"pageNum\") int pageNum ); 封装发布者 /** * 封装 图片模块的http接口 */ public class PicInfoApi { private final String TAG=\"PicInfoApi\" ; private static PicInfoApi picInfoApi; private PicInfoService picInfoService; private PicInfoApi() { final String BASE_URL_PANDA = \"https://www.aivin666.cn/AivinInfo/\"; picInfoService = HttpClient.getInstance(BASE_URL_PANDA).createApi(PicInfoService.class); } public static PicInfoApi getInstance() { if(picInfoApi == null) { picInfoApi = new PicInfoApi(); } return picInfoApi; } public void getPicListByGet (Observer >subscriber , int pageNum) { // 通过操作符 map(...) 将接收的数据经过处理后再返回 Observable observable = picInfoService.getPicListByGet(pageNum) .flatMap( function ); // 将观察者 和订阅者 关联起来 toSubscribe(observable, subscriber); } public void getPicListByPost (Observer> subscriber , int pageNum) { // 通过操作符 map(...) 将接收的数据经过处理后再返回 Observable observable = picInfoService.getPicListByPost(pageNum) .flatMap( function ); // 将观察者 和订阅者 关联起来 toSubscribe(observable, subscriber); } private void toSubscribe( Observable> o, Observer> s){ // 运行在 io 线程中 o.subscribeOn(Schedulers.io()) // 取消订阅 .unsubscribeOn(Schedulers.io()) // 指定接收事件的线程 .observeOn(AndroidSchedulers.mainThread()) // 订阅 .subscribe(s); } /*** * 配合 操作符 map 使用 * Function, List> 第一个参数是输入数据类型 ， 第二个参数是输出类型 * List apply(List list) * 第一个 List 是返回数据类型 ， 第二个 List 是输入的数据类型 * */ private Function function = new Function, Observable > >() { @Override public Observable > apply(List list) throws Exception { // 可以在这个函数里面进行数据过滤等处理 if(list != null && list.size() > 0) { Log.i(TAG , \" 数据处理=\"+ list.size()) ; }else{ Log.i(TAG , \" 数据处理 没有获取到数据\") ; } return Observable.fromArray(list) ; } }; 进行http访问的相关配置 public class HttpClient { private static String token = \"\"; private static Retrofit retrofit; private static HashMap clients = new HashMap<>(); private HttpClient(String url) { retrofit = new Retrofit.Builder() // 设置接口主地址 .baseUrl(url) // 配置 HTTP 请求客户端 .client(getHttpRequestClient()) // 配置json 转换器 .addConverterFactory(GsonConverterFactory.create()) // 添加支持 - 返回值定义为Observable对象 .addCallAdapterFactory(RxJava2CallAdapterFactory.create()) .build(); } public T createApi(Class clazz) { // 获取接口实例 return retrofit.create(clazz); } public static HttpClient getInstance(String url){ if(!clients.containsKey(url)) { HttpClient httpClient = new HttpClient(url); clients.put(url, httpClient); } // 一个主地址 对应一个client return clients.get(url); } /** * 定制 http 访问访问器 */ private OkHttpClient getHttpRequestClient() { HttpLoggingInterceptor logging = new HttpLoggingInterceptor( new OkHttpLogTool()); // 打印获取到的信息。 （不设置不打印） logging.setLevel(HttpLoggingInterceptor.Level.BODY); //设置缓存路径 String cacheDir = MyApplication.getInstance().getExternalCacheDir().getAbsolutePath() ; File httpCacheDirectory = new File(cacheDir , \"OKHttpResponses\"); //设置缓存 大小 Cache cache = new Cache(httpCacheDirectory, 50 * 1024 * 1024); // 自定义拦截器 Interceptor interceptor = new Interceptor() { @Override public Response intercept(Chain chain) throws IOException { Request request = chain.request() .newBuilder() .addHeader(\"token\", token) .build(); // 无网络时 ，使用缓存 if (!NetUtil.isNetworkConnected(MyApplication.getInstance())) { request = request.newBuilder() .cacheControl(CacheControl.FORCE_CACHE) .build(); } Response response = chain.proceed(request); if (NetUtil.isNetworkConnected(MyApplication.getInstance())) { // 有网络时 设置缓存超时时间0个小时 int maxAge = 0 * 60; response.newBuilder() .addHeader(\"Cache-Control\", \"public, max-age=\" + maxAge) // 清除头信息，因为服务器如果不支持，会返回一些干扰信息，不清除下面无法生效 .removeHeader(\"Pragma\") .build(); } else { // 无网络时，设置超时为1周 int maxStale = 60 * 60 * 24 * 7; response.newBuilder() .addHeader(\"Cache-Control\", \"public, only-if-cached, max-stale=\" + maxStale) .removeHeader(\"Pragma\") .build(); } return response; } }; OkHttpClient httpClient = new OkHttpClient.Builder() .addInterceptor(logging) .cache(cache) .addInterceptor(interceptor) .build(); return httpClient; } } 如何使用 private int pageNum = 6 ; private void testUrlGet() { PicInfoApi.getInstance().getPicListByGet( new HttpSubscriber>(new PicInfoSubscriberListener () { @Override public void onSucceed(List data) { // 获取到数据 } @Override public void onError(int code, String msg) { } }, this) , pageNum); } private void testUrlPost( ) { PicInfoApi.getInstance().getPicListByPost( new HttpSubscriber>(new PicInfoSubscriberListener () { @Override public void onSucceed(List data) { } @Override public void onError(int code, String msg) { } }, this) , pageNum); } Hierarchyviewer 检验手机是否开启了View Server： adb shell service call window 3 //View Server处于关闭状态 返回：Result: Parcel(00000000 00000000 '........')\" //View Server处于开启状态 返回值：Result: Parcel(00000000 00000001 '........')\" 借助ViewServer这个工具可以在任何手机上使用 hierarchyviewer。 注：在 android device monitor 可以找到 hierarchyviewer。 react-native Windows下搭建React Native Android开发环境 //需要安装软件 1、python2.x 2、node.js 3、react-native-cli npm install -g yarn react-native-cli 4、webstorm 主流IED之一 5、android开发环境 jdk 、sdk之类的。为了方便可以通过通过Androidstudio来下载sdk。 开发过程用 webstorm即可。 //初始化项目 react-native init 你的项目名字 如果出现新建失败，可以尝试切换成淘宝源 npm config set registry https://registry.npm.taobao.org npm config set disturl https://npm.taobao.org/dist //安装新模块 npm install xxxxxx --save 安装成功后，库的依赖信息配置到package.json里面，具体内容被下载到node_module文件夹中。 //安装apk 在连接好设备的前提下 react-native run-android //调试项目(debug模式才能) 1、adb shell input keyevent 82 打开调试窗口。 2、手机和电脑处于同一个局域网，确保能互相ping通。 3、电脑浏览器填写 http://localhost:8081/debugger-ui/（用ip会遇到跨域方面的错误）。 手机APP上要填写电脑的ip。（192.168.2.170:8081） 启动react native 服务，如果出现默认端口8081被占用的情况，可以指定端口。 react-native start --port 9999 测试是否启动成功 http://localhost:9999/index.android.bundle?platform=android http://localhost:9999/ 查看版本、修改版本 //查看本地版本 react-native --version //查看最新版本 npm info react-native //在package.json文件中修改成对应版本 \"react-native\": \"^0.55.4\" //重新安装 npm install 项目结构说明 android 是一个可以用 Androidstudio 打开的android项目 ios ios项目 index.js 打包 app 时进入 react native（js 部分） 的入口文件 App.js 可以理解为 react native（js 部分） 代码部分的入口文件 app.json 项目说明，主要给原生 app 打包用 package.json 项目依赖包配置文件 node_modules 依赖包安装目录 yarn.lock yarn包管理文件 常用类和方法解释 常用类和方法 说明 ReactActivity 默认所有的Activity都继承它 ReactNativeHost ReactActivityDelegate ReactActivity的逻辑代理实现 ReactRootView React NativeUI的所在 ReactInstanceManager XReactInstanceManagerImpl ReactContext 管理React Native的状态等 NativeModule 继承它的module可以在js端使用 Callback／Promise 回调接口，与js端交互 ReactNativeHost Simple class that holds an instance of ReactInstanceManager . ReactInstanceManager ?? ReactPackage 可以看作是，向ReactNative注册了原生模块，这样在JS中你也可以使用原生模块的功能. NativeModule A native module whose API can be provided to JS catalyst instances SoLoader To load a native library getJSMainModuleName() Returns the name of the main module. Determines the URL used to fetch the JS bundle from the packager server . Props 、属性 大多数组件在创建时就可以使用各种参数来进行定制。用于定制的这些参数就称为props 。 props是内置的一个关键字 属性是不可以变的，一般用来传值 点击事件 onPress={this._onPressButton} _onPressButton() { Alert.alert('You tapped the button!') } State 、状态 state是系统关键字 一切界面变化都是状态state变化引起的 state的修改必须通过setState()方法，其他方式无效 setState 只修改指定属性，并不影响其他没有指定的属性 setState 是异步操作，修改不会马上生效 样式 style是系统关键字 实际开发中组件的样式会越来越复杂， 我们建议使用StyleSheet.create来集中定义组件的样式。 弹性宽高 flex 理解参考android的权重比例。 flex 是系统关键字 一般使用flex:1来指定某个组件扩张以撑满所有剩余的空间。 并列的子组件的flex值越大，占用的空间比例就越大。 如果没有指定 flex 和 width、height ，容器尺寸就会为0 ，无法显示。 组件 文本输入框 TextInput placeholder // 提示 onChangeText //监听内容变化 onSubmitEditing //监听提交 弹性布局 Flexbox Flexbox规则可以在不同屏幕尺寸上提供一致的布局结构。 // flexDirection 主轴的方向 (row 、column) flexDirection: 'column' // justifyContent 子元素沿着主轴的排列方式 (flex-start 、center、flex-end、space-around、space-between 、 space-evenly) justifyContent: 'space-evenly' //alignItems 决定其子元素沿着次轴的排列方式 (flex-start、center、flex-end 、 stretch) alignItems: 'flex-end' 滚动视图 ScrollView 可以横向或纵向滚动 普通长列表 FlatList data //数据源 renderItem //每一行的视图 带分组的 长列表 SectionList sections // 数据源 renderItem // 每一行的视图 renderSectionHeader //每一个组头的视图 keyExtractor //此函数用于为给定的item生成一个不重复的key。Key的作用是使React能够区分同类元素的不同个体 网络访问框架 Fetch react native 内置支持 XMLHttpRequest（ajax）和 fetch框架 。推荐使用fetch。 react native 不支持jQuery 。因为jQuery包含了一些 react native 没有的东西。 无版权 可以无限制使用！ all right reserved，powered by Gitbook该文件更新时间： 2020-08-26 10:34:21 "},"chinese/数据结构/常用数据结构.html":{"url":"chinese/数据结构/常用数据结构.html","title":"常用数据结构","keywords":"","body":"常用数据结构 Hash 、Hash碰撞 // Hash 是一种信息摘要算法，一般用于验证完整性，它还叫做哈希、散列。我们平时使用的MD5,SHA1,SSL中的公私钥验证都属于Hash算法。 // Hash碰撞 好的Hash算法可以出计算几乎出独一无二的HashCode，如果出现了重复的hashCode，就称作碰撞; 不过就算是MD5这样优秀的算法也会发生碰撞，即两个不同的key也有可能生成相同的MD5。 哈希表 Hashtable Hashtable 和 HashMap 的内部数据结构相似。 // HashMap 和 Hashtable 的区别 Hashtable 已经被淘汰了,不用关注太多细节。 知道以下几个区别就好了。 1、HashMap可以允许key为null，value为null，Hashtable 都不允许为null 。 2、HashMap 没有提供同步机制，是线程不安全的，需要自己在外面写同步代码，Hashtable 部分方法上有自己的 synchronize 同步，是线程安全的。 3、父类不一样 ， 各自拥有的方法不完全一样 ， 扩充机制不一样 。 HashMap Hashtable和HashMap的内部数据结构相似. HashMap由数组+链表组成的，数组是HashMap的主体，链表则是主要为了解决哈希冲突而存在的。 HashMap中的链表出现越少，性能才会越好。当链表较长时，又会引入红黑树来解决性能问题。 // HashMap存储的步骤put（K,V） 传入key和value，计算key的hash值，根据hash值搜索在哈希表table中的索引位置， 若当前索引位置不为null，则对该位置的Entry链表进行遍历， 如果链中存在该key，则用传入的value覆盖掉旧的value，同时把旧的value返回。 入股链中不存在该key，就用key-value创建一个新的节点，并把该节点插入到该索引对应的链表的头部 // HashMap 如何解决 Hash碰撞问题的 根据不同的key 计算得到 hash值，如果有碰撞，就进入当前hash值索引对应的 链表中， 在同一条链表中 根据 不同的 key 来存储不同的 value值。 // HashMap的读取实现get（key，value） 读取的步骤比较简单，调用hash（key）求得key的hash值，然后调用indexFor（hash）求得hash值对应的table的索引位置，然后遍历索引位置的链表，如果存在key，则把key对应的Entry返回，否则返回null // HashMap键的遍历，keySet() HashMap遍历时，按哈希表的每一个索引的链表从上往下遍历。 // 缺点 1、在移动设备端内存资源很珍贵，HashMap为实现快速查询带来了很大内存浪费。 2、ArrayMap是非线程安全的类 。 android 对 HashMap 的优化 ArrayMap ArrayMap是Android api提供的 ，Android里的Bundle内部就是ArrayMap 。 ArrayMap有两个数组 。第一个数组存放存放item的hash值，第二数组是把key，value连续的存放在数组里， 通过先算hash在第一个数组里找到它的hash index，根据这个index在去第二个数组里找到这个key-value。 // ArrayMap 如何解决哈希碰撞问题的。（以下结论是我猜测的） 1、存储 如果产生了相同的哈希值了，如果他的key是相同的，就把key对应的value修改。如果key 不同，就会把当前哈希值也保存在哈希数组中(此时数组中有相同的哈希值)。 2、读取 由于存在hash碰撞的情况，而二分法查找到下标可能是多个连续相同hash值中的任意一个， 所以此时需要用equals比对对命中的Key对象是否相符，不相符时，从当前index先向后再向前遍历所有相同hash。 3、注意比较 与 HashMap解决哈希冲突方法的区别。 // 比 HashMap 更省内存。 ArrayMap 相对于 HashMap ，无需为每个键值对创建Node对象， 这就是为什么ArrayMap相对HashMap要节省空间。 // 缺点 1、ArrayMap查找时间复杂度O(logN)；HashMap查找、修改的时间复杂度为O(1)； 2、ArrayMap增加、删除操作需要移动成员，速度相比较慢 。 SparseArray 在 Android 中，IDE会提醒我们应该使用 SparseArray 替换掉 HashMap，其根本原因就在于 SparseArray 相比较 HashMap 会更省内存。 // 更省内存 1、SparseArray 对应的key只能是int类型，它不会对key进行装箱操作。 所以比 HashMap 更省内存。 2、SparseArray 不需要保存key所对应的哈希值，所以比 ArrayMap 更省内存。 // SparseArray 的 延迟回收 机制 当执行delete()或者removeAt()删除数据的操作，只是将相应位置的数据标记为DELETE，并设置mGarbage=true，而不会直接执行数据拷贝移动的操作。 比如删除某个数据后被标记删除，接着又需要在相同位置插入数据，则不需要任何数组元素的来回移动操作。所以SparseArray适合频繁删除和插入来回执行的场景。 栈 手写代码实现一个栈。 1、用数组实现 通过移动下标来模拟。 2、使用系统的 LinkedList 来实现。 Deque queue = new LinkedList(); queue.addFirst(e); queue.removeFirst(); 3、自己模拟单链表 实现栈 。 sample没有考虑线程安全等细节，只是简洁地展示关键思想 // 栈节点 public class Node{ public Object data;/**数据*/ public Node next ;/**下一个节点*/ public Node(Object data ,Node next) { this.data=data ; this.next =next; } } public class MyStack{ /**栈顶节点*/ private Node topNode ; /**栈大小*/ public int stackSize; // 入栈 public void push(Object data){ Node newNode = new Node(data, topNode);//新节点 topNode= newNode ; //对外公布 新栈顶元素 stackSize++ ; } // 出栈 public void pop() { Node temp= topNode ;//需要出栈的节点 topNode = temp.next ;//对外公布 新的栈顶元素 stackSize-- ; } /**打印该栈所有元素*/ public void showStackInfo() { Node temp =topNode ; if(temp==null) { System.out.println(\"空栈\"); return ; } while(temp !=null ) { System.out.println(\"栈节点值=\"+ temp.data); temp = temp.next; } } } // 测试 public static void main(String[] args){ MyStack myStack = new MyStack(); myStack.showStackInfo(); myStack.push(1) ; myStack.push(2) ; myStack.showStackInfo(); myStack.pop(); myStack.showStackInfo(); } 队列 队列的特点是“先进先出”。 阻塞队列 与普通队列的区别在于：当阻塞队列为空时，从队列中获取元素的操作将会被阻塞，或者当队列是满时，往队列里添加元素会被阻塞。 阻塞双端队列 指允许两端都可以进行入队和出队操作的阻塞队列。 常用队列 特点 常用方法 安全性 LinkedBlockingQueue 基于链表的单向队列 线程安全 LinkedBlockingDeque 基于链表的双端队列 interface BlockingQueue extends Queue ... interface BlockingDeque extends BlockingQueue , Deque {... class LinkedBlockingDeque ... implements BlockingDeque {... class LinkedBlockingQueue implements BlockingQueue... 无版权 可以无限制使用！ all right reserved，powered by Gitbook该文件更新时间： 2020-09-25 09:42:49 "},"chinese/android基础/常用代码块.html":{"url":"chinese/android基础/常用代码块.html","title":"常用代码块","keywords":"","body":"常用代码片段 数组操作 list去重 将重复值去掉，同时不能破坏现有的顺序。 private List removeDuplicate(List list) { Set set = new HashSet(); List newList = new ArrayList(); for (String str : list) { // 借助set的特性 if (set.add(str)) { newList.add(str); } } return newList; } String 操作 字符串切割 String [] array= myString.split(\"[.]\"); 分割字符 表达 . \"[.]\" | \"\\\\|\" * \"\\\\*\" \\ \"\\\\\\\\\" [ \"\\\\[\" ] \"\\\\]\" String 简单格式化 return String.format(\"bookId= %s, bookName=%s]\", bookId, bookName); 代码超时 函数超时、 执行超时、等待超时、连接超时 final ExecutorService exec = Executors.newFixedThreadPool(1); Callable call = new Callable() { public String call() throws Exception { // 耗时操作... Thread.sleep(1000 * 3); return \"执行结果(成功或失败)\"; } }; try { Future future = exec.submit(call); // 超时时间 设置 String result = future.get(1000 * 5, TimeUnit.MILLISECONDS); System.out.println(\"执行未超时:\" + result); } catch (TimeoutException ex) { System.out.println(\"处理超时\"); ex.printStackTrace(); } catch (Exception e) { System.out.println(\"处理失败.\"); e.printStackTrace(); } exec.shutdown(); } 对象排序 Collections.sort(mBeanList, new Comparator() { @Override public int compare(MyBean bean1, MyBean bean2) { // 按照对象属性排序 return = bean1.xx - bean2.xx; } }); 数组操作 数组相等 Arrays.equals(myArray, NSS_MSG_TYPE_GET_MAIN_STREAM); 数组打印 System.out.println(Arrays.toString(myArray)); 数组扩容 public String [] getNewArrayWithMoreSpaceString( String [] oldArray ,String [] increceData){ String [] lastArray=new String[oldArray.length+increceData.length]; //数组复制 System.arraycopy(oldArray, 0, lastArray, 0, oldArray.length); System.arraycopy(increceData, 0, lastArray, oldArray.length+1, increceData.length); return lastArray ; } byte[]相关 byte[]和基础数据互转 例如一个32位long数据，0x12345678: 0x12345678 高字节 -----------------> 低字节 内存低地址 -----------------> 内存高地址 大端模式 0x12 0x34 0x56 0x78 //符合人的直观认识 小端模式 0x78 0x56 0x34 0x12 // int 转为 byte byte intTo1ByteHex(int intVaue ){ return Integer.valueOf(intVaue & 0xff).byteValue(); } // byte 转 int int bytes1ToInt(byte src) { return src & 0xFF; } // int 转 byte[4] ,大端模式 byte[] intTo4ByteBig(int n) { byte[] b = new byte[4]; b[3] = (byte) (n & 0xff); b[2] = (byte) (n >> 8 & 0xff); b[1] = (byte) (n >> 16 & 0xff); b[0] = (byte) (n >> 24 & 0xff); return b; } // int 转 byte[4],小端模式 byte[] intTo4ByteLittle(int n) { byte[] b = new byte[4]; b[0] = (byte) (n & 0xff); b[1] = (byte) (n >> 8 & 0xff); b[2] = (byte) (n >> 16 & 0xff); b[3] = (byte) (n >> 24 & 0xff); return b; } // byte[4] 转int ，小端模式 int bytes4ToIntLittle(byte[] bytes ) { int int1=bytes[0]&0xff; int int2=(bytes[1]&0xff)> 8 & 0xff); return b; } // short 转 byte[2] ，小端模式 byte[] shortTo2ByteLittle(short n) { byte[] b = new byte[2]; b[0] = (byte) (n & 0xff); b[1] = (byte) (n >> 8 & 0xff); return b; } // byte[2] 转 short ,小端模式 short byte2ToShortLittle(byte[] b) { return (short) (((b[1] > 56)); b[6] = (byte) (0xff & (value >> 48)); b[5] = (byte) (0xff & (value >> 40)); b[4] = (byte) (0xff & (value >> 32)); b[3] = (byte) (0xff & (value >> 24)); b[2] = (byte) (0xff & (value >> 16)); b[1] = (byte) (0xff & (value >> 8)); b[0] = (byte) (0xff & value); return b; } // double 转 byte[8] ,大端模式 byte[] doubleTo8Bytes_Big(double d){ long l = Double.doubleToLongBits(d); byte[] b = new byte[8]; b[0] = (byte) (0xff & (l >> 56)); b[1] = (byte) (0xff & (l >> 48)); b[2] = (byte) (0xff & (l >> 40)); b[3] = (byte) (0xff & (l >> 32)); b[4] = (byte) (0xff & (l >> 24)); b[5] = (byte) (0xff & (l >> 16)); b[6] = (byte) (0xff & (l >> 8)); b[7] = (byte) (0xff & l); return b; } /** * byte[8] 转 double */ double bytes8ToDouble(byte[] bytes, boolean littleEndian) { ByteBuffer buffer = ByteBuffer.wrap(bytes,0,8); if(littleEndian){ buffer.order(ByteOrder.LITTLE_ENDIAN); }else{ buffer.order(ByteOrder.BIG_ENDIAN); } long l = buffer.getLong(); return Double.longBitsToDouble(l); } 获得校验位 /* 只保留低八位，高位舍去。 P1=s/256; //整除高8位 P0=s%256; //取余是低8位 */ public static byte[] getVerifyValue(byte [] lastBytes){ byte checksum = 0; for (int i = 0; i = 0; i--) { array[i] = (byte)(b & 1); b = (byte) (b >> 1); } return array; } // byte[] 转换成十六进制字符串 ,方便打印查看 String byte2HexStr(byte[] b){ String stmp ; StringBuilder sb = new StringBuilder(\"\"); for (int n = 0; n 文件操作 获得指定文件的byte数组 public byte[] getBytesFromFile(File file){ byte[] buffer = null; try { if(!file.exists()){ file.createNewFile(); } FileInputStream fis = new FileInputStream(file); ByteArrayOutputStream bos = new ByteArrayOutputStream(1000); byte[] b = new byte[1000]; int n; while ((n = fis.read(b)) != -1) { bos.write(b, 0, n); } fis.close(); bos.close(); buffer = bos.toByteArray(); } catch ( Exception e) { e.printStackTrace(); } return buffer; } 根据byte数组，生成文件 public void getFileFromBytes(byte[] bfile, File file ,boolean isAppend){ BufferedOutputStream bos = null; FileOutputStream fos = null; try { fos = new FileOutputStream(file ,isAppend); bos = new BufferedOutputStream(fos ); bos.write(bfile); } catch (Exception e) { e.printStackTrace(); } finally { if (bos != null) { try { bos.close(); } catch (IOException e1) { e1.printStackTrace(); } } if (fos != null) { try { fos.close(); } catch (IOException e1) { e1.printStackTrace(); } } } } 保存String到本地 public boolean saveTxtToSdWithAppend(String messgeStr, String filePath, boolean isAppend){ File file = new File(filePath); try { file.createNewFile(); } catch (IOException e) { e.printStackTrace(); } boolean resultFlage = true; try { // 打开一个写文件器，是否追加形式 FileWriter writer = new FileWriter(filePath, isAppend); writer.write(messgeStr + \"\\r\\n\"); writer.close(); } catch (IOException e) { resultFlage = false; e.printStackTrace(); } return resultFlage; } 从txt(小文件) 获取String public String getStringFromTxt(File file) { StringBuffer sb = new StringBuffer(); try { BufferedReader rd = new BufferedReader(new FileReader(file)); String s = rd.readLine(); while (null != s) { sb.append(s); s = rd.readLine(); } } catch (FileNotFoundException e) { e.printStackTrace(); } catch (IOException e) { e.printStackTrace(); } return sb.toString(); } 按行读取(较大文件) 、解决乱码问题 public void read(String filePath, String logPath) throws Exception { RandomAccessFile raf = new RandomAccessFile(filePath, \"r\"); // 设置指针的位置为文件的开始部分 raf.seek(currentInex); long totalLenth = raf.length(); while (currentInex 递归 遍历文件夹 public void getFileList(String strPath) { File dir = new File(strPath); File[] files = dir.listFiles(); if (files != null) { for (File file : files) { if (file.isDirectory()) { getFileList(file.getAbsolutePath()); } else { // 文件 } } } } 时间间隔 public static String getConversationDateString(String result) throws Exception{ if(!result.equals(\"\")){ SimpleDateFormat sdf = new SimpleDateFormat(\"MM-dd HH:mm\"); SimpleDateFormat sdfDay = new SimpleDateFormat(\"MM-dd\"); String now = sdf.format(new Date()); Date oldTime = null; Date newTime = null; oldTime = sdf.parse(result); newTime = sdf.parse(now); long time = newTime.getTime() - oldTime.getTime(); int day; String[] olds = sdfDay.format(oldTime).split(\"-\"); String[] news = sdfDay.format(newTime).split(\"-\"); if(news[0].equals(olds[0])){ day = Integer.valueOf(news[1]) - Integer.valueOf(olds[1]); }else{ Calendar cal = Calendar.getInstance(); //月份设置要减1，所以设置1月就是1-1，设置2月就是2-1，如此类推 cal.set(Calendar.MONTH, 1-1); cal.add(Calendar.MONTH, -(Integer.valueOf(news[0]) - Integer.valueOf(olds[0]))); //得到上一个月最最后一天日期(31/30/29/28) int oldDay=cal.getActualMaximum(Calendar.DAY_OF_MONTH) - Integer.valueOf(olds[1]); day = oldDay + Integer.valueOf(news[1]); } if(time 求夹角 根据正切公式 /**根据两个点获取 斜率*/ public static double getXl(MyPointBean bean1, MyPointBean bean2) { double xlValue = 0; xlValue = (bean2.getY() - bean1.getY()) / (bean2.getX() - bean1.getX()); return xlValue; } /**根据2条线的斜率 获得之间的夹角*/ public static double getAngle(double xl_1, double xl_2) { double angleValue = 0; // 反正切 angleValue = Math.atan((xl_2 - xl_1) / (1 + xl_1 * xl_2)); // 将弧度转为度数 return Math.toDegrees(angleValue); } 遍历map 遍历set Map map=new HashMap(); //方法一 ，需要遍历 两次 for (Object object : map.keySet()) { String key = (String) object; Integer value = (Integer) map.get(key); } // 方法二， 只需遍历一次 （推荐） Set> entrySet = map.entrySet(); for (Entry object : entrySet){ Object key = object.getKey(); Object value = object.getValue(); } //遍历set Set set=new HashSet(); Iterator iterator=set.iterator(); while (iterator.hasNext()) { String obj = iterator.next(); } 随机数 Random Math.Random() 范围是 [0,1) 生成 [startNum,endNum) public int getRadomInt(int startNum, int endNum){ return new Random().nextInt(endNum - startNum) + startNum; } 生成 [startNum,endNum] public int getRadomInt2(int startNum, int endNum){ return new Random().nextInt(endNum - startNum + 1) + startNum; } 文件解压缩 zip解压缩是基于 pache的 ant.jar 实现 。 /** * 解压耗时操作应该在子线程中进行。 */ public class ZipUtil{ private byte[] buf; public ZipUtil(){ this.buf = new byte[ 1024*4]; } /** * @param zipFileAbsulutPaht 压缩文件的绝对路径 xxx/xxx.zip * @param destFileDir　　　解压到的目录　 */ public void unZip(String zipFileAbsulutPaht, String destFileDir) { FileOutputStream fileOut; File file; InputStream inputStream; try { //生成一个zip的文件 ZipFile zipFile = new ZipFile(zipFileAbsulutPaht); //遍历zipFile中所有的实体，并把他们解压出来 for (@SuppressWarnings(\"unchecked\") Enumeration entries = zipFile.getEntries(); entries.hasMoreElements();) { ZipEntry entry = entries.nextElement(); //生成他们解压后的一个文件 String tempNameFile=entry.getName() ; file = new File(destFileDir+File.separator+tempNameFile.replace(\"\\\\\", \"/\")); if (entry.isDirectory()) { file.mkdirs(); } else { File parent = file.getParentFile(); if (!parent.exists()) { parent.mkdirs(); } //获取出该压缩实体的输入流 inputStream = zipFile.getInputStream(entry); fileOut = new FileOutputStream(file); int length = 0; //将实体写到本地文件中去 while ((length = inputStream.read(this.buf)) > 0) { fileOut.write(this.buf, 0, length); } fileOut.close(); inputStream.close(); } } zipFile.close(); } catch (IOException ioe) { ioe.printStackTrace(); } } } // 使用 new ZipUtil().unZip(mnt/xxx/xxx.zip , mnt/xx/xx/); URLEncoder 中文 判断是否有中文 URLEncoder.encode(str ,\"UTF-8\")); public static boolean isChineseChar(String str){ boolean temp = false; Pattern p=Pattern.compile(\"[\\u4e00-\\u9fa5]\"); Matcher m=p.matcher(str); if(m.find()){ temp = true; } return temp; } 正则换URL字符串里面的汉字部分 public static String encode(String str, String charset) { Pattern p = Pattern.compile(\"[\\u4e00-\\u9fa5]\"); Matcher m = p.matcher(str); StringBuffer b = new StringBuffer(); while (m.find()) { m.appendReplacement(b, URLEncoder.encode(m.group(0), charset)); } m.appendTail(b); return b.toString(); } 其他 相隔多少天 ??? 日期格式化 ??? 判断是否是闰年 if (n%400==0 ||n%4==0 && n%100!=0) { //闰年 } 正则表达式 ``` ### 不定参数 ```text //相当于是二维数组，arg中每个空间保存一个数组 public void method(int[]...arg); 倒计时 简单场景就使用Chronometer。 复杂场景使用网上很多开源的，比如小米时钟、锤子时钟中的实现思路。 选中效果 xxx.setSelected(false); 全屏、去掉标题栏 //在setContentView之前设置 requestWindowFeature(Window.FEATURE_NO_TITLE); //Activity supportRequestWindowFeature(Window.FEATURE_NO_TITLE); // ok AppCompatDialog getWindow().setFlags(WindowManager.LayoutParams.FLAG_FULLSCREEN, WindowManager.LayoutParams.FLAG_FULLSCREEN); getWindow().setFlags(WindowManager.LayoutParams.FLAG_FORCE_NOT_FULLSCREEN, WindowManager.LayoutParams.FLAG_FULLSCREEN); //extends AppCompatActivity android:theme=\"@style/Theme.AppCompat.Light.NoActionBar\" getSupportActionBar().hide(); 启动默认浏览器 Intent intent =newIntent(); intent.setAction(\"android.intent.action.VIEW\"); Uri content_url =Uri.parse(\"http://www.xxx.com\"); intent.setData(content_url); startActivity(intent); 启动第三方应用 PackageManager pm = this.getPackageManager(); Intent intent = pm.getLaunchIntentForPackage(\"xxx.包名.xxx\"); try { startActivity(intent); } catch (Exception e) { //请先安装 } ```text 系统分享功能 Intent wechatIntent = new Intent(Intent.ACTION_SEND); wechatIntent.setPackage(\"com.tencent.mm\");//微信 wechatIntent.setType(\"text/plain\"); wechatIntent.putExtra(Intent.EXTRA_TEXT, \"hello world\"); try{ context. startActivity(wechatIntent); }catch (Exception e){ //请先安装微信 } ### 使用自定义字体 ```text AssetManager mgr = getAssets(); Typeface tf = Typeface.createFromAsset(mgr, \"fonts/2.TTF\");// 文件在assets/fonts目录下 textView.setTypeface(tf); XML解析 SAX：Simple API for XML。 相比于DOM，SAX是一种速度更快，更有效的方法。它逐行扫描文档，一边扫描一边解析。 不用实现调入整个文档，占用资源少。尤其在嵌入式环境中，如android，极力推荐使用SAX解析。 复制粘贴 // 得到剪贴板管理器 ClipboardManager cmb = (ClipboardManager) context.getSystemService(Context.CLIPBOARD_SERVICE); //复制 cmb.setText( msg); // 粘贴 String msg=cmb.getText().toString() 防止 Toast 重复提示 private static Toast mToast; public void showMsg(Context context, String msg) { if (mToast == null) { mToast = Toast.makeText(context, msg, Toast.LENGTH_SHORT); } else { //直接设置，不用重复创建 mToast.setText(msg); } mToast.show(); } res/raw和assets // res/raw和assets的相同点： 1、两者目录下的文件在打包后会原封不动的保存在apk包中，不会被编译成二进制。 // res/raw和assets的不同点： 1、res/raw中的文件会被映射到R.java文件中，访问的时候直接使用资源ID即R.id.filename； 2、assets文件夹下的文件不会被映射到R.java中，访问的时候需要AssetManager类。 3、res/raw不可以有目录结构； 4、而assets则可以有目录结构，也就是assets目录下可以再建立文件夹 performClick Custom view FloatingforView overrides onTouchEvent but not performClick less... case MotionEvent.ACTION_UP: performClick(); break; @Override public boolean performClick() { return super.performClick(); } 保存控件截图 public static Bitmap saveViewBitmap(View view) { view.setDrawingCacheEnabled(true); view.buildDrawingCache(true); Bitmap cacheBitmap = view.getDrawingCache(true); Bitmap destBitmap = Bitmap.createBitmap(cacheBitmap); cacheBitmap.recycle(); view.setDrawingCacheEnabled(false); return destBitmap; } 图片转byte[] ByteArrayOutputStream stream = new ByteArrayOutputStream(); bitmap.compress(Bitmap.CompressFormat.JPEG, 100, stream); byte[] array = stream.toByteArray(); 图片转Base64 ByteArrayOutputStream bStream = new ByteArrayOutputStream(); bitmap.compress(Bitmap.CompressFormat.PNG, 100, bStream); byte[] bytes = bStream.toByteArray(); return Base64.encodeToString(bytes, Base64.DEFAULT); 占位符 学号：%1$d ;姓名：%2$s ;成绩：%3$.2f String result = String.format(testStr,1001,\"张三\",9.235); %N代表第N个参数，如%3代表的是第三个参数； $是结束符； d/s/.2f代表的是整数/字符串/保留2位小数点的浮点数 图片平铺 android:background=\"@drawable/redline_verticalbitmap\" 环境变量配置 1、建->变量名：JAVA_HOME 变量值：D:/Java/jdk1.6.0_12(这只是我的JDK安装路径) 2、编辑->变量名：Path 在变量值的最前面加上：%JAVA_HOME%/bin;%JAVA_HOME%/jre/bin 3、新建->变量名：CLASSPATH 变量值：.;%JAVA_HOME%/lib;%JAVA_HOME%/lib/dt.jar;%JAVA_HOME%/lib/tools.jar 分别输入java，javac，java -version 命令测试是否配置成功 SDK解压，把解压后文件夹的tools目录添加到环境变量path中 查看配置好的变量、jdk当前路径、jdk安装路径 echO %JAVA_HOME% //字母o java javac 显示版本正常，也能够编译成功，运行java 的时候出现找不到类的错误。 在classpath中添加 .; 即可解决。 ByteBuffer相关 // 深度克隆ByteBuffer private ByteBuffer deepCloneByteBuffer(ByteBuffer original) { ByteBuffer clone = ByteBuffer.allocate(original.capacity()); original.rewind(); // 用put接口，才会把byte数组的内容拷贝到ByteBuffer中 clone.put(original); original.rewind(); clone.flip(); return clone; } //java.nio.ByteBuffer变量解释 int position 读写位置，表示当前进行读写操作时的位置。 position的位置会随着数据的写入而移或者读取一个字节一个字节的移动。 比如添加一个byte类型的数据position会+1, 添加一个int类型的数据position会+4 int limit 读写限制, 缓冲区可以进行读写的范围的最大值。 int capacity 容量，它的值是在创建缓冲区的时候指定的，设定后无法对其进行修改。 int mark 临时标记变量，用来存储 postion的。 //常用方法 ByteBuffer= allocate(int capacity) 分配一个新的字节缓冲区。 ByteBuffer= allocateDirect(int capacity) 分配新的直接字节缓冲区。 int =position() 获取position Buffer= position(10) ; 设置 position int =limit() 获取limit Buffer =limit(10) 设置limit int =capacity() 获取capacity byte[] = array() Buffer= flip() 把limit设为当前position，把position设为0 Buffer= mark() 将存储当前position的值，等下次调用reset()方法时，会设定position的值为之前的标记值； Buffer= reset() Buffer= rewind() 把position设为0，limit不变 Buffer= clear() 把position设为0，把limit设为capacity。并不是清空内容 ByteBuffer= compact() 将 position 与 limit之间的数据复制到buffer的开始位置， 若 position 与limit 之间没有数据的话发，就不会进行复制 。 其实就是删除已读过的数据复制后 position = limit -position,limit = capacity 。 ByteBuffer= wrap(byte[] array, int offset, int length) limit 等于 offset ByteBuffer= wrap(byte[] array ) 这个缓冲区的数据会存放在byte数组中，bytes数组或buff缓冲区任何一方中数据的改动都会影响另一方。 ByteBuffer= slice() 返回原ByteBuffer的一个镜像，所有改变互相可见 ByteBuffe=r put(byte[] src) 将一个数组写入 ByteBuffer= put(byte b) 将一个byte写入，postion+1 ByteBuffer= put(int index, byte b) 把src中可读的部分（也就是position到limit）写入此byteBuffer ByteBuffer =get(byte[] dst) 将内容读取到然后放到 dst中 byte= get() 读取一个byte 反编译 keystore 、 // apktool http://ibotpeaches.github.io/Apktool/install/ 解压apk文件，获取其中的图片、布局文件 ，必须用apktool打开。 apktool.bat d -f test.apk test 直接用解压软件打开的会显示乱码。 // dex2jar https://sourceforge.net/projects/dex2jar/files/ 直接用解压软件解开,获得dex。 用 dex2jar 将classes.dex转变成jar包。 dex2jar.bat classes.dex //在当前文件夹里生成classes_dex2jar.jar // jd-gui http://java-decompiler.github.io/ 用 jd-gui打开jar包，查看class 文件。 EditText 在 PopupWindow 中 ，EditText 有时无法获取输入法焦点。 在 PopupWindow 中设置一下 this.setFocusable(true); 无版权 可以无限制使用！ all right reserved，powered by Gitbook该文件更新时间： 2020-12-23 10:50:40 "},"chinese/常用算法/算法术语.html":{"url":"chinese/常用算法/算法术语.html","title":"算法术语","keywords":"","body":"算法术语 时间复杂度 在数据结构中,每个算法有他的时间复杂度 , 用O（）表示。括号里面是通过算法求出来的时间复杂度 , n*n 是n的平方，如果求出来是n*n+n 这时它的时间复杂度还是 0（n*n）, 因为规定时间复杂度是取它的最高次幂 递归 相同的结构层级嵌套，自我调用的过程。 迭代 迭代就像是操场永不回头的跑圈，不断利用相同的优化过程将输出作为新的输入，使问题推进到一个个里程碑，直到符合答案的要求。 计算1+2+3+…+n, sum1是递归, sum2是迭代. function sum1(n){ if (n == 0) { return 0; } else { return n + sum1(n - 1); } } function sum2(n){ var result = 0; for (var i = 1; i 无版权 可以无限制使用！ all right reserved，powered by Gitbook该文件更新时间： 2020-08-19 17:20:00 "},"chinese/常用算法/排序算法.html":{"url":"chinese/常用算法/排序算法.html","title":"排序算法","keywords":"","body":"排序算法 冒泡排序 核心思想是 \"冒泡\"。最后的效果是 第一个最小，最后一个最大，沉在最下。一次比较 可以让数值中最小的那个值冒出来。 然后依次比较，直到完成。 /** * int[] array = { 7, 3, 10, 0, 6 , 0 ,-56 }; * 冒泡排序 */ public static int[] sortBubble(int[] array){ //外层for 确定 排序趟次 for ( int i = 0 ; i i ; j--) { int temp; //将小的值往前移动 if(array[j] 归并排序 、合并排序 合并排序 体现了 分治思想 。 递归“分” 递归“分”的终止条件是“只剩下一个元素” 。 因为一个元素认为它有序 。 有序元素的“合” 先比一下 A指针 和 B指针 指向的两个元素谁比较小一点，然后把比较小的元素（此时假设A指针指向的元素小）放到C指针指的位置上。 A往前挪，C 往前挪 。然后继续比较A指针和B指针的两个元素。 合并排序缺点 需要额外的空间辅助。 /** * 归并 排序。 升序 */ public static void mergeSort(int[]array , int start , int end){ if(start>=end){ //递归终止条件 return ; }else{ int mid = (start + end )/2 ; //递归处理左边 mergeSort(array , start ,mid); //递归处理右边 mergeSort(array ,mid+1 ,end); //合并 排序好的左右 mergeAction(array ,start ,mid ,end); } } public static void mergeAction(int[]arr ,int start ,int mid , int end ){ //辅助数组空间 并不是 int[] tempArr = new int[arr.lengh] int[] tempArr = new int[end - start + 1]; //左数组的下标 int ptrA = start; //右数组的下标 int ptrB = mid +1; //辅助数组的下标 int ptrC=0; //循环比较，直至有一个区间被取完 while (ptrA 插入排序 无 递归排序 无 快速排序 之所以说它是快速的原因，不是因为它比其他的排序算法都要快。而是从实践中证明了快速排序在平均性能上的确是比其他算法要快一些 。 快速排序的基本思路 找一个基准元素，对数组进行调整， 调整的标准是，这个基准元素的左边存放的都是比这个元素小的，右边都是比这个元素大的。 然后分而治之，对左右两边的子数组利用同样的规则调整，调整到每一个子数组中都只有一个元素时结束。 （快排体现了分而治之的思想，一步步地把问题变小，最终解决。） 快排的理解 快排有多种理解角度，个人觉得从“挖坑填坑”的角度比较容易理解。 /**最基础的 快速排序*/ public void quickSort(int[] array, int left , int right){ if(left = base){ right-- ; } //找到坑值，填坑 array[left] = array[right] ; //从左边开始寻找坑值 while (left 选择排序 选择排序的思想：就是不断地从未排序的元素中选择最大（或最小）的元素放入已排好序的元素集合中，直到未排序中仅剩一个元素为止 。 选择排序 和冒泡排序有点类似，都是在一次排序后把最大(最小)的元素放到最前面。但是过程不同，冒泡排序是通过相邻的比较和交换。而选择排序是通过对整体的选择。 选择排序 可以看成 冒泡排序 的优化，只有在确定了最小数的前提下才进行交换，大大减少了交换的次数。 选择排序关键点 1、有序区间 、 无序区间 2、如何选出最大（/最小）元素 /** * 选择排序 升序 */ public static int [] sortSelect(int [] array){ int length = array.length; for(int i=0 ;i array[k]){ minPos=k ; } } //将当前趟次的结果放到 有序区间 if(array[minPos] 无版权 可以无限制使用！ all right reserved，powered by Gitbook该文件更新时间： 2020-08-19 17:20:00 "},"chinese/常用算法/查找算法.html":{"url":"chinese/常用算法/查找算法.html","title":"查找算法","keywords":"","body":"查找算法 二分查找 、折半查找 前提：数组是 排好序的。 （升序、降序都可以） 越界异常 int middle = (low+high)/2 // 错误写法 int middle = low + (high - low) / 2; // 正确写法 low 和 high 都是整形，当你的low和high很大的时候， low+high 就会产生溢出，low+high 的结果就会变为负数，数组越界了。 /** * @param array 升序 数组 * @param key 需要查找的值 */ public static int binarySearch(int[] array, int key) { int low = 0; int high = array.length - 1; while (low key) { high = middle - 1; } else if (array[middle] 顺序查找 优点： 算法简单 、 对线性链表也适用 缺点： 慢 public static int SequenceSearch(int[] array, int key){ int length = array.length ; for (int i=0 ;i 无版权 可以无限制使用！ all right reserved，powered by Gitbook该文件更新时间： 2020-08-19 17:20:00 "},"chinese/常用算法/大数相加.html":{"url":"chinese/常用算法/大数相加.html","title":"大数相加","keywords":"","body":"大数相加 如果利用java的 API ，就非常简单。 BigInteger value1= new BigInteger(\"-11\") ; BigInteger value2= new BigInteger(\"-11\"); BigInteger reslut = value1.subtract(value2) ; 无版权 可以无限制使用！ all right reserved，powered by Gitbook该文件更新时间： 2020-09-15 16:00:11 "},"chinese/常用算法/集合的所有子集.html":{"url":"chinese/常用算法/集合的所有子集.html","title":"获得集合的所有子集","keywords":"","body":"获得集合的所有子集 思想比较巧妙。 集合A={a,b,c}中的元素在每个子集中，要么存在，要么不存在。 映射关系： (1,1,1)->(a,b,c) --> 7 (1,1,0)->(a,b) --> 6 (1,0,1)->(a,c) --> 5 (1,0,0)->(a) --> 4 (0,1,1)->(b,c) --> 3 (0,1,0)->(b) --> 2 (0,0,1)->(c) --> 1 (0,0,0)->(空集) --> 0 public static void GetPowerSet(int nArray[] ) { // 一共多少种组合 0 ,1, 2 ... n-1 int end = 1 无版权 可以无限制使用！ all right reserved，powered by Gitbook该文件更新时间： 2020-08-19 17:20:00 "},"chinese/常用算法/扫描线种子填充算法.html":{"url":"chinese/常用算法/扫描线种子填充算法.html","title":"扫描线种子填充算法","keywords":"","body":"扫描线种子填充算法 一般用来 填充不规则多边形 该算法并不完美，对图片有要求，识别的也不是很精准 ，而且有锯齿。 ColourImageView.java public class ColourImageView extends ImageView { private Bitmap mBitmap; private Paint mPaint ; /** * 边界的颜色 */ private int mBorderColor = -1; private boolean hasBorderColor = false; private ImageTool imageTool; public ColourImageView(Context context, AttributeSet attrs) { super(context, attrs); imageTool = new ImageTool(mBorderColor, hasBorderColor ); mPaint = new Paint(); mPaint.setColor(Color.RED); } @Override protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) { super.onMeasure(widthMeasureSpec, heightMeasureSpec); // 规定让图片按比例显示 int viewWidth = getMeasuredWidth(); setMeasuredDimension(viewWidth, getDrawable().getIntrinsicHeight() * viewWidth / getDrawable().getIntrinsicWidth()); if (mBitmap == null) { Bitmap bm = ((BitmapDrawable) getDrawable()).getBitmap(); mBitmap = Bitmap.createScaledBitmap(bm, getMeasuredWidth(), getMeasuredHeight(), false); } } private int touchX ; private int touchY ; @Override public boolean onTouchEvent(MotionEvent event) { touchX = (int) event.getX(); touchY = (int) event.getY(); if (event.getAction() == MotionEvent.ACTION_DOWN) { fillColorToSameArea( ); } return super.onTouchEvent(event); } /** * 以触摸点为种子点 进行填充 */ private void fillColorToSameArea( ) { int bitmapWidth ; int bitmapHeight ; int[] pixels ; int currentTouchPixel ; currentTouchPixel = mBitmap.getPixel(touchX, touchY); if (currentTouchPixel == Color.TRANSPARENT || (hasBorderColor && mBorderColor == currentTouchPixel)) { return; } bitmapWidth = mBitmap.getWidth(); bitmapHeight = mBitmap.getHeight(); pixels = new int[bitmapWidth * bitmapHeight]; mBitmap.getPixels(pixels, 0, bitmapWidth, 0, 0, bitmapWidth, bitmapHeight); int newColor = randomColor(); //填色 imageTool.fillColor(pixels, bitmapWidth, bitmapHeight, currentTouchPixel, newColor,touchX, touchY); //重新设置bitmap mBitmap.setPixels(pixels, 0, bitmapWidth, 0, 0, bitmapWidth, bitmapHeight); setImageBitmap(mBitmap); invalidate(); } @Override protected void onDraw(Canvas canvas) { super.onDraw(canvas); canvas.drawCircle(touchX ,touchY ,10 ,mPaint); } /** * 返回一个随机颜色 */ private int randomColor() { Random random = new Random(); int color = Color.argb(255, random.nextInt(256), random.nextInt(256), random.nextInt(256)); return color; } } ImageTool.java public class ImageTool { private Stack mStacks = new Stack<>(); private int mBorderColor = -1; private boolean hasBorderColor = false; public ImageTool( int mBorderColor ,boolean hasBorderColor ){ this.mBorderColor = mBorderColor ; this.hasBorderColor= hasBorderColor ; } /** * @param pixels 像素数组 * @param currentTouchPixel 当前触摸点的 颜色 * @param newColor 填充色 */ public void fillColor(int[] pixels, int bitmapWidth, int bitmapHeight, int currentTouchPixel, int newColor, int x, int y) { //步骤1：将种子点(x, y)入栈； mStacks.push(new Point(x, y)); //步骤2：判断栈是否为空， // 如果栈为空则结束算法，否则取出栈顶元素作为当前扫描线的种子点(x, y)， // y是当前的扫描线； while (!mStacks.isEmpty()) { /* * 步骤3：从种子点(x, y)出发，沿当前扫描线向左、右两个方向填充，直到边界。 * 分别标记区段的左、右端点坐标为xLeft和xRight */ Point seed = mStacks.pop(); int count = fillLineLeft(pixels, currentTouchPixel, bitmapWidth, newColor, seed.x, seed.y); int left = seed.x - count + 1; count = fillLineRight(pixels, currentTouchPixel, bitmapWidth, newColor, seed.x + 1, seed.y); int right = seed.x + count; //从y-1找种子 if (seed.y - 1 >= 0){ findSeedInNewLine(pixels, currentTouchPixel, bitmapWidth, seed.y - 1, left, right); } //从y+1找种子 if (seed.y + 1 = 0) { int index = y * bitmapWidth + x; if (needFillPixel(pixels, pixel, index)) { pixels[index] = newColor; count++; x--; } else { break; } } return count; } /** * 往右填色，返回填充的个数 */ private int fillLineRight(int[] pixels, int currentTouchPixel, int bitmapWidth, int newColor, int x, int y) { int count = 0; while (x 0xFFBBBBBB ; // 直接跟当前pixel比较，有较明显的锯齿，原因不明 //return pixels[index] > pixel ; } } /** * 在新行找种子节点 */ private void findSeedInNewLine(int[] pixels, int currentTouchPixel, int bitmapWidth, int indexY, int left, int right) { // 获得该行的开始索引 int begin = indexY * bitmapWidth + left; // 获得该行的结束索引 int end = indexY * bitmapWidth + right; boolean hasSeed = false; int newSeedIndexX ; while (end >= begin) { if (pixels[end] == currentTouchPixel) { if (!hasSeed) { newSeedIndexX = end % bitmapWidth; mStacks.push(new Point(newSeedIndexX, indexY)); hasSeed = true; } } else { hasSeed = false; } end--; } } } 无版权 可以无限制使用！ all right reserved，powered by Gitbook该文件更新时间： 2020-08-19 17:20:00 "},"chinese/设计模式/设计模式.html":{"url":"chinese/设计模式/设计模式.html","title":"设计模式","keywords":"","body":"设计模式 参考资料教材 目前设计模式： 23个GoF设计模式 + 简单工厂模式 学习设计模式的意义 过多地使用 if else 会造成代码臃肿 ，维护困难（容易产生bug ，需要大量修改代码）。此时你应该要考虑用某种设计模式来解决这个问题。 简单的设计意味着缺少灵活性，我们将其称之为“一次性代码”，不能方便地被应用在其他项目。 而合适的设计模式，可以让你的代码可以被反复使用。 设计模式分类 创建模型 创建型模式用来处理对象的创建过程 模式类型 学习进度 工厂方法模式（Factory Method Pattern） 抽象工厂模式（Abstract Factory Pattern） 建造者模式（Builder Pattern） 原型模式（Prototype Pattern） 单例模式（Singleton Pattern） 附：简单工厂模式：又叫做静态工厂方法（StaticFactory Method）模式，是属于创建型模式，但不属于23种GOF设计模式之一。 结构型模式 用来处理类或者对象的组合 模式类型 学习进度 适配器模式（Adapter Pattern） 桥接模式（Bridge Pattern） 组合模式（Composite Pattern） 装饰者模式（Decorator Pattern） 外观模式（Facade Pattern） 享元模式（Flyweight Pattern） 代理模式（Proxy Pattern） 行为型模式 用来对类或对象怎样交互和怎样分配职责进行描述 模式类型 学习进度 责任链模式（Chain of Responsibility Pattern） 命令模式（Command Pattern） 解释器模式（Interpreter Pattern） 迭代器模式（Iterator Pattern） 中介者模式（Mediator Pattern） 备忘录模式（Memento Pattern） 观察者模式（Observer Pattern） 状态模式（State Pattern） 策略模式（Strategy Pattern） 模板方法模式（Template Method Pattern） 访问者模式（Visitor Pattern） 面向对象设计原则 面向对象设计原则蕴含在很多设计模式中，它们是从许多设计方案中总结出的指导性原则。是我们用于评价一个设计模式的使用效果的重要指标之一。 [x] 1、单一职责原则(Single Responsibility Principle, SRP) [x] 2、开闭原则(Open-Closed Principle, OCP) [x] 3、接口隔离原则(Interface Segregation Principle, ISP) [x] 4、依赖倒转原则(Dependency Inversion Principle, DIP) [x] 5、里氏代换原则(Liskov Substitution Principle, LSP) [x] 6、迪米特法则(Law of Demeter, LoD) [x] 7、合成复用原则(Composite Reuse Principle, CRP) 无版权 可以无限制使用！ all right reserved，powered by Gitbook该文件更新时间： 2020-08-19 17:20:00 "},"chinese/设计模式/模式详解.html":{"url":"chinese/设计模式/模式详解.html","title":"模式详解","keywords":"","body":"依赖倒转原则(Dependency Inversion Principle, DIP) 抽象不应该依赖于细节，细节应当依赖于抽象。换言之，要针对接口编程，而不是针对实现编程。 DIP要求传递参数时或在关联关系中，尽量引用层次高的抽象层类，而不要用具体类。 我们需要针对抽象层编程。将具体类的对象通过依赖注入的方式注入到其他对象中。 依赖注入(DependencyInjection, DI) : 当一个对象要与其他对象发生依赖关系时，通过抽象来注入所依赖的对象。 常用的注入方式有三种： 1、构造注入。通过构造函数来传入具体类的对象； 2、设值注入。通过Setter方法来传入具体类的对象； 3、接口注入。通过在接口中声明的业务方法来传入具体类的对象。 依赖倒置和里氏替换的区别 在大多数情况下，这三个设计原则会同时出现，开闭原则是目标，里氏代换原则是基础，依赖倒转原则是手段，它们相辅相成，相互补充，目标一致，只是分析问题时所站角度不同而已。 1、定义的角度不同。里氏替换原则是关于子类和父类的原则;依赖倒置原则是关于抽象与细节的原则。 2、应用范围不同。依赖倒置原则使用范围更广。 在大多数情况下，OCP、LSP、DIP会同时出现。开闭原则是目标，里氏代换原则是基础，依赖倒转原则是手段，它们相辅相成，相互补充，目标一致，只是分析问题时所站角度不同而已。 单一职责 一个类只负责一个功能领域中的相应职责。 在软件系统中，一个类承担的职责越多，它被复用的可能性就越小。一个类承担的职责过多，就相当于将这些职责耦合在一起，当其中一个职责变化时，可能会影响其他职责的运作。 因此，要将这些职责进行分离，将不同的职责封装在不同的类中。 单一职责原则是实现高内聚、低耦合的指导方针，它是最简单但又最难运用的原则。 高内聚 是指一个模块是由相关性很强的代码组成，只负责一项任务。 低耦合 模块与模块之间，尽可能的使其独立存在。 里氏代换原则(Liskov Substitution Principle, LSP) LSP 是由麻省理工学院计算机科学实验室的Liskov女士提出来的。所以以她的名字命名。 里氏代换原则要求，在软件中将一个基类对象替换成它的子类对象，程序将不会产生任何错误和异常，反过来则不成立。 例如：我喜欢动物，那我一定喜欢狗，因为狗是动物的子类；但是我喜欢狗，不能据此断定我喜欢所有动物。 里氏代换原则是实现开闭原则的重要方式之一，因此在程序中尽量使用基类类型来对对象进行定义，而在运行时再确定其子类类型，用子类对象来替换父类对象。 //在使用LSP时需要注意如下问题： 1、子类的所有方法必须在父类中声明，或子类必须实现父类中声明的所有方法。 因为如果一个方法只存在子类中，在父类中不提供相应的声明，则无法在以父类定义的对象中使用该方法。 2、在运用LSP时，尽量把父类设计为抽象类或者接口，让子类继承父类或实现父接口，并实现在父类中声明的方法， 运行时，子类实例替换父类实例，我们可以很方便地扩展系统的功能，同时无须修改原有子类的代码。 附： 类似 List tempList= new ArrayList() ; ? //申明时用基类List ， 具体实现时用子类ArrayList 。 迪米特法则(Law of Demeter, LoD) 一个软件实体应当尽可能少地与其他实体发生相互作用。 迪米特法则可降低系统的耦合度，当其中某一个模块发生修改时，就会尽量少地影响其他模块。 //所以在类的结构设计上： 1、每一个类都应当尽量降低其成员变量和成员函数的访问权限； 2、在类的设计上，只要有可能，一个类型应当设计成不变类； 3、在对其他类的引用上，一个对象对其他对象的引用应当降到最低。 迪米特法则还有几种定义形式，包括：不要和“陌生人”说话、只与你的直接朋友通信等 其朋友包括以下几类： 1、当前对象本身(this)； 2、以参数形式传入到当前对象方法中的对象； 3、当前对象的成员对象； 4、 如果当前对象的成员对象是一个集合，那么集合中的元素也都是朋友； 5、当前对象所创建的对象。 任何一个对象，如果满足上面的条件之一，就是当前对象的“朋友”，否则就是“陌生人”。 迪米特法则要求我们在设计系统时，应该尽量减少对象之间的交互， 如果两个对象之间不必彼此直接通信，那么这两个对象就不应当发生任何直接的相互作用， 如果其中的一个对象需要调用另一个对象的某一个方法的话，可以通过第三者转发这个调用。 简言之，就是通过引入一个合理的第三者来降低现有对象之间的耦合度。 附： law of Demeter 有些书也译作 “得墨忒耳法则” 。 为什么叫做这个名字，我的猜测是根据\"德墨忒尔\"的故事进行命名的。纯粹猜测 ，读者如果知道正确的原因请留言告知我。谢谢。 开闭原则 一个软件实体应当对扩展开放，对修改关闭。应尽量在不修改原有代码的情况下进行扩展。 //软件实体：可以指一个软件模块、一个由多个类组成的局部结构或一个独立的类。 当软件系统需要面对新的需求时，我们应该尽量保证系统的设计框架是稳定的。如果一个软件设计符合开闭原则，那么可以非常方便地对系统进行扩展，而且在扩展时无须修改现有代码，使得软件系统在拥有适应性和灵活性的同时具备较好的稳定性和延续性。 在Java中，可以为系统定义一个相对稳定的抽象层(抽象类或者接口)，而将不同的实现行为移至具体的实现层中完成。 增加新的具体类来实现新的业务功能，在不修改已有代码的基础上扩展系统的功能。 //注意： 因为xml和properties等格式的配置文件是纯文本文件，编辑后无须编译，因此在软件开发中，一般不把对配置文件的修改认为是对系统源代码的修改。 如果一个系统在扩展时只涉及到修改配置文件，而原有的Java代码没有做任何修改，则可认为该系统是一个符合开闭原则的系统。 合成复用原则(Composite Reuse Principle, CRP) 组合复用原则、聚合复用原则 尽量使用对象组合，而不是继承来达到复用的目的。 在面向对象设计中，可以通过两种方法在不同的环境中复用已有的设计和实现: 1、通过组合/聚合实现 组合/聚合可以使系统更加灵活，降低类与类之间的耦合度。请优先考虑。 2、通过继承实现 继承复用会破坏系统的封装性，因为继承会将基类的实现细节暴露给子类。 由于基类的内部细节通常对子类来说是可见的，所以这种复用又称“白箱”复用。 一般而言，如果两个类之间是“Has-A”的关系应使用组合或聚合； 如果是“Is-A”关系可使用继承。 附： 有一些书上没有列上CRP， 只说“六大设计原则” 。 接口隔离原则(Interface Segregation Principle, ISP) 使用多个专门的接口，而不使用单一的总接口。因为在面向对象编程语言中，实现一个接口就需要实现该接口中定义的所有方法，所以大的总接口使用起来不一定很方便。 //注意： 在使用接口隔离原则时，我们需要注意控制接口的粒度。 1、接口不能太小。接口太小会导致系统中接口泛滥，不利于维护； 2、接口也不能太大。太大的接口将违背接口隔离原则，灵活性较差，使用起来很不方便。 一般而言，接口中仅包含为某一类用户定制的方法即可。 //“接口”往往有两种不同的含义： 对于不同的含义，ISP的表达方式以及含义都有所不同。 1、把接口理解成角色，一个接口只能代表一个角色，每个角色都有它特定的一个接口，此时，这个原也可以叫做“角色隔离原则”。 2、如果把“接口”理解成狭义的特定语言的接口，那么ISP表达的意思是指接口仅仅提供客户端需要的行为。 回调机制 回调的简单理解： A需要做一件事情(不需要立刻知道结果)，给B设置一个回调对象，然后B在条件合适的时候执行得到一个结果， 然后通过A传过来的回调对象告诉A。 1、回调普通使用 1、定义回调接口： public interface IH264StoreFinishCallBack { public void onStoreAndParseFinished( boolean result, String msgStr) ; } 2、设置接口： private IH264StoreFinishCallBack ih264StoreFinishCallBack = new IH264StoreFinishCallBack() { @Override public void onStoreAndParseFinished(boolean result, String msgStr) { if(result) { disMissIosLoading(); } } } ; H264FileSotrPresenter h264FileSotrPresenter = new H264FileSotrPresenter(ih264StoreFinishCallBack); 3、触发回调： if(ih264StoreFinishCallBack!=null) { ih264StoreFinishCallBack.onStoreAndParseFinished(true ,\"切换到照片时自动触发结束录像命令\"); } 2、全局回调的使用方法(结合单例模式) 这种模式可以实现在不同的activity之间传递参数。 1、定义回调函数管理类： /** * Created by Aivin on 2017/5/8. * 单例模式 管理一个回调对象， * 实现两个不同的activity实时通讯 *用户手动改变计量单位后，通知另外一个activity做出相应的改变 */ public class UnitsChangeCallBackManager { private IUnitsModeChangeCallBack iUnitsModeChangeCallBack ; /** *接受传入的回调实例 */ public void setiUnitsModeChangeCallBack(IUnitsModeChangeCallBack iUnitsModeChangeCallBack) { this.iUnitsModeChangeCallBack = iUnitsModeChangeCallBack; } /** * 用户手动改变电池的警报值 * @param type 标记是 哪一个电池被修改 * @param value 具体的修改值 * @param msgStr 拓展字段，备用。 */ public void sendUnitsChangedByUser(int type , int value , String msgStr) { if(iUnitsModeChangeCallBack !=null) { iUnitsModeChangeCallBack.onUnitsModeChange(type , value , msgStr); } }// /**私有化构造函数，防止被其他类实例化*/ private UnitsChangeCallBackManager() { //初始化操作 }// /**使用一个内部类来维护单例 *单例模式使用内部类来维护单例的实现。 *利用jvm提供的机制，加载类的线程互斥的，用来解决多线程访问的时候可能会遇到null的问题。 **/ private static class SingletonFactory { private static UnitsChangeCallBackManager instance = new UnitsChangeCallBackManager(); } /**获取实例,对外提供的接口 */ public static UnitsChangeCallBackManager getInstance() { return SingletonFactory.instance; } /**为了能在序列化过程仍能保持单例的特性，需要添加一个readResolve()方法 */ private Object readResolve() { return getInstance(); } } 2、设置回调： UnitsChangeCallBackManager.getInstance().setiUnitsModeChangeCallBack(this); public void onUnitsModeChange(int type, int value, String msgStr) { switch (type) { case 1: break; case 2: break; } } 3、触发回调： UnitsChangeCallBackManager.getInstance().sendUnitsChangedByUser(1,1 ,\"英尺\"); 中介者模式 Mediator Pattern “中介者模式” 是 “迪米特法则” 的一个典型应用。（不要与陌生人说话）。 同事类之间没有直接显示交流 ，而是通过中介类（定义了行为接口）进行通信。 应用场景： 1、在有些软件中，某些类/对象之间的相互调用关系错综复杂，类似QQ用户之间的关系， 此时，我们特别需要一个类似“QQ群”一样的中间类来协调这些类/对象之间的复杂关系 。 2、 请结合现实生活中的 “中介”进行理解。 房产中介... 优点 1、 简化了对象之间的交互，将原本难以理解的网状结构转换成相对简单的星型结构。 2、 增加新的中介者和新的同事类都比较方便，更好地符合“开闭原则”。 缺点 1、 中介者类中包含了大量同事类之间的交互细节，可能会导致中介者类非常复杂 。 享元模式 Flyweight Pattern 当系统中存在大量相似或相同的对象时，将会导致运行代价过高、OOM 等问题，享元模式正为解决之一类问题而诞生。 注意 1、享元模式在使用时存在线程安全问题，需要考虑线程安全。 2、通常用一个 工厂类 类维护享元对象。 内部状态 Internal State 存储在享元对象内部并且不会随环境改变而改变的状态，内部状态可以共享。 外部状态 External State 随环境改变而改变的、不可以共享的状态。外部状态由客户端保存。 外部状态不可以影响享元对象的内部状态，它们是相互独立的。 缺点 1、对象 需要分离出 内部状态 和 外部状态，这使得程序的逻辑复杂化。 2、读取外部状态使得运行时间变长。 示例 围棋棋盘中包含大量的黑子和白子，它们的形状、大小都一模一样，只是出现的位置不同而已。如果将每一个棋子都作为一个独立的对象存储在内存中，将导致该围棋软件在运行时所需内存空间较大。 class Chessman { /**内部状态*/ private String color; /**外部状态*/ private Point location; public Chessman(String color) { ...} public String getColor() { ... } public String getLocation() { ...} /**更新外部状态 需要主要线程安全*/ public synchronized void updateLocation( Point loation) { ... } } public class ChessmanFactory { /**享元池*/ private static Map map=new HashMap<>(); public static ChessFlyWeight getChess(String color) { if(map.get(color)!=null){ return map.get(color); }else{ Chessman chessman=new Chessman(color); map.put(color, chessman); return chessman; } } } //多次调用 也只创建了一个 Chessman 对象 Chessman chessman=ChessmanFactory.getChess(\"黑色\"); 代理模式（Proxy Pattern） 当无法直接访问某个对象或访问某个对象存在困难时可以通过一个代理对象来间接访问。 关键点：代理对象控制对原对象的引用 。 静态代理 代理类与委托类有同样的接口　。通过代理对象访问目标对象。 1、可以在目标对象实现的基础上,增强额外的功能操作 。(这一点跟装饰者模式一样) 实现自定义的控制策略。 /** * 委托类 实现的接口 */ public interface IUser { /**获取用户信息*/ public String getUserInfo(); } /** * 委托类。对外提供 查询用户信息的功能。 */ public class UserTools implements IUser { public String getUserInfo(){ return \"he is tom\"; } } /** * 代理类。 实现的接口与委托类一模一样。 * 用户通过代理作为中间人去使用原对象拥有的功能。 * 但是真正执行的还是原来的对象。 */ public class UserToolsProxy implements IUser { private UserTools userTools ; public String getUserInfo() { //做授权判断 boolean isTheRightTime = true of false...; if(isTheRightTime) { return userTools.getUserInfo(); }else{ return \"wrong time\"; } } 动态代理 暂时没用过。 在java的动态代理机制中，有两个重要的类或接口，一个是 InvocationHandler(Interface)、另一个则是 Proxy(Class)，这一个类和接口是实现我们动态代理所必须用到的。~ 代理模式和接口回调的区别 跟做iOS的同事曾经讨论过，对方说代理模式和接口回调理解起来差不多。( 可能是iOS的代理的定义不一样?) 我个人认为这两者相差还是比较大的，出发点和定义都不一样。 单例模式（Singleton Pattern） 在Java应用中，单例对象能保证在一个JVM中，该对象只有一个实例存在。 使用场景： 1、某些大型的类创建频繁时会导致很大的系统开销。 2、软件系统中有些地方只能有一个实例，否则会出现各种问题。例如打印机为了避免状态不一致而采用单例模式。 缺点： 1、单例实例的生命周期和软件的生命周期一样长。如果它持有某些对象的引用 ，会导致该对象无法释放。 特点： 1、单例类只能有一个实例。 2、单例类必须自己自己创建自己的唯一实例。 3、单例类必须给所有其他对象提供这一实例。 4、构造方法限定为private，避免了类在外部被实例化，只能通过getInstance()方法访问。（此处不考虑反射机制） 单例模式分二种：饿汉式单例、懒汉式单例。 public class SingleTonBean { /**持有私有静态实例，防止被引用，此处赋值为null，目的是实现延迟加载*/ private static SingleTonBean instance = null ; /**私有化构造函数，防止被其他类实例化*/ private SingleTonBean() { //初始化操作 }// /**使用一个内部类来维护单例 *单例模式使用内部类来维护单例的实现。 *利用jvm提供的机制，加载类的线程互斥的，用来解决多线程访问的时候可能会遇到null的问题。 **/ private static class SingletonFactory { private static SingleTonBean instance = new SingleTonBean(); } /**获取实例,对外提供的唯一接口 */ public static SingleTonBean getInstance() { return SingletonFactory.instance; } /**为了能在序列化过程仍能保持单例的特性，需要添加一个readResolve()方法 */ private Object readResolve() { return getInstance(); } } 饿汉式单例 ： public class SingletonDemo1 { private SingletonDemo1(){ //构造方法是私有 } //饿汉式：被调用之前就自己创建好实例 private static final SingletonDemo1 singleton=new SingletonDemo1(); public SingletonDemo1 getIncetance(){ return singleton; } } 懒汉式单例 ： public class SingletonDemo2 { private static SingletonDemo2 singleton = null; private SingletonDemo2() { // 私有化构造方法 } public synchronized static SingletonDemo2 getIncetance() { if (singleton == null) { // 懒汉式：在调用的时候才实例化对象 singleton = new SingletonDemo2(); } return singleton; } } 使用类的静态方法也可以实现单例模式的效果，分析这两种方案的不同。 1、单例模式可以延迟初始化，有助于优化性能 。 2、待补充。 要点解析 1、单例模式和反序列化的问题 一般来说，一个类实现了Serializable接口，我们就可以将它写入内存然后再从内存中读取组装成一个跟原来一样的对象。此时，内存中存在N（N>=2）个相同的对象。 而单例模式要求JVM中只能有一个类的对象。如果不做特殊处理反序列就会违反单例模式的规则。 /** * 实现readResolve方法，一个class可以直接控制反序化返回的类型和对象引用。 * ObjectInputStream 会检查对象的class是否定义了readResolve方法。 * Method readResolveMethod = getInheritableMethod( cl, \"readResolve\", null, Object.class); */ private Object readResolve() throws ObjectStreamException { return INSTANCE; //直接返回已经存在单例对象，不再组装新的对象。确保唯一性。 } 原型模式 Prototype Pattern 原型模式特点 在于通过 克隆 一个已经存在的实例来返回新的实例，而不是新建实例。被复制的实例就是我们所称的“原型”。 特点 1、模型需要对外暴露自己实现的克隆接口。 使用场景 当创建新的对象实例较为复杂、成本较大时，使用原型模式可以简化对象的创建过程、节约资源。 // 创建原型对象 WeeklyLog log_previous = new WeeklyLog(); log_previous.setDate(\"第12周\"); //调用克隆方法创建克隆对象 WeeklyLog log_new = log_previous.clone(); log_new.setDate(\"第13周\"); 缺点 1、需要为每一个类配备一个克隆方法 ，当对已有的类进行改造时，需要修改源代码，违背了“开闭原则”。 2、如果对象复杂，实现深克隆的时候较麻烦。（每一层对象对应的类都必须支持深克隆）       注： 浅克隆、深克隆的概念请查阅其他资料。本章不予讲解。 命令模式 Command Pattern 类型 特点 命令 Command 有N种。包含具体的接收者。 接收者 Receiver 有N种 。执行具体逻辑的地方 。 请求者 Invoker 1种 。 只负责 接收命令并调用命令的执行方法。 示例 /**调用者 */ public class Invoker { /**接收具体命令 并执行*/ public void executeCmd(Command command) { command.execute(); } } /**具体的命令,例如打开连接 */ public class CommandOpenConnection implements Command { 　　private Receiver receiver; /**命令 和 接收者 绑定*/ 　　public CommandOpenConnection(Receiver receiver) { ...} /**执行命令*/ 　　public void execute() { 　　 receiver.doSomeThing(...); 　　} } /**具体的接收者*/ public class ReceiverOpenConnection implements Receiver { public void doSomeThing(...) { 具体的逻辑.... } } //使用场景 Receiver receiver=... ; Invoker invoker = ...; Command cmd1 = ... ; //Command cmd2 = ... ; // 调用者 更新命令 并发起执行 invoker.executeCmd(cmd1);    优点 1、请求者（Invoker） 和执行者（Receiver） 完全解耦。 2、添加新的命令 符合 “开闭原则” 。 缺点 1、一种命令 对应 一个命令类(xxx.java)。导致 类个数过多 。    命令模式 和 策略模式 的区别 1、命令模式 只是强调解耦合，调用者只是负责发起调用。不同的命令得到不同的处理结果 。 2、策略模式 强调 一个问题可以用多种策略方法来 获得相同的处理结果 。 备忘录模式 Memento Pattern 、快照模式 在不破坏封闭的前提下，保存对象当前状态，并且在需要的时候可以再次恢复到此状态。 数据库的 回滚操作、编辑器的 Ctrl+Z恢复 都有用到 备忘录模式。 如何理解“不破坏封闭的前提” 发起者只提供有限的接口（保存、恢复数据）。不暴露其他不该暴露的信息。 缺点 消耗资源。 /**发起者*/ public class Game { /**游戏开始时间*/ private int time; /**游戏人头数*/ private int killPeople; /** 将信息保存到备忘录*/ public GameInfo saveGameInfo() { ... GameInfo gameInfo= new GameInfo(time, killPeople); return gameInfo; } /** * 根据备忘录 恢复 信息 。 */ public void loadGame(GameInfo gameInfo) { ... time = gameInfo.getTime(); killPeople = gameInfo.getKillPeople(); ... } } /**备忘录角色 ,保存指定的状态信息*/ public class GameInfo { private int time; private int killPeople; public GameInfo(int time, int killPeople) { ... } } //使用 Game dota = new Game(); // 将状态保存到备忘录中 GameInfo info = dota.saveGameInfo(); // 根据备忘录 恢复数据 dota.loadGame(info); 外观模式 Facade Pattern 、门面模式 有一个系统 很大、很复杂，以至于一般的人不会用。即使会用也很麻烦。 这时，我们可以对这个系统做封装 ，让大家通过封装后的接口很方便地使用原来的系统 。 示例 开启电脑 需要经过多个步骤，接通电源、启动BIOS、加载系统等等。显然，用户不需要去操作这么繁琐复杂的流程 。 所以我们给用户暴露了一个简单的接口，只要一按开机键 就可以启动电脑了 。大大减小了系统使用的复杂度。 缺点 1、如果子系统做了修改 ， 外观类可能需要做相应修改。违背了开闭原则。 代理模式 、外观模式 的区别 1、侧重点不同， 代理强调 不直接访问原系统（因为权限等） 。 外观模式 强调 复杂系统的简化。 工厂方法模式（Factory Method Pattern） 又被称为多态工厂模式。 通常我们所说的工厂模式是指工厂方法模式。 工厂方法是针对每一种产品提供一个工厂类。通过不同的工厂实例来创建不同的产品实例。 反射生成对象只能适用一些最简单的情况，简单的创建一个对象。如果对象的创建过程比较复杂，例如要调用有参构造函数、创建之前要配置环境等等，需要将这些代码封装到工厂中。 /** * 定义工厂的公共行为。 * 可以用接口或抽象类。 */ public interface Factory { public Product produceProduct() ; } /** * 具体的产品 car */ public class Car implements Product { @Override public void getProductInfo() { System.out.println(\"汽车产品\"); }// }// /** * 具体的产品 bicycle */ public class Bicycle implements Product { @Override public void getProductInfo() { System.out.println(\"自行车产品\"); }// }// /** * 定义工厂的公共行为。 * 可以用接口或抽象类。 */ public interface Factory { public Product produceProduct() ; } /** * 具体的工厂类。BicycleFactory */ public class BicycleFactory implements Factory { @Override public Product produceProduct() { //做一些复杂的操作。比如连接数据库等 // ... //调用有参构造等 Bicycle bicycle = new Bicycle(); return bicycle; } }// /** * 具体的工厂类。CarFactory */ public class CarFactory implements Factory { @Override public Product produceProduct() { //做一些复杂的操作。比如连接数据库等 // ... //调用有参构造等 Car car = new Car(); return car; } }// /**使用场景*/ public static void main(String[] args) { //根据相关参数 生成具体的工厂对象。例如根据配置文件或者网络参数来决定 Factory factory ; factory= new CarFactory() ; //factory= new BicycleFactory() ; Product product = factory.produceProduct() ; product.getProductInfo(); }// 工厂方法模式优点： 1、它能够让工厂可以自主确定创建何种产品对象，而如何创建这个对象的细节则完全封装在不同的具体工厂内部。 2、加入新产品时，无须修改抽象工厂和抽象产品提供的接口，也无须修改其他的具体工厂和具体产品，而只要添加一个具体工厂和具体产品就可以了。 工厂方法模式缺点： 1、在添加新产品时，需要新加新的具体产品类和与之对应的具体工厂类，在一定程度上增加了系统的复杂度，有更多的类需要编译和运行，会给系统带来一些额外的开销。 策略模式和工厂模式有什么区别 1、侧重点不一样 。 工厂模式侧重构建过程，使用者拿到最终的“生产物”即可。 策略模式侧重 事件的行为，使用可互换的规则创建成功业务。 策略模式是开放的，大多数事情要你自己亲力亲为。而工厂模式作是封闭的，很多事情都帮组你做好了，你直接“点”就可以了。 工厂相当于黑盒子，策略相当于白盒子? 参考资料 建造者模式 Builder Pattern 适用于 构建流程非常复杂的 对象。 定义 将一个复杂对象的构造与它的表示分离，使同样的构建过程可以创建不同的表示。 1、对象的构建：对象的组装生成过程。 2、对象的表示：产品本身。产品的特性。 3、同样的创建过程：指挥者中定义的创建的相同流程。 4、创建不同的表示：不同的创建细节区分在构建者当中，调用不同的构建者会有不同的结果。 具有指挥者的建造者模式 （完整模式） // 具体的构建者 只负责 最后的构建细节。 // 不负责这些细节如何组装 class DevilBuilder extends ActorBuilder{ public void buildType() { ...} public void buildSex() { ... } public void buildFace() { ... } public void buildCostume() {...} public void buildHairstyle() {...} } // 指挥者 只负责构建顺序 class ActorController{ public Product getProduct(ActorBuilder ab) { ab.buildType(); ... ab.buildCostume(); // Product在ActorBuilder的构造函数中创建好 return ab.createAProduct(); } } //测试 // 构建顺序定义在 ActorController 中 ActorController controller = ...; // 产品不同部位的构建能力 定义在 builer 中 ActorBuilder builer=...; //根据构建者不同返回产品不同 Product product = controller.getProduct(builer); 没有指挥者的建造者模式（简略模式） 构建顺序 和构建能力 全部定义在 ActorBuilder 中 class DevilBuilder extends ActorBuilder{ public void buildType() { ...} public void buildSex() { ... } public void buildFace() { ... } public void buildCostume() {...} public void buildHairstyle() {...} public Product getProduct() { buildType(); ... buildCostume(); return createAProduct(); } } 建造者模式 和 工厂模式 的区别 工厂模式与 建造者模式的完整模式相比，就多了一个 指挥者。 不同的构建者的 构建流程 抽象出来放在一起了。 与简略模式相比，我感觉没啥区别。 建造者模式 和 策略模式 的区别 个人感觉只是定义的出发点不同。 从形式上看，都是根据传入不同的策略，获得不同的结果。（一种构建者可以看做一种策略） 抽象工厂模式（Abstract Factory Pattern） 工厂方法模式是一个具体工厂生产一种具体产品，抽象工厂模式是一个具体工厂生产一个品牌下的多种产品。 工厂方法模式解决了简单工厂模式中工厂类职责太重的问题。但由于工厂方法模式中的每个工厂只生产一类产品，可能会导致系统中存在大量的工厂类，势必会增加系统的开销。 此时，我们可以考虑将一些相关的产品组成一个“产品族”，由同一个工厂来统一生产，这就是抽象工厂模式的基本思想。 产品等级结构： 类似手机与androdi手机、mac手机的关系。手机和Android手机、mac手机具体手机产品之间构成了一个产品等级结构。 产品族: 同一个品牌下的各种产品，比如android手机和Android电视属于同一个产品族。 Abstract Factory Pattern优点： 1、隔离了具体类的生成，更换一个具体工厂就变得相对容易。 2、增加新的产品族很方便，无须修改已有系统，符合“开闭原则”。 Abstract Factory Pattern 缺点： 1、增加新的产品等级结构麻烦，违背了“开闭原则”。 增加新的产品族很方便，但是增加新的产品等级结构很麻烦，抽象工厂模式的这种性质称为“开闭原则”的倾斜性。 /** * 抽象产品 *Iphone */ public interface Iphone { public void getInfo(); } /** * 抽象产品 *Iphone */ public interface TV { public void getInfo(); } /** * 具体产品。 */ public class AndroidIphone implements Iphone { @Override public void getInfo() { System.out.println(\"mac 手机\"); } } /** * 具体产品。 */ public class MacIphone implements Iphone { @Override public void getInfo() { System.out.println(\"android 手机\"); } } /** * 具体产品。 */ public class AndroidTv implements TV { @Override public void getInfo() { System.out.println(\" Android 电视\"); } } /** * 具体产品。 */ public class MACTv implements TV { @Override public void getInfo() { System.out.println(\" MAC 电视\"); } } /** * 抽象工厂 */ public interface IFactory { public Iphone createPhone() ; public TV createTV() ; } /** * 具体工厂。 */ public class AndroidFactory implements IFactory { @Override public Iphone createPhone() { return new MacIphone(); } @Override public TV createTV() { return new MACTv(); } } /** * 具体工厂 */ public class MacFactory implements IFactory { @Override public Iphone createPhone() { return new AndroidIphone(); } @Override public TV createTV() { return new AndroidTv(); } } /*** * 测试场景 */ public static void main(String[] args) { IFactory factory = new AndroidFactory() ; //根据配置文件或者网络参数，动态决定采用哪一个工厂。 //IFactory factory = new MacFactory() ; //批量得到属于同一品牌下的产品。 Iphone phone = factory.createPhone() ; TV tv = factory.createTV() ; tv.getInfo(); }// 桥接模式 Bridge Pattern 如果一个类有多个变化维度。此时可以使用继承的方法进行组合 ，但是这样会产生大量的派生类 才能满足要求。 此时我们的桥接模式，采用聚合而非继承的方式 也可以实现同样的效果。但是需要的派生类就大大减少了。 抽象部分 、实现部分 概念参考自刘伟 。 假如一个类有两个独立的纬度，我们将与这个类关系最密切、最本质的那个纬度 称之为 “抽象部分”。而另外的一个纬度称之为“实现部分” 。 例如 一支毛笔，有“大小型号” 和\"能绘制的颜色\" 两个纬度 。因为毛笔一旦生产它的大小型号就已经被固定了，而能绘制的颜色可以根据沾染的涂料不同而变化。 所以， “型号”这个纬度划分为 “抽象部分” ，“颜色”划分为 “实现部分” 。 示意图 采用继承的方式去实现效果。需要较多的派生类。 采用桥接的方式去实现效果。型号和颜色互相组合即可实现。 //实现部分 public class Color{ String color=\"\"; public Color(String color) {...} } // 抽象部分 public class Size { Color color; String size =\"大号\" ; public Size(Color color){...} public void disPlay() { System.out.println(size+\" \"+ color.color+ \" 笔\"); } } //组合 Color white =new Color(\"白色 \"); Size size = new Size(white); size.disPlay(); //获得 大号白色笔 模板模式 、模板方法模式 、Template Method Pattern 模板方法使得子类可以在不改变算法结构的情况下，重新定义算法中的某些步骤。 为防止恶意操作，一般模板方法都加上 final 防篡改。 示例 /**抽象类*/ public abstract class AbstractComputer { /**开机*/ protected void powerOn() { ... } /**常规硬件检查*/ protected void checkHardware() { ...} /**加载 操作系统*/ protected void loadOS() { ...} /**默认无密码验证，直接进入系统*/ protected void login() { ... } /** * 模板方法，用 final修饰，防止被篡改 算法流程。 */ public final void startUp() { //公共方法 powerOn(); //有差异性的方法 checkHardware(); //公共方法 loadOS(); //有差异性的方法 login(); } } // 程序员的电脑 CoderComputer extends AbstractComputer... @Override protected void login() { // 验证用户名和密码 } //军用计算机 class MilitaryComputer extends AbstractComputer... @Override protected void checkHardware() { //进行 硬件防火墙 等安全设备是否正常 ... } @Override protected void login() { //验证 指纹 、 用户名、密码等 } AsyncTask 应用 模板方法 @MainThread public final AsyncTask execute(Params... params) { return executeOnExecutor(sDefaultExecutor, params); } @MainThread public final AsyncTask executeOnExecutor( Executor exec, Params... params) { ... onPreExecute(); ... exec.execute(mFuture); return this; } 状态模式 State Pattern 某种业务情况下，确实可以用 if else 来完成 ，但是由于 不同状态下的处理方法不一样。会导致大量的 if else 代码。 会造成代码复杂，不易维护等问题。 此时可以考虑用 状态模式 解决。 示例 一个订单的状态： 未支付、正在支付、已支付、申请退款，退款中，退款完成 //直接采用简单的 if else 方式 public void 支付（） { if(未支付) { //处理 支付操作 }else if(正在支付){ //提示 不符合操作条件。 } else if(退款完成){ //提示 不符合操作条件。 } } public void 退款（） { if(未支付) { //提示 不符合操作条件。 }else if(正在支付){ //提示 不符合操作条件。 } else if(退款完成){ //提示 不符合操作条件。 }else if(已支付){ // 处理退款操作.. } } //如果要新增 一个 \"退款审核\"状态 。 //此时需要去修改以上所有的 if else ,严重破坏 开闭原则 。 //采用状态模式 /**未支付状态*/ public class NoPayStatus { public NoPayStatus(Order order,String name) { //初始化订单信息 } public OrderStatus processOrder(Order order) { //处理当前状态下的订单， ... //根据处理结果，设置订单新的状态 OrderStatus state=new PayStatus(order,\"已支付\"); order.setStatus(state); return state; } } /**申请退款*/ public class ApplyDrawbackStatus { private Order order; private String name; public ApplyDrawbackStatus(Order order, String name) { //初始化订单信息 } @Override public OrderStatus processOrder(Order order) { //处理当前状态下的订单， ... //根据处理结果，设置订单新的状态 return new DrawbackStatus(order, \"订单回款中\"); } } //使用场景 //某个时刻根据情况根据具体情况给订单设置状态 Order order=new Order(); order.setStatus( 某个状态); .... //在另一个时刻，处理订单。 OrderStatus status=order.getStatus(); status.processOrder(order); 缺点 并没有完全符合 开闭原则 。 @Override public OrderStatus processOrder(Order order) { //如果要新增 一个 \"退款审核\"状态 。 //也需要修改相关代码 //return new DrawbackStatus(order, \"订单回款中\"); return new CheckDrawbackStatus(order, \"退款审核中\"); }       策略模式 和 状态模式 的区别 1、策略模式只是一个解决方案的封装 。重在外部对策略的选择或动态的切换。策略模式每个算法是相对独立的。 2、状态模式是初始化一个状态，之后的每个状态的变化都会指定下一个状态。状态模式中每个状态是存在相互转化的， 策略模式 Strategy Pattern /**抽象接口，定义共同操作*/ public interface Strategy { public double getValue(double paramA, double paramB); } /*** * 加法策略 */ public class AddStrategy implements Strategy { @Override public double getValue(double paramA, double paramB) { return paramA + paramB; } }// /*** * 减法策略 */ public class SubStrategy implements Strategy { @Override public double getValue(double paramA, double paramB) { return paramA - paramB; } }// /** * 根据传入的策略类型返回计算结果。 辅助类。 */ public class CalcClient { private Strategy strategy; public void setStrategy(Strategy strategy) { this.strategy = strategy; } public double calc(double paramA, double paramB) { return this.strategy.getValue(paramA, paramB); } } /////////////// 演示 ///////////////////// public static void main(String[] args) { double paramA = 5; double paramB = 21; //用if-else实现 （ 普通形式） System.out.println(\"普通方法-加法结果是：\" + calc(\"+\", paramA, paramB)); System.out.println(\"普通方法-减法结果是：\" + calc(\"-\", paramA, paramB)); //System.out.println(\"乘法结果是：\" + calc(\"*\", paramA, paramB)); //System.out.println(\"除法结果是：\" + calc(\"/\", paramA, paramB)); //策略模式 System.out.println(\"策略模式-加法结果是：\" + calc(new AddStrategy(), paramA, paramB)); System.out.println(\"策略模式-减法结果是：\" + calc(new SubStrategy(), paramA, paramB)); //System.out.println(\"乘法结果是：\" + calc(new MultiStrategy(), paramA, paramB)); //System.out.println(\"除法结果是：\" + calc(new DivStrategy(), paramA, paramB)); } /*** * 用if-else实现 （ 普通形式） */ public static double calc(String op, double paramA, double paramB) { if (\"+\".equals(op)) { return paramA + paramB; } else if (\"-\".equals(op)) { return paramA - paramB; } else if (\"*\".equals(op)) { return paramA * paramB; } else if (\"/\".equals(op)) { return paramA / paramB; } else { throw new IllegalArgumentException(\"未找到计算方法!\"); } } /*** * 策略模式 实现 */ public static double calc(Strategy strategy, double paramA, double paramB) { CalcClient calc = new CalcClient(); calc.setStrategy(strategy); return calc.calc(paramA, paramB); } 前者通过简单的if-else来解决问题，在解决简单问题事会更简单、方便; 后者则是通过给予不同的具体策略来获取不同的结果，对于较为复杂的业务逻辑显得更为直观，扩展也更为方便。 策略模式的优缺点： 优点： 1、结构清晰明了、使用简单直观。 2、耦合度相对而言较低，扩展方便。 3、操作封装也更为彻底，数据更为安全。 缺点： 1、随着策略的增加，子类也会变得繁多。 简单工厂模式（Simple Factory Pattern） 又叫做静态工厂方法（StaticFactory Method）模式。 注：简单工厂模式实际上不属于23个GOF模式。 工厂类根据传入的参量,动态的决定应该创建出哪一个产品类的实例的设计模式。一个工厂可以生产多种产品。 优点 使用者不需要去负责具体的创建过程，只需要向工厂传递参数信息就可以获得自己想要的产品。 缺点： 因为工厂类集中了所有实例的创建逻辑， 如果需要增加新的产品，就需要修改工厂类，不利于代码的维护。违背了“开闭原则” 。所以不推荐使用这种设计模式。 客户很爽，工厂很被动。 //demo: /** * 产品抽象类，定义产品共同的特效 */ public interface Product { public void getProductInfo() ; } /** * 具体的产品 car */ public class Car implements Product { @Override public void getProductInfo() { System.out.println(\"汽车产品\"); }// }// /** * 具体的产品 bicycle */ public class Bicycle implements Product { @Override public void getProductInfo() { System.out.println(\"自行车产品\"); }// }// /** * 简单工厂。 */ public class SimpleFactory { /** * 根据不同的参数进行判断，返回不同的结果。 * 如果增加了产品类，需要修改判断代码。 * 静态工厂方法 的“静态”体现在这个 static方法上 */ public static Product getProductInfo(String productType ) { Product product = null ; if(\"car\".equals(productType)){ product = new Car() ; }else{ product = new Bicycle() ; } return product; }// } /** * 测试场景 */ public static void main(String[] args) { //直接调用工厂类的 静态方法或的产品。 Product product =SimpleFactory.getProductInfo(\"car\") ; product.getProductInfo() ; }// 组合模式 Composite Pattern 、 整体-部分模式 组合模式将一批有共同特征的对象组合成 “树形结构”。 关键点是定义了一个抽象构件类，它既可以代表叶子，又可以代表容器，而客户端针对该抽象构件类进行编程，无须知道它到底表示的是叶子还是容器，可以对其进行统一处理。 透明组合模式 （推荐使用） 强调透明性一致性。 因为叶子节点不存在子节点，所以一些方法是无效的。可以用过 “提供异常处理或相关提示”来解决 。 安全组合模式 /**抽象节点 */ abstract class AbstractFile { public abstract void add(AbstractFile file); public abstract AbstractFile getChild(int i); public abstract void killVirus(); } /**叶子节点*/ class ImageFile extends AbstractFile { private String name; public ImageFile(String name) { ...} public void add(AbstractFile file) { // 子节点 不支持 当前方法 的相关提示 } public AbstractFile getChild(int i) { // 子节点 不支持 当前方法 的相关提示 return null; } public void killVirus() { //模拟杀毒 ... } } /**容器节点*/ class Folder extends AbstractFile { private ArrayList fileList=new ArrayList<>(); private String name; public Folder(String name) {...} public void add(AbstractFile file) { fileList.add(file); } public AbstractFile getChild(int i) { return (AbstractFile)fileList.get(i); } public void killVirus() { //递归调用 for(AbstractFile obj : fileList) { obj .killVirus(); } } } //使用 。针对抽象构件编程 // 子节点 AbstractFile folder2 = new Folder(\"图像文件夹\"); folder2.add(new ImageFile(\"xxx.jpg\")); folder2.add(new ImageFile(\"xxxx.gif\")); // 容器节点 AbstractFile file1 = new Folder(); folder1.add(folder2); folder1.killVirus(); 优点 1、将对象们进行树形分层，方便对整个某个层次的所有对象进行处理。 2、使用透明组合模式时， 新增节点(容器节点、子节点) 符合 “开闭原则” 。 装饰者模式 、Decorator Pattern 、包装模式 、Wrapper Pattern 在不改变一个对象原有结构和功能的前提下，给它新加一些额外的功能。 装饰模式是一种用于替代继承的技术。 /**被装饰的原始对象*/ public class ConcreteComponent extends MyComponent { /**原有功能*/ @Override public void operation() { ... } } 透明装饰模式 (尽量使用这种方式) 要求完全针对抽象编程。可以透明地使用装饰之前的对象和装饰之后的对象。 为了达到这种效果， 必须在构件对象的方法中调用 增强方法。 但是缺点是用户不能单独地调用那些增强的方法 。 /**具体装饰器*/ public class ConcreteDecoratorA extends MyComponent { MyComponent component ; /**持有被装饰的对象*/ public ConcreteDecoratorA(MyComponent component) { ... } public int operationA(){ ... 增强方法 ... } @Override public void operation() { // 区别点！！里面调用了 operationA（） operationA(); component.operation(); } } MyComponent myComponet1= new ConcreteComponent(...); // 针对MyComponent抽象编程 MyComponent myComponet2 = new ConcreteDecoratorA(myComponet1); myComponet1.operation(); //不能在外面调用额外功能 。- 编译 出错 myComponet2.operationA(); myComponet2.operation(); 半透明装饰模式 /**具体装饰器*/ public class ConcreteDecoratorA extends MyComponent { MyComponent component ; /**持有被装饰的对象*/ public ConcreteDecoratorA(MyComponent component) { ... } public int operationA(){ ... 增强方法 ... } @Override public void operation() { // 区别点！！ 在里面并没有调用 operationA() component.operation(); } } MyComponent myComponet1= new ConcreteComponent(...); ConcreteDecoratorA myComponet2 = new ConcreteDecoratorA(myComponet1); //透明装饰者模式 myComponet1.operation(); // 可以在外 调用增强方法 - 编译ok myComponet2.operationA(); myComponet2.operation(); 如何理解 “半透明装饰模式不能实现对同一个对象的多次装饰” 首先明确一点：半透明装饰模式 是将 增强方法 和原有方法 独立开来的。在装饰器中 原有方法并没有调用过增强方法。 因为装饰类持有的是 MyComponent 类型的引用，而 MyComponent 并不能调用增强方法。所以导致如下结果： 多次装饰的情况下，无法使用那些增强方法。 代理模式 与 装饰者模式 区别 代理模式的目标是控制对被代理对象的访问（强调控制） ，而装饰模式是给原对象增加额外功能 （强调增加功能）。 观察者模式 Observer Pattern 观察者模式 1、Observer Pattern用于建立一种对象与对象之间的依赖关系。 一个对象发生改变时将自动通知其他对象，其他对象将相应作出反应。 2、Observer Pattern包含1个观察目标和n(n>=1)观察者两类对象。一旦观察目标的状态发生改变，所有的观察者都将得到通知。 3、这种交互也称为发布-订阅(Publish-Subscribe)。 发布者发出通知时并不需要知道谁是它的观察者，可以有任意数目的观察者订阅它并接收通知。 4、凡是涉及到一对一或者一对多的对象交互场景都可以使用观察者模式。 观察者模式的应用 1、交通信号灯是汽车（驾驶员）的观察目标，而汽车是观察者。 随着交通信号灯的变化，汽车的行为也将随之而变化，一盏交通信号灯可以指挥多辆汽车。 2、在当前流行的MVC架构中也应用了观察者模式，它包含三个角色：模型(Model)，视图(View)和控制器(Controller)。 其中模型可对应于观察者模式中的观察目标，而视图对应于观察者，控制器可充当两者之间的中介者。 当模型层的数据发生改变时，视图层将自动改变其显示内容。 观察目标 Observer Pattern中，发生改变的对象称为观察目标。 观察者 而被通知的对象称为观察者。 1、一个观察目标可以对应多个观察者。 2、这些观察者之间可以没有任何相互联系。 3、可以根据需要增加和删除观察者，使得系统更易于扩展。 Observer Pattern优点 1、观察者模式可以实现表示层和数据逻辑层的分离，定义了稳定的消息更新传递机制，并抽象了更新接口，使得可以有各种各样不同的表示层充当具体观察者角色。 2、观察者模式在观察目标和观察者之间建立一个抽象的耦合。观察目标只需要维持一个抽象观察者的集合，无须了解其具体观察者。 3、观察者模式支持广播通信，观察目标会向所有已注册的观察者对象发送通知，简化了一对多系统设计的难度。 4、观察者模式满足“开闭原则”的要求，增加新的具体观察者无须修改原有系统代码，而且观察目标和观察者没有紧密地耦合在一起，因此它们可以属于不同的抽象化层次。在具体观察者与观察目标之间不存在关联关系的情况下，增加新的观察目标也很方便。 Observer Pattern缺点： 1、若一个观察目标对象有很多直接和间接观察者，将所有的观察者都通知到会耗时过多。 2、若观察者和观察目标之间存在循环依赖，观察目标会触发它们之间进行循环调用，可能导致系统崩溃。 3、Observer Pattern没有相应的机制让观察者知道所观察的目标对象是怎么发生变化的，而仅仅只是知道观察目标发生了变化。 Observer Pattern应用场景 1、邮件订阅和RSS订阅，当我们浏览一些博客或wiki时，当你订阅了该文章，如果后续有更新，会及时通知你。 demo: /** * 观察者抽象类，定义共同的行为 */ public interface Observer { public void update(); } /*** * 具体的观察者 1 */ public class Observer1 implements Observer { @Override public void update() { System.out.println(\"观察者 1收到通知\"); } }// /*** * 具体的观察者 2 */ public class Observer2 implements Observer { @Override public void update() { System.out.println(\"观察者 2收到通知\"); } }// /** * 被观察者接口。 * 定义一些 方法用来管理 观察者集合。 */ public interface Subject { /**添加观察者*/ public void addObserver(Observer observer) ; /**删除观察者*/ public void delObserver(Observer observer) ; /**通知观察者*/ public void notifyAllObservers(); }// /*** * 具体的 被观察者 （观察目标）。 */ public class MySubject implements Subject { /**线程安全的集合*/ private Vector myObservers ; /**构造函数*/ public MySubject () { myObservers = new Vector(); } @Override public void addObserver(Observer observer) { myObservers.add(observer) ; } @Override public void delObserver(Observer observer) { myObservers.remove(observer) ; } @Override public void notifyAllObservers() { //使用迭代器获取所有观察者 并通知 Iterator iterator = myObservers.iterator() ; while (iterator.hasNext()) { Observer observer = iterator.next(); observer.update(); }// }// } /**实际场景应用*/ public static void main(String[] args) { Observer1 ob1 = new Observer1() ; Observer2 ob2 = new Observer2() ; MySubject mySubject = new MySubject() ; mySubject.addObserver(ob1); mySubject.addObserver(ob2); mySubject.notifyAllObservers() ; }// 解释器模式 Interpreter Pattern 还未完全理解。 等过段时间再来更新.... 解释器模式为自定义语言的设计和实现提供了一种解决方案，它用于定义一组文法规则并通过这组文法规则来解释自定义语言中的句子。 #### 应用场景 1、正则表达式解释器 2、SQL语法的解释器 相关概念 特点 举例 终结符（表达式） 不可拆分的最小元素。 一个语法的规则不能改变终结符。 x -> xa a是终结符 非终结符（表达式） 可拆分元素。 非终结符是可以被取代的元素。运算符也是非终结符 x -> xa x 是非终结符 语言的文法规则 即语法规则。拥有自己的表达式和结构。 抽象语法树(Abstract Syntax Tree, AST) 用来直观地表示语言的构成。 每一棵抽象语法树对应一个语言实例。 终结符表达式类的实例作为树的叶子节点，非终结符表达式类的实例作为非叶子节点。 通过对抽象语法树的分析，可以识别出语言中的终结符类和非终结符类。 环境角色 存放文法中各个终结符所对应的具体值 #### 示例 Java无法直接解释类似“1+ 2 + 3 – 4 + 1”这样的字符串。 我们可以自己定义 一个解释器来解释这个语句 。 一些重复发生的问题，比如加减乘除四则运算，但是公式每次都不同，有时是a+b-cd，有时是ab+c-d，等等等等个，公式千变万化，但是都是由加减乘除四个非终结符来连接的，这时我们就可以使用解释器模式。 ``` ~~#### 缺点 1、 执行效率低。 2、 维护困难。~~ # 访问者模式 Visitor Pattern 访问者模式把 数据结构 和 作用于结构上的操作 解耦合 。适用于数据结构相对稳定算法又易变化的场景。 ## [示例](https://blog.csdn.net/lovelion/article/details/7433576) 以公司员工和部门的关系为场景。 ```java /**全职员工*/ public class FulltimeEmployee implements Employee { public FulltimeEmployee(String name, int workTime) {...} /**每个对象都会实现这个方法*/ @Override public void accept(Department handler) { //每个访问者都会有这个方法 handler.visit(this); } } /**人力资源部类：具体访问者类*/ public class HRDepartment implements Department { /**所有访问者都会重载 所有 visit方法*/ @Override public void visit(FulltimeEmployee employee) { ... } /***所有访问者都会重载 所有 visit方法 */ @Override public void visit(ParttimeEmployee employee) { ... } } //使用。访问者不同，会做出不同的处理结果 Employee employee = new FulltimeEmployee(...); Department dep = new HRDepartment(....) ; //Department dep = new FADepartment (....) ; employee.accept(dep); 优点 1、方便定义 新的访问者，实现新的数据操作。 //Department dep = new HRDepartment(....) ; //定义新的访问者 Department dep = new FADepartment (....) ; 缺点 1、违背了\"依赖倒置原则\" 。访问者依赖的是具体元素，而不是抽象元素。 public void visit(FulltimeEmployee employee) { ... } 2、增加新的元素类比较困难。 每增加一个元素类 , 访问者就要多加一个visit()。 // 有 n个元素类 就有 n 个visit 方法 @Override public void visit(FulltimeEmployee employee) { ... } .... @Override public void visit(ParttimeEmployee employee) { ... }    访问者模式 和 策略模式 的区别 我个人感觉这两个模式差不多。 个人体会到的区别： 1、策略模式是通过构造方法将策略传进去的 。 访问者模式 是通过普通的方法 accept() 将访问者（策略）传进的。 2、 体现在定义架构上 public class HRDepartment implements Department { @Override public void visit(FulltimeEmployee employee) { ... } ... @Override public void visit(ParttimeEmployee employee) { ... } } 责任链模式 Chain of Responsibility Pattern 其实 ，swith 、if-else 体现了最简单的责任链思想 。只是这种写法 比较臃肿、耦合度高。 优点 1、一个请求沿着一条“链”传递，申请者不需要知道是谁来批准这个请求。 批阅者也不需要这个请求来自谁。 这样将 申请者和批阅者优雅地解耦了。 2、容易拓展责任链 缺点 1、需要对链中责任人的遍历，如果责任人太多那么遍历必定会影响性能。 2、请求不一定会被处理掉。 代码示例 /**责任人的处理方法*/ public void handleRequest(ProgramApe ape){ if ( 有处理权限) { // 自己处理掉... } else { if (null != mSuperiorLeader) { //如果自己没有权限处理， 就交给上级处理 } else { //如果自己没有权限处理， 也没有其他领导。就抛出错误，提示该 //请求没有被处理掉 } } } //应用场景 //先来一个程序猿 这里给他一个三万以内的随机值表示需要申请的差旅费 ProgramApe ape = new ProgramApe((int) (Math.random() * 30000)); //再来四个领导 Leader leader = new GroupLeader(); Leader director = new Director(); Leader manager = new Manager(); Leader boss = new Boss(); //事先设置好 责任链之间的连接关系 leader.setLeader(director); director.setLeader(manager); manager.setLeader(boss); // 提交申请（不用写 if else 繁琐代码） leader.handleRequest(ape); 迭代器模式 Iterator Pattern 、游标模式 迭代器模式 提供一种机制 遍历一个聚合对象中的各个元素，而又不暴露其他细节。 /**具体迭代器*/ class ConcreteIterator implements MyIterator{ private List list = new ArrayList (); private int cursor =0; public ConcreteIterator(List list){ this.list = list; } public boolean hasNext(){ return !(cursor == list.size()); } public Object next(){ if(hasNext()){ return list.get(cursor++); } return null; } } /**具体的聚合类*/ class ConcreteAggregate { private List list = new ArrayList(); public MyIterator iterator(){ return new ConcreteIterator(list); } /** * 聚合类中的其他方法 ，处理其他逻辑 * fun1 、saveObj 、removeObj */ public void saveObj(Object obj) { ... } ... 其他逻辑... } //使用 // 聚合类 ConcreteAggregate ag = new ConcreteAggregate(); ag.saveObj(\"obj1\"); ag.saveObj(\"obj2\"); // 获取迭代器 MyIterator it = ag.iterator(); //根据迭代器 遍历 while(it.hasNext()){ ... } 优点 1、将聚合类 的 “数据存储” 和 \"数据遍历\" 分离 。 2、自定义的迭代器可以实现一些自己想要的遍历效果（逆序遍历、只遍历符合自己指定条件的对象等）。 缺点 1、一个具体的聚合类 对应一个 迭代器 ，略显繁琐。 注 由于java已经为我们对容器对象（Collection，List、Set、Map等）做了很好的封装，我们平时其实很少会自己实现迭代器模式。 适配器模式 Adapter Pattern 解决接口不兼容的问题。 A 需要 C接口， 但是系统只提供了B接口。 同时, A 和B 都不想改或者不能改。 如果，我们将B封装一下，改成C接口的规范。就解决了问题。 被适配者 ：即源接口 一、类适配器 （不推荐） 采用继承方案。 // 旧接口 提供220V电压 public class Voltage220 { public int output220V() { return 220; } } // 用户需要 5V的电压 public interface Voltage5{ int output5V(); } //新建适配器 public class VoltageAdapter extends Voltage220 implements Voltage5 { @Override public int output5V() { //获得旧接口的数据， 转换成用户需要的数据 int src = output220V(); return src / 44; } } 二、对象适配器 （推荐） 采用持有方案。 // 新建适配器 public class VoltageAdapter2 implements Voltage5 { private Voltage220 mVoltage220; public VoltageAdapter2(Voltage220 voltage220) {...} @Override public int output5V() { int src = mVoltage220.output220V(); return src / 44; } } 三、缺省适配器 、接口适配器模式（推荐） 原接口是 interface 。 // 原接口 public interface AnimatorPauseListener{ void onAnimationStart(Animator animation); void onAnimationEnd(Animator animation); ... void onAnimationResume(Animator animation) ; } // 新建适配器 public abstract class AnimatorListenerAdapter implements AnimatorListener { @Override public void onAnimationEnd(Animator animation){...} @Override public void onAnimationStart(Animator animation){...} @Override public void onAnimationResume(Animator animation) {...} } // 使用 XXX.addListener(new AnimatorListenerAdapter() { @Override public void onAnimationStart(Animator animation) { // 重新 需要的那个方法就行。 // 而不必 要实现 interface 中所有的方法，从而简化代码 } }); 四、双向适配器 （不推荐） 同时持有原接口和旧接口的对象。 class Adapter implements DesInterface,SrcInterface { private Des des; private Src src; public Adapter(Des des) {... } public Adapter(Src src) {...} public void() func1(){ src.xxx(); }; public void() func2(){ des.xxx(); }; } Android 中 常用的设计模式 单例模式 // 建造者模式 Builder // AlertDialog.Builder 观察者模式 // Rxjava ， 适配器模式 // 解决接口不兼容的问题 ，两个系统的接口不一样，我继承旧接口,然后... 代理模式 // 源码中 有大量用到 ActivityManagerProxy , AMS 无版权 可以无限制使用！ all right reserved，powered by Gitbook该文件更新时间： 2020-12-17 17:26:07 "},"chinese/设计模式/mvc等.html":{"url":"chinese/设计模式/mvc等.html","title":"mvc等","keywords":"","body":"常用架构 MVC 架构 1979年，Trygve Reenskaug 在Smalltalk-80系统上首次提出了MVC的概念， 最初的时候叫做Model-View-Controller-Editor。 MVC并不是一种设计模式，不在23种经典设计模式中。 可以理解为 MVC是一种架构模式，一种架构可能 运用到了多种设计模式。 Model 模型 适合做一些业务逻辑处理，比如数据库存取操作，网络操作，复杂的算法，耗时的任务等都在model层处理。 View 视图 处理数据显示的部分，XML布局可以视为V层，显示Model层的数据结果。 Controllor 控制器 处理用户交互问题。 mvc 优点 、缺点 // 优点 1、实现了分层开发 ,降低了代码的耦合 // 缺点 1、增加了代码编写的复杂性 2、MVC中 允许 M 层 和 V 层进行交互 ，解耦合不够彻底 MVP 架构 Model 业务逻辑和实体模型层 View 视图展示层。 V层没有任何的逻辑部分又不用主动监听数据，被称之为“被动视图”。 Presenter 负责view和model层的交互。 mvp 特点 于mvc相比，mvp有以下特点 1、 M 层和 V 层只能通过 P 层进行交互 2、V 层和 P 层通过接口进行交互 3、一个复杂的 V 层可以对应多个 P mvp 优点 、缺点 // 优点 1、相对mvc解耦更彻底 // 缺点 1、多了很多接口文件。 繁多的接口，繁琐的接口通信 , 在实际的开发过程中，很难严格遵循。 MVVM 、 MV-VM 架构 MVVM架构在一定程度上减少了MVP存在的以下缺点。 1、P 层与 V 层是通过接口进行交互的，接口粒度不好控制。 粒度太小，就会存在大量接口的情况，使代码太过碎版化; 粒度太大，解耦效果不好。 2、V 层与 P 层还是有一定的耦合度。 一旦 V 层某个UI元素更改，那么对应的接口就必须得改， 数据如何映射到UI上、事件监听接口这些都需要转变，牵一发而动全身。 3、复杂的业务同时也可能会导致 P 层太大。虽然可以 一个 V 对应 多个 P 。 MVVM模块 模块 说明 M Model 数据提供 V View 视图展示 VM ViewModel M 和 V 绑定 ， 监听数据变化，一旦有改变，就响应到另一方 mvvm的缺点 2、引入新框架，增加学习成本。 3、通过 数据绑定的方式 ，出现问题 ，不容易调试。 MVVM 实现数据绑定、完全解耦的原理 在安卓中，DataBinding 是 谷歌提供的一个工具， 可以将 V 和 M 进行数据绑定 。 能实现数据绑定的原因，我猜测是框架采用了 观察者模式 实现数据驱动， DataBinding 具体源码我暂时还未看过，只能是猜测 。 其他方向，例如前端也有类似的框架，例如 Vue.js DataBinding 完全解耦的方案中 ，如何管理生命周期 可以使用 谷歌的 LiveData 。 LiveData 具有生命周期感知能力，意指它遵循其他应用组件（如 Activity、Fragment 或 Service）的生命周期。 这种感知能力可确保 LiveData 仅更新处于活跃生命周期状态的应用组件观察者。 总结 1、MVC中 允许 M 层 和 V 层进行交互 ，耦合太高，不合理。 2、MVP 中 ， P 层与 V 层还是有一定的耦合度。还不够完美。 3、MVVM ，通过数据绑定的方式，实现数据监听 ，完全解耦。 无版权 可以无限制使用！ all right reserved，powered by Gitbook该文件更新时间： 2020-12-18 08:20:03 "},"chinese/java基础/原码补码反码.html":{"url":"chinese/java基础/原码补码反码.html","title":"java部分","keywords":"","body":"原码补码反码 类型 正数规则 负数规则 其他 原码 0表示正号，1表示负号，后面是数值部分 跟正数一样 反码 与原码相同 原码的符号位不变，其它位取反 补码 与原码相同 反码+1 加法运算 只能通过 补码来运算，因为通过原码不能保证所有的计算都是正确的。 例如 ： 6+（-3） 补码存在的意义 1、 因为采用原码或反码 进行 减法运算 ，并不能保证结果正确。 为了保证计算正确， 因此设计了补码的规则 。至于为什么采用这样的设计就能保证结果正确。请查阅其他资料。 无版权 可以无限制使用！ all right reserved，powered by Gitbook该文件更新时间： 2020-08-19 17:20:00 "},"chinese/java基础/java虚拟机.html":{"url":"chinese/java基础/java虚拟机.html","title":"java虚拟机","keywords":"","body":"参考资料： 1、 深入理解Java虚拟机 无版权 可以无限制使用！ all right reserved，powered by Gitbook该文件更新时间： 2020-08-19 17:20:00 "},"chinese/java基础/类加载机制.html":{"url":"chinese/java基础/类加载机制.html","title":"类加载机制","keywords":"","body":"类加载机制 类的生命周期 java类加载器分类 从虚拟机层面角度分类 从虚拟机层面角度讲,分为两大类型的类加载器。 一是Bootstrap Classloader ，即启动类加载器（C++实现），它是虚拟机的一部分， 二是其他类型类加载器（JAVA实现），在虚拟机外部，并全部继承ClassLoader类。 从加载顺序角度来分类 1、Bootstrap ClassLoader 主要负责加载JVM自身工作所需要的类。 是由C/C++编写的，它本身是虚拟机的一部分，所以它并不是一个JAVA类，无法在java代码中获取它的引用。 所以getClass().getName()返回null。 System.out.println(System.getProperty(\"sun.boot.class.path\")); xxx\\jre\\lib\\resources.jar; xxx\\jre\\lib\\rt.jar; xxx\\jre\\lib\\sunrsasign.jar; xxx\\jre\\lib\\jsse.jar; xxx\\jre\\lib\\jce.jar; xxx\\jre\\lib\\charsets.jar; xxx\\jre\\lib\\jfr.jar; xxx\\jre\\classes 2、ExtClassLoader 负责装载JRE扩展目录ext下的jar类包。一般为JVM平台扩展工具。 System.out.println(System.getProperty(\"java.ext.dirs\")); xxx\\jre\\lib\\ext; C:\\Windows\\Sun\\Java\\lib\\ext 3、AppClassLoader(SystemAppClass) 如果应用程序中没有自定义过自己的类加载器，一般情况下这个就是程序中默认的类加载器。 System.out.println(System.getProperty(\"java.class.path\")); //这个路径其实就是当前java工程目录bin，里面存放的是编译生成的class文件。 F:\\aivin_space\\myEclipseSpace\\MySample\\bin 类加载之间的父子关系是怎样的 子类加载器和父类加载器的关系，是委派关系并不是继承关系。 双亲委派（parent delegation）模型 在加载类别时，每个类别加载器会先将加载类别的任务交由其parent，如果parent找不到，才由自己负责加载，如果自己也找不到，就会丢出 NoClassDefFoundError。 为什么要用“双亲委派模型” 防止内存中出现多份同样的字节码 。比如两个类A和类B都要加载System类：如果不用委托而是自己加载自己的，那么类A就会加载一份System字节码，然后类B又会加载一份System字节码，这样内存中就出现了两份System字节码。 自定义类加载器的意义和使用场景 1、为了实现jdk的类加载器没有的某些功能。 例如Tomcat使用自定义的类加载器实现了热部署功能。 2、将java写的核心代码编译成.clas文件，然后将lass文件就加密。只有使用在自己的类加载器才能正确使用这些核心代码。 (因为只要获得了这个加载器，核心代码就可以轻易被获取。 所以要保护好自己的加载器。) 无版权 可以无限制使用！ all right reserved，powered by Gitbook该文件更新时间： 2020-08-26 11:12:55 "},"chinese/java基础/内存.html":{"url":"chinese/java基础/内存.html","title":"内存","keywords":"","body":"内存详解 运行时数据区域 分为5块内存空间。 附：栈是运行的单位，而堆是存储的单元。 // 1、程序计数器 当前线程所执行的字节码的行号指示器。用来记录程序运行到哪里了，下一步又该执行哪一步操作。 // 2、本地方法栈 存储本地方法执行过程中的栈数据。 // 3、JVM栈（Java栈） 存放一个Java线程的运行状态。 // 4、堆 存放运行时产生的对象的。Java只能在堆中存放对象 // 5、方法区 方法区主要是用来存类型数据的，与类型相关的东西，比如常量，静态变量。 注：运行时常量池是方法区的一部分，用来存放编译器生成的各种字面量和符号引用。 (绿色部分是每个线程私有的，白色部分是线程共享的) Java内存模型 其他语言，例如c/c++直接使用了物理硬件或操作系统的内存模型， 由于不同平台上内存模型的差异性，需要开发者针对不同的平台做相应的兼容处理。 Java内存模型是为了屏蔽各种硬件和系统的访问差异，达到一致的并发效果。进一步解决多线程编程中的线程安全等问题。 基本概念 1、主内存： 进程内存？ 所有线程共享主内存。 2、工作内存： 线程内存? 每个线程都有自己的执行空间(即工作内存)，线程执行的时候用到某变量， 首先要将变量从主内存拷贝的自己的工作内存空间，然后对变量进行操作：读取，修改，赋值等，这些均在工作内存完成， 操作完成后再将变量写回主内存； 3、可见性 各个线程都从主内存中获取数据，线程之间数据是不可见的；打个比方：主内存变量A原始值为1，线程1从主内存取出变量A，修改A的值为2， 在线程1未将变量A写回主内存的时候，线程2拿到变量A的值仍然为1； 4、指令重排序 即生成的机器指令与字节码指令顺序不一致。 为什么会有重排序? 为了提高执行效率，目前大多数现代微处理器都会采用将指令乱序执行。 在条件允许的情况下，直接运行当前有能力立即执行的后续指令，避开获取下一条指令所需数据时造成的等待。 int a = 1; int b = 2; int c = a + b; 将上面的代码编译成Java字节码或生成机器指令，大致可视为展开成了以下几步动作： 对a赋值1 --1 对b赋值2 --2 取a的值 --3 取b的值 --4 将取到两个值相加后存入c --5 在上面5个动作中，动作1可能会和动作2、4重排序， 动作2可能会和动作1、3重排序，动作3可能会和动作2、4重排序， 动作4可能会和1、3重排序。但动作1和动作3、5不能重排序。 动作2和动作4、5不能重排序。因为它们之间存在数据依赖关系， 一旦重排，as-if-serial语义便无法保证。 5、as-if-serial语义 所有的动作都可以为了优化而被重排序，但是必须保证它们重排序后的结果和程序代码本身的应有结果是一致。所以，重排序不会发生在有数据依赖的操作之中。 8大原子操作 为了解决主内存和工作线程的一致性问题，Java定义了如下原子操作. 1、 lock 锁定 作用于主内存，把变量标记为一条线程独占状态。 2、unlock 解锁。 作用于主内存，释放后的变量才能被其他线程锁定。 3、 read读取 作用于主内存。 将变量的值从主内存传输到工作内存中。 4、load 载入 作用于工作内存。将从主内存中得到的变量值放入工作内存的变量副本中。 5、 use 使用。 作用于工作内存。 将工作内存中的变量的值传递给执行引擎。 6、assign 赋值 作用于工作内存。将执行引擎传递过来的值赋值给工作内存中的变量副本。 7、store 存储 作用于工作内存。 将工作内存中的变量值传递到主内存。 8、write 写入 作用于主内存。将从工作内存中传递过来的值 赋值给主内存的变量。 无版权 可以无限制使用！ all right reserved，powered by Gitbook该文件更新时间： 2020-09-24 10:17:44 "},"chinese/java基础/GC机制.html":{"url":"chinese/java基础/GC机制.html","title":"GC机制","keywords":"","body":"gc机制 GC机制的诞生时间大于Java。在早期的一些语言也曾使用过GC机制。 经过多年的发展，GC机制已经已经进入了“自动化”时代了，我们为什么还要去了解GC机制呢？ 因为深入了解GC机制能更好地排查内存溢出泄露问题。 当GC机制成为高并发的瓶颈时，我们可以通过监控和调节GC过程，采取合适的优化方案。 普通的程序员也可以从GC机制中学习到它们优秀的策略。 判断对象是否存活的方法 1、引用计数算法 (Reference Counting) 给对象中添加一个引用计数器,每当有一个地方引用它时,计数器值就加1; 当引用失效时,计数器值就减1;任何时刻计数器为0的对象就是不可能再被使用的。 java已经摈弃了这种方案。因为很难解决对象之间的互相循环引用的问题。 2、可达性分析算法( Reachability Analysis) / 根搜索算法( GC Root Tracing) 目前主流编程语言(java,C#等)中,都是称通过可达性分析来判定对象是否存活的。 该算法的基本思路就是通过一系列的“GC Roots”对象作为起始点,从这些节点开始向下搜索(搜索所走过的路径称为引用链), 当一个对象到GC Roots没有任何引用链相连(用图论的话来说,就是从GC Roots到这个对象不可达)时,则证明此对象是不可用的。 如下图所示，对象object 5、object 6、object 7虽然互相有关联,但是它们到GC Roots是不可达的,所以它们将会被判定为是可回收的对象。 Java语言中 可作为GC Roots的对象 1、虚拟机栈(栈帧中的**本地变量表**)中引用的对象。 2、持久代中类**静态属性引用的对象**。 3、持久代中**常量引用的对象**。 4、本地方法栈中JNI(即一般说的Native方法)引用的对象。 垃圾收集算法 标记-清除算法 首先标记出所有需要回收的对象，标记完成后统一回收被标记过的对象。 缺点： 1、效率不高。标记和清除过程效率都不高。 2、空间问题。标记清除后会产生大量不连续的内存碎片。 复制算法 将内存均分为两块，每次只用其中一块。当着一块的内存用完了，就将还存活的对象复制到另一块内存上。 然后将已经使用过的这块内存一次性清理掉。 优点： 实现简单，运行高效。 缺点： 浪费内存，可用内存较少。 标记-整理 算法 标记过程与 “标记-清除”算法一样。然后，让所有存活的对象向一端移动，最后直接清理掉端边界以外的内存。 分代收集算法 该算法是目前大部分JVM的垃圾收集器采用的算法。 核心思想是根据对象存活的生命周期将内存划分为若干个不同的区域。然后根据各个年代的特点采用适当的收集算法。 内存划分类型 内存被分为下面三个区域 。 Enden、form survicor space、to survivor space。 新生代 绝大多数最新被创建的对象会被分配到这里。对象从这个对象消失的过程称为”minor GC”。 特征： （1）GC的发生相对比较频繁和迅速高效。 （2）包含了许多短周期对象。 老年代 (1)、从新生代存活下来的对象会被拷贝到这里，它的空间比新生代要大 (2)、GC操作不是很频繁，但是耗时比新生代中的GC要长。 内存占用的增长比较缓慢。 对象从老年代消失的过程称为”major GC”或者”full GC”。 永久代 (方法区/持久代) 用来存放类常量和字符串常量(并不是用来存储那些从老年代存活下来的对象)。它也会发生GC操作。 内存分配与回收机制 对象优先在Eden分配 对象一般在新生代Eden区中分配，当Eden区没有足够的空间进行分配时，虚拟机将发起一次Minor GC 。 大对象直接就进入老年代 大对象(类似很长的字符串或数组 需要大量连续内存空间的对象)。 长期存活的对象将进入老年代 虚拟机给每个对象定义了一个对象年龄计数器。对象再Survivor区中每熬过一次Minor GC,年龄就会增加1岁。当年龄增加到一定程度(默认配置15岁)，对象就会被移动到老年代中。 动态对象年龄判定 并不是一定要达到规定的年龄，对象才会被移动到老年代中。 如果Survivor空间中相同年龄 所有对象的大小的总和大于Survivor空间的一半，年龄>=该年龄的对象就会直接被移动到老年代中。 空间分配担保 在执行Minor GC之前，虚拟机先检查老年代最大可用的连续空间是否大于新生代所有对象总空间，如果ok，那么此次Minor GC可以安全进行。否则，虚拟机会查看HandlePromotionFailure设置值是否允许担保失败。如果允许，那么会继续检查老年代最大可用的连续空间是否大于历次晋升到老年代对象的平均大小，如果大于，将尝试着进行一次Minor GC，(尽管此次 Minor GC是有风险的)；如果小于，或者HandlePromotionFailure设置不允许冒险，就改为执行 Full GC（不执行 Minor Gc）。 拓展知识点 Java中引用的类型 1、强引用 类似Object obj= new Object(); 只要强引用还存在，GC永远不会回收掉被引用的对象。 2、软引用 可用SoftReference实现软引用。 系统内存不足时，会把软引用关联的对象加入回收范围并进行回收，回收后如果内存还是不足才会抛出内存溢出异常。 3、弱引用。 可用WeakReference实现。 当GC执行时，无论当前内存是否充足，都会将若引用关联的对象回收掉。 4、虚引用 可用PhantomReference实现。 为一个对象设置虚引用的唯一目的就是希望对象被回收时系统能提供一个系统通知。 finalize() finalize()的发明是为了向c/c++程序员妥协。 在Java中使用finalize()方法反而会带来更多的不确定性。 所以在Java中不推荐使用这个方法，不建议对象进行自我拯救。 类似于“关闭外部资源”之类的工作可以交给try-finally或其他方式完成。 被GC判断为”垃圾”的对象一定会回收吗 在可达性分析算法中不可达的对象,也并非是“非死不可”的, 这时候它们暂时处于“缓刑”阶段,要真正宣告一个对象死亡,至少要经历 两次标记过程。 如果对象在进行可达性分析后发现没有与GC Roots相连接的引用链,那它将会被第一次标记并且进行一次筛选, 筛选的条件是此对象是否有必要执行finalize()方法。 当对象没有覆盖finalize()方法,或者finalize()方法已经被虚拟机调用过,虚拟机将这两种情况都视为“没有必要执行”。(即意味着直接回收)。 如果这个对象被判定为有必要执行finalize()方法,那么这个对象将会放置在一个叫做F-Queue的队列之中, 并在稍后由Finalizer线程(虚拟机建立的、低优先级)去触发finalize()方法。 finalize()方法是对象逃脱死亡命运的最后一次机会,稍后GC将对F-Queue中的对象进行第二次小规模的标记, 如果对象要在finalize()中成功拯救自己——只要重新与引用链上的任何一个对象建立关联即可, 譬如把自己(this关键字)赋值给某个类变量或者对象的成员变量,那在第二次标记时它将被移除出“即将回收”的集合; 如果对象这时候还没有逃脱,那基本上它就真的被回收了。 任何一个对象的finalize()方法只能被系统自动调用一次。所以对象自我拯救的次数有限。 无版权 可以无限制使用！ all right reserved，powered by Gitbook该文件更新时间： 2020-08-19 17:20:00 "},"chinese/java基础/对象内存布局.html":{"url":"chinese/java基础/对象内存布局.html","title":"对象内存布局","keywords":"","body":"对象内存布局 在HotSpot虚拟机中，对象在内存中存储的布局分为对象头Header、实例数据Instance Data、对齐填充Padding。 // 对象头 object header , 包括了关于堆对象的布局、类型、GC状态、同步状态和标识哈希码的基本信息。Java对象和vm内部对象都有一个共同的对象头格式。 // 实例数据 Instance Data ,主要是存放类的数据信息，父类的信息，对象字段属性信息。 // 对齐填充 Padding, 为了字节对齐，填充的数据，不是必须的。 对齐填充并不是必然存在的，无特别含义，起着占位符的作用， HotSpotVM的自动内存管理系统要求对象起始地址必须是8字节的整数倍，也就是对象的大小必须是8字节的整数倍， 对象头正好是8字节的倍数，所以当对象实例数据部分没有对齐，就需要通过对齐填充来补全。 对于Java和C、C++、C#这类高级语言，因为编译器的存在，编译器或虚拟机会自动帮我们进行字节对齐补白。无需手动去处理。 为什么要进行内存对齐 // 平台原因 不是所有的硬件平台（例如某些嵌入式系统中使用的低端微处理器）都能访问任意地址上的任意数据，某些硬件平台只能访问对齐的地址，否则会出现硬件异常。 // 性能原因 如果数据存放在未对齐的内存空间中，则处理器访问变量时需要做两次内存访问，而对齐的内存访问仅需要一次访问。 显然，内存对齐在某些情况下可以减少读取内存的次数以及一些运算，性能更高。 另外，由于内存对齐保证了读取 b 变量是单次操作，在多核环境下，原子性更容易保证。 但是内存对齐提升性能的同时，也需要付出相应的代价。由于变量与变量之间增加了填充，并没有存储真实有效的数据，所以占用的内存会更大。 这也是一个典型的空间换时间的应用场景。 如何解决 内存对齐 带来的内存浪费问题 有内存对齐就会有内存浪费的情况，所以为了减少内存浪费，并达到内存对齐的目的，JVM就会将字段重新排列。 struct A{ int i ; char c ; short s ; }; struct B{ char c ; int i ; short s ; }; // 打印结果 sizeof( struct A));--- > 8 sizeof( struct B)); ---->12 从上面例子可以看到，包含相同变量的两个结构体，由于声明变量的顺序不同，最后为结构体申请的内存大小也不同。 JVM为了优化内存空间利用率， ①按照类型的大小从小到大顺序，那么可以减少一些补白空间 ②将相同类型的字段组合在一起，减少一些补白操作，提升了整个空间利用率。 无版权 可以无限制使用！ all right reserved，powered by Gitbook该文件更新时间： 2020-09-24 09:49:19 "},"chinese/java基础/线程详解.html":{"url":"chinese/java基础/线程详解.html","title":"线程详解","keywords":"","body":"线程同步 相关概念 可重入 可重入函数保证了在多线程条件下，函数的状态不会出现错误。 以下分别是一个不可重入和可重入函数的示例： // func1是不可重入的 , 因为tmp是 static 全局变量，多线程访问时，会出现问题。 static int tmp; void func1(int* x, int* y){ tmp=*x; *x=*y; *y=tmp; } //func2是可重入的 void func2(int* x, int* y){ int tmp; tmp=*x; *x=*y; *y=tmp; } 线程中断 中断本质是一种特殊的电信号。处理器接受到中断后，会马上向操作系统反映此信号的到来，然后就由os负责处理这些新到来的数据。 要中断一个Java线程，可调用线程类对象的实例方法：interrupte()。其本质只是设置该线程的中断标志，将中断标志设置为true，并根据线程当前的状态决定做出不同的响应。 CAS / 非阻塞同步 CAS(Compare-and-Swap) 。基于冲突检测的乐观并发策略 ，先将内存的值进行保存，当操作完成时再判断保存的值和当前内存的值是否相同，如果不同则说明其他线程操作了该数据，所以需要重试或者放弃。这种乐观的并发策略不需要把线程挂起，因此这种同步措施称为非阻塞同步。 ABA问题 是指在CAS操作中带来的一个潜在问题。例如，线程1将初始值为A的变量 先修改成B，再修改回成A。线程B的CAS操作无法分辨当前V值是否发生过变化。 原子操作 是指不会被线程调度机制打断的操作机制。这种操作一旦开始，就一直运行到结束，中间不会有任何 context switch （切换到另一个线程）。根据java 定义，原子操作是不会被打断地的操作，因此被认为是线程安全的。java中可以通过锁和循环CAS的方式来实现原子操作。 公平锁（Fair） 加锁前检查是否有排队等待的线程，优先排队等待的线程，先来先得。 非公平锁（Nonfair） 加锁时不考虑排队等待问题，直接尝试获取锁，获取不到自动到队尾等待 独享锁/共享锁 独享锁(例如synchronized )是指该锁一次只能被一个线程所持有。 共享锁是指该锁可被多个线程所持有。 ReadWriteLock rtLock = new ReentrantReadWriteLock(); rtLock.readLock();//共享锁 rtLock.writeLock();//互斥锁 ReadWriteLock rtLock = new ReentrantReadWriteLock(); 死锁 多个线程同时被阻塞，它们中的一个或者全部都在等待某个资源被释放。由于线程被无限期地阻塞。 //java 死锁产生的四个必要条件： 1、互斥使用，即当资源被一个线程使用(占有)时，别的线程不能使用. 2、不可抢占，资源请求者不能强制从资源占有者手中夺取资源，资源只能由资源占有者主动释放。 3、请求和保持，即当资源请求者在请求其他的资源的同时保持对原有资源的占有。 4、循环等待，即存在一个等待队列：P1占有P2的资源，P2占有P3的资源，P3占有P1的资源。 这样就形成了一个等待环路。 当上述四个条件都成立的时候，便形成死锁。当然，死锁的情况下如果打破上述任何一个条件，便可让死锁消失。 线程阻塞 阻塞指的是暂停一个线程的执行以等待某个条件发生（如某资源就绪）。 sleep() sleep() 允许线程在指定的时间内进入阻塞状态，不能得到CPU 时间，指定的时间一过，线程重新进入可执行状态。 只是不参与cpu时间的竞争， 已经拿到手的锁资源并不释放 （此时不一定占有锁）。 sleep 方法时间到了会自动醒过来， 时间没到可以用interrupt方法强行唤醒。 Thread.sleep(50); suspend() 和 resume() 两方法配套使用，调用suspend()进入阻塞状态（不会立即的停止，而是执行到一个安全点后挂起 。不会自动恢复）。 调用resume()进入唤醒状态。 在多线程场景中很容易造成死锁，目前这2个方法已经被废弃。 yield() 线程礼让、让步。 yield()方法让当前正在执行的线程放弃当前分得的CPU时间（并不是阻塞该线程），它只是将该线程从运行状态转入就绪状态。 只是礼让当前的cpu使用权，让系统的线程调度器重新调度一次。 很有可能，当这个线程调用了yield()方法后它又马上抢占了CPU的执行权，继续执行。 Thread t = new Thread; t.sleep(); t.yield(); wait() 、 notify() wait() 、 notify() 两个方法配套使用 。都是Object的方法。并不是Thread独有的。 这里要明确 线程等待的就是一个对象发出的信号，所以要基于对象而存在。 wait() 、 notify() 必须在 synchronized 同步方法或块中调用 。 否则运行时会抛出 IllegalMonitorStateException 异常 。 // 为什么java规定 wait()，notify()和notifyAll()必须在同步块或同步方法中调用。而suspend()、 resume()可以在任何地方都调用？ 1、首先suspend()、 resume()是基于线程存在的。 wait()、notify()基于对象存在的。 2、既然是基于对象的，此时在这个对象上可能同时有多个线程调用wait()/notify()方法， 依然存在并发的问题，理论上也需要一个锁来控制。 调用wait进入阻塞后，会释放占用的锁。 obj.wait( time ) ， 超时自动唤醒或者由notify( )、notifyAll()唤醒 进入就绪状态。 obj.wait( ) ，由notify( )、notifyAll( )唤醒 进入就绪状态。 调用wait会让当前线程释放这个对象的锁。 （线程此时不一定持有锁，如果没有锁就忽略，如果占有锁就会释放） 如果多个线程调用了某个对象的 wait() ， 对象的notify()被调用时 是随机选择一个线程唤醒 。 如果多个线程调用了某个对象的 wait() ， notifyAll()被调用时 将这些线程全部唤醒，抢到锁的那个线程 进入就绪状态 。 线程竞争对象的锁。 join() 线程A 里面 调用了 线程B.join() 。 此时线程A进入阻塞状态 ，线程B执行。 直到线程B执行完毕或者被打断，线程A才能恢复继续执行 。 主要用于线程之间的交互。 线程同步机制 同步是一种计算机术语，一般指的是在多个数据库、文件、模块、线程之间用来保持数据内容一致性的机制。 程同步的真实意思和字面意思恰好相反，其实是“线程排队”：几个线程之间要排队，一个一个对共享资源进行操作，而不是同时进行操作。 1、java的每个对象都有一个内置锁 . 2、同步高开销，尽量减少同步的内容。一般同步关键代码（代码块）即可。 线程状态的转换 同步方法 //锁住 当前方法 public synchronized void funcA(){ } //锁住 当前类 public static synchronized void funcB(){ } 同步代码块 synchronized(object) { //同步是一种高开销的操作，通常没有必要同步整个方法， //使用synchronized代码块同步关键代码即可。 } 使用 volatile 轻量级同步机制 (这个结论有问题) //一个变量使用volatile后，它将具有以下两种特性： ①、此变量对所有线程可见。 当一条线程修改了这个变量的值，新的值对于其他线程来说是立即得知的。普通变量不能实现这一点。 ( 注：因为Java里的运算并非原子操作，所以volatile只能保证了可见性，仍然需要通过加锁来保证数据的一致性 ， 个人感觉跟同步没啥关系。 volatile修饰的变量，只保证从主内存加载到线程工作内存的值是最新的。保证不了线程安全 。) ②、 volatile 禁止CPU进行指令重排序优化。 普通的变量可能会进行指令重排序，所以不能保证变量赋值操作的顺序与程序代码中的执行顺序一致。 重入锁 ReentrantLock //fair为true表示是公平锁 。默认非公平。 boolean fair= false ; ReentrantLock reentrantLock = new ReentrantLock(fair) ; private void func1(ReentrantLock lock){ //如果已经被锁定了 就会忽略。不会等待。 if(lock.tryLock()){ try{ //执行相关操作 }finally{ //释放锁 lock.unlock(); } } } private void func2(ReentrantLock lock) throws InterruptedException{ //如果被锁定了，就会尝试等待指定时长。如果还没有就放弃 if(lock.tryLock(5 , TimeUnit.SECONDS)){ try{ //执行相关操作 }finally{ //释放锁 lock.unlock(); } } } private void func3(ReentrantLock lock){ //如果已经被锁定了 ,会在此等待 try{ lock.lock(); //执行相关操作 }finally{ //释放锁 lock.unlock(); } } /*** * 如果指定时间内没有完成操作。就中断当前线程，释放锁 * @param lock */ private void func4(ReentrantLock lock){ //tryLock和lockInterruptibly方法在申请锁的过程中是可以被中断的 . //如果线程被中断，抛出一个InterruptedException异常 try { lock.lockInterruptibly(); // } catch (InterruptedException e) { //执行相关操作 }finally{ //释放锁 lock.unlock(); } } ThreadLocal 线程局部变量 实现线程同步 (这个结论有问题) 以下来自网络解释 。 作为Thread的一个局部变量 。为解决多线程程序的并发问题提供了一种新的思路。 ThreadLocal会为每一个线程维护一个和该线程绑定的变量的副本，从而隔离了多个线程的数据，每一个线程都拥有自己的变量副本，从而也就没有必要对该变量进行同步了。 ”~~~ 通俗的解释，threadlocal就跟自助餐的餐盘一样，外面一堆人排队，进去的一人一个餐盘，装一堆，再慢慢消化，有这个场景的应该都可以用。 我不太理解和赞同上述解释。 阻塞队列 LinkedBlockingQueue 实现线程同步 使用java封装的帮助类，实现多线程安全。 每次只允许 一个线程去队列里面存放对象 。 BlockingQueue outQueue = new LinkedBlockingQueue<>(Integer.MAX_VALUE); outQueue.put(msg); msg = outQueue.poll(); 使用 Atomic 原子变量实现线程同步 原子操作就是指将读取变量值、修改变量值、保存变量值看成一个整体来操作即-这几种行为要么同时完成，要么都不完成。 根据java 定义，原子操作是不会被打断地的操作，因此被认为是线程安全的。 java.util.concurrent.atomic包提供 Atomic 用CAS方式实现 原子操作。 /**原子更新基本类型类 （没有 double 和float的封装类型） */ AtomicInteger atomicInt = new AtomicInteger(100); AtomicBoolean atomicBoolean = new AtomicBoolean(false); AtomicLong atomicLong = new AtomicLong(1000000); private void func1( ){ //原子更新数组类 int[]arrayInt ={1,30}; AtomicIntegerArray atomicIntArray = new AtomicIntegerArray(arrayInt); atomicIntArray.getAndSet(i, newValue); atomicIntArray.addAndGet(i, delta); //AtomicReferenceFieldUpdater 一个基于反射的工具类，它能对指定类的指定的volatile引用字段进行原子更新。(这个字段不能是private的) AtomicReferenceFieldUpdater updater=AtomicReferenceFieldUpdater.newUpdater(Dog.class,String.class,\"name\"); updater.compareAndSet(dog1,dog1.name,\"test\") ; //AtomicMarkableReference ,为解决 CAS 操作中潜在的 ABA 问题 设计的解决方案。 AtomicMarkableReference atomicMarkRef= new AtomicMarkableReference (\"StrMsg\", false) ; if(!atomicMarkRef.isMarked()){ atomicMarkRef.set(\"bbb\", true); }; //AtomicStampedReference 用法与 AtomicMarkableReference 类似 } 线程池 为什么要用线程池: 1.减少了创建和销毁线程的次数，每个工作线程都可以被重复利用，可执行多个任务。 2.可以根据系统的承受能力，调整线程池中工作线线程的数目，防止因为消耗过多的内存 Java 自带的线程池类型 // newSingleThreadExecutor 创建一个单线程的线程池。如果这个唯一的线程异常结束，会有一个新的线程来替代它。 此线程池保证所有任务的执行顺序按照任务的提交顺序执行。 ExecutorService pool1 = Executors.newSingleThreadExecutor(); pool1.execute(command); // newFixedThreadPool 每次提交一个任务就创建一个线程，直到线程达到线程池的最大大小。 ExecutorService pool2 =Executors.newFixedThreadPool(10); pool2.execute(command); // newCachedThreadPool 如果有线程超过一定时间(60秒)，就会被回收。 当线程不够时，又会新建线程。 线程池大小完全依赖于当前JVM能够创建的最大线程大小。 ExecutorService pool3=Executors.newCachedThreadPool(); pool3.execute(command); // newScheduledThreadPool 支持定时及周期性任务执行 ScheduledExecutorService pool4 =Executors.newScheduledThreadPool(10); pool4.scheduleAtFixedRate(command, initialDelay, period, unit); // ScheduledThreadPoolExecutor 跟 Executors 出来的差不多 ScheduledThreadPoolExecutor pool5 =new ScheduledThreadPoolExecutor(10); pool5.scheduleAtFixedRate(command, initialDelay, period, unit); pool5.execute(command); ExecutorService 线程池demo public class MyThreadPoolTools{ private ExecutorService singleThreadPool = null ; private ExecutorService getThreadPoolsIncetance() { //guava-17.0.jar ThreadFactory threadFactory = new ThreadFactoryBuilder().setNameFormat(\"wk-pool-%d\").build(); RejectedExecutionHandler handler =new ThreadPoolExecutor.AbortPolicy(); /*核心线程数量newSingleThreadExecutor 最大线程数量ScheduledThreadPoolExecutor 当线程池数量超过核心线程数量以后，空闲时间超过这个值的线程会被终止 KeepAlive时间单位 任务队列 创建线程的工厂对象 任务被拒绝后调用的handler*/ ExecutorService threadPool = new ThreadPoolExecutor( 5 , 10 , 3 , TimeUnit.MICROSECONDS , new LinkedBlockingQueue(Integer.MAX_VALUE) , threadFactory , handler ) ; return threadPool ; } /**提交任务并执行*/ public void addTask(Runnable runnable) { if (singleThreadPool == null) { singleThreadPool= getThreadPoolsIncetance(); } //运行线程池中的任务 singleThreadPool.submit(runnable) ; } /**关闭线程池*/ public void shutdownThreadPool() { if (singleThreadPool != null) { if(!singleThreadPool.isShutdown()) { singleThreadPool.shutdownNow() ; } } } } //使用 MyThreadPoolTools myThreadPoolTools= new MyThreadPoolTools(); Runnable task = new Runnable(){ @Override public void run() { //耗时操作 } }; myThreadPoolTools.addTask(task); myThreadPoolTools.shutdownThreadPool(); 无版权 可以无限制使用！ all right reserved，powered by Gitbook该文件更新时间： 2020-09-24 10:47:12 "},"chinese/java基础/equals，hashcode和==的区别.html":{"url":"chinese/java基础/equals，hashcode和==的区别.html","title":"equals，hashcode和==的区别","keywords":"","body":"相等判断 针对基本数据类型 == 比较的是它们的值是否相同 。 针对(类、接口、数组)这样的引用数据类型 。 == 比较的是它们在内存中的地址（在栈中）。 如果要比较引用对象的值是否相同，就需要重写equals方法。可以根据自己定义的规则判断对象是否相同。 hashCode()在hashSet这种集合中的使用 java规定： Set中元素无序，元素不可重复。 需要解决的问题：如何高效地判断新加的元素是否与集合中的元素不一样，从而保证保证元素不重复 ？ 解决办法： 我们可以用equals方法依次判断是否相等。但是，每增加一个元素就检查一次，那么当元素很多时，后添加到集合中的元素比较的次数就非常多了。这显然会大大降低效率。 于是，Java采用了哈希表的原理： 当集合要添加新的元素时， 先调用这个元素的hashCode方法，就一下子能定位到在hash表中的位置。 如果这个位置上没有元素，它就可以直接存储在这个位置上，不用再进行任何比较了； 如果这个位置上已经有元素了（hash碰撞现象），就调用它的equals方法与新元素进行比较，相同的话就不存，不相同就（再次求hashcode）散列其它的地址。 这样一来实际调用equals方法的次数就大大降低了，几乎只需要一两次。 如何重写hashCode() hashSet这种集合判断集合中对象是否相同，为了提升效率 ，首先进行hashCode比较 ，然后再调用 equals比较 。 @Override public int hashCode(){ int hashCode = 0; //自定义系数，随意写。只要不是特别大或特别小 导致最后hash值查出int的范围即可 int k1=5 ; //最后的hash值生成原则： 用到类里面的所有属性。 hashCode = k1 * age + name.hashCode(); return hashCode ; } @Override public boolean equals(Object obj){ //对象地址完全一样，对象肯定相等 if (obj == this){ return true; } //如果类型都不一样了，肯定不相等 if (!(obj instanceof Bean1)) { return false; } //根据自定义规则判断是否相等 Bean1 bean = (Bean1)obj; return bean.name.equals(name) && bean.age == age; } 开发中需要注意的问题 重写了equals() 就必须重写 hashCode()方法。 同一个对象，hashCode 一定相同。 否则就会违背以下的规则： equal objects must have equal hash codes · 无版权 可以无限制使用！ all right reserved，powered by Gitbook该文件更新时间： 2020-08-19 17:20:00 "},"chinese/java基础/深度拷贝.html":{"url":"chinese/java基础/深度拷贝.html","title":"深度拷贝","keywords":"","body":"深度拷贝 public List deepCopy(List src) { ByteArrayOutputStream byteOut = new ByteArrayOutputStream(); ObjectOutputStream out = new ObjectOutputStream(byteOut); out.writeObject(src); ByteArrayInputStream byteIn = new ByteArrayInputStream(byteOut.toByteArray()); ObjectInputStream in = new ObjectInputStream(byteIn); List dest = (List) in.readObject(); return dest; } // 深度克隆ByteBuffer private ByteBuffer deepCloneByteBuffer(ByteBuffer original) { ByteBuffer clone = ByteBuffer.allocate(original.capacity()); original.rewind(); clone.put(original); // 用put接口，才会把byte数组的内容拷贝到ByteBuffer中 original.rewind(); clone.flip(); return clone; } 无版权 可以无限制使用！ all right reserved，powered by Gitbook该文件更新时间： 2020-08-26 10:45:02 "},"chinese/java基础/java多态.html":{"url":"chinese/java基础/java多态.html","title":"java多态","keywords":"","body":"从一定角度来看，封装和继承几乎都是为多态而准备的。 多态的定义：指允许不同类的对象对同一消息做出响应。即同一消息可以根据发送对象的不同而采用多种不同的行为方式。 以下是现实生活中多态的例子。比方说按下 F1 键这个动作，如果当前在 Word 下弹出的就是 Word 帮助； 在 Windows 下弹出的就是 Windows 帮助和支持。同一个事件发生在不同的对象上会产生不同的结果。 Java中多态的实现方式： 1、接口实现 2、继承父类进行方法重写 3、同一个类中进行方法重载 。（特殊- 有争议） 方法重载 为什么可以实现多态？？ 多态分为编译时多态和运行时多态。 其中编译时多态是静态的，主要是指方法的重载，它是根据参数列表的不同来区分不同的函数，通过编辑之后会变成两个不同的函数，在运行时谈不上多态。 注意 方法重载这个多态和另外另个多态方式的不同 。 （个人感觉跟上面那个多态的定义不太符合。） Java实现多态有三个必要条件： 1、继承 （extends 、 implements） 2、重写 3、向上转型 //例如 ： Object cat = new Cat() 无版权 可以无限制使用！ all right reserved，powered by Gitbook该文件更新时间： 2020-08-19 17:20:00 "},"chinese/java基础/类_接口.html":{"url":"chinese/java基础/类_接口.html","title":"类_接口","keywords":"","body":"类、接口 抽象类接口区别 以下是常用的几点区别。另外的小细节可以在编码的时候体会得到。 1、抽象类可以有构造器 ，接口不能有构造器 问：抽象类不能new，但抽象类里为什么还要有构造方法？ 答：抽象类可以有成员变量，他们的初始化怎么做呢？这么一样你就明白为什么抽象类可以有构造函数了。 2、接口和抽象类可以被new吗 ？ Java语言规范规定了抽象类不能实例化 。接口也不能被new出来 。 但是我们平时有时会见到一些迷惑性的代码，其实那是创建了匿名内部类 。具体请参考匿名内部类的定义。 匿名内部类 造成 new 出一个 抽象函数或接口实例 的假象 // java编译器特有的写法？？ AbstractClassA test1= new AbstractClassA() { @Override public void func1() { System.out.println(\"func1...\"); } }; //错误写法，无法通过编译 AbstractClassA test2= new AbstractClassA(); 内部类 可以将一个类的定义放在另一个类的定义内部，这就是内部类。 使用内部类最大的优点就在于它能够非常好的解决多重继承的问题， 如果我们不需要解决多重继承问题，那么我们自然可以使用其他的编码方式 。 内部类是个编译时的概念，一旦编译成功后，它就与外围类属于两个完全不同的类（当然他们之间还是有联系的）。 内部类它可以无限制地访问外围类的元素。 Java中内部类主要分为成员内部类、局部内部类、匿名内部类、静态内部类。 内部类类名规则 , 带 $ 的函数 public class TestClass { // 内部类 private MyTestCallback myTestCallback = new MyTestCallback() { @Override public void showMsg(String msg) { } }; } // 编译成功后，发现有生成 TestClass$1.class class TestClass$1 implements MyTestCallback { TestClass$1(TestClass this$0) { this.this$0 = this$0; } public void showMsg(String msg) { } } 实现多重继承的方案 1、接口, 无需多说。 2、内部类。 // 这种方式实现多重继承，我认为不太优雅。 public class Father { public void strong(){ } } public class Mother { public void kind(){ } } public class Son { // 通过 2个内部类，获得两个父类的能力。 class Father_1 extends Father{ } class Mother_1 extends Mother{ } } 匿名内部类 匿名内部类没有名字 ，创建格式如下 。 new 父类构造器（参数列表）|实现接口（） { //匿名内部类的类体部分 } // 匿名内部类参数为何要为final 1、首先在内部类编译成功后，它会产生一个class文件，该class文件与外部类并不是同一class文件，仅仅只保留对外部类的引用。 2、内部类并不是直接调用方法传递的参数，而是利用自身的构造器对传入的参数进行备份， 自己内部方法调用的实际上时自己的属性而不是外部方法传递进来的参数。 3、在内部类中的属性和外部方法的参数两者从外表上看是同一个东西，但实际上却不是，也就是说在内部类中我对属性的改变并不会影响到外部的形参， 而然这从程序员的角度来看这是不可行的，毕竟站在程序的角度来看这两个根本就是同一个， 如果内部类该变了，而外部方法的形参却没有改变这是难以理解和不可接受的，所以为了保持参数的一致性，就规定使用final来避免形参的不改变。 （规定的！！） 父类的静态方法能否被子类重写 Java静态方法形式上可以重写，但从本质上来说不是Java的重写。 静态方法： java中 static修饰符修饰的方法就是静态方法。 所谓静态就是指：在编译之后所分配的内存会一直存在，不会被回收，直到程序退出内存才会释放这个空间。 static方法不是后期绑定的，它在编译期就绑定了。 静态方法是不需要对象的。自然无法根据对象的类去覆盖方法。 如果父类中定义的静态方法在子类中被重新定义，那么定义在父类中的静态方法将被隐藏。 public class Father { public static void test(){ } } public class Son extends Father{ public static void test(){ } } // Son 中有test这方法， Son.test() 执行的就是 son的test ，如果没有这个方法，调用的就是father的test . Son.test(); 无版权 可以无限制使用！ all right reserved，powered by Gitbook该文件更新时间： 2020-12-17 15:49:47 "},"chinese/java基础/泛型通配符extends与super的区别.html":{"url":"chinese/java基础/泛型通配符extends与super的区别.html","title":"泛型通配符extends与super的区别","keywords":"","body":"泛型通配符 泛型的作用 泛型，就是将类型参数化。 就是在定义的时候你不知道这个地方需要什么类型的数据 ，只有实际使用的时候才会知道。 让编译器在编译期间帮忙检查类型错误。 未使用泛型 Object是所有类的根类，任何类的对象都可以设置给该Object引用变量，使用的时候可能需要类型强制转换 。 需要开发者手动做强制转换，如果开发者判断失误，程序运行会崩溃。 使用了泛型： 这样设计的容器在使用时编译器就可以帮忙做很大一部分的类型安全检查工作了， 这就避免了很多运行时的ClassCastException异常，程序员也无需记住各种对象的类型和担心类型匹配问题了。 (编译器在编译是就帮我们做检查，更容易发现错误。) 定义泛型常用的字母 原则上来讲，使用任何字母或字符串都是可以的。 但是为了代码的可读性，我们一般有如下约定； E - Element //在集合中使用，因为集合中存放的是元素) T - Type // 类型 K - Key //键 V - Value // 值 N - Number // 数字 ? - //表示不确定的java类型 泛型的应用范围 泛型类 泛型接口 泛型方法 泛型类 public class Tool { private T value ; } 泛型接口 public interface Person { T getType(); }} 泛型方法 // 说明当前是一个泛型方法，并且将类型定义为T200 // 返回值 为 T200 public T200 showKeyName (List list) { return list.get(0) ; } public class Tool { // 静态方法不能使用类定义的泛型。 public static void show(T200 t){ // 这样使用编译器会报错 } } 泛型与可变参数 //printMsg(\"111\",222,\"aaaa\",\"2323.4\",55.55); public static void printMsg( T300... args){ for(T300 t : args){ System.out.println(\"t is \" + t); } } 泛型中 extends 和 super的区别 参考资料 上界通配符 ：是指 “上界通配符（Upper Bounds Wildcards）” Plate 一个能放水果以及一切是水果派生类的盘子。 下界通配符 ：是指 “下界通配符（Lower Bounds Wildcards）” Plate 一个能放水果以及一切是水果基类的盘子。 为什么要用通配符和边界 优点： 让Java不同泛型之间的转换更容易了。 使用泛型、通配符提高了代码的复用性。 缺点： 容器的部分功能失效。(从类型转换的角度去理解 ，编译器不能确定具体类型，但是要确保不报错，所以不能给你强制转换) 1、上界不能往里存，只能往外取 2、下界不影响往里存，但往外取只能放在Object对象里 无版权 可以无限制使用！ all right reserved，powered by Gitbook该文件更新时间： 2020-08-26 11:37:41 "},"chinese/java基础/容器类之间的区别.html":{"url":"chinese/java基础/容器类之间的区别.html","title":"容器类之间的区别","keywords":"","body":"容器类之间的区别 Array ，Arrays Array：就是数组。（我没怎么用过） Arrays：是Array的工具类，其静态方法定义了对Array的各种操作。 Collection 、 Collections Collection是接口，集合。 Collections是工具类。提供静态方法 封装了一些对集合的操作。 无版权 可以无限制使用！ all right reserved，powered by Gitbook该文件更新时间： 2020-08-19 17:20:00 "},"chinese/java基础/为什么要使用泛型.html":{"url":"chinese/java基础/为什么要使用泛型.html","title":"为什么要使用泛型","keywords":"","body":"http://blog.csdn.net/wgp15732622312/article/details/63683751 还未整理。。。 无版权 可以无限制使用！ all right reserved，powered by Gitbook该文件更新时间： 2020-08-19 17:20:00 "},"chinese/java基础/Java枚举.html":{"url":"chinese/java基础/Java枚举.html","title":"Java枚举","keywords":"","body":"Java枚举 [JDK1.5 ,+∞ ) 支持枚举 为了唯一性，所以规定了构造函数不能为public、protected 只能是private 或 不写 简单枚举 public enum CarType { BWO ,DZ ,AD } CarType type= CarType.DZ ; switch (type) { case BWO: System.out.println(\"宝马\"); break; case DZ: System.out.println(\"大众\"); break; case AD: System.out.println(\"奥迪\"); break; default: break; } 枚举类 public enum CarType { //初始化枚举实例 ，必须在构造函数前面 BWOINFO(1 ,\"宝马\" ,500.0), // 初始的值 对应构造函数的顺序 DZINFO( 2 ,\"大众\" ,600.0), ADOINFO(3 ,\"奥迪\" ,700.0) ; private int carId ; private String carName ; private double price ; private CarType(int id ,String name ,double price){ this.carId =id ; this.carName = name ; this.price = price ; } ... get set 方法 ... } // 单个实例 CarType car = CarType.BWOINFO; System.out.println(car.getCarName() + \" \" + car.getPrice()); // 修改枚举实例的值 car.setPrice(888.0); // 遍历枚举类中的所有实例 for (CarType temp : CarType.values()) { System.out.println(temp.getCarName() + \" \" + temp.getPrice()); } 枚举的缺点 每一个枚举值都是一个对象,在使用它时会增加额外的内存消耗 ，同时也会增加 DEX文件的大小 。 所以android官方文档建议尽量避免使用枚举。 Android 中枚举的替代方案 @IntDef 1、添加依赖 implementation 'com.android.support:support-annotations:28.0.0-rc02' 2、定义 public class MyDefBean { //先定义 常量 public static final int SUNDAY = 0; public static final int MONDAY = 1; public static final int TUESDAY = 2; //用 @IntDef \"包住\" 常量 声明构造器 @IntDef({SUNDAY, MONDAY,TUESDAY }) // @Retention 定义策略 @Retention(RetentionPolicy.SOURCE) // 定义‘接口’ public @interface WeekDays {} } 3、使用 @MyDefBean.WeekDays int currentDay = SUNDAY; void test(@MyDefBean.WeekDays int today) { switch (today) { case MyDefBean.MONDAY: break; case SUNDAY: break; case MyDefBean.TUESDAY: break; default: break; } } 无版权 可以无限制使用！ all right reserved，powered by Gitbook该文件更新时间： 2020-08-19 17:20:00 "},"chinese/java基础/自定义异常.html":{"url":"chinese/java基础/自定义异常.html","title":"自定义异常","keywords":"","body":"自定义异常 自定义异常方式我用的较少，一般都习惯用回调的方式回调逻辑错误。 不过，自定义错误有一个优点，方便定位异常具体地点。(点击即可跳转) public class WkException extends Exception { private static final long serialVersionUID = 1L; private String errorInfo ; private int errorCode= -100 ; public WkException(String errorInfo){ this.errorInfo = errorInfo ; } public WkException(int errorCode ,String errorInfo){ this.errorCode = errorCode ; this.errorInfo = errorInfo ; } @Override public String toString() { return errorCode+\" \"+errorInfo; } } // 使用 public static void checkValue(int value ) throws WkException{ if(value>4){ throw new WkException(1001, \"数据错误\"); } } try { checkValue(10); } catch (WkException e) { e.printStackTrace(); } 无版权 可以无限制使用！ all right reserved，powered by Gitbook该文件更新时间： 2020-08-26 11:14:24 "},"chinese/java基础/java注解.html":{"url":"chinese/java基础/java注解.html","title":"java注解","keywords":"","body":"java注解 注解 是在 Java SE 5.0 版本中开始引入的概念。 元注解 元注解是一种基本注解， 它能够应用到其它的注解上面。 元注解类型 说明 其他 @Retention 说明了这个注解的的存活时 @Retention(RetentionPolicy.RUNTIME) @Retention(RetentionPolicy.SOURCE ) @Retention(RetentionPolicy.CLASS ) @Documented 能将注解中的元素包含到Javadoc中去 - @Target 指定了注解运用的地方 @Target(ElementType.ANNOTATION_TYPE ) //可以给一个注解进行注解 @Target(ElementType.CONSTRUCTOR ) //可以给构造方法进行注解 @Target(ElementType.FIELD ) // 可以给属性进行注解 @Target(ElementType. LOCAL_VARIABLE) //可以给局部变量进行注解 @Target(ElementType.METHOD ) // 可以给方法进行注解 @Target(ElementType. PACKAGE) //可以给一个包进行注解 @Target(ElementType.PARAMETER ) //可以给一个方法内的参数进行注解 @Target(ElementType.TYPE ) //可以给一个类型进行注解，比如类、接口、枚举 @Inherited 如果一个f类被 @Inherited 注解过的注解 进行注解的话， 那么如果它的子类没有被任何注解应用的话， 那么这个子类就继承了超类的注解。 - @Repeatable Java 1.8 重复注解 ， 注解的值可以同时取多个 @Person(role=\"coder\") @Person(role=\"PM\") public class SuperMan{... Java内置的注解 说明 备注 @Deprecated 标记过时 - @Override 标记复写 - @SuppressWarnings 阻止编译器报警告提示 @SuppressWarnings(\"all\") // 抑制所有警告 @SuppressWarnings(\"boxing\") // 抑制装箱、拆箱操作时候的警告 @SuppressWarnings(\"cast\") // 抑制映射相关的警告 @SuppressWarnings(\"dep-ann\") // 抑制启用注释的警告 @SuppressWarnings(\"deprecation\") // 抑制过期方法警告 @SuppressWarnings(\"fallthrough\") // 抑制确在switch中缺失breaks的警告 @SuppressWarnings(\"finally\") // 抑制finally模块没有返回的警告 @SuppressWarnings(\"hiding\") // 忽略 关于隐藏的本地变量的警告 @SuppressWarnings(\"incomplete-switch\") // 忽略没有完整的switch语句 @SuppressWarnings(\"nls\") // 忽略非nls格式的字符 @SuppressWarnings(\"null\") // 忽略对null的操作 @SuppressWarnings(\"rawtypes\") // 使用generics时忽略没有指定相应的类型 @SuppressWarnings(\"restriction\") // 忽略 使用不建议或者禁止的引用的警告 @SuppressWarnings(\"serial\") // 忽略在serializable类中没有声明serialVersionUID变量 @SuppressWarnings(\"static-access\") // 抑制不正确的静态访问方式警告 @SuppressWarnings(\"synthetic-access\") // 抑制子类没有按最优方法访问内部类的警告 @SuppressWarnings(\"unchecked\") // 抑制没有进行类型检查操作的警告 @SuppressWarnings(\"unqualified-field-access\") // 抑制没有权限访问的域的警告 @SuppressWarnings(\"unused\") // 抑制没被使用过的代码的警告 @SafeVarargs JDK 7 阻止编译器产生 unchecked 这样的警告，效果跟 @SuppressWarnings(\"unchecked\")相同 注意：使用了这种注解后，开发者要确保自己的类型转换是没有问题的，否则运行时会报错的 @FunctionalInterface Java 1.8 当你写的接口不符合函数式接口定义的时候，编译器会报错 注解的属性 (成员变量) 注解只有属性，没有方法。 注解的属性在注解的定义中以“无形参的方法”形式来声明， 其方法名定义了该成员变量的名字，其返回值定义了该成员变量的类型。 自定义注解 一般在制作自己的框架 或者某种小工具时， 我们可以使用自定义注解 。 注意： 如果仅仅自定义了注解，并使用在代码中。这些注解并不会起作用。 如果想要真正使用上它们，你还得写一个其他工具类，利用反射等原理。 @Retention(RetentionPolicy.RUNTIME) public @interface TestAnnotation { public int id() default -1; public String msg() default \"Hi\"; } 注解与反射 通过反射获取 注解的内容。 private void testAninotation(Class clz) throws Exception { // 检测 某个类是否应用了 指定的注解 boolean hasAnnotation = clz.isAnnotationPresent(TestAnnotation.class); if(hasAnnotation){ TestAnnotation testAnnotation = clz.getAnnotation(TestAnnotation.class); //testAnnotation.id()+\" \"+testAnnotation.msg() } // 检测 某个 属性 是否应用了 指定的注解 // private void test( int age , String name ){...} /// 获取所有属性 Field[] fields = clz.getDeclaredFields(); Field a = MainActivity.class.getDeclaredField(\"testMsg\"); a.setAccessible(true); TestAnnotation testAnnotation1 = a.getAnnotation(TestAnnotation.class); if ( testAnnotation1 != null ) { // } ///检测 某个 方法 是否应用了 指定的注解 . test 是方法名 ///获取所有的类 Method[] method = clz.getDeclaredMethods(); Method testMethod = clz.getDeclaredMethod(\"test\" ,int.class ,String.class); if ( testMethod != null ) { Annotation[] ans = testMethod.getAnnotations(); for( Annotation annotation : ans) { // annotation.annotationType().getName() if(annotation instanceof TestAnnotation){ testMethod.setAccessible(true); // 在反射中调用 某个类的方法 // 第一个参数 是类的实例 ， 以后的多个参数都是方法需要的参数 testMethod.invoke( new MainActivity() , 20 , \"aivin\") ; } } } } 无版权 可以无限制使用！ all right reserved，powered by Gitbook该文件更新时间： 2020-08-19 17:20:00 "},"chinese/java基础/java8新特性.html":{"url":"chinese/java基础/java8新特性.html","title":"java8新特性","keywords":"","body":"java8新特性 java8新特性 说明 1、Lambda表达式 - 2、接口的默认方法与静态方法 - 3、方法引用 - 4、重复注解 - 5、扩展注解的支持 6、Optional - 7、Stream - 8、Date/Time API (JSR 310) - 9、JavaScript引擎Nashorn 10、Base64 java8对Base64进行优化后，放到java.util包下 Java Lambda Lambda是Java8的新特性 ，是一个语法糖 // 语法格式 (params) -> expression (params) -> statement (params) ->{ statements; } // List循环 List list = ...; list.forEach( reslut -> { reslut +=\"_修改过\" ; }); // 循环输出 list.forEach(System.out::println); //Map循环 Map map =...; map.forEach( (key ,value)-> { value +=100 ; }); map.forEach( ( key ,value ) -> System.out.println( \"key=\"+key +\" value=\"+value) ); // List 条件过滤 List result1 = // 将list转为 流 list.stream() // 将符合条件的元素过滤出来 .filter( line -> line.contains(\"aa\")) // 收集并将输出的流转为 list .collect(Collectors.toList()); result1.forEach(System.out::println); // 对象排序 List listSort= ... ; listSort.sort( (Student stu1 , Student stu2) -> stu1.age- stu2.age); listSort.forEach( (sutdent) -> { System.out.println(sutdent.name+\" : \"+sutdent.age); }); 接口的默认方法与静态方法 public interface MyMathTool { // 被 default关键字 修饰过的 sqrt 方法 将在子类上可以直接使用. // 可以有多个 默认方法 default double sqrt(int a) { return Math.sqrt(a); } } // 被 static修饰的方法 ，跟普通类的静态方法一样可以直接调用 // 可以有多个 静态方法 static double cacle(int a, int b){ return a+b ; } 函数式编程 函数式接口是Java支持函数式编程的基础。 \"函数式编程\"是一种\"编程范式\" 方法引用 方法引用是lambda表达式的一种语法糖, 为了简化代码和加速开发。 当我们想要实现一个函数式接口的那个抽象方法，但是已经有类实现了我们想要的功能， 这个时候我们就可以用方法引用来直接使用现有类的功能去实现。（至于为什么可以这样，我暂时还不知道，没看源码。） 方法引用规定：实现抽象方法的参数列表，必须与方法引用方法的参数列表保持一致。返回值就不作要求。 引用分类 分类 说明 引用方法 类名::静态方法名 类名::实例方法名 实例::实例方法名 引用构造器 引用数组 // 实例::实例方法名 Consumer consumer = System.out::println; consumer.accept(\"This is Major Tom\"); // 类名::静态方法名 Function f = Math::abs; Long result = f.apply(-3L); // 类名::实例方法名 // 这个地方有点不太好理解。 // 可以暂时这样理解： 生成了一个 BiPredicate 实例b ， // 并且 b中的 方法 test里面的内容和 String类的静态方法 equals 一模一样 BiPredicate b = String::equals; b.test(\"abc\", \"abcd\"); // 引用构造器 Function fun = StringBuffer::new; StringBuffer buffer = fun.apply(10); // 引用数组 Function fun2 = Integer[]::new; Integer[] arr2 = fun2.apply(10); 函数式接口 为了更友好的支持Lambda表达式，Java 8引入了函数式接口的概念。 所谓的函数式接口，当然首先是一个接口，然后就是在这个接口里面只能有一个抽象方法。 1、Java 8为函数式接口引入了一个新注解 @FunctionalInterface，主要用于编译级错误检查， 加上该注解，当你写的接口不符合函数式接口定义的时候，编译器会报错。 2、加不加@FunctionalInterface对于接口是不是函数式接口没有影响， 该注解知识提醒编译器去检查该接口是否仅包含一个抽象方法 3、函数式接口里是可以包含默认方法 、静态方法、Object里的public方法 @FunctionalInterface public interface Consumer { void accept(String msg); } 内置的函数式接口 为了方便开发者，java8内置了一批函数式接口。 Java8内置的函数式接口 参数类型 返回类型 用途 Consumer T void 对类型T参数操作，无返回结果，包含方法 void accept(T t) Supplier 无 T 返回T类型参数，方法时 T get() Function T R 对类型T参数操作，返回R类型参数，包含方法 R apply（T t） Predicate T boolean 断言型接口，对类型T进行条件筛选操作，返回boolean，包含方法 boolean test（T t） BinaryOperator T,T T 对类型T对象进行二元运算，并返回T类型的结果，包含方法T apply(T t1,T t2) BigConsumer T,U void 对类型T，u参数进行操作，包含方法void accept（T t,U u） BiConsumer 代表了一个接受两个输入参数的操作，并且不返回任何结果 BiFunction 代表了一个接受两个输入参数的方法，并且返回一个结果 BinaryOperator 代表了一个作用于于两个同类型操作符的操作，并且返回了操作符同类型的结果 BiPredicate 代表了一个两个参数的boolean值方法 BooleanSupplier 代表了boolean值结果的提供方 Consumer 代表了接受一个输入参数并且无返回的操作 DoubleBinaryOperator 代表了作用于两个double值操作符的操作，并且返回了一个double值的结果。 DoubleConsumer 代表一个接受double值参数的操作，并且不返回结果。 DoubleFunction 代表接受一个double值参数的方法，并且返回结果 DoublePredicate 代表一个拥有double值参数的boolean值方法 DoubleSupplier 代表一个double值结构的提供方 DoubleToIntFunction 接受一个double类型输入，返回一个int类型结果。 DoubleToLongFunction 接受一个double类型输入，返回一个long类型结果 DoubleUnaryOperator 接受一个参数同为类型double,返回值类型也为double 。 IntBinaryOperator 接受两个参数同为类型int,返回值类型也为int 。 IntConsumer 接受一个int类型的输入参数，无返回值 。 IntFunction 接受一个int类型输入参数，返回一个结果 。 IntPredicate 接受一个int输入参数，返回一个布尔值的结果。 IntSupplier 无参数，返回一个int类型结果。 IntToDoubleFunction 接受一个int类型输入，返回一个double类型结果 。 IntToLongFunction 接受一个int类型输入，返回一个long类型结果。 IntUnaryOperator 接受一个参数同为类型int,返回值类型也为int 。 LongBinaryOperator 接受两个参数同为类型long,返回值类型也为long。 LongConsumer 接受一个long类型的输入参数，无返回值。 LongFunction 接受一个long类型输入参数，返回一个结果。 LongPredicate R接受一个long输入参数，返回一个布尔值类型结果。 LongSupplier 无参数，返回一个结果long类型的值。 LongToDoubleFunction 接受一个long类型输入，返回一个double类型结果。 LongToIntFunction 接受一个long类型输入，返回一个int类型结果。 LongUnaryOperator 接受一个参数同为类型long,返回值类型也为long。 ObjDoubleConsumer 接受一个object类型和一个double类型的输入参数，无返回值。 ObjIntConsumer 接受一个object类型和一个int类型的输入参数，无返回值。 ObjLongConsumer 接受一个object类型和一个long类型的输入参数，无返回值。 Predicate 接受一个输入参数，返回一个布尔值结果。 Supplier 无参数，返回一个结果。 ToDoubleBiFunction 接受两个输入参数，返回一个double类型结果 ToDoubleFunction 接受一个输入参数，返回一个double类型结果 ToIntBiFunction 接受两个输入参数，返回一个int类型结果。 ToIntFunction 接受一个输入参数，返回一个int类型结果。 ToLongBiFunction 接受两个输入参数，返回一个long类型结果。 ToLongFunction 接受一个输入参数，返回一个long类型结果。 UnaryOperator 接受一个参数为类型T,返回值类型也为T。 匿名函数 参考匿名类。 匿名函数就是一个没有名字的函数。 常与 Lambda 搭配使用 // 新建了一个Runnable 对象。省略了 Runnable 的run函数的名字，并在函数里面打印了一句话 Runnable r = () -> System.out.println(\"Thread start...\"); // 使用这个新建的对象 new Thread(r).start(); Optional 是一个封装了一个元素的容器，而这个元素可以是null也可以是其它任意类型的。 Optional 的方法 说明 Optional.of(T t) 创建一个 Optional 实例 Optional.ofNullable(T t) 若 t 不为 null,创建 Optional 实例,否则创建空实例 Optional.empty() 创建一个空的 Optional 实例 optional.get() 获取Optional中的值 optional.isPresent() 判断optional对象是否有值 Stream 这个Stream并不是我们以前认识的IO流， 而是一个数据渠道，用于操作数据源（集合、数组等）所生成的元素序列。 Stream API 提供了一种高效且易于使用的处理数据的方式 ，例如 非常复杂的查找、过滤和映射数据等 。 注意：Stream 不会改变源对象。它会返回一个持有结果的新Stream（这样可以链式编程）。 Stream 延迟执行 只要Stream的方法返回的对象是Stream，这些方法就是延迟执行的方法 。 一般在Stream流中，一个方法返回的不是Stream，基本就是迫切方法 。 // 由集合创建 Stream List list = new ArrayList<>(); //获取一个顺序流 Stream stream = list.stream(); //获取一个并行流 Stream parallelStream = list.parallelStream(); // 由数组创建流 Integer[] nums = new Integer[8]; Stream stream3 = Arrays.stream(nums); // 由值创建流 Stream stream4 = Stream.of(1,2,3,4,5); // 由函数创建流 , 会不停打印一个随机数 Stream.generate(() -> Math.random()).forEach(System.out::println); Stream.iterate(1, (x) -> x + 1).forEach(System.out::println); // 筛选 ,自定义 List list2 = Arrays.asList(2, 3, 5, 4, 4,4, 1, 8, 10, 9, 7, 6); list2.stream() .filter((e) -> e > 5).forEach(System.out::println); // 筛选 ，去重 list2.stream() .distinct() .forEach(System.out::println); // 切割 ，限定个数 list2.stream().limit(3).forEach(System.out::println); // 返回一个去掉了前 n 个元素的流。若元素不足 n 个，则返回一个空流。 list.stream().skip(3).forEach(System.out::println); // 映射 , 将 参数 经过自定义处理后 再返回 list2.stream() .map(x -> x*x) .forEach(System.out::println); // 特殊的 映射操作 ， 结果一定要是 double类型 list2.stream() .mapToDouble(x -> x+0.1) .forEach(System.out::println); // 特殊的映射 ， 将流中的每个元素映射成一个流 list2.stream() .flatMap( xxx ) .forEach(System.out::println); // 按自然顺序排序 list2.stream() .sorted() .forEach(System.out::println); // 自定义排序 list.stream() .sorted( (x,y) -> -x.compareTo(y) ) .forEach(System.out::println); // 检查是否匹配所有元素 ,(是否全部元素都大于2) boolean allMatch = list2.stream() .allMatch(x -> x > 2); // 匹配元素位置 Optional first = list2.stream() .findFirst(); int val = first.get(); // 求最大值 最小值 Optional first1 = list2.stream() .min(Integer::compareTo); Optional first2 = list2.stream() .max(Integer::compareTo); Integer val1 = first.get(); // 将流中元素收集到List中 List resultList = list2.stream() .collect(Collectors.toList()); // 将流中元素收集到Set中 Set resultSet = list2.stream() .collect(Collectors.toSet()); 日期时间 API 在旧版的 Java 中，日期时间 API 存在很多问题，比如线程安全问题 、命名、设计、分包不合理等问题。 Java 8 提供的日期时间 API都在java.time包下， 这个包涵盖了所有处理日期(date)，时间(time)，日期/时间(datetime)， 时区（zone)，时刻（instant），间隔（duration）与时钟（clock）的操作 // 获取当前日期时间 LocalDateTime now = LocalDateTime.now(); int year = now.getYear(); int month = now.getMonthValue() ; int day = now.getDayOfMonth() ; // 将当前日期时间减去两天 LocalDateTime dateTime2 = now.minusDays(2); // 将当前日期时间加上五天 LocalDateTime dateTime3 = now.plusDays(5); // 构造一个指定日期时间的对象 , 年 月 日 时 分 LocalDateTime dateTime = LocalDateTime.of(2016, 10, 23, 8, 20); // 获取当前时间的时间戳 Instant instant = Instant.now(); // 结果跟System.currentTimeMillis()一样 long milli = instant.toEpochMilli(); // 时区偏移 OffsetDateTime dateTime4 = instant.atOffset(ZoneOffset.ofHours(8)); //时间间隔 LocalTime start = LocalTime.now(); LocalTime end = LocalTime.now(); Duration duration = Duration.between(start, end); // 日期间隔 LocalDate startDate = LocalDate.of(2015, 3, 4); LocalDate endDate = LocalDate.of(2017, 8, 23); Period period = Period.between(startDate, endDate); // 日期格式化 为字符串 ， 内置格式 LocalDate now6 = LocalDate.now(); String strNow = now6.format(DateTimeFormatter.BASIC_ISO_DATE); // 日期格式化 为字符串 ， 自定义格式 String strNow2 = now6.format(DateTimeFormatter.ofPattern(\"yyyy年MM月dd日\")); // 将字符串转换成日期 LocalDate date = LocalDate.parse(strNow2, DateTimeFormatter.ofPattern(\"yyyy年MM月dd日\")); // 目前支持的时区 Set set = ZoneId.getAvailableZoneIds(); //获取当前时区的日期时间 ZonedDateTime now3 = ZonedDateTime.now(); //获取美国洛杉矶时区的日期时间 ZonedDateTime USANow = ZonedDateTime.now(ZoneId.of(\"America/Los_Angeles\")); 重复注解 在 java8 以前，同一个程序元素前最多只能有一个相同类型的注解； 如果需要在同一个元素前使用多个相同类型的注解，则必须使用注解“容器”。 java8简化了使用的步骤，虽然仍然要定义“容器” 。但是直接使用的就是注解。 // java8 之前的写法 @Retention(RetentionPolicy.RUNTIME) public @interface Authority { String role(); } @Retention(RetentionPolicy.RUNTIME) public @interface Authorities { Authority[] value(); } @Authorities({@Authority(role = \"Admin\"), @Authority(role = \"Manager\")}) private void test( ) { ... } // java8 及之后的写法 @Retention(RetentionPolicy.RUNTIME) @Repeatable(Authorities.class) public @interface Authority { String role(); } @Retention(RetentionPolicy.RUNTIME) public @interface Authorities { Authority[] value(); } @Authority( role = \"Admin\" ) @Authority( role = \"Manager\" ) private void test( ) { ... } 无版权 可以无限制使用！ all right reserved，powered by Gitbook该文件更新时间： 2020-08-19 17:20:00 "},"chinese/通信方式/通信方式.html":{"url":"chinese/通信方式/通信方式.html","title":"通信方式","keywords":"","body":"http 、https 方式 1、http是基于 TCP/IP 的应用层协议 。 2、 采用 “一问一答” 模式 ，并不会保持长连接。 3、HTTP允许传输任意类型的数据对象。传输的类型由Content-Type加以标记。 Content-type HTTP Content-type 手册 文件扩展名 Content-Type .*（ 二进制流，不知道下载文件类型） application/octet-stream .txt text/plain .xml text/xml .css text/css .html text/html .js application/x-javascript 以下是RFC1867协议为HTTP协议的基础上|-为INPUT标签增加了file属性 文件扩展名 Content-Type 无文件的表单提交 application/x-www-form-urlencoded 有文件的表单提交 multipart/form-data 没查到何人何时 添加支持“json提交格式 ”的。 文件扩展名 Content-Type json格式的请求 application/json 建立、断开 http连接 http建立连接，底层是通过 Tcp协议 经过了3次握手、断开经过4次挥手。具体请查看tcp的相关知识。 TCP/IP协议族 https请求 即使采用了 HTTPS，也可以实现中间人攻击，或者进行数据解密等，但是，目前 HTTPS 目前使用的加密算法需要巨大的计算量才能破解 HTTPS 的目的主要有三个， 一个是数据的保密性，你给别人送个邮包，但邮包是打了封印的，快递员不知道包里装的是啥。 第二是数据的完整性，快递员不知道邮包是啥，但可以掉包啊，HTTPS 发现了掉包的数据，可以拒收。 第三就是身份验证，HTTPS 可以保证邮包被正确的送到指定的接收方，而不是第三方。 https相关术语 专业名词 解释 其他 SSL（Secure Sockets Layer） 网景公司设计的 单向证书认证 任何客户端都可以访问服务器 双向证书认证 被允许的客户端才能访问服务器 对称加密 加密和解密时使用的是同一个秘钥 非对称加密 用公钥加密，私钥解密 https 在内容传输的加密上使用的是对称加密，非对称加密只作用在证书验证阶段。 公钥 负责加密 在网络上传输 私钥 负责解密 本地保管，别人无法获取 // 对称加密 常见的 对称加密算法 有 DES、3DES、Blowfish、IDEA、RC4、RC5、RC6 、 AES 。 在数据传送前，发送方和接收方必须商定好秘钥。 用同一个秘钥进行加密和解密。如果一方的秘钥遭泄露，那么整个通信就会被破解。 // 非对称加密 常见的非对称加密算法有: RSA、ECC 、Diffie-Hellman、El Gamal、DSA 秘钥自己私下保管，公钥可以公开 ，别人通过公钥加密的信息发给你，只有通过私钥才能解密。 不用担心别人把秘钥泄露而导致整个通信被破解。 // md5 md5 不是对称和非对称算法。而是一种机制，一般用来做一致性校验。 对任何文件或内容 都生成 一串 32位的字符。不能根据字符反推。 比如一个很大的文件，下载完成之后要验证下 md5和给出的是否一致，如果不一致 说明你下载出错了或者文件被别人修改过。 虽然MD5 有很小很小的概率发生碰撞(可以忽略不计)，是一种非常优秀的算法。 ftp 第三方工具ftp4j ftp登录 public void run(){ //标记是否登录成功 boolean loginError = false ; try { mFTPClient.setType(FTPClient.TYPE_BINARY); //中文文件名 乱码处理 mFTPClient.setCharset(\"GBK\"); //登录成功后FTP服务器返回的欢迎语句 String[] welcome = mFTPClient.connect(FTP.HOST_IP, FTP.HOST_PORT); mFTPClient.login(FTP.HOST_USER, FTP.HOST_PASSWORD); mHandler.sendEmptyMessage(FTP.MSG_CMD_CONNECT_OK); }catch (Exception e) { loginError = true ; } if(loginError && FTP.mDameonRunning){ mHandler.sendEmptyMessageDelayed(FTP.MSG_CMD_CONNECT_FAILED, 2000); } } ftp删除文件（夹） public void run(){ try { if (isDirectory) { //删除文件夹 mFTPClient.deleteDirectory(realivePath); } else { //删除文件 mFTPClient.deleteFile(realivePath); } mHandler.sendEmptyMessage(FTP.MSG_CMD_DELE_OK); } catch (Exception ex) { mHandler.sendEmptyMessage(FTP.MSG_CMD_DELE_FAILED); } } ftp断开连接 if (mFTPClient != null){ try { mFTPClient.disconnect(true); } catch (Exception ex) { ex.printStackTrace(); } } ftp文件下载 if(! localFile.exists()){ long fileSize = ftpFile.getSize() ; if(fileSize > 0){ mFTPClient.download( ftpFile.getName(), new File(localFilePath), new DownloadFTPDataTransferListener(ftpFile.getSize())); }else{ //文件异常的情况 下载发生异常the size of file muset be larger than zero. } } ftp 获取文件列表 @Override public void run(){ try { mFTPClient.changeDirectory(FTP.FTPSMAllPICDIR); FTPFile[] ftpFiles = mFTPClient.list(); synchronized (mLock){ mFileList.clear(); //数组拷贝到list中去 mFileList.addAll(Arrays.asList(ftpFiles)); } mHandler.sendEmptyMessage(FTP.MSG_CMD_LIST_OK); } catch (Exception ex) { mHandler.sendEmptyMessage(FTP.MSG_CMD_LIST_FAILED); } }// ftp 文件上传（进度条） try { File file = new File(path); mFTPClient.upload(file, new DownloadFTPDataTransferListener( file.length())); } catch (Exception ex) { return false; } ftp 连接守护进程 //在子线程中定时判断 if (mFTPClient != null && !mFTPClient.isConnected()){ try { //解决中文件名乱码问题 mFTPClient.setType(FTPClient.TYPE_BINARY); mFTPClient.setCharset(\"GBK\"); mFTPClient.connect(FTP.HOST_IP, FTP.HOST_PORT); mFTPClient.login(FTP.HOST_USER, FTP.HOST_PASSWORD); Thread.sleep(FTP.MAX_DAMEON_TIME_WAIT); } catch (Exception ex) { } } FTP 传输进度 回调 public class DownloadFTPDataTransferListener implements FTPDataTransferListener{ /**已经传送量*/ private int totolTransferred = 0; /**数据总量*/ private long fileSize = -1; public DownloadFTPDataTransferListener(long fileSize){ if (fileSize 使用场景 FtpManager ftpManager = new FtpManager(); //然后 ftp 的相关操作 要放到子线程中去执行。 建议使用线程池。 sockt tcp_udp 进行tcp通信时，需要注意处理 粘包的问题。然后控制好休眠时间 和 接收的 buffer[] 大小。 TCP标志位 (位码) 标记 含义 SYN synchronous 建立联机 ACK acknowledgement 确认 PSH push传送 FIN finish结束 RST reset重置 URG urgent紧急 术语 Sequence number 顺序号码 Acknowledge number 确认号码 MSL Maximum Segment Lifetime ，报文最长存活时间 tcp相关问题 为什么连接的时候是三次握手，2次不行吗? 为了让服务器、客户端端彼此知道 自己+对方的 接收、发送功能正常。 自己模拟一下就知道至少需要三次。 为什么连接的时候是三次握手，关闭的时候却是四次挥手？ 关闭连接时，当Server端收到FIN报文时，很可能并不会立即关闭SOCKET， 所以只能先回复一个ACK报文，告诉Client端，\"你发的FIN报文我收到了\"。 只有等到我Server端所有的报文都发送完了，我才能发送FIN报文，因此不能一起发送。 故需要四步挥手。 （为了争取一段缓冲时间，完成正在进行的数据传输） 为什么客户端在TIME-WAIT状态必须等待2MSL (Maximum Segment Lifetime) 的时间？ 为了保证客户端发送的最后一个ACK报文段能够到达服务器。 因为这个ACK报文段有可能丢失，因而使处在LAST-ACK状态的服务器收不到对已发送的FIN+ACK报文段的确认。 服务器会超时重传这个FIN+ACK报文段。而客户端就能在2MSL时间内收到这个重传的FIN+ACK报文段。 接着客户端重传一次确认，重新启动2MSL计时器。 最后客户端和服务器都正常进入到CLOSED状态。 粘包处理 目前不是最优方法，速度有点慢。想到高效的方法再补充。 public class AirUnPackTools{ /**帧头*/ private static final byte packHead1= (byte) 0xDD; /**是否在有效数据之内*/ private static boolean isContinue = false ; private static byte mlastByte =(byte) 0x00 ; /**byte索引 ， 用来指示 关键字 和 长度 */ private static int mByteIndex = 0; /**当前帧的长度*/ private static int mFrameLengh =0 ; /**临时list*/ private static List lastBytesList = new ArrayList<>() ; /**数据段 数据长度 */ private static int mbyteCount = 0; /**遥控器返回的消息类型 = 0x55 ,5a ,5b ， 00为默认状态，无意义*/ private static byte msgType =0x00 ; public static DronePacket320 unPackageofGround(byte mByte){ DronePacket320 packetGround = null ; //判断是否是帧开头 switch (mByte) { case packHead1: // 连续出现2个DD ，说明这是帧头 if(mlastByte == packHead1 ) { lastBytesList.clear(); lastBytesList.add(packHead1) ; mByteIndex = 0; isContinue = true ; } break; } if(isContinue) { boolean reslut = getUnpackagedFrame(mByte); if(reslut) { packetGround = new DronePacket320() ; packetGround.msgType = msgType ; packetGround.bytes = listToBytesArray(lastBytesList) ; }else{ packetGround = null ; } }else{ packetGround = null ; } mlastByte = mByte ; return packetGround ; } public static byte [] listToBytesArray(List list) { byte[] bytes = new byte[list.size()] ; for(int i= 0; i public class DronePacket320{ public short msgType; public byte[] bytes; } //使用 for (int i = 0; i 第三方库 netty 用来连接tcp、接收 和发送数据的 public interface MyNettyCallBack{ /**tcp成功建立连接*/ public static final int Key_State_connect=1 ; /**tcp断开*/ public static final int Key_State_disConnect=2 ; /**tcp正在重连*/ public static final int Key_State_isReConnect=3 ; /**连接发生异常*/ public static final int Key_State_error=4; /**连接手动关闭*/ public static final int Key_State_close=5; /**连接正常-正在接收数据*/ public static final int Key_State_recevieData=6; /**服务器返回信息给客户端*/ public void sendMsgToUser(byte[] reslut , int state ,String stateMsg) ; } public class NettyTcpTools{ private int port; private String host; private SocketChannel socketChannel; private Bootstrap bootstrap; private boolean isConnect = false; /**是否需要重连*/ private boolean isRepeate = false; /**用来区分是用户主动断开还是异常导致断开用户主动断开的话就不用去重连*/ private boolean isStopByUser =false ; /**通信管道*/ private ChannelFuture future = null; /**状态回调*/ private MyNettyCallBack myNettyCallBack ; /**线程池工具*/ private MyThreadPoolTools myThreadPoolTools ; public NettyTcpTools(String host , int port){ this.port = port; this.host = host; bootstrap = new Bootstrap(); bootstrap.channel(NioSocketChannel.class); //保持长连接 bootstrap.option(ChannelOption.SO_KEEPALIVE, true); //自动调整下一次缓冲区建立时分配的空间大小，避免内存的浪费 bootstrap.option(ChannelOption.RCVBUF_ALLOCATOR, new AdaptiveRecvByteBufAllocator(1024, 1024 * 32, 1024 * 64)); bootstrap.group( new NioEventLoopGroup()); bootstrap.remoteAddress(host, port); bootstrap.handler(new ChannelInitializer() { @Override protected void initChannel(SocketChannel socketChannel) throws Exception { //超时处理 socketChannel.pipeline().addLast(new IdleStateHandler(3, 3, 3 ,TimeUnit.SECONDS)); //接收服务器信息 socketChannel.pipeline().addLast( new NettyClientHandler()); } }); } private void gotoConnectTcp(){ closeThreadPool(); myThreadPoolTools= new MyThreadPoolTools(); Runnable task = new Runnable() { @Override public void run() { isStopByUser = false ; try { if (future != null) { boolean isActive = future.channel().isActive() ; boolean isOpen = future.channel().isOpen() ; MyLogUtils.mLog_iNormal(\"连接测试：isActive=\" + isActive +\" isOpen=\"+ isOpen); /* 这个地方注意了： 如果 没有关闭，会导致多个tcp连接 使用 网络调试助手.exe 进行调试查看*/ future.channel().close(); } future = bootstrap.connect(new InetSocketAddress(host, port)).sync(); if (future.isSuccess()) { socketChannel = (SocketChannel) future.channel(); sendMsgToUser(null ,MyNettyCallBack.Key_State_connect ,\"connect server Success\"); isConnect = true; return; } } catch (Exception cause) { sendMsgToUser(null ,MyNettyCallBack.Key_State_error ,\"error2:\"+cause.toString()); } //连接状态在此处处理 repeateTcp(); } }; if (myThreadPoolTools == null) { myThreadPoolTools= new MyThreadPoolTools(); } myThreadPoolTools.addTask(task); } public void startTcpTools(){ gotoConnectTcp(); } private void closeThreadPool(){ if(myThreadPoolTools!=null) { myThreadPoolTools.shutdownThreadPool(); myThreadPoolTools=null ; } } public void nettySendBytes(final byte[] bytesSend) { Runnable runnable = new Runnable() { @Override public void run() { if (isConnect) { ByteBuf buf = Unpooled.buffer(bytesSend.length); buf.writerIndex(); buf.writeBytes(bytesSend); socketChannel.writeAndFlush(buf); } } } ; if (myThreadPoolTools == null) { myThreadPoolTools= new MyThreadPoolTools(); } myThreadPoolTools.addTask(runnable); } public class NettyClientHandler extends SimpleChannelInboundHandler{ @Override protected void channelRead0(ChannelHandlerContext channelHandlerContext,ByteBuf byteBuf) throws Exception { //这里是接受服务端发送过来的消息 byte[] result = new byte[byteBuf.readableBytes()]; byteBuf.readBytes(result); /*这种方式会定长读取，后面有很多00 00 00 byte[] bytes = byteBuf.array();*/ sendMsgToUser(result ,MyNettyCallBack.Key_State_recevieData ,\"channelRead0\"); } /**这里是断线要进行的操作*/ @Override public void channelInactive(ChannelHandlerContext ctx) throws Exception { super.channelInactive(ctx); ctx.close() ; if(!isStopByUser) { sendMsgToUser(null ,MyNettyCallBack.Key_State_disConnect ,\"channelInactive\"); repeateTcp(); } } /**这里是出现异常的话要进行的操作*/ @Override public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception { //ctx.close() ; sendMsgToUser(null ,MyNettyCallBack.Key_State_error ,\"error1:\"+cause.toString()); repeateTcp(); } /**用来处理读写超时的 自定义操作*/ @Override public void userEventTriggered(ChannelHandlerContext ctx, Object evt) throws Exception { super.userEventTriggered(ctx, evt); if (evt instanceof IdleStateEvent) { IdleStateEvent event = (IdleStateEvent) evt; if (event.state().equals(IdleState.READER_IDLE)) { // 在指定的时间内没有收到服务器的反馈信息 } else if (event.state().equals(IdleState.WRITER_IDLE)) { //在指定的时间内没有像服务器发送过信息 } else if (event.state().equals(IdleState.ALL_IDLE)) { //在指定的时间内 既没有收到过信息 也没有发送过信息 } } } } // 设置消息回调接口，用来获取从服务器返回的消息。 public void setMyNettyCallBack(MyNettyCallBack myNettyCallBack) { this.myNettyCallBack = myNettyCallBack ; } private void sendMsgToUser(byte[] result , int state ,String sendMsgToUser) { if (myNettyCallBack != null) { myNettyCallBack.sendMsgToUser(result ,state ,sendMsgToUser); } } // tcp重连 private void repeateTcp() { if(isStopByUser) { return; } if (!isRepeate) { if (isConnect) { isConnect = false; //断线监听在此处处理 } isRepeate = true; sendMsgToUser(null ,MyNettyCallBack.Key_State_isReConnect ,\"repeateTcp\"); try { TimeUnit.SECONDS.sleep(5); } catch (InterruptedException e) { e.printStackTrace(); } isRepeate = false; startTcpTools(); } } // 关闭 tcp连接 public void nettyToolsClose() { resetState(); closeThreadPool(); if (future != null && future.channel() != null) { if (future.channel().isOpen()) { sendMsgToUser(null ,MyNettyCallBack.Key_State_close ,\"close\"); future.channel().close(); } } } private void resetState() { isConnect = false; isRepeate=false; isStopByUser = true ; } } 拓展知识 数字信号 、模拟信号 模拟信号和数字信号之间是可以相互转换的。 模拟信号：时间连续，幅值连续。 数字信号：时间离散，幅值离散。 在电学中，将连续变化的电压、电流等物理量称为模拟信号，而离散变化的电压、电流则称为数字信号。 模拟信号在日常生活中很常见，譬如家用的220V交流电压、环境温度及光线的变化、蓄电池的放电、人的说话声，这些皆为模拟信号。 数字信号的波形如上图所示，是一个由一系列高低电平组成的离散变化的物理量。数字信号在生活中较少见。 数字信号就是一系列的“0”和“1”的组合。 咱们自然界中各种事物变化，都是模拟信号，比如，随着时间的流逝，太阳缓缓升起， 在这里，时间是连续变化的，太阳的位置也是连续变化的，每一个时间点，对应于一个太阳的位置。 现在，咱们为了研究太阳位置的变化规律，要将这个时间与太阳的位置变化关系交给计算机研究。 有个问题：咱们的时间是连续的，可以无限分下去的，同样的，太阳的位置点也可以有无穷多个，咱们该如何把这么多的数据存储起来呢？ 并且，对于咱们的研究来说，真的需要将这么多的数据存储下来吗？ 所以咱们要进行离散化的处理，比如早晨8点到10点，每隔5分钟，咱们记录一个太阳的位置，这样，储存的数据是不是大大减少了？ 现在，对于这个问题，咱们的时间变量，变成了每隔五分钟一个，咱们的太阳位置，也相对应的变成了离散化的， 也就是说，时间是离散化的，幅值也是离散化的。变成了一个数字信号，也就可以交给计算机处理啦。 OSI ( Open System Interconnection ) 七层模型 // 物理层 物理设备、例如网线、电缆、集线器等. // 链路层 数据链路层，负责对于底层物理信号识别成某种信息。为了匹配物理层电气特征。 将比特组合成字节,再将字节组合成帧,使用链路层地址 (以太网使用MAC地址)来访问介质,并进行差错检测。 链路层就像同城跑腿（网络层是跨城跑腿，类似邮局快递等），你把货交给他，告诉他地址，他直接送达。 链路层识别mac地址，链路联通后，交换机学习各端口的mac地址，建立mac地址转发表，然后链路层就开始工作了。 // 网络层 就是通常说的IP层。这一层就是我们经常说的IP协议层。IP寻址、IPV4 / IPV6 等。 本层通过IP寻址来建立两个节点之间的连接，为源端的运输层送来的分组，选择合适的路由和交换节点， 正确无误地按照地址传送给目的端的运输层。 网络层按理来说，数据链路层已经能够起到信息识别的作用了，为何还需要网络层呢？ 关键就在于数据链路层所能识别出的信息，能够很好的被机器理解。但不能很好的被人所理解。所以需要构建一层来方便人来进行处理。 为什么有了MAC地址，还需要IP地址？ 历史原因：以太网诞生于因特网之前，在IP地址之前MAC地址就已经在使用了。两者结合使用，是为了不影响已存在的协议 分层实现：对网路协议进行分层以后，数据链路层的实现不需要考虑数据之间的转发，网络层的实现不需要考数据链路层的影响。 分工合作：IP地址是会随着主机接入网络的不同而发生改变的，而MAC一般不会改变。这样的话，我们可以使用IP地址进行寻址，当数据报和目的主机处于同一网络时，就使用MAC地址进行数据交付。 // 传输层 对网络层的进一步封装，TCP 、UDP 就是这一层。 // 会话层 负责建立和断开通信连接（数据流动的逻辑通路）。 例如要根据你自己的逻辑，来决定什么时候要进行数据连接、数据重连、连接断开等。 // 表示层 主要负责数据格式的转换。将设备固有的数据格式转换为网络标准传输格式，不同设备对同一比特流解释的结果可能会不同。 例如同样的一串 byte[]数据，不同的APP采用的不是同一套解析协议，所以要根据不同的协议转为APP能识别的信息。 // 应用层 有些分层版本中，将 会话层+表示层+ 应用层 = 统一称为应用层。 因为会话层和表示层没有办法完全抽象成公共层，一般都是和应用层一起实现。 就是各个公司开发的不同的应用。例如 HTTP超文本传输、 HTTPS FTP文件传输 、SMTP邮件传输 等不同侧重方向的传输协议。 usb 通信 AOA协议 Google推出的 Android开放配件协议AOA（Android Open Accessory Protocol）及配件开发工具包ADK（Accessory Development Kit） 提供了Android设备与Android配件通过USB或蓝牙进行通信的API， 为基于Android系统的智能设备控制外设提供了条件。 利用Android，系统可以连接从家用电器到重型机械、机器人等多种设备。 当前项目用到的是 android 的AOA协议。遥控器作为主机供电，移动设备（手机、平板）作为从机。 使用方法请自行查阅相关文档。 使用场景一 ：android设备作为从机 参考资料 这种模式是Android定义的一种新的通讯模式，它将usb配件作为协议交互的主要角色，配件内置USB Embedded Host端，可以为Android手机供电，并且识别Android手机，建立数据通道。使得配件成为一个简化版的PC Host端。 usb通信demo MusbAccessoryManager.java /** * usb 操作管理类 */ public class MusbAccessoryManager{ private Context mCtx; /**文件操作符*/ private ParcelFileDescriptor fileDescriptor; /**输入流*/ private FileInputStream inputStream; /**输出流*/ private FileOutputStream outputStream; /**读线程*/ private AccessoryReadThread readThread; /**写线程*/ private AccessoryWriteThread writeThread; /**解析线程*/ private BytesDataRepackThread repackThread ; /**usb 通信是否在进行*/ private boolean enableThread; /**发送队列*/ private BlockingQueue outQueue; /**读取队列*/ private BlockingQueue readQuene; /**回调接口 - 状态标记*/ private IOperateResultCallBack iUsbResultCallBack ; /**回调接口 - byte[] 传输*/ //private IBytesTransferInterface iGetBytesInterface ; /**解析后的数据对象 回调-*/ private IUsbPackageTransferInterface iusbpackageTransInterface ; /**读入流 时的休眠间隔 微秒*/ private final long READ_STRING_SLEEPTIME= 20L; /**写入流 时的休眠间隔*/ private final long WRITE_STRING_SLEEPTIME= 60L; /**解析 byte[] 时的休眠间隔*/ private final long REPACKAGE_SLEEPTIME= 0L; /** 调整读取大小*/ private byte[] buffer= new byte[2048 * 3] ; public MusbAccessoryManager(Context context , IOperateResultCallBack iUsbResultCallBack , IUsbPackageTransferInterface iusbpackageTransInterface) { this.mCtx = context; fileDescriptor = null; inputStream = null; outputStream = null; readThread = null; writeThread = null; repackThread =null ; enableThread = false; this.iUsbResultCallBack= iUsbResultCallBack; this.iusbpackageTransInterface = iusbpackageTransInterface; outQueue = new LinkedBlockingQueue(Integer.MAX_VALUE); readQuene = new LinkedBlockingQueue<>(Integer.MAX_VALUE) ; } /** * 添加数据 到发送队列 */ public void addMessage(MyBytesTransfer msg) { try { outQueue.put(msg); }catch (Exception e) { MyLogUtils.mLog_iNormal(\"usb设备== 发送异常1 =\"+e.getMessage()); } } /** * 打开USB通信 */ public void OpenAccessory(UsbAccessory accessory) { if (!enableThread) { fileDescriptor = ((UsbManager) mCtx.getSystemService(Context.USB_SERVICE)).openAccessory(accessory); if (fileDescriptor != null) { FileDescriptor fd = fileDescriptor.getFileDescriptor(); inputStream = new FileInputStream(fd); outputStream = new FileOutputStream(fd); if (inputStream == null || outputStream == null) { // 读取流异常 iUsbResultCallBack.onResultCallBack(MyStateConfig.STATE_2); return; } //连接成功 iUsbResultCallBack.onResultCallBack(MyStateConfig.STATE_14); enableThread = true; readThread = new AccessoryReadThread(inputStream); readThread.start(); writeThread = new AccessoryWriteThread(outputStream); writeThread.start(); repackThread = new BytesDataRepackThread() ; repackThread.start(); }else{ toastMsg(\"fileDescriptor==null \" ) ; } } }// /** * 关闭连接、清空队列、停止线程 */ public void CloseAccessory() { try { if (fileDescriptor != null) { fileDescriptor.close(); } if (outputStream != null) { outputStream.close(); } if (inputStream != null) { inputStream.close(); } }catch (Exception ie) { ie.printStackTrace(); } outQueue.clear(); readQuene.clear(); enableThread = false; fileDescriptor = null; outputStream = null; inputStream = null; } /** 读取子线程 */ private class AccessoryReadThread extends Thread { private FileInputStream inStream; public AccessoryReadThread(FileInputStream stream) { this.inStream = stream; } @Override public void run() { while (enableThread) { try { int realReaded = inStream.read(buffer); // 将Buffer中有效的数据拷贝出来 if(realReaded>0) { byte [] realBytes = MyStringUtils.subBytes(buffer, 0 , realReaded) ; readQuene.put(realBytes); } } catch (Exception e) { com.walkera.base.utils.MyLogUtils.mLog_iNormal(\"usb设备== 接收异常=\"+e.getMessage()); MyApplication.usbReadStreamState= MyStateConfig.STATE_8; //发生异常，继续执行 continue; } MyApplication.usbReadStreamState= MyStateConfig.STATE_9; try { TimeUnit.MICROSECONDS.sleep(READ_STRING_SLEEPTIME); } catch (InterruptedException e) { e.printStackTrace(); } } // end while } // end run }// /** *发送子线程 */ private class AccessoryWriteThread extends Thread { private FileOutputStream outStream; public AccessoryWriteThread(FileOutputStream outputStream) { this.outStream = outputStream; } @Override public void run() { MyBytesTransfer msg; while (enableThread){ try{ if (outStream != null) { msg = outQueue.poll(); if (msg != null) { sendByteDataToServer(msg.bytes ); msg = null; }else{ } } else{ MyApplication.usbWriteStreamState= MyStateConfig.STATE_11; outQueue.clear(); } MyApplication.usbWriteStreamState= MyStateConfig.STATE_10; try { Thread.sleep(WRITE_STRING_SLEEPTIME); } catch (InterruptedException e) { e.printStackTrace(); } }catch (Exception ex) { com.walkera.base.utils.MyLogUtils.mLog_iNormal(\"发送测试3= msg=\"+ex.getMessage()); MyApplication.usbWriteStreamState= MyStateConfig.STATE_11; } } } /** * 将数据发送给服务器 */ private void sendByteDataToServer(byte[] buffer) { try { if (outStream != null) { iUsbResultCallBack.onResultCallBack(MyStateConfig.STATE_13); outStream.write(buffer, 0, buffer.length); outStream.flush(); } }catch (IOException ex) { iUsbResultCallBack.onResultCallBack(MyStateConfig.STATE_12); } }// } /** * 解析 重组包 子线程 */ private class BytesDataRepackThread extends Thread{ @Override public void run() { while (enableThread) { if(readQuene!=null) { byte[] realBytes = readQuene.poll() ; if(realBytes!=null) { rePackageForBytes(realBytes) ; } } try { Thread.sleep(REPACKAGE_SLEEPTIME); } catch (InterruptedException e){ e.printStackTrace(); } } // while }//end run } /*** * 重组包 ， 将遥控器 、 飞控、视屏数据分开 . */ private void rePackageForBytes(byte[] bytes) { if(bytes!=null) { int size =bytes.length ; for(int i=0 ; i UsbMsgClient.java /** * 功能描述： 负责 用usb方式的通信方式 给其他部件提供发送和接收数据的功能 */ public class UsbMsgClient{ private Context mCtx ; /**usb管理类*/ private UsbManager usbmanager ; /**usb 操作管理类*/ private MusbAccessoryManager mubAccessoryManager; /**对外暴露的接口 ，以便其他模块获取 对应的数据*/ private IUsbMsgBackInterface iUsbMsgBackInterface ; /** * @param iUsbMsgBackInterface 对外暴露的接口 ，以便其他模块获取 对应的数据 * @param iUsbResultCallBack usb 返回状态码 */ public UsbMsgClient (Context mCtx ,IUsbMsgBackInterface iUsbMsgBackInterface ,IOperateResultCallBack iUsbResultCallBack) { this.mCtx = mCtx; this.iUsbMsgBackInterface= iUsbMsgBackInterface ; usbmanager=((UsbManager) mCtx.getSystemService(Context.USB_SERVICE)) ; mubAccessoryManager = new MusbAccessoryManager(mCtx , iUsbResultCallBack ,iusbpackageTransInterface); discoverAccessories(); }// /**回调 来自usb的数据*/ private IUsbPackageTransferInterface iusbpackageTransInterface = new IUsbPackageTransferInterface() { @Override public void transferUsbPackageBean(MyBytesTransfer myBytesTransfer) { if(myBytesTransfer != null) { // 4759图传 - 3678飞控 - 5869 遥控器 if( Arrays.equals(myBytesTransfer.msgType, MyStateConfig.VEDEO_DATA_RECEIVE)) { //视屏数据 iUsbMsgBackInterface.getUsbVedioByte(myBytesTransfer); }else if(Arrays.equals(myBytesTransfer.msgType, MyStateConfig.FC_DATA_RECEIVE)) { //飞控数据 iUsbMsgBackInterface.getUsbFcByte(myBytesTransfer); }else if(Arrays.equals(myBytesTransfer.msgType, MyStateConfig.RC_DATA_RECEIVE)) { //遥控器数据 iUsbMsgBackInterface.getUsbRcByte(myBytesTransfer); } } } } ; /** * 扫描usb设备 发现从设备 */ private void discoverAccessories() { UsbAccessory[] list = usbmanager.getAccessoryList(); if (list != null && list.length!=0) { openTheAccessory(list[0]); }else { //MyToastTools.toastWarning(mCtx ,mCtx.getString( R.string.v5_str_1)); } }// /** * 连接 指定设备 */ private void openAccessory(UsbAccessory accessory) { mubAccessoryManager.OpenAccessory(accessory); // 延时 n秒 发送打开session命令 new Handler().postDelayed(new Runnable() { @Override public void run() { byte[] openSession = { (byte)0xDD , (byte)0xDF ,(byte)0x06 ,(byte)0x00 } ; sendBytesToDevices(openSession); } } , 2000) ; } /** * 连接USB设备 */ private void openTheAccessory(UsbAccessory accessory) { if (accessory == null) { MyToastTools.toastWarning(mCtx ,mCtx.getString( R.string.v5_str_2)); }else { if (usbmanager.hasPermission(accessory)) { openAccessory(accessory); }else { com.walkera.base.utils.MyLogUtils.mLog_iNormal(\"usb设备== 无权限1\"); } } } /** * 通知遥控器关闭 */ private void closeSession() { byte[] closeSession = { (byte)0xDD , (byte)0xDF ,(byte)0x07 ,(byte)0x00 } ; sendBytesToDevices(closeSession); } /** * 关闭usb收发工具 */ public void closeUsbMsgClinet() { closeSession(); new Handler().postDelayed(new Runnable() { @Override public void run() { closeAccessory(); } }, 500); } /** * 断开设备 */ private void closeAccessory(){ if (mubAccessoryManager != null) { mubAccessoryManager.CloseAccessory(); } } /** * 发送数据 */ public void sendBytesToDevices( byte[] data ) { if (mubAccessoryManager != null) { mubAccessoryManager.addMessage(new MyBytesTransfer(data , MyStateConfig.STATE_6,null)); } } } MyStateConfig.java public class MyStateConfig{ /**请求usb访问的自定义权限*/ public static final String ACTION_USB_ACCESSORY_PERMISSION = \"com.wk.USB_ACCESSORY_PERMISSION\"; /**当前参数无意义 */ public final static int STATE_NULL = -100 ; /**所有的状态的初始化状态 */ public final static int STATE_0 = 0 ; /** usb退出 */ public final static int STATE_1 =1 ; /** usb连接异常 , 读取流异常 */ public final static int STATE_2 =2 ; /** usb 权限被拒绝了 */ public final static int STATE_3 =3; /**接收usb byte 正式*/ public final static int STATE_4 =4; /**接收usb byte 测试*/ public final static int STATE_5 =5; /**发送的bytes[]*/ public final static int STATE_6 =6; /**接收到的byte[]*/ public final static int STATE_7 =7; /**usb输入流异常*/ public final static int STATE_8 =8; /**usb输入流正常*/ public final static int STATE_9 =9; /**usb输出流正常*/ public final static int STATE_10 =10; /**usb输出流异常*/ public final static int STATE_11 =11; /**发送失败*/ public final static int STATE_12 =12; /**发送成功*/ public final static int STATE_13 =13; /**Usb连接成功*/ public final static int STATE_14 =14; /**属于相机数据 */ public final static int STATE_15 = 15 ; } xml中的一些配置、usb插入、拔出监听 请参考官网 使用 /**usb收发工具*/ private UsbMsgClient usbMsgClient ; //初始化usb数据接收器 usbMsgClient = new UsbMsgClient( mContext ,iUsbMsgBackInterface ,iUsbResultCallBack) ; //发送byte[]数据 usbMsgClient.sendBytesToDevices(code); //关闭连接 usbMsgClient.closeUsbMsgClinet(); /** * 接收 usb 返回数据 */ private IUsbMsgBackInterface iUsbMsgBackInterface = new IUsbMsgBackInterface(){ /**视屏数据*/ @Override public void getUsbVedioByte(MyBytesTransfer vedioData) { //解码... } /**飞控数据*/ @Override public void getUsbFcByte(MyBytesTransfer fcData) { //解析飞控数据 } /**遥控器数据*/ @Override public void getUsbRcByte(MyBytesTransfer rcData) { //解析遥控器数据 } } ; /** * 接收 usb 操作、状态码 */ private IOperateResultCallBack iUsbResultCallBack = new IOperateResultCallBack(){ @Override public void onResultCallBack(int state ){ //状态码 } }; 私有协议 参数类型对应的字节数 类型 对应字节数 备注 bit 1/8 byte 1 char 1 boolean 1 uint8 1 uint8_t 1 uint16 2 int16 2 short 2 int 4 float 4 int32 4 uint32_t 4 double 8 long 8 心跳机制 心跳机制 在私有协议中，我们常常需要用心跳来判断对方是否已经掉线。比如持续20秒收不到约定的信号，判断为对方掉线。 public abstract class HeartBeatTask implements Runnable { private String taskName ; public HeartBeatTask( ){ taskName = \"beatTask_\"+System.nanoTime() ; } public String getTaskName() { return taskName; } } public class WkHeartBeatTool { private ScheduledExecutorService mScheduledExecutorService; private HashMap map ; public WkHeartBeatTool() { initTool(); } public int getTaskNum(){ return map==null? 0 : map.size() ; } private void initTool() { mScheduledExecutorService = Executors.newScheduledThreadPool(5);// 线程池大小 5 map = new HashMap() ; } public void startTheBeatAction(HeartBeatTask task , int period){ if(map.containsKey(task.getTaskName())){ System.out.println(\"心跳正在进行，无需重复添加\"); return ; } Future future = mScheduledExecutorService.scheduleAtFixedRate( task , 0, period, TimeUnit.MILLISECONDS); map.put(task.getTaskName() , future) ; } public void shutDownTheBeatAction(HeartBeatTask task ){ Future future = map.get(task.getTaskName()) ; if(future!=null){ future.cancel(true) ; map.remove(task.getTaskName()) ; }else{ System.out.println(\"你指定的这个心跳任务已经不存在，无需关闭\"); } } public void startDelayedAction( HeartBeatTask task , int delayTime){ mScheduledExecutorService.schedule( task, delayTime ,TimeUnit.MILLISECONDS ); } public void shutDownAll() { if (mScheduledExecutorService != null) { mScheduledExecutorService.shutdownNow(); // 强制关闭 mScheduledExecutorService = null; } map.clear(); map=null ; } } WkHeartBeatTool heartBeatTool = new WkHeartBeatTool() ; HeartBeatTask task1 = new HeartBeatTask() { public void run() { ...} }; heartBeatTool.startTheBeatAction(task1, 1000) ;// 开始心跳 heartBeatTool.shutDownTheBeatAction(task1) ;// 停止心跳 heartBeatTool.startDelayedAction(task1, 5 * 1000) ;// 发送延时任务 int sum = heartBeatTool.getTaskNum() ;// 获取 心跳任务总数 heartBeatTool.shutDownAll() ;// 关闭所有任务 并销毁工具 无版权 可以无限制使用！ all right reserved，powered by Gitbook该文件更新时间： 2020-12-17 11:41:34 "},"chinese/java基础/数据解析.html":{"url":"chinese/java基础/数据解析.html","title":"数据解析","keywords":"","body":"数据解析 json解析 fastjson 阿里出品 ，零依赖 。 https://github.com/alibaba/fastjson compile 'com.alibaba:fastjson:1.1.70.android' String detail = JSON.toJSONString(listToStore) ; //list数组转string JSONArray array = JSONArray.parseArray( string ); // string 转json数组 List saveBeans = JSONObject.parseArray(array.toJSONString(), XXBean.class); // JSONArray 转List对象 XXBean item = JSON.parseObject(string, XXBean.class); //json字符串转对象 Protocol Buffer developers protobuf github protobuf 相比于XML或Json格式存储数据， 数据量较大时，通过Protocol Buffers来定义的文件体积更小，解析速度更快 。 //感觉跟自定义私有协议差不多，只是proto使用起来会更方便一点，比如数据的转换和拓展... 1、引入辅助插件protobuf-gradle-plugin // 最新版本请参考官网 https://github.com/google/protobuf-gradle-plugin classpath 'com.google.protobuf:protobuf-gradle-plugin:0.8.12' // (项目最外层build.gradle) 2、导入 protocol库 （考虑到文件大小，Android采用精简版 protobuf-lite） // 具体版本请参考 https://search.maven.org/artifact/com.google.protobuf/protobuf-lite compile \"com.google.protobuf:protobuf-lite:3.0.1\" //app层build.gradle 3、应用插件 apply plugin: 'com.google.protobuf' // app层build.gradle 4、其他配置 // app层build.gradle protobuf { protoc { artifact = 'com.google.protobuf:protoc:3.0.0' } plugins { javalite { artifact = 'com.google.protobuf:protoc-gen-javalite:3.0.0' } } generateProtoTasks { all().each { task -> task.builtins { remove java } task.plugins { javalite { } } } } } 5、编写.proto文件 在src\\main\\ 目录下新建proto文件夹 ，新建 xxx.proto文件 // 版本号为3 syntax = \"proto3\"; //自动生成的对应的Java文件放这个目录下 option java_package = \"com.myProto.pack\"; // java_multiple_files 为true时，生成的Java类将是包级别的，否则会在一个包装类中。 option java_multiple_files = true; // 该文件对应的Java类名，不用写了，因为 message Person已经写了 //option java_outer_classname = \"Person\"; message Person { //proto3 已经取消了默认值的设置。 // 这里的1 2 3是字段号，不是默认值 string name =1; bool isMan =2; int32 age =3; double money =4; string phone =5 ; } 6、编译工程，系统就会自动生成对应的Java文件。 7、Java层使用和解析数据 private void test(){ Person person = Person.newBuilder(). setName(\"aivin666\") .setIsMan(true) .setAge(20) .setMoney(1000) .setPhone(\"13650909087\") .build(); byte[] dataSend = person.toByteArray();// 对象转byte[] Person result = Person.parseFrom(dataSend); //byte[]转对象 } 无版权 可以无限制使用！ all right reserved，powered by Gitbook该文件更新时间： 2020-09-24 11:26:26 "},"chinese/android基础/android相关概念.html":{"url":"chinese/android基础/android相关概念.html","title":"android部分","keywords":"","body":"安卓基本概念 双缓冲 两个线程配合完成某一项工作，一个线程做A部分（例如绘制UI），另一个线程做B事情（例如读取资源，计算数据）。 常见的例子： 1、TCP数据传输， 数据的收发速度不一致可能导致数据的丢失。数据线发送到缓冲区中，然后从缓冲区中取走。有效地防止了数据的丢失。 2、复杂图像绘制过程中。 线程A将一帧的计算结果放在缓冲区中，线程中绘制完当前帧后就去缓冲区中取下一帧完整的绘制资源。 这样就可以避免画面闪烁结果。 很多图形的操作都很复杂需要大量的计算，很难访问一次显示缓冲区就能写入待显示的完整图形数据，通常需要多次访问显示缓冲区，每次访问时写入最新计算的图形数据。而这样造成的后果是一个需要复杂计算的图形，你看到的效果可能是一部分一部分地显示出来的，造成很大的闪烁不连贯。 throw new RuntimeException(\"Stub!\"); 代表没找到对应的android。下载对应版本的源码就可查看。 android内部API 有些类可以在源码中调用，但是在Androidstudio中找不到，是因为这是 内部API 不允许用户调用。 例如 com.android.internal.policy; 注意关键字“internal” 。 其中 PhoneWindow 就是一个私有API . 硬件加速 图形的绘制如果是 GPU处理的就是 硬件加速绘制，如果是 CPU 处理的 就是软件绘制。 硬件加速使用 GPU 进行View上的绘制操作。 硬件加速可以在以下四个级别开启或关闭： Application ： 为整个 APP开启 Activity： activity 范围 Window： window 范围 getWindow().setFlags( WindowManager.LayoutParams.FLAG_HARDWARE_ACCELERATED View： view 范围 oneView.setLayerType(View.LAYER_TYPE_SOFTWARE, null); 并非所有的2D绘图操作支持硬件加速。所以硬件加速的开关分为四个层次。 以下是已知不支持硬件加速的绘图操作(需要最新的请查阅官网) 支持硬件加速情况 Canvas 第一次支持 Paint 第一次支持 drawBitmapMesh() (colors array) 18 setAntiAlias() (for text) 18 drawPicture() 23 setAntiAlias() (for lines) 16 drawPosText() 16 setFilterBitmap() 17 drawTextOnPath() 16 setLinearText() ✗ drawVertices() ✗ setMaskFilter() ✗ setDrawFilter() 16 setPathEffect() (for lines) ✗ clipPath() 18 setRasterizer() ✗ clipRegion() 18 setShadowLayer() (other than text) ✗ clipRect(Region.Op.XOR) 18 setStrokeCap() (for lines) 18 clipRect(Region.Op.Difference) 18 setStrokeCap() (for points) 19 clipRect(Region.Op.ReverseDifference) 18 setSubpixelText() ✗ clipRect() with rotation/perspective 18 Xfermode 第一次支持 Shader 第一次支持 PorterDuff.Mode.DARKEN (framebuffer) ✗ ComposeShader inside ComposeShader ✗ PorterDuff.Mode.LIGHTEN (framebuffer) ✗ Same type shaders inside ComposeShader ✗ PorterDuff.Mode.OVERLAY (framebuffer) ✗ Local matrix on ComposeShader 18 Drawing operation to be scaled 第一次支持 drawText() 18 drawPosText() ✗ drawTextOnPath() ✗ Simple Shapes* 17 Complex Shapes* ✗ drawPath() ✗ Shadow layer ✗ 无版权 可以无限制使用！ all right reserved，powered by Gitbook该文件更新时间： 2020-12-17 14:30:59 "},"chinese/android基础/权限配置.html":{"url":"chinese/android基础/权限配置.html","title":"权限配置","keywords":"","body":"权限配置 动态权限申请第三方辅助工具 一般权限 这类权限一般不涉及用户隐私，是不需要用户进行授权的，比如手机震动、访问网络等 危险权限 1、需要用户授权。必须在Manifest中申明，否则申请时不提示用户，直接回调开发者权限会被拒绝。 2、同一个权限组的任何一个权限被授权了，这个权限组的其他权限也自动被授权。 3、申请某一个权限的时候系统弹出的Dialog是对整个权限组的说明，而不是单个权限。 4、Android 6.0开始需要动态权限申请 危险权限 含义 READ_CALENDAR WRITE_CALENDAR 日历 CAMERA 相机 READ_CONTACTS WRITE_CONTACTS GET_ACCOUNTS 联系人 ACCESS_FINE_LOCATION ACCESS_COARSE_LOCATION 位置 RECORD_AUDIO 麦克风 READ_PHONE_STATE CALL_PHONE READ_CALL_LOG WRITE_CALL_LOG ADD_VOICEMAIL USE_SIP PROCESS_OUTGOING_CALLS 手机 BODY_SENSORS 传感器 SEND_SMS RECEIVE_SMS READ_SMS RECEIVE_WAP_PUSH RECEIVE_MMS 短信 READ_EXTERNAL_STORAGE WRITE_EXTERNAL_STORAGE 存储 正常权限 含义 ACCESS_LOCATION_EXTRA_COMMANDS 访问额外的位置提供命令 ACCESS_NETWORK_STATE 访问有关GSM网络信息 ACCESS_NOTIFICATION_POLICY ？ ACCESS_WIFI_STATE 访问Wi-Fi网络状态信息 BLUETOOTH 连接到已配对的蓝牙设备 BLUETOOTH_ADMIN 允许程序发现和配对蓝牙设备 BROADCAST_STICKY 允许一个程序广播常用intents CHANGE_NETWORK_STATE 允许程序改变网络连接状态 CHANGE_WIFI_MULTICAST_STATE ？ CHANGE_WIFI_STATE 允许程序改变Wi-Fi连接状态 DISABLE_KEYGUARD 允许程序禁用键盘锁 EXPAND_STATUS_BAR 允许一个程序扩展收缩在状态栏 GET_PACKAGE_SIZE 允许一个程序获取任何package占用空间容量 INSTALL_SHORTCUT ？ INTERNET 允许程序打开网络套接字 KILL_BACKGROUND_PROCESSES ？ MODIFY_AUDIO_SETTINGS 　允许程序修改全局音频设置 NFC ？ READ_SYNC_SETTINGS 允许程序读取同步设置 READ_SYNC_STATS 　允许程序读取同步状态 RECEIVE_BOOT_COMPLETED 允许程序接收到 REORDER_TASKS 允许程序改变Z轴排列任务 REQUEST_INSTALL_PACKAGES ？ SET_ALARM ？ SET_TIME_ZONE 允许程序设置时间区域 SET_WALLPAPER 允许程序设置壁纸 SET_WALLPAPER_HINTS 允许程序设置壁纸hits TRANSMIT_IR ？ UNINSTALL_SHORTCUT ？ USE_FINGERPRINT ？ VIBRATE 允许访问振动设备 WAKE_LOCK ？ WRITE_SYNC_SETTINGS 允许程序写入同步设置 常用权限配置 无版权 可以无限制使用！ all right reserved，powered by Gitbook该文件更新时间： 2020-08-19 17:20:00 "},"chinese/android基础/android坐标体系.html":{"url":"chinese/android基础/android坐标体系.html","title":"android坐标体系","keywords":"","body":"屏幕坐标系 在Android系统中，屏幕的左上角是坐标系统的原点（0,0）坐标。 原点向右延伸是X轴正方向，原点向下延伸是Y轴正方向。       View坐标系 View坐标系以父视图的左上角为坐标原点。 getTop(); //获取子View左上角距父View顶部的距离 getLeft(); //获取子View左上角距父View左侧的距离 getBottom(); //获取子View右下角距父View顶部的距离 getRight(); //获取子View右下角距父View左侧的距离       //触摸点相对于其所在视图坐标的坐标 event.getX(); event.getY(); //触摸点相对于屏幕的坐标 event.getRawX(); event.getRawY(); 无版权 可以无限制使用！ all right reserved，powered by Gitbook该文件更新时间： 2020-08-19 17:20:00 "},"chinese/android基础/事件分发机制.html":{"url":"chinese/android基础/事件分发机制.html","title":"事件分发机制","keywords":"","body":"事件分发理解 一个事件包括三个部分： ACTION_DOWN 、ACTION_MOVE、ACTION_UP 。 如果事件被拦截了导致 ACTION_DOWN都没能接收到，后面两个步骤肯定是没有的。 事件类型 MotionEvent.ACTION_DOWN //按下View(所有事件的开始) MotionEvent.ACTION_UP //抬起View MotionEvent.ACTION_MOVE MotionEvent.ACTION_CANCEL // 非人为原因，事件取消 事件分发的主要对象 1、Activity 通过其他回调方法与Window、View交互 2、View 3、ViewGroup // (ViewGroup extends View) 跟事件相关的常用方法 // Activity dispatchTouchEvent(MotionEvent ev) // 当事件传递给当前对象时，最先被调用 onTouchEvent(MotionEvent event) // 被 dispatchTouchEvent 被调用 // View dispatchTouchEvent(MotionEvent ev) // 当事件传递给当前对象时，最先被调用 onTouchEvent(MotionEvent event) // 被 dispatchTouchEvent 被调用 //ViewGroup //(ViewGroup extends View) dispatchTouchEvent(MotionEvent ev) // 当事件传递给当前对象时，最先被调用 onTouchEvent(MotionEvent event) // 被 dispatchTouchEvent 被调用 onInterceptTouchEvent(MotionEvent ev) // 用来决定是否拦截事件。只有在ViewGroup才有这个方法。被 dispatchTouchEvent 调用。 事件分发、消费顺序 事件如果被上级拦截(return true)，下级就无法收到。 事件如果被下级消费掉(return true)，就不会继续往上传。 分发顺序 Activity –> 外层ViewGroup –> 内层ViewGroup –> View 消费顺序 View –> 内层ViewGroup –> 外层ViewGroup –> Activity Activity事件分发详情 事件开始 --> Activity.dispatchTouchEvent{ getWindow().superDispatchTouchEvent(ev) } --> PhoneWindow(Window).superDispatchTouchEvent{ return mDecor.superDispatchTouchEvent(event) } --> DecorView(FrameLayout).superDispatchTouchEvent{ return super.dispatchTrackballEvent(event) // super是ViewGroup，所以Activity 跟Goup连接起来了 } --> 如果ViewGroup把事件消耗掉，返回true ，Activity的dispatchTouchEvent 就直接返回true ，事件结束。 否则就去调用Activity的onTouchEvent ，然后事件结束。 View事件分发详情 dispatchTouchEvent( ) --> onTouch (setOnTouchListener) 如果onTouch消耗掉事件，返回true --> 事件结束 如果onTouch 不处理事件，返回 false --> onTouchEvent --> performClick --> onClick(setOnClickListener)--> 事件结束 ViewGroup事件分发详情 dispatchTouchEvent() --> onInterceptTouchEvent() --> ... 事件分发图解 无版权 可以无限制使用！ all right reserved，powered by Gitbook该文件更新时间： 2020-09-10 10:53:57 "},"chinese/android基础/view的加载流程-原理.html":{"url":"chinese/android基础/view的加载流程-原理.html","title":"view的加载流程-原理","keywords":"","body":"Activity.java Activity是通过Window间接的操纵View实例。      Window.java、PhoneWindow.java Window是抽象类。PhoneWindow是Window的唯一实现类， 主要是为View提供展示策略，比如标题栏，默认背景颜色等。      DecorView.java 继承自FramentLayout 。 DecorView为整个Window界面的最顶层View。 用 Hierarchy Viewer这个工具查看DecorView的布局，发现继承自Activity和AppCompatActivity后的结构是不一样的。如果选用的主题不一样，结构也会不一样。具体结构请自行用工具查看分析。 但是我们自己添加的布局一般都是加载到 id/content的ViewGroup中去了。      ViewRootImpl.java 作为DecorView和WindowManager之间的桥梁。      WindowManager.java 管理Window。      WindowManagerService.java android的窗口管理服务      Activity、Window、DecorView的关系 Activity中包含一个Window ,Window中包含一个DecorView . MainActivity.this.getWindow() .getDecorView();      setContentView()后的加载流程 一路追踪源码，发现用户的view是被添加到mContentParent中。 ViewGroup mContentParent = generateLayout(mDecor); ViewGroup contentParent = (ViewGroup)findViewById(ID_ANDROID_CONTENT); public static final int ID_ANDROID_CONTENT = com.android.internal.R.id.content; 无版权 可以无限制使用！ all right reserved，powered by Gitbook该文件更新时间： 2020-08-19 17:20:00 "},"chinese/android基础/自定义控件.html":{"url":"chinese/android基础/自定义控件.html","title":"自定义控件","keywords":"","body":"自定义控件 自定义View的意义 1、实现基础控件无法做到的特效。 2、代码封装后方便给其他成员共用，无需重复造轮子。 3、将控件的内部逻辑封装在自定义View中，便于应用内解耦 Android自定义View类型 1、组合控件 将基础控件(TextView、ProgressBar等)组合而成，比如下拉刷新控件等。 2、完全自定义控件 继承 View(UI在主线程中绘制)、ViewGroup 等顶级控件或 SurfaceView 特定控件。 难点在于程序的设计、事件传递处理、效率优化。 SurfaceView extends View ，但是是一个比较特殊的系统控件。UI在一个子线程中进行绘制。 常用的相关方法 measure() // 测量入口 ，一般不用重写。 public final void measure(int widthMeasureSpec, int heightMeasureSpec){ } onMeasure() 测量View与Child View的大小。 protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) { //MeasureSpec 通过一个int数值(widthMeasureSpec、heightMeasureSpec)计算“模式”和“大小”， // 前2位表示“大小的模式” ，后30bit表示 “尺寸大小” int widthMode=MeasureSpec.getMode(widthMeasureSpec); int widthSize=MeasureSpec.getSize(widthMeasureSpec); int heighMode=MeasureSpec.getMode(heightMeasureSpec); int heighSize=MeasureSpec.getSize(heightMeasureSpec); int mesW= widthMode==MeasureSpec.EXACTLY ? widthSize: dip2px(getContext(),100); int mesH =heighMode==MeasureSpec.EXACTLY ? heighSize : (int) (mesW*ratio) ; setMeasuredDimension(mesW,mesH); // 使得测量结果生效 } //MeasureSpec.EXACTLY 用的较多。 父容器已经检测出子View所需要的精确大小。在该模式下，View的测量大小即为 SpecSize 。 //MeasureSpec.UNSPECIFIED 父容器未能检测出子View所需要的精确大小，但是指定了一个可用大小即specSize 在该模式下，View的测量大小不能超过SpecSize。用得少。 //MeasureSpec.AT_MOST 父容器不对子View的大小做限制 。用得少。 onSizeChanged() 该方法在当前View尺寸变化时被调用 。可以在这里重新获取view的长宽等参数。 protected void onSizeChanged(int w, int h, int oldw, int oldh) { super.onSizeChanged(w, h, oldw, oldh); if (w != oldw || h != oldh) { mHeight = h; mMaxOverScrollDistance = w / 2.f; } } onLayout() 一般用来 放置子View的位置。在ViewGroup中是abstract,所以必须重写。 在View中是空函数，一般不用重写。 protected void onLayout(boolean boo, int l, int t, int r, int b) { for (int j=0;j layout() 确定View自己的位置。 ViewGroup中的 是 final void layout ，不能重写。 View中 public void layout ，可以重写。但是一般不重写。在 父容器中直接让子View直接调用即可。 for (int j=0;j onDraw() 绘制View自己 。这个相信大家都很熟悉了，不多讲解。 dispatchDraw() 绘制子View。 View 没有重写 dispatchDraw的必要。 ViewGroup 貌似一般也不用重写 dispatchDraw ，只是在合适的地方调用一下自己的这个方法，使得自己的子View都去重新绘制。 invalidate() 、postInvalidate() 都是用于刷新界面。 invalidate 在UI线程调用。 postInvalidate 在非UI线程调用，将非UI线程切换到UI线程，最后也是调用invalidate 。 requestLayout() 会导致调用 measure()过程 和 layout()过程， 将会根据标志位判断是否需要 onDraw。 invalidate 会导致调用 onDraw 。 所以一般而言，如果是绘制内容变了就调用 invalidate ， 如果是位置变了就调用 requestLayout 。 setWillNotDraw( ) setWillNotDraw(true) // 设置后 就不会调用 onDraw() 。一般用来优化GroupView View中默认设置为false ,ViewGroup默认设置为true 。 view自定义属性 通过定义属性，使得开发者可以在xml中对控件进行一些参数配置。 不过，我不喜欢这种方式，我习惯在代码中配置。 实例讲解 瀑布流实现思路 将手机屏幕分成N块 ， 每当需要添加一张图片时，会将这张图片的宽度压缩成和列一样宽，再按照同样的压缩比例对图片的高度进行压缩， 然后在这三列中找出当前高度最小的一列，将图片添加到这一列中。 之后每当需要添加一张新图片时，都去重复上面的操作，就会形成瀑布流格局的照片墙。 然后解决下内存溢出问题。 LayoutInflater 它的作用类似于 findViewById(),不同点是LayoutInflater是用来找layout下xml布局文件，并且实例化！ 而findViewById()是找具体xml下的具体 widget控件。 LayoutInflater inflater1 = activity.getLayoutInflater(); LayoutInflater inflater2 = LayoutInflater.from(this); LayoutInflater inflater3 = (LayoutInflater)activity.getSystemService(LAYOUT_INFLATER_SERVICE); // XmlPullParser parser, ViewGroup root, boolean attachToRoot // 参数意义：parser :R.layout.abc , root :root布局 attachToRoot :是否加到root布局中 View itemView=inflater1.inflate(R.layout.abc, null); 注意： 通过 inflate 获得的view 是获取到的长宽都是为0 。 // itemView.getWidth() 、itemView.getHeight() 都会为0 为了能获得长宽，我目前采用的是如下方式 ： 将这个布局放到启动页下 ，通过 findViewById 的方式获取到后 保存起来给其他用 。 无版权 可以无限制使用！ all right reserved，powered by Gitbook该文件更新时间： 2020-09-24 11:46:12 "},"chinese/android基础/进程通信.html":{"url":"chinese/android基础/进程通信.html","title":"进程通信","keywords":"","body":"多进程通信 进程通信、多进程通信、 进程间通信 进程和线程的区别 一个程序至少有一个进程,一个进程至少有一个线程。 区别的本质 : 操作系统对他们的调度和资源分配不同。 从逻辑角度来看，多线程的意义在于一个应用程序中，有多个执行部分可以同时执行。 但操作系统并没有将多个线程看做多个独立的应用来实现进程的调度和管理以及资源分配。 进程是具有一定独立功能的程序关于某个数据集合上的一次运行活动,进程是系统进行资源分配和调度的一个独立单位。 进程在执行过程中拥有独立的内存单元，而多个线程共享内存，从而极大地提高了程序的运行效率。 进程和线程的主要差别在于它们是不同的操作系统资源管理方式。 进程有独立的地址空间，一个进程崩溃后，在保护模式下不会对其它进程产生影响。 所以多进程的程序要比多线程的程序健壮，但在进程切换时，耗费资源较大，效率要差一些。 dvm指dalivk的虚拟。每一个Android应用程序都在它自己的进程中运行,都拥有一个独立的 Dalvik虚拟机实例。 而每一个DVM都是在Linux 中的一个进程,所以说可以认为是同一个概念. 进程级别 、进程优先级 前台进程 > 可见进程 > 服务进程 > 后台进程 > 空进程 // 前台进程 正在与用户交互的进程。 //可见进程 可以被看见，但是并没有正在交互。 例如你的　activity　被一个悬浮窗或者系统弹窗挡住部分了。 // 服务进程 例如 下载进程、音乐播放进程 // 后台进程 例如　按下 Home 键 进入了后台。 // 空进程; 只是出于缓存的目的而被保留,为了更加有效地使用内存而不是完全释放掉 ， 只要系统需要可以随时杀掉它们。 如何提高进程优先级 我们并不能直接指定 XX进程是 前台进程 或可见进程。而是由系统来判断决定的。 我们只能尽可能地让进程的优先级可能高一点。这就是 “进程保活” 的话题了。 例如 指定优先级 多进程的使用场景 1、将核心模块跑在一个进程中， 降低被系统kill的概率。 2、android系统的内存限制是针对进程的，多开几个进程 可以获得更多的内存。 3、模块化开发，子进程中崩溃并不会导致主进程崩溃。提高程序的健壮性 。 4、需要调用其他应用提供的数据。 APP使用多进程带来的不良影响 因为多进程导致多个虚拟机，会导致以下问题出现： 1、静态成员和单例模式完全失效 。 2、线程同步机制完全失效。 3、SharedPreferences 的可靠性下降 ，这是因为 Sp 不支持两个进程并发进行读写， 有一定几率导致数据丢失。 4、 Application 会多次创建。 Android 系统在创建新的进程时会分配独立的虚拟机， 所以这个过程其实就是启动一个应用的过程， 自然也会创建新的Application。 5、进程间传递的信息要么是 基本数据类型 ，要么就必须能被序列化 。 android 进程间通信方案 1、 Intent + Bundle 同一个app中的不同进程单向通信。一般用于四大组件中。 2、socket socket都可以实现网络通信，那么实现跨进程通信自然是ok的。开销大。 3、通过文件 不同的进程通过对同一个文件进行读写来实现信息交互。 4、ContentProvider 基于 Binder的 ContentProvider 可以让 一个应用向其他应用暴露接口，提供数据。 5、BroadcastReceiver 通过广播播放实现单方面通知。 6、android.os.Messenger 基于AIDL。串行通信。 一个 server 运行在一个 apk 中 ， 另一个apk 绑定服务，发送和接收信息。 7、AIDL 和 Binder 支持并发交互。 相关术语 RPC Remote Procedure Call Protocol， 远程过程调用协议 。 IPC inter process communication ，多进程通信的过程。 oom_adj 对于每一类别的进程会有其oom_adj值的取值范围。在系统执行低杀操作时，会从oom_adj值越高的开始杀。 Binder Binder是一种用来实现进程间通信的架构。 Android基于Linux的， Linux 现有的进程通信手段有以下几种： 1、管道 ; 2、消息队列; 3、共享内存; 4、套接字; 5、信号量。 既然安卓因为基于Linux，已经拥有这么多的IPC通信方案了，为什么还要引入Binder方案呢。 注：( Binder 不是Android提出来的一套新的进程间通信机制，它是基于OpenBinder实现的。) 这是主要从以下几个原因考虑的： 1、效率。 // 对于消息队列、 Socket 和 管道来说， 数据先从发送方的缓存区拷贝到内核开辟的缓存区中，再从内 核缓存区拷贝到接收方的缓存区， 一共两次拷贝。 2、稳定性 。 // 因为共享内存需要处理并发同步问题， 容易出现死锁和资源竞争， 稳定性较差。 3、安全性。 // 传统 Linux IPC 的接收方无法获得对方进程可靠的 UID/PID，从而无法鉴别对方身份。 Binder是一种架构(定义了一种通信机制)， 这种架构提供了服务端接口、Binder驱动、客户端接口三个模块。 Binder使用Client-Server通信方式，安全性好，简单高效，再加上其面向对象的设计思想， 独特的接收缓存管理和线程池管理方式，成为Android进程间通信的中流砥柱。 Binder 通信原理概略 因为安全机制， 一个进程不能直接操作或者访问另一个进程，只能通过IPC方案进行访问。 // 基本原理 Linux系统将一个进程分为用户空间和内核空间。 对于进程之间来说， 用户空间的数据不可共享， 内核空间的数据可共享。 用户空间可以通过系统回调与内核空间通信。 如果在内核空间中有一个模块，能够完成数据的转发，就实现了跨进程通信。 Binder的通信模型有4个角色： 1、Binder Client // 使用数据 ，进程A。 2、Binder Server // 提供数据，进程B。 3、Binder Driver // Binder驱动，将数据从进程B的用户空间中拷贝到进程A的用户空间。 4、ServiceManager // 管理数据查询和注册。 进程C 。 AIDL Android Interface definition language ， 是一种android内部进程通信接口的描述语言。用来定义进程间的通信接口。 当作为客户的一方和要和作为服务器的一方进行通信时，需要指定一些双方都认可的接口， 这样才能顺利地进行通信。而AIDL就是定义这些接口的一种工具。 为什么要借助AIDL来定义，而不直接编写接口呢（比如直接通过Java定义一个Interface）？ 里涉及到IPC的问题。 在Android平台下,各个进程都占有一块自己独有的内存空间， 各个进程在通常情况下只能访问自己的独有的内存空间，而不能对别的进程的内存空间进行访问。 进程之间如果要进行通信，就必须先把需要传递的对象分解成操作系统能够理解的基本类型， 并根据你的需要封装跨边界的对象。而要完成这些封装工作，需要写的代码量十分地冗长而枯燥。 因此Android提供了AIDL来帮助你完成这些工作。 AIDL 支持的数据类型 1、Java 的基本数据类型 2、List 和 Map 元素必须是 AIDL 支持的数据类型 Server 端具体的类里则必须是 ArrayList 或者 HashMap 3、其他 AIDL 生成的接口 4、实现 Parcelable 的实体 aidl in out // 一般而言，客户端是调用接口， 服务端是服务实现 in 表示数据只能由接口的调用进程流向接口的实现进程， out 表示数据只能由接口的实现进程流向接口的调用进程， inout 则表示数据可在接口的调用进程与实现进程之间双向流通。 AIDL 实例Demo 代码下载： https://gitee.com/hnyer/aidl-demo 1、ERROR: Process 'command 'F:\\sdk2\\build-tools\\30.0.1\\aidl.exe'' finished with non-zero exit value -1073741701 原因是： buildToolsVersion 可能不兼容，尝试改一下 版本号。 //buildToolsVersion \"30.0.1\" //编译不过 buildToolsVersion \"29.0.1\" // 编译ok XXX bookManager = XXX.Stub.asInterface(service); // 根据server 获取在aidl中的自定义接口 XX.asBinder().isBinderAlive() // isBinderAlive ，判断binder是否还存在 xx.asBinder().isBinderAlive() // asBinder ,根据自定义 aidl接口获得 binder对象 // CopyOnWriteArrayList 一个系统类，只有写入和写入之间需要进行同步等待。 但是有不少缺点：一是内存占用问题，毕竟每次执行写操作都要将原容器拷贝一份，数据量大时，对内存压力较大 ； 二是无法保证实时性，由于其实现策略的原因，写和读分别作用在新老不同容器上， 在写操作执行过程中，读不会阻塞但读取到的却是老容器的数据。 // RemoteCallbackList 用来存储监听接口。本质是一个 ArrayMap，内部自动实现了线程同步的功能。 xx.getBroadcastItem(i) // 根据索引获取接口 xx.beginBroadcast() // 获取接口个数。beginBroadcast 必须与 finishBroadcast 配对使用 xx.finishBroadcast() xx.register() //添加接口 xx.unregister() // 移除接口 // IBinder.DeathRecipient unlinkToDeath() // 服务端监听客户端进程是否挂掉 // 启动方式 因为 startService 方式不能获得service的方法，所以不能不能拿到AIDL定义的接口，无法双向通信。 所以只能用 bindService 方式，根据 ServiceConnection 获得接口。 无版权 可以无限制使用！ all right reserved，powered by Gitbook该文件更新时间： 2020-12-22 08:58:44 "},"chinese/android基础/Binder详解.html":{"url":"chinese/android基础/Binder详解.html","title":"Binder详解","keywords":"","body":"Binder详解 从英文字面上意思看， Binder 具有粘结剂的意思，那么它把什么东西粘结在一起呢？在Android系统的Binder机制中，Binder由 Client、Server、Service Manager和Binder驱动组成。Binder就是一种把这四个组件粘合在一起的粘结剂了。 为什么要采用Binder Linux已经有多种跨进程通信方式，Android为何还要采用Binder？ 因为 更高效、更安全。 方式 缺点 优点 数据拷贝次数 共享内存 控制机制复杂 0 Binder 可以建立私有通道、有UID鉴别身份 1 socket 开销大、效率低 2 管道、消息队列 效率低 2 Binder 通信采用 C/S架构。 Binder框架定义了四个角色：Server、Client、ServiceManager 、驱动。 这四个角色的关系和互联网类似：Server是服务器，Client是客户终端，SMgr是域名服务器（DNS），驱动是路由器。 1、BinderDriver 尽管名叫“驱动”实际上和硬件设备没有任何关系，存在于内核空间中。 Android系统已经实现。 2、ServerManager 提供了查询服务和注册服务的功能。 Android系统已经实现。 Service Manager是一个守护进程。 3、BinderClient 调用其他进程中的相关服务。由开发者实现。 4、Binder Server 提供相关的服务。由开发者实现。 关键类、方法 1、Native端： IBinder 、 BBinder 、 BpBinder 、 IPCThread 、 ProcessState、 IInterface 、JavaBBinder jni端： android_util_Binder.cpp 、 2、Java端： IBinder 、 Binder、 BinderProxy （Binder的一个内部类）、 Stub、 Proxy 、ServiceManager（Java源码 被@hide了） 3、Binder Driver 端： binder_proc、 binder_thread、 binder_node 、ioctl（是一个函数） 关键名词 实名Binder 注册了名字的Binder。 Binder实体 Binder实体实际上是binder_node结构体的对象。 Binder引用 每一个Binder引用都是某一个Binder实体的引用。 0号引用 我们可能会发现一个细节：SMgr是一个进程，Server是另一个进程，Server向SMgr注册Binder必然会涉及进程间通信。当前实现的是进程间通信却又要用到进程间通信，这就好象蛋可以孵出鸡前提却是要找只鸡来孵蛋。 Binder的实现比较巧妙：预先创造一只鸡来孵蛋：系统给Smgr创建一个特殊专门的Binder实体。 它没有名字也不需要注册。一个Server若要向SMgr注册自己Binder就必需通过0这个引用号和SMgr的Binder通信。类比网络通信，0号引用就好比域名服务器的地址。 匿名 Binder Server端可以通过已经建立（通过实名Binder实现）的Binder连接将创建的Binder实体传给Client 。由于这个Binder没有向SMgr注册名字，所以是个匿名Binder。 匿名Binder为通信双方建立一条私密通道，只要Server没有把匿名Binder发给别的进程，别的进程就无法通过穷举或猜测等任何方式获得该Binder的引用。 为什么Binder只进行了一次数据拷贝？ mmap()分配的内存除了映射进了接收方进程里，还映射进了内核空间。所以调用copy_from_user()将数据拷贝进内核空间也相当于拷贝进了接收方的用户空间 。 数据从发送方的缓存区拷贝到内核的缓存区，而接收方的缓存区与内核的缓存区被是映射到同一块物理地址的，因此只需要一次拷贝即可。 先把数据拷贝到内核的缓存区，然后再从内核的缓存区拷贝给接收方。这样做会产生两次数据的拷贝。linux中的管道通信就是采取这种方式。 简单理解                   Binder 通信模型、 Binder 架构       Binder 机制 Binder 驱动       Binder 进程与线程       ServiceManager启动       ServiceManager 注册服务       ServiceManager 获取服务       进行一次完整通讯 Binder通信命令字 命令 含义 说明 BINDER_WRITE_READ 该命令向Binder写入或读取数据 常用的命令 BINDER_SET_MAX_THREADS 该命令告知Binder驱动接收方线程池中最大的线程数 - BINDER_SET_CONTEXT_MGR 将当前进程注册为SMgr。 - BINDER_THREAD_EXIT 通知Binder驱动当前线程退出了。 - BINDER_VERSION 获得Binder驱动的版本号 - Binder写操作命令字 命令 含义 说明 BC_TRANSACTION Client向Server发送请求数据 最常用 BC_REPLY Server向Client发送回复数据 最常用 BC_ACQUIRE_RESULT、 BC_ATTEMPT_ACQUIRE 尚未实现 BC_FREE_BUFFER 释放一块映射的内存 BC_INCREFS、BC_ACQUIRE 、BC_RELEASE 、BC_DECREFS 增加或减少Binder的引用计数 BC_INCREFS_DONE 、BC_ACQUIRE_DONE 处理完毕反馈信息 BC_REGISTER_LOOPER 通知驱动线程池中一个线程已经创建了 BC_ENTER_LOOPER 通知驱动该线程已经进入主循环，可以接收数据 BC_EXIT_LOOPER 通知驱动该线程退出主循环，不再接收数据 BC_REQUEST_DEATH_NOTIFICATION 要求驱动在Binder实体销毁得到通知 BC_DEAD_BINDER_DONE 收到销毁通知的进程在删除引用后用本命令告知驱动 Binder读操作命令字 命令 含义 说明 BR_ERROR 发生内部错误 BR_OK 、BR_NOOP 操作完成 BR_SPAWN_LOOPER 向接收方发送该命令要求创建更多线程以备接收数据 BR_TRANSACTION 、BR_REPLY 表示当前接收的数据是请求还是回复 BR_ACQUIRE_RESULT 、BR_ATTEMPT_ACQUIRE 、BR_FINISHED 尚未实现 BR_DEAD_REPLY 交互过程中如果发现对方进程或线程已经死亡则返回该消息 BR_TRANSACTION_COMPLETE 发送数据包后，收到该消息做为成功发送的反馈 BR_INCREFS 、BR_ACQUIRE 、BR_RELEASE 、BR_DECREFS 用于管理强/弱指针的引用计数 BR_DEAD_BINDER 、BR_CLEAR_DEATH_NOTIFICATION_DONE 收到死亡通知书 BR_FAILED_REPLY 如果发送非法引用号则返回该消息 Binder接收/发送数据包的标准格式 成员 含义 说明 union {     size_t handle;void *ptr;} target; 指明发送目的地 void *cookie; 存放的是创建Binder实体时由该接收方自定义的任意数值，做为与Binder指针相关的额外信息存放在驱动中。 unsigned int code; 存放收发双方约定的命令码 unsigned int flags; 与交互相关的标志位 pid_t sender_pid;、uid_t sender_euid; 该成员存放发送方的进程ID和用户ID，由驱动负责填入 size_t data_size; 缓冲区存放的数据长度。 size_t offsets_size; 偏移位置 union { struct { const void buffer; const void offsets; } ptr; uint8_t buf[8]; } data; 放要发送或接收到的数据, 无版权 可以无限制使用！ all right reserved，powered by Gitbook该文件更新时间： 2020-08-19 17:20:00 "},"chinese/android基础/BroadcastReceiver.html":{"url":"chinese/android基础/BroadcastReceiver.html","title":"BroadcastReceiver 广播","keywords":"","body":"BroadcastReceiver 广播 Service 向activity中传递数据，更新UI时不太方便，此时可以使用广播来实现。 // 在 Service 中发送广播 Intent intent = new Intent(); intent.setAction( MyConfig.KEY_BROADCAST_ACTIONFLAG ); intent.putExtra(MyConfig.KEY_BROADCAST_MSG,msg); service.sendBroadcast(intent); // 定义广播，并传入一个接口，方便回调给activity public class BroadcastReceiver extends BroadcastReceiver { private MsgCallBack msgCallBack ; public BroadcastReceiver(MsgCallBack msgCallBack){ this.msgCallBack =msgCallBack; } @Override public void onReceive(Context context, Intent intent) { String msg = intent.getStringExtra( MyConfig.KEY_BROADCAST_MSG); msgCallBack.onGetMsg(msg); } } // activity中注册广播 IntentFilter intentFilter = new IntentFilter(); intentFilter.addAction(MyConfig.KEY_BROADCAST_ACTIONFLAG); broadcastReceiver = new BroadcastReceiver(msgCallBack); registerReceiver(broadcastReceiver, intentFilter); // 解绑广播 unregisterReceiver(broadcastReceiver); // 在回调接口中更新UI @Override public void onGetMsg(final String msg) { ((Activity)context).runOnUiThread(new Runnable() { @Override public void run() { showInfoTv.setText(msg); } }); } 无版权 可以无限制使用！ all right reserved，powered by Gitbook该文件更新时间： 2020-09-17 11:33:08 "},"chinese/android基础/Service服务.html":{"url":"chinese/android基础/Service服务.html","title":"Service 服务","keywords":"","body":"Service 服务 Service 是运行在主线程中的， 所以 Service 处理不当 也是会引起 ANR 的。 如果有耗时操作在Service里，就必须用子线程处理 。 Service的意义 1、优先级高，不容易被系统杀死。用来实现需要稳定、长时间运行的模块。 (Service的优先级高于后台挂起的Activity， 也高于Activity所创建的Thread) 2、用在一些不适合activity的的场景。例如音乐播放和文件下载等场景 。 Service 启动方式 因为 startService 方式不能获得service的方法，所以不能不能拿到AIDL定义的接口，无法双向通信。 所以aidl中只能用 bindService 方式，根据 ServiceConnection 获得接口。 start模式 一旦启动，Service将一直运行在后台，即便启动Service的组件已被destroy。 Intent intent = new Intent(this, MyNormalService.class); startService(intent);//启动服务 stopService(intent) ;//停止服务 //或在服务类中 调用 stopSelf(); bind模式 通过绑定方式启动的Service是一个client-server结构。 多个组件可与一个service绑定，service不再与任何组件绑定时，该service会被destroy。 Intent intent = new Intent(MainActivity.this, MyNormalService.class) ; this.bindService( intent, serviceConnection , BIND_AUTO_CREATE ); // 绑定 this.unbindService(serviceConnection); // 解绑 // 启动远程service ,比如aidl通信时，service不在同一个APP。 Intent intent=new Intent(); intent.setAction(\"com.remoteService.test\"); //用来识别service的标记 intent.setPackage(\"com.wk.iadlservice\"); // 服务所在的应用id bindService(intent, mConnection, Context.BIND_AUTO_CREATE); ServiceConnection serviceConnection = new ServiceConnection(){ @Override public void onServiceConnected(ComponentName name, IBinder service) { MyNormalService.MyBinder myBinder = (MyNormalService.MyBinder) service ; myBinder.func1();//调用自定义Binder中的方法 } @Override public void onServiceDisconnected(ComponentName name) { } } ; //MyNormalService.java @Override public IBinder onBind(Intent intent){ return new MyBinder(); } class MyBinder extends Binder{ public void func1(){ ... } } public class MyNormalService extends Service{ // 通过start方式启动 时回调的方法 @Override public IBinder onBind(Intent intent){ .... } // 通过bind方式启动 回调的方法 @Override public int onStartCommand(Intent intent, int flags, int startId){ ... } } bindService( , ,) bindService( , , int flags ) flags 含义 BIND_AUTO_CREATE //若绑定服务时服务未启动，则会自动启动服务。 BIND_DEBUG_UNBIND // 使用此标志绑定服务之后的unBindService 方法会无效。 这种方法会引起内存泄露，建议只在调试时使用。 BIND_NOT_FOREGROUND // 被绑定的服务进程优先级不允许被提到 FOREGROUND 级别 BIND_ABOVE_CLIENT // 如果当绑定服务期间遇到OOM需要杀死进程，客户进程会先于服务进程被杀死。 BIND_WAIVE_PRIORITY // 被绑定的服务进程不会被OOM列入猎杀对象中。 service 生命周期 // 手动调用方法 startService() stopService() bindService() unbindService() // 内部自动调用的方法 onCreat() onStartCommand() 开始服务 onDestroy() onBind() onUnbind() onStartCommand() 默认情况下， onStartCommand 返回值 START_STICKY_COMPATIBILITY 或 START_STICKY 。 1、START_STICKY // 会重启服务，可能会传递null的intent。 如果Service所在的进程，在执行了onStartCommand方法后，被清理了， 那么这个Service会被保留在已开始的状态，但是不保留传入的Intent， 随后系统会尝试重新创建此Service，由于服务状态保留在已开始状态， 所以创建服务后一定会调用onStartCommand方法。 如果在此期间没有任何启动命令被传递到service，那么参数Intent将为null，需要我们小心处理。 2、START_NOT_STICKY // 不会重启服务。这是最安全的选项 如果Service所在的进程，在执行了onStartCommand方法后，被清理了，则系统不会重新启动此Service。 3、START_REDELIVER_INTENT // 会重启服务。传入最后一个intent 。 如果系统在 onStartCommand() 返回后终止服务，则会重建服务，并通过 传递给服务的最后一个 Intent。 4、START_STICKY_COMPATIBILITY // 是START_STICKY 的兼容版本，但是不能保证被清理后 onStartCommand方法一定会被重新调用。 前台服务、后台服务 // 1、前台服务 前台服务必须给状态栏提供一个通知 。 系统内存不足的时候不允许系统杀死的服务。 // 参数一：唯一的通知标识；参数二：通知消息。 xx.startForeground(12345, notification);// 开始前台服务 xx.stopForeground(true);// 停止前台服务--参数：表示是否移除之前的通知 IntentService 1、public abstract class IntentService extends Service.. 2、HandlerThread thread = new HandlerThread(\"IntentService[\" + mName + \"]\").. 3、mServiceHandler = new ServiceHandler(mServiceLooper).. 1、内部已经采用了独立的子线程处理问题。无需手动开启子线程。 2、内部采用队列处理问题。 不用考虑多线程并发问题。 3、任务结束后会自动停止。无需手动调用停止代码。 解决Service内存泄漏问题。 Service 和 Activity 通信 1、bindService 启动的服务 通过 ServiceConnection 拿到 service的引用，给它发送数据。 activity - > service 通过发送广播，广播在通过回调接口 把消息传给 activity 。 service -> activity 2、startService 启动的服务 eventbus等第三方库 实现 activity - > service 。 // 如果不用第三方库 怎么实现？ 通过广播 发消息给activity 。 service -> activity 无版权 可以无限制使用！ all right reserved，powered by Gitbook该文件更新时间： 2020-12-18 09:05:23 "},"chinese/android基础/Handler详解.html":{"url":"chinese/android基础/Handler详解.html","title":"Handle详解","keywords":"","body":"Handle、Looper 、Message、MessageQueue 模型 简单的说：一个线程开启一个无限循环模式，不断遍历自己的消息列表，如果有消息就挨个拿出来做处理，如果列表没消息，自己就堵塞（相当于wait，让出cpu资源给其他线程），其他线程如果想让该线程做什么事，就往该线程的消息队列插入消息，该线程会不断从队列里拿出消息做处理。 Looper.prepare() --> sThreadLocal.set(new Looper(quitAllowed)); Looper.loop() // 记住这点就不会弄错执行线程的问题 handleMessage 最终在哪个线程执行 , 要看 Looper 是由哪个 线程创建的。 Message 定义了消息必要的描述和属性数据。 public final class Message implements Parcelable{ public int what;//用来标识一个消息.区分来源 public int arg1; //简单消息 public int arg2; public Object obj; //任意类型数据 public Messenger replyTo; Bundle data;//存储复杂点的对象 Handler target;//发送和处理消息关联的 Handler Runnable callback; //消息的回调 ...... } // 获取 Message 的方式 Message message ; message= new Message(); // Return a new Message instance from the global pool. // Allows us to avoid allocating new objects in many cases. message= Message.obtain(); message= Message.obtain( message ) ; message= Message.obtain( handler ) ; message= Message.obtain( handler, what) ; message= Message.obtain( handler ,runnable) ; // 效果跟 Message.obtain( handler ) 一样 ，因为最终也是执行到了 Message.obtain( handler ) message= handler.obtainMessage(); message= handler.obtainMessage( what); MessageQueue 消息队列 ,提供入队、出队等功能。系统只会自动给主线程建立 MessageQueue。 (子线程也可以有 MessageQueue，只是需要调用 Looper.prepare(); ) boolean enqueueMessage(Message msg, long when) Message next() Handle 负责 Message 的发送和执行处理等。 handler.post(runnable) ; handler.postAtTime(runnable ,0) ; handler.postDelayed( runnable ,0) ; handler.sendMessage(message); handler.sendEmptyMessage( 1 ); handler.sendMessageDelayed(message, 0); // 以上 6个函数 都最后会 被执行到 sendMessageAtTime() handler.sendMessageAtTime(message ,0) ; // 插入到消息队列最前面 handler.postAtFrontOfQueue(runnable) ; Looper 循环器，扮演 MessageQueue 和 Handler 之间桥梁的角色，循环取出 MessageQueue 里面的Message，并交付给 Handler 进行处理。 Looper 在prepare中通过ThreadLocal保证了每个线程Looper对象的唯一性， 对于每个线程，有唯一的Looper对象和MessageQueue队列。 loop() 中有一个死循环 for (;;) ，会不断调用 MessageQueue 的next()，当有消息就处理，否则就阻塞等待。 Looper.loop(); // 死循环 判断是否有需要处理的 Message public static void loop(){ final Looper me = myLooper(); final MessageQueue queue = me.mQueue; for (;;) { Message msg = queue.next(); //如果没有消息则阻塞。 msg.target.dispatchMessage(msg); //将消息进行分发 处理 } } HandlerThread HandlerThread extends Thread.. HandlerThread 是一个内部实现了 Looper循环的线程 。 Android中多线程的场景很多，为了解决多线程问题，Android提供了很多方案。 线程池整体量级有些偏重， HandlerThread 是一种轻量的多线程解决方案。 mHandler = new Handler( mHandlerThread.getLooper()){ public void handleMessage(Message msg){ // 这里是子线程 ，可以执行耗时操作 activity.runOnUiThread(new Runnable() { @Override public void run() { // 这里是主线程 } }); } }; mHandler.sendEmptyMessage(MSG_UPDATE_INFO); mHandler.removeMessages(MSG_UPDATE_INFO); mHandlerThread.quit(); ThreadLocal 从ThreadLocal这个名字看，它带着浓浓的“本地线程”的味道； 其实 ThreadLocal并不是用来操作什么本地线程而是用于实现不同线程的数据副本。 每一个线程都可以独立地改变自己的副本并且不会影响其它线程所持有的对应的副本。 在 Looper.java 中 有使用到 ThreadLocal 的这特性。 static final ThreadLocal sThreadLocal = new ThreadLocal(); //将新创建的对象的引用保存到各线程的自己的一个map中 sThreadLocal.set(new Looper(quitAllowed)); public static Looper myLooper() { // 各线程从自己的map中取出放进去的对象， // 因此取出来的是各自自己线程中的对象 ,使得每个 thread 都有自己独立的 handle return sThreadLocal.get(); } 一个线程有几个Looper 因为在调用 Looper.prepare() 给当前线程新建 Looper 时有判断 , 所以 只能有一个 Looper private static void prepare(boolean quitAllowed){ if (sThreadLocal.get() != null) { throw new RuntimeException(\"Only one Looper may be created per thread\"); } sThreadLocal.set(new Looper(quitAllowed)); } 判断是否是主线程 通过判断两个线程的 Looper 是否是同一个。 return Looper.myLooper() == Looper.getMainLooper(); Can't create handler inside thread that has not called Looper.prepare() 在子线程中 直接调用 Handler handler=new Handler() ,会提示这个错误。 因为 在 Handle 的构造函数中 对 Looper 进行检查 mLooper = Looper.myLooper(); if (mLooper == null) { throw new RuntimeException( \"Can't create handler inside thread \" + Thread.currentThread() + \" that has not called Looper.prepare()\"); } 所以需要 手动调用 Looper.prepare() private static void prepare(boolean quitAllowed) { if (sThreadLocal.get() != null) { throw new RuntimeException(\"Only one Looper may be created per thread\"); } sThreadLocal.set(new Looper(quitAllowed)); // 通过 ThreadLocal 给当前线程设置 looper } 而且需要手动调用 Looper.loop() ,开启 handle 对应 looper 的死循环 for (;;) 为什么主线程中 新建Handle 不要手动调用 Looper.prepare() 和 Looper.loop() 因为在 ActivityThread.java 中的 public static void main(String[] args) 函数中 系统已经 启用了 Looper.prepareMainLooper() 、Looper.loop() 主线程中的Looper.loop()一直无限循环为什么不会造成ANR 为什么当主线程处于死循环的 Message msg = queue.next() 这句会阻塞线程的代码的时候不会产生 ANR 异常, 1、当没有消息的时候会阻塞 2、其他线程有消息发过来，它马上就会被唤醒，去分发message。 所以 阻塞是有的，但是不会报ANR 。 因为ANR的根本原因是在等待的时间内没有回应， 你都没有 Message 要处理，我当然不需要任何回应。 ANR (Application Not Responding )原理 ANR的监控和处理，是在系统层做的。 系统服务发出一条指令后会在约定的时间等待返回， 如果在约定时间内没有返回，系统就会给出 ANR 提示。 为什么 Handler 有潜在内存泄露 在 Activity 中 用这种内部类的方式 新建 handle， handle就会持有外部类 activity 的引用， Handler handler = new Handler() { ... }; 同理 ，Runnable 也会拥有 外部类 activity 的引用 handler.postDelayed(new Runnable() { public void run() { ... } }) Runnable 被封装成 Message 被 MessageQueue 持有，所以 activity 被 MessageQueue 间接持有了。 activity 退出时，如果延时时间还没到，所以 activity 无法被释放掉。 至于为什么 内部类会持有外部类的引用 ，可以查阅其他博客。 通过 WeakReference 解决 handle 内存泄漏 private static class MyHandler1 extends Handler { //WeakReference 当GC执行时，无论当前内存是否充足，都会将弱引用关联的对象回收掉。 private final WeakReference weakReference; public MyHandler1(InfoHudViewHolder controller) { weakReference = new WeakReference<>(controller ); } @Override public void handleMessage(Message msg) { InfoHudViewHolder holder = weakReference.get() ; if(holder==null){ return; } } } // 使用 MyHandler myHandler =new MyHandler(this) ; 为什么 在子线程中调用 activity.runOnUiThread() 也可以更新UI new Thread(new Runnable() { activity.runOnUiThread(new Runnable() ... ) }).start(); public final void runOnUiThread(Runnable action) { if (Thread.currentThread() != mUiThread) { // 在子线程中调用activity.runOnUiThread( ... ) 的情况 mHandler.post(action); } else { // 在主线程中调用activity.runOnUiThread( ... ) 的情况 action.run(); } } 从源码可以得知 ，如果调用 runOnUiThread()的线程就是主线程，就立马执行。 如果是在子线程中调用，就会把 Runnable 封装成 Message ，进入消息队列， 最后会转发给 创建 mHandler 所在的线程执行 ，Handler mHandler = new Handler(); mHandler 是系统在 Activity.java 中创建，所以最后会在主线程中执行了。 为什么 在子线程中调用 handler.post(new Runnable...) 也可以更新UI // 前提条件 ： handler是在 主线程中新建的 new Thread(new Runnable() { handler.post(new Runnable() { // 更新 UI } ).start(); 跟踪源码发现 执行 post 后 ，会经过 一系列函数 ，将 Runnable 包装成 Message ， 最后分发回 handler所依附线程(主线程)中运行。 private static Message getPostMessage(Runnable r) { Message m = Message.obtain(); // 包装 Runnable 给 Message m.callback = r; return m; } public void dispatchMessage(@NonNull Message msg) { if (msg.callback != null) { handleCallback(msg); // 执行 Runnable 的run 函数 } } private static void handleCallback(Message message) { message.callback.run(); } handler 为什么可以更新UI 、为什么可以实现线程间通信 现在有A、B两个线程，在A线程中创建了handler，然后在B线程中调用 A线程的 handler发送一个message。 当A线程创建handler的时候，同时创建了 MessageQueue 与 Looper， Looper在A线程中被调用，进入 for (;;) 循环 ，轮询 MessageQueue 是否有需要处理的消息。 在B线程使用 A线程中的 handler发送一个message ,将message插入到handler对应的MessageQueue中， Looper发现有message插入到MessageQueue中，便取出message执行相应的逻辑， 因为Looper.loop() 是在A线程中启动的，对应的 MessageQueue 和 Looper 都是属于 A线程的 ， 所以 Handle 的方法 handleMessage() 是在 A线程中执行。 Runnable 是一定运行在子线程中吗 Runnable 运行在子线程中是错误的观念。 runnable只是创建了一个执行任务的对象，但是它本身并不会创建一个新的子线程。 最终的执行线程是要看 所依附的线程 。 1、举例 handler.post(runnable) // The runnable will be run on the thread to which this handler is attached. public final boolean post(@NonNull Runnable r) { return sendMessageDelayed(getPostMessage(r), 0); } 2、举例view.post(runnable) The runnable will be run on the user interface thread. MessageQueue 如何对 Message 排序的 通过时间排序 。 public final boolean postDelayed(@NonNull Runnable r, long delayMillis) { return sendMessageDelayed(getPostMessage(r), delayMillis); } public final boolean sendMessageDelayed(@NonNull Message msg, long delayMillis) { ... // SystemClock.uptimeMillis() Returns milliseconds since boot, not counting time spent in deep sleep return sendMessageAtTime(msg, SystemClock.uptimeMillis() + delayMillis); } boolean enqueueMessage(Message msg, long when) { synchronized (this) { ... msg.when = when; Message p = mMessages; // 下一条信息 boolean needWake; // 根据 when 进行顺序排序，将消息插入到其中 if (p == null || when == 0 || when Handler.postDelayed()是如何 实现实现延时执行的 会马上进入队列的，而不是等时间到了再加入队列。 Handler 不是自己处理 Delay，而是交给了MessageQueue处理。 大概流程如下： 1、postDelay 一个延时10秒钟的A消息进队，MessageQueue调用 nativePollOnce ()阻塞，Looper阻塞； 2、紧接着post 一个B消息进队，判断现在A时间还没到、正在阻塞，把B插入消息队列的头部（A的前面）， 然后调用nativeWake()方法唤醒线程； 3、MessageQueue.next()方法被唤醒后，读取消息链表，第一个消息B无延时，直接返回给Looper，执行B消息。 4、Looper for(;;) 处理完这个消息再次调用next()方法，MessageQueue继续读取消息链表， 假如消息A还没到时间，继续阻塞；直到阻塞时间到或者下一次有Message进队再次唤醒； 这样就实现了延时。 Handler.postDelayed() 的延时方法是一定非常精准吗 这种方式是不精准的。 Message的执行时机是在加入队列时就计算好的。 sendMessageAtTime(msg, SystemClock.uptimeMillis() + delayMillis); 然后 Looper.looper()函数中的 for (;;) 是串行执行的，执行了上一条后再去判断下一个Message 是否要执行。 (handle 和 Looper 是处于一个线程，所以执行一条才能下一条)。 举个夸张的例子， myThread1.handler1.postDelayed(new Runnable() { @Override public void run() { long time =System.currentTimeMillis() - timeStart ; Wklog.d(\"延时5秒执行=\"+ Thread.currentThread().getId()+\" 间隔描述=\"+ (time/1000)); } } ,5*1000) ; myThread1.handler1.post(new Runnable() { @Override public void run() { timeStart = System.currentTimeMillis() ; Wklog.d(\"马上执行线程=\"+ Thread.currentThread().getId() ); Thread.sleep(3*1000); //Thread.sleep(7*1000); } } }) ; handler1.postDelayed 按计划是延时5秒执行的， handler1.post 是马上执行的 。 如果 post的 Handle在5秒内执行完毕， postDelayed的Runable 还是按照原计划 5秒后执行， 如果 post的 Handle 超过5秒执行完毕， postDelayed的Runable 就不能实现延时5秒了，而是7秒了。 因为，本来应该在 for(;;)判断是否要执行下一条的时间里 却在执行 耗时操作，错过了。 MessageQueue 中为什么不用 wait 而用 epoll 进行等待呢 在旧版本中，是用的wait 实现等待。 后来需要处理 native 层的一些事情，改成 select 再改成 epoll private native void nativePollOnce(long ptr, int timeoutMillis) 实现等待 。 https://android.googlesource.com/platform/frameworks/base/+/46b9ac0ae2162309774a7478cd9d4e578747bfc2%5E%21/#F16 如何退出 Looper 循环 、退出 Handle handler.getLooper().quit(); // 我手动调用这个代码 // Looper.java public void quit() { mQueue.quit(false); } // MessageQueue.java void quit(boolean safe) { synchronized (this) { if (mQuitting) { return; } mQuitting = true; // 1、标记可以退出 if (safe) { removeAllFutureMessagesLocked(); // 2、删除相关数据 } else { removeAllMessagesLocked(); } nativeWake(mPtr); // 3、唤醒线程 } } 然后再来看 Looper.java 中的 loop() 函数 public static void loop() { for (;;) { Message msg = queue.next(); // might block ， if (msg == null) { // 6、nex 返回空 ，退出 loop循环 return; } msg.recycleUnchecked(); } } // MessageQueue.java Message next() { for (;;) { // nativePollOnce 用于“等待”, 直到下一条消息可用为止 // 4、被step3唤醒 ，继续往下执行 nativePollOnce(ptr, nextPollTimeoutMillis); synchronized (this) { if (mQuitting) { // 5、mQuitting 在 step 1被设置为 true了 ，所以返回 null dispose(); return null; } } 主线程 的 looper 能否 quit() void quit(boolean safe) { if (!mQuitAllowed) { throw new IllegalStateException(\"Main thread not allowed to quit.\"); } } 从源码可知，主线程的Looper 禁止开发者 quit 。 因为主线程中的 handle 要处理很多事情，退出之后 整个APP就没得玩了。 private class H extends Handler｛ public void handleMessage(Message msg) { switch (msg.what) { case LAUNCH_ACTIVITY case RELAUNCH_ACTIVITY: { case PAUSE_ACTIVITY: { case PAUSE_ACTIVITY_FINISHING: case STOP_ACTIVITY_SHOW: case STOP_ACTIVITY_HIDE: case LOCAL_VOICE_INTERACTION_STARTED: ... Handler 如何确保线程安全 // 与 handle 对应的 MessageQueue ，Message 进入队列 synchronized 上锁了 boolean enqueueMessage(Message msg, long when) { // MessageQueue.java synchronized (this) { // Looper 中获取 Message 时 MessageQueue 的next 也被上锁了 for (;;) { // Looper.java Message msg = queue.next(); Message next() { // MessageQueue.java synchronized (this) { ... } } 手写 handle 机制 实现 线程间通信 handle 不仅仅只用于 主线程 和子线程的通信 ，也可以实现 子线程和子线程的通信 。 可以参考我的 demo https://gitee.com/hnyer/my-handle 无版权 可以无限制使用！ all right reserved，powered by Gitbook该文件更新时间： 2020-12-07 15:34:12 "},"chinese/android基础/Fragment详解.html":{"url":"chinese/android基础/Fragment详解.html","title":"Fragment详解","keywords":"","body":"Fragment详解 一个Fragment总是嵌入到一个Activity，是一个模块化的View，它的生命周期受它所嵌入的Activity生命周期的的影响。可以动态的添加、替换、移除某个Fragment。 fragment的优势 同样的界面 ， fragment 比activity 占用内存更少 ，响应速度更快 。 Fragment生命周期 activity与fragment生命周期的关系 与activity相同的生命周期函数 onCreate 、onStart 、onResume、onPause、onStop 、onDestroy 与activity相比多出的生命周期函数 onAttach 、onDetach 、onActivityCreated 、onViewCreated 、onCreateView 、onDestroyView 常用函数 getSupportFragmentManager 获得碎片管理者 getChildFragmentManager 获取自己的FragmentManager对象。 getFragmentManager 获取的是父Fragment(如果没有，则是FragmentActivity)的FragmentManager对象。 getBackStackEntryCount 从管理器中得到Fragment当前已加入Fragment回退栈中的fragment的数量。 onHiddenChanged onHiddenChanged 不是生命周期函数 ，通过 hide 和 show 进行触发。 无版权 可以无限制使用！ all right reserved，powered by Gitbook该文件更新时间： 2020-12-18 08:52:57 "},"chinese/android基础/Android启动模式.html":{"url":"chinese/android基础/Android启动模式.html","title":"Android启动模式","keywords":"","body":"Android启动模式 activity 生命周期 onDestroy // onStop 和 onDestroy 回调为什么会延时 由于要关闭的 或者要打开的 Activity 往主线程的 MessageQueue 中发送了 大量的 Message , 导致主线程一直在不断的进行消息循环处理这些消息而没有得到停歇。 App 侧就不能向 AMS 告知自己有空闲时间来处理 AMS 侧的任务。 所以，finish Activity B后，onDestroy不会被及时回调。 具体延时多久，要看主线程什么时候闲下来。 // 为什么 Activity.finish() 之后 10s 才 onStop 、onDestroy 除正常流程外，Android 系统另行安排了一套流程来保证即使正常流程被阻断以后，Activity B还是能被销毁。 ActivityStac.java 中 // schedule an idle timeout in case the app doesn't do it for us. mStackSupervisor.scheduleIdleTimeoutLocked(next); this.mHandler.sendMessageDelayed(msg, 10000L); // 10s onRestart 经过测试，以下几种情况 onRestart()方法 会被调用 1、按下home键之后，然后切换回来 2、从本Activity跳转到另一个Activity之后，按 back键返回原来 Activity 3、从本Activity切换到其他的应用，然后再从其他应用切换回来 onStop 两个Activity之间跳转 , 从A跳到B ，A的 onStop 是否执行 取决于 B是否完全覆盖在 A上 导致A整个不可见。 如果 B 是透明的 Activity 或者是个 Dialog 样式 ，A 的 onStop 并不会被执行。 按 Back 键 后，activity 的生命周期变化 这些东西 写个简单demo 实验一把 当场就能出结果。 面试官要是硬要你回答，就是沙比。 按 Home 键 后，activity 的生命周期变化 这些东西 写个简单demo 实验一把 当场就能出结果。 activity 启动另外一个activity的时候横屏切换再点击返回，过程中发生的生命周期 这些东西 写个简单demo 实验一把 当场就能出结果。 启动模式 通过使用不同的启动模式，来控制是否生成唯一还是多个activity实例 。来满足不同的使用场景 。 standard 模式 默认模式。每当有一次Intent请求，就会创建一个新的Activity实例 。 并且被放到启动它的那个Activity所属的任务栈中。 singleTop 模式 栈顶复用。 栈顶有此实例就使用（调用 onNewIntent()方法） ，没有就重新创建。(调用onCreate()方法) singleTask 模式 栈内复用。 若栈中已有该Activity的实例，就重用该实例(调用onNewIntent()方法)。 并且会将它所在任务栈之前的所有activity实例移除掉。因此该实例就处于栈顶了。 若栈中不存在该实例，将会onCreate()。 可以用在 消除交互界面的嵌套循环 场景。 singleInstance 模式 全局唯一。 Activity单独占用一个Task栈 。整个系统中是单例的。 启动模式属性 // taskAffinity android:taskAffinity=\"task001\" 它倾向于将 taskAffinity 属性相同的Activity，扔进同一个Task中。指定Activity希望归属的栈 // allowTaskReparenting 任务状态是否始终由系统来维护 android:allowTaskReparenting=\"true\" //默认false 任务栈 task stack 每次启动新的Activity都将被添加到Activity Stack。 用户返回就会将当期的activity实例出栈。 如果当前栈空了，就会进入 Home screenn 所在的栈 。 1、一个应用程序一被启动,系统就给它分配一个任务栈 。 一个应用程序一个任务栈。 2、一个任务栈中存放多个activity ,可以来自不同的应用程序。 查看 系统的任务栈 、 Activity 栈信息 、各个栈的 Activity 列表 adb shell dumpsys activity 指定启动模式 代码方式 优先级大于 xml方式 // xml方式 // 代码方式 Intent intent = new Intent( this ,TestActivity.class); intent.addFlags(Intent.FLAG_ACTIVITY_SINGLE_TOP); this.startActivity(intent); Intent的 Flag标志 官网flags Intent的Flag标志 意义 FLAG_ACTIVITY_NEW_TASK 默认的跳转类型 FLAG_ACTIVITY_SINGLE_TOP singletop模式 FLAG_ACTIVITY_BROUGHT_TO_FRONT FLAG_ACTIVITY_CLEAR_TOP SingleTask模式 FLAG_ACTIVITY_NO_HISTORY Activity不会保留在栈中 FLAG_ACTIVITY_NO_ANIMATION 不使用过渡动画 FLAG_ACTIVITY_EXCLUDE_FROM_RECENTS 最近应用里面查看不到这个activity的启动记录 无版权 可以无限制使用！ all right reserved，powered by Gitbook该文件更新时间： 2020-12-21 10:10:24 "},"chinese/android基础/动画详解.html":{"url":"chinese/android基础/动画详解.html","title":"动画详解","keywords":"","body":"动画详解 多个动画之间，是可以组合在一起同时播放的。 AnimatorSet.playTogether(xxx) 动画类型 // 帧动画 Drawable Animation、Frame Animation ,容易OOM // 补间动画 View Animation、TweenedAnimation , 只能平移、缩放、旋转、透明度。不能拓展效果。 // 属性动画 Property Animation , 可以拓展动画效果。可以作用于View和非View对象 。 帧动画 将一个完整的动画拆分成一张张单独的图片，然后再将它们连贯起来进行播放，类似于动画片的工作原理。 补间动画 补间动画可以望文生义 ，就是在两点之间插入渐变值来平滑过渡。 // 特点 1、XML声明文件存放在res/anim目录； 2、基于Animation和AnimationSet的类结构； 3、效果由四个因素决定：1）初始状态；2）结束状态；3）持续时间；4）Interpolator // 不足之处 1、只能够作用在View上 。 2、补间动画机制是使用硬编码的方式来完成的，功能限定死 淡入淡出(透明度)、缩放(大小)、平移(位置)、旋转四种， 基本上没有任何扩展性可言。例如不能实现对View的背景色进行动态地改变。 3、它只是改变了View的显示效果而已，而不会真正去改变View的属性。 例如 现在屏幕的左上角有一个按钮，补间动画将它移动到了屏幕的右下角，你点击这个按钮，点击事件不会触发， 因为实际上这个按钮还是停留在屏幕的左上角，只不过补间动画将这个按钮绘制到了屏幕的右下角而已。 （想真正移动某组件，需要在动画结束后添加代码实现。） 属性动画 顾名思义，通过控制对象的属性，来实现动画效果。 // 特点 1、需要Android API level 11 （android3.0）以上使用。 2、XML文件存放在res/animator目录下； 3、基于Animator和AnimatorSet的类结构； // 优点 1、可以对所有的 Object对象的 任意属性进行操作。 2、动画效果不局限于 透明度、缩放 、平移 、旋转四种效果。 3、因为是一种不断地对值进行操作的机制，并将值赋值到指定对象的指定属性上，所以不仅仅是一种视觉上的动画效果了。 例如我们通过属性动画来移动一个按钮，那么这个按钮就是真正的移动了，而不再是仅仅在另外一个位置绘制了而已。 ViewPropertyAnimator 虽然属性动画给我们提供了ValueAnimator类和ObjectAnimator类， 在正常情况下，基本都能满足我们对动画操作的需求， 但ValueAnimator类和ObjectAnimator类本身并不是针对View对象的而设计的， 而我们在大多数情况下主要都还是对View进行动画操作的，因此Google官方在Android 3.1系统中补充了ViewPropertyAnimator类， 这个类便是专门为View动画而设计的。 他解决了View在使用属性动画时步骤繁琐，效率低下（使用PropertyAnimator为View设置多种动画，每种动画在执行过程中都会单独的触发View的UI重绘）的问题。 val animator = tvText.animate() animator.duration=1000 animator.translationXBy(100f)//每次点击都会向右偏移 //animator.translationX(100f)//点击一次会向右偏移，再点击没效果 animator.start() ValueAnimator 是对 值 的平滑过渡动画。你拿到不断变化的值后，你想干嘛就干嘛。 private void testValueAnimator(final View someView){ ValueAnimator valueAnimator = ValueAnimator.ofFloat(0f, 180f) ; valueAnimator.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() { @Override public void onAnimationUpdate(ValueAnimator valueAnimator) { // 拿到这个不断变化的值， 可以给 view的某个属性赋值，或其他 float value = (Float) valueAnimator.getAnimatedValue(); someView.setRotation(value); } }); } ObjectAnimator // ObjectAnimator extends ValueAnimator 。 ObjectAnimator 继承了ValueAnimator的所有方法和特性，并且还封装很多实用的方法，方便开发人员快速实现动画。 private void testObjectAnimator( View someView ){ ObjectAnimator objectAnimator = ObjectAnimator.ofFloat(someView ,\"rotation\" , 0 ,360 ,180 ,0 ); objectAnimator.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() { @Override public void onAnimationUpdate(ValueAnimator valueAnimator) { float value = (float) valueAnimator.getAnimatedValue(); Log.d(\"testTag\" , String.valueOf(value)) ; } }); objectAnimator.setDuration(2000).start(); } 矢量动画 svg SVG（Scalable Vector Graphics）是Android 5.0中新加入的一个新特性 。 svg文件 使用xml格式定义 。 svg图片可以无限拉伸并不会变形和锯齿。 // svg在安卓上使用稍显复杂 ， 使用 Lottie 库 + AE 导出的json文件 可以更方便快捷地实现同样的效果 。 同时 Lottie 兼容 android 、ios、React Native 、web 。 https://github.com/airbnb/lottie-android 无版权 可以无限制使用！ all right reserved，powered by Gitbook该文件更新时间： 2020-09-23 15:05:34 "},"chinese/android基础/屏幕刷新机制.html":{"url":"chinese/android基础/屏幕刷新机制.html","title":"屏幕刷新机制","keywords":"","body":"屏幕刷新机制 CPU 计算屏幕数据、GPU 进一步处理和缓存、最后 display 再将缓存中（buffer）的屏幕数据显示出来。 屏幕每一帧的画面可以持续 16.6ms，当过了 16.6ms，底层就会发出一个屏幕刷新信号，而屏幕就会去显示下一帧的画面。 当屏幕刷新信号到的时候，屏幕就去将 CPU 计算的屏幕画面数据显示出来；同时 CPU 也接收到屏幕刷新信号，所以也开始去计算下一帧的屏幕画面数据。 在每一次屏幕刷新信号来的时候都会去切换这一帧的画面，这点我们是控制不了的，是底层的工作机制。 当用户不操作了、当前界面也没动画 时 ，CPU没有 下一帧画面数据需要计算，但是底层仍然会以固定的频率来切换每一帧的画面，只是它后面切换的每一帧画面都一样，所以给我们的感觉就是屏幕没刷新。 CPU 绘制视图树来计算下一帧画面数据的工作是在屏幕刷新信号来的时候才开始工作的，而当这个工作处理完毕后，也就是下一帧的画面数据已经全部计算完毕，也不会马上显示到屏幕上，而是会等下一个屏幕刷新信号来的时候再交由底层将计算完毕的屏幕画面数据显示出来。 https://www.jianshu.com/p/0d00cb85fdf3 无版权 可以无限制使用！ all right reserved，powered by Gitbook该文件更新时间： 2020-08-19 17:20:00 "},"chinese/android基础/sdk开发.html":{"url":"chinese/android基础/sdk开发.html","title":"sdk开发","keywords":"","body":"SDK开发 将一些业务逻辑独立出来，打包成jar、so、aar，暴露一些APIs给外部调用，也可以称为SDK。 SDK 不同于普通应用,不能频繁的进行更新,以免让开发者觉得 SDK 不稳定或者让开发者频繁的集成 。 为了安全起见,数据加密类、模块算法类都都应该采用NDK开发 。 sdk加密方案 方案名字 缺点 优点 代码混淆 1、有些类不能混淆（例如工具类，自定义控件等，如果被混淆了用户就不方便调用），所以对代码架构要求比较高。2、混淆后的代码虽然不易识别了，但是仔细分析还是能看懂的。 修改class的字段 某些字段对运行没有影响，但是能导致别人无法反编译。 自定义类加载器ClassLoader ClassLoader容易被攻破 jvmti 不适用于Android平台？（我暂时还未测试成功） SDK 版本号命名及修改原则 SDK版本号命名和我们以往的命名规则并无太大不同,通由4部分组成,格式为: V主版本号_子版本号_阶段版本号_日期版本号_希腊字母版本号 比如：V1_1_2_161209_beta. 希腊字母版本号说明 1、Alpha版:内部测试版。此版本表示该软件在该阶段主要是以实现功能为主,Bug相对较多,需要继续修改,通常只在内部流通流通而不对外开放。 2、Beta版:外部测试版。该版本相对Alpha已经有了很大的改进,不存在严重的Bug,但还是存在一些缺陷,需要进一步的测试以检查和消除Bug。 3、RC版: 该版本已经相当成熟,不存在导致错误的Bug，与正式版相差无几。 4、Release版:该版本意味着”最终版本”,是最终交付用户或者公开发布的版本,也称为标准版。在发布的时候回以符合R来代替Release单词。 版本号修改规则 1、 主版本号变化:当功能模块有较大的变化或者整体架构发生变化 2、子版本号变化:当功能有一定变化 3、阶段版本号变化:一般是Bug修复或者较小的变动,根据反馈,需要经常发布修订版本. 4、日期版本号(161209):用于记录修改项目的当前日期,每天对项目的修改都要更改日期版本号. 5、希腊字母版本号:此版本号用于标注当前软件处于那个开发阶段,当软件进入到另一个阶段是需要修改. API版本管理 原则上SDK API一旦公开发布后其状态应为不可变。 1、对于特殊情况下API的变更,需要遵守”开闭原则” 2、在需要废除某些方法时,需要在正式版发版前使用 @deprecated 标识。并给出替代方案和开始废弃的 SDK版本号。 经验之谈 原文 http://blog.csdn.net/dd864140130 有删减。 //SDK实现目标 1、简洁易用 SDK不应该对宿主应用有过多的代码侵入,也不应该有复杂频繁的接入工作。 当我们需要使用该 SD K的服务时,通过一行代码便可启用 Ad.init(this,params) 2、稳定 ① SDK的API一旦确定,如无非常严重情况不可更改。 ②、必须确保SDK自身运行的稳定,并且保证接入方不会因为我们的SDK产生不稳定。 ③、不能频繁更新迭代。防止增加用户负担。 //SDK整体架构设计 模块化开发 根据单一职责将系统拆分为不同的小模块，每个模块保持相对独立。 模块之间通过协议或接口通信，以减少相互之间的依赖耦合。 为了安全起见, 核心逻辑应该采用NDK开发。 //API版本管理 原则上SDK API一旦公开发布后，应为不可变。 对于特殊情况下API的变更,需要遵守”开闭原则”: 1、在需要调整SDK API时,优先选择添加新方法,而不是在原方法上修改 。 2、在需要废除某些方法时,需要在正式版发版前使用 @deprecated 标识,并标明开始废弃的版本。 sdk开发-Module支持c++ 1、按照正常流程创建一个支持c++的项目。 此时 CMakeLists.txt 文件在 app 这个项目里面。 2、新建一个module ，并添加到app中。 3、将 CMakeLists.txt 剪切到 module对应的 目录下。 4、 同理 ，以下代码也剪切到 module对应的文件中去。 externalNativeBuild { cmake { path \"CMakeLists.txt\" } } externalNativeBuild { cmake { cppFlags \"-std=c++11 -frtti -fexceptions\" } } 5、刷新工程即可。 无版权 可以无限制使用！ all right reserved，powered by Gitbook该文件更新时间： 2020-09-24 11:36:25 "},"chinese/android基础/相机模块.html":{"url":"chinese/android基础/相机模块.html","title":"相机模块","keywords":"","body":"相机模块 从Android 5.0(21)开始， android.hardware.Camera 被废弃 ，启用 android.hardware.Camera2 。 Android相机兼容性问题非常大,如果只是拍照,尽量调用系统相机,如果需要预览和拿视频流, 可以基于某些第三方库开发。 natario1 CameraView     谷歌非官方 cameraview     基于谷歌非官方 cameraview     camerakit-android 参考资料 拍出来的照片旋转了 获取照片的角度值，然后再用矩阵纠正过来。 拍照后闪退 部分机型对自家相机做了优化，会销毁我们的activity。 根据调试情况，在onSaveInstanceState()中保存对应状态即可。 图片无法显示 图片太大导致OOM ，对图片进行压缩即可。 自拍镜像 开启前置摄像头后，预览的画面和拍照后的画面是左右相反的。进行图片翻转即可。 预览画面 贴图 相机 + opengl es 方案。 无版权 可以无限制使用！ all right reserved，powered by Gitbook该文件更新时间： 2020-08-19 17:20:00 "},"chinese/android基础/WebView详解.html":{"url":"chinese/android基础/WebView详解.html","title":"WebView详解","keywords":"","body":"WebView详解 [ Android4.4, +∞) Chromium内核取代了Webkit内核。 [ Android5.0, +∞) WebView移植成了一个独立的apk，可以不依赖系统而独立存在和更新。 [ Android7.0, +∞) 如果用户手机里安装了 Chrome ， 系统优先选择 Chrome 为应用提供 WebView 渲染。 [ Android8.0, +∞) 默认开启WebView多进程模式，即WebView运行在独立的沙盒进程中。 无版权 可以无限制使用！ all right reserved，powered by Gitbook该文件更新时间： 2020-08-19 17:20:00 "},"chinese/android基础/图表绘制.html":{"url":"chinese/android基础/图表绘制.html","title":"图表绘制","keywords":"","body":"图表绘制 MPAndroidChart https://github.com/PhilJay/MPAndroidChart 是 Android 中一个较流行的第三方开源库 。 适用于 Android 2.2 ( API 8 ) 及以上。 本次讲解基于 v3.0.3 版本。 MPAndroidChart 的动画机制只在Android API 11 及以上有效 。 无版权 可以无限制使用！ all right reserved，powered by Gitbook该文件更新时间： 2020-08-19 17:20:00 "},"chinese/android基础/沉浸式.html":{"url":"chinese/android基础/沉浸式.html","title":"沉浸式","keywords":"","body":"沉浸式 Android 至4.4才开始支持沉浸式状态栏 。 所谓的 沉浸式 就是 可以设置手机状态栏的背景 。 实际的效果其实就是透明的状态栏，然后在状态栏的位置显示我们自定义的颜色 或图片 。 这里 有一个比较好用的第三方库 ImmersionBar 无版权 可以无限制使用！ all right reserved，powered by Gitbook该文件更新时间： 2020-08-19 17:20:00 "},"chinese/android基础/svg绘制不规则图形.html":{"url":"chinese/android基础/svg绘制不规则图形.html","title":"svg绘制不规则图形","keywords":"","body":"svg 、vector SVG Scalable Vector Graphics 、矢量图 在各种设备上能实现自然伸缩或扩展而不影响图片质量。 参考 https://github.com/zhangjundi/taiwanDemo 1、加载、解析 svg文件 ，获得 path 数据 2、将path数据转换为 Path 对象。谷歌官方有现成的工具类 PathParser.java。 3、将解析出来的所有path绘制出来 4、判断点击点是否在当前path范围内。 public boolean isInArea(Path mPath ,float x, float y){ RectF r=new RectF(); mPath.computeBounds(r, true); Region re=new Region(); re.setPath(mPath, new Region((int)r.left,(int)r.top,(int)r.right,(int)r.bottom)); return re.contains((int)x, (int)y); } vector vector 就是Android中的矢量图使用方案。 Android 5.0发布的时候，Vector只支持Android 5.0+。 不过自从AppCompat 23.2之后，Google做了兼容处理 ， 只需要引用com.android.support:appcompat-v7:23.2.0以上的版本就 适用于Android 2.1以上的所有系统 。 vector标签属性 意义 width 图形宽度 height 图形高度 viewportHeight 画布高度 viewportWidth 画布宽度 group 对Path进行分组 path 对应一个Pathname // path名字fillAlpha//填充透明度fillColor //填充颜色strokeColor//线条颜色 pathData //path指令strokeWidth//线条宽度 Android基于vector文件绘制不规则图形的例子 无版权 可以无限制使用！ all right reserved，powered by Gitbook该文件更新时间： 2020-08-26 09:32:13 "},"chinese/android基础/地图模块.html":{"url":"chinese/android基础/地图模块.html","title":"地图模块","keywords":"","body":"地图模块 坐标类型 // 世界标准地理坐标 、WGS-84 国际标准，从国际标准GPS设备中获取到的坐标都是 WGS84 。 WGS－84 坐标系是美国建立的GSP原始坐标系； // 中国国测局地理坐标 、 GCJ-02 、 火星坐标 中国标准，国家测绘局 发布的坐标系 。在中国，必须至少使用GCJ02对地图进行首次加密。 火星坐标系统 ，就是中国设计的一个加密插件，是对真实地图进行人为的加偏处理，按照一定的加偏算法，将真实的坐标加密成虚假的坐标。 加偏处理不是线性的加偏，所以各地的偏移情况都会有所不同。这样一来地图的坐标就与实地的坐标不相符了，于是大家把这种坐标戏称为\"火星坐标\" 。 // CGCS2000 坐标系 China Geodetic Coordinate System 2000 ,是我国建立的大地坐标系，类似于WGS－84坐标系，是原始坐标系。 // 搜狗坐标系 由GCJ-02进行进一步的偏移算法得到。 // 百度地理坐标 、 BD-09 百度标准， 在GCJ02 的基础上进行二次加密。 各个地图软甲采用的坐标系 在中国，任何一个地图产品 至少使用GCJ-02进行首次加密，不允许直接使用WGS-84坐标下的地理数据，同时任何坐标系均不可转换为WGS-84坐标。 网上有人总结反推的一些转换接口，都是有偏差的。对精度非常严格的使用场景，要慎重使用。 基于 GCJ-02 转 WGS-84 的转换结果都有偏差。 基于 WGS-84 转 GCJ-02 的转换结果没有偏差。 // 百度地图 1、境内、包括港澳台 : BD09 。 2、境外 : WGS-84 。 // 高德地图: 1、境内：GCJ-02 2、境外：暂不支持 // 腾讯地图 1、境内：GCJ-02 2、境外：暂不支持 // google地图 1、境内：GCJ-02 , 数据来源于高德，两者互通。 2、境外：WGS-84 。 // bing地图 ,微软的 全球统一：WGS-84 。Bing地图图源较老 。 // 天地图 全球统一 ：CGCS2000 地图坐标互相转换 https://github.com/hnyer/JZLocationConverter-for-Android 高德地图 根据指定经纬度显示和导航 String.format(Locale.getDefault(), \"https://m.amap.com/share/index/lnglat=%f,%f\" , xx.longitude ,xx.latitude) ; 隐藏左下角Logo // 高德地图隐藏左下角Logo UiSettings settings = aMap.getUiSettings(); settings.setLogoBottomMargin(-50);//高德logo图标无法移除 ，但是可以通过设置偏移的位置 来隐藏它 地理围栏 https://lbs.amap.com/api/android-location-sdk/guide/additional-func/local-geofence/ 加载谷歌瓦片地图数据 http://mt0.google.cn/vt/lyrs=y&hl=en&gl=en&src=app&x=6678&y=3558&z=13&s= // ok http://mt0.google.cn/vt/lyrs=y&x=6678&y=3558&z=13http://mt0.google.cn/vt/lyrs=y@110&x=6678&y=3558&z=13 格式 http://mt0.google.cn/vt/lyrs={lyrs}&hl=en&gl=en&src=app&x=%d&y=%d&z=%d&s= http://mt0.google.cn/vt/lyrs={lyrs}&x=%d&y=%d&z=%d // 一般用这个就可以了，不需要很多其他参数 // 服务器地址 ，可选，效果都是一样的 http://mt0.google.cn http://mt1.google.cn http://mt2.google.cn http://mt3.google.cn // x 列号 // y 行号 // z zoom级别 // lyrs m：路线图 ​t：地形图 ​s：卫星图 ​p：带标签的地形图 ​y：带标签的卫星图 ​h：标签层（路名、地名等） 我看到其他有些后面跟了个@参数，暂时不知道什么作用。lyrs=m@167000000 。不用貌似也没有问题。 // hl en 、 zh-CN // gl en 、cn 经过测试发现 谷歌中国，高德 都采用了 火星坐标系。不过谷歌中国同时也提供了 wgs84坐标系方式的地图，只要修改一个参数即可， 将gl=cn去掉，则下载的地图 就变成了 wgs84,否则 则是火星坐标系。 // src 标记来自哪里的请求？ // s 作用未知，可用可不用。随便填 。 其他 禁飞区 大疆禁飞区查询 https://www.dji.com/cn/flysafe/geo-map 优凯限飞区查询与下载 http://xianfei.u-care.net.cn/#/downLoad 在线导入kml查看效果图 http://geojson.io/#map=2/20.0/0.0 Java主要用dom4j包解析kml文件。 无版权 可以无限制使用！ all right reserved，powered by Gitbook该文件更新时间： 2020-09-24 08:38:01 "},"chinese/android基础/虚拟机对比.html":{"url":"chinese/android基础/虚拟机对比.html","title":"虚拟机对比","keywords":"","body":"虚拟机对比 JVM Java Virtual Machine。基于栈 ，运行java字节码。 DVM Dalvik Virtual Machine 。 运行自谷歌定义的 .dex字节码格式。 Dalvik 基于寄存器的架构， 更适合资源紧张的系统。 ART Android runtime 。 Android 4.4 开始加入 ART模式。 ART下，应用在第一次安装的时候，字节码就会预编译成机器码，首次启动会变慢， 但是以后每次启动执行的时候，都可以直接运行。（空间换时间） 无版权 可以无限制使用！ all right reserved，powered by Gitbook该文件更新时间： 2020-08-26 09:58:14 "},"chinese/android基础/apk瘦身.html":{"url":"chinese/android基础/apk瘦身.html","title":"apk瘦身","keywords":"","body":"apk瘦身 最主要的是 从图片资源 、第三方库 和 .so 方面考虑 。 1、 用lint检查， 删除无用资源 2、 用tinypng等压缩图片。 3、用webp格式图片 4、开启代码混淆 5、删除冗余代码。 无版权 可以无限制使用！ all right reserved，powered by Gitbook该文件更新时间： 2020-08-26 09:42:37 "},"chinese/android基础/性能优化.html":{"url":"chinese/android基础/性能优化.html","title":"性能优化","keywords":"","body":"性能优化 、 APP优化 启动优化 // 冷启动 、热启动 当启动应用时，后台已有该应用的进程， 所以在已有进程的情况下，这种启动会从已有的进程中来启动应用，这个方式叫热启动。 按back键、home键，应用虽然会退出，但是该应用的进程是依然会保留在后台。 因为一个应用从新进程的创建到进程的销毁，Application只会初始化一次， 所以热启动的过程只需要创建和初始化一个 MainActivity 就行了，而不必创建和初始化 Application 。 冷启动就是从0开始启动 App 。 // 冷启动优化 1、Application中对 第三方的SDK进行异步或延时初始化 。 2、做一个闪屏界面。在展示的这段时间里，去加载下一页需要的资源。 // 热启动优化 在app 退出时 不要finish ，而是 moveTaskToBack ，即模拟 HOME按键的事件 。 UI流畅度优化 、界面卡顿 排查及优化 Skipped 60 frames! The application may be doing too much work on its main thread. 在大部分Android平台的设备上，Android系统是 16ms (1000 /60 = 16.67 ) 刷新一次，也就是一秒钟60帧。 要达到这种刷新速度就要求在ui线程中处理的任务时间必须要小于16ms，如果ui线程中处理时间长， 就会导致跳过帧的渲染，也就是导致界面看起来不流畅，卡顿。 卡顿引起的具体原因 1、cpu 占用过高，容易卡顿 。一般是 后台线程处理的东西太繁忙。 注意逻辑的优化，线程不要空跑。 2、主线程 绘制时间过长。 UI的层级别太大 ，不要冗余嵌套 卡顿检测 Choreographer 使用 Androidstudio 自带的 工具，和一些第三方的监控工具 例如 BlockCanary 就差不多了。 // FPS ( Frames Per Second ) 即 Frame Rate，单位 fps，是指 gpu 生成帧的速率 ，Android中更帧率相关的类是 SurfaceFlinger 。 SurfaceFlinger (SurfaceFlinger.h) 是Android的一个 native进程 ， 接受多个来源的图形显示数据，将他们合成，然后发送到显示设备。 // VSync (Synchronization ) ,垂直同步 信号。 Android系统每隔16ms发出 VSync 信号，触发对UI进行渲染， Android 4.1 开始引入 VSync 机制，用来同步渲染， 让 UI 和 SurfaceFlinger 可以按硬件产生的 VSync 节奏进行工作。 WkHeartBeatTool wkHeartBeatTool = new WkHeartBeatTool(); wkHeartBeatTool.startTheBeatAction(new HeartBeatTask() { @Override public void run() { // 一秒钟统计一次 ，如果小于 60 ，就说明掉帧了 WkLogTool.showLog(\"fps====\"+count); count= 0 ; } } ,1000); // Choreographer 编舞者 ，统计一秒内 count 的数量 ， Choreographer.getInstance() .postFrameCallback( new Choreographer.FrameCallback() { // frameTimeNanos: The time in nanoseconds when the frame started being rendered, @Override public void doFrame(long frameTimeNanos) { count++ ; Choreographer.getInstance().postFrameCallback(this); } }); 排查 线上App ,用户反馈卡顿的问题 1、记录用户的使用机型和使用场景。例如操作流程、网络环境 2、加入卡顿检测机制，有第三方的 SDK 也可以自己写 ， 将卡顿时的堆栈信息记录并回传，定位分析。 内存优化 1、别频繁GC 2、控制好对象的引用，防止对象一直无法释放。 稳定性 优化 稳定的纬度： 1、崩溃角度 非常重要，出现闪退现象会导致用户体验非常差。 容错机制，发生异常尽量不要闪退，而是给出提示。 不要随意使用try catch去隐藏问题：而应该从源头 了解崩溃的本质原因，保证后面的运行流程。 2、性能稳定 启动速度、流畅卡顿程度、内存占用、耗电量、界面绘制速度、网络流量、 保证业务功能可用。ANR 响应超时、 能持续运行多长时间 3、业务可用性纬度。 保证APP主流程 和核心路径的稳定可用性。确保核心业务高可用。因为核心业务覆盖的人群最多。 其他方面只有经常用的人才有可能触发。 保证业务可用的高效可用，性能不能相差起伏太大。 解决方案： 1、预防为主、监控修复为辅 ①、开发阶段 ，采用成熟稳定方案、加强编码能力； 对APP的 cpu、内存、进程线程数、网络流量、耗电量、log记录、启动页耗时 等信息记录和分析 ②测试阶段：加强机型覆盖测试、压力测试、特殊场景测试(例如无网络、故意下发错乱数据等)； 从用户角度入手，尽量模拟真实使用场景、测试验证。不要从开发者角度进行测试。 线下大规模覆盖测试、发现问题 解决问题； ③发布阶段：进行灰度发布、多轮发布 ； 发布前多测试、捕获异常上传并分析 、发新包修复或者热修复。 如果新发布的功能出现BUG，可以通过远程开关进行关闭功能模块，不让该功能显示。 ④ 运维阶段： 版本回退策略、热修复、发布新版本 线上定位问题 定位机型。 发生崩溃异常时，需要远程上报相关信息，包括 报错信息、机型、系统版本、APP版本、渠道等。 监控工具： 1、例如Android 自带的 monkey 2、 腾讯的 Bugly 3、阿里的 mobileperf 单元测试 // 黑盒测试 一般而言，都是自己或者测试做做黑盒测试，模仿用户使用场景 使用即可。 我问过很多人，他们基本都是这样测试后就上线了。 // 白盒测试 1、对于一些 要求严谨的大型 app ，例如 微信 支付宝，肯定是要做白盒测试了。 黑盒测试无法完全覆盖，一旦出错，损失无法承受 ，当然，这种级别的测试，都有专门的测试人员。 2、有一些大型的app ,编译时间比较长，或者路径比较深。采用手动点击试验看效果的方法，会比较浪费时间。 为了免去编译安装的等待时间，要引入白盒测试，缩短自测的时间。 // TDD ( Test-Driven Development ) 测试驱动开发 JUnit4 方案 Androidstudio 自带。 测试运行在本地开发环境的Java虚拟机上，无需连接Android设备或模拟器。 因此，无法获得Android相关的API，只能测试只使用Java API的一些功能。 @Test 表示此方法为测试方法 @Before 在每个测试方法前执行，可做初始化操作 @After 在每个测试方法后执行，可做释放资源操作 @Ignore 忽略的测试方法 assertEquals 断言传入的预期值与实际值是相等的 assertArrayEquals 断言传入的预期数组与实际数组是相等的 assertNull 断言传入的对象是为空 assertTrue 断言条件为真 assertSame 断言两个对象引用同一个对象，相当于“==” assertThat 断言实际值是否满足指定的条件 @Ignore(\"等会再测\") @Test public void getAppVersion(){ } @Test public void valueAdd() { MyDeviceTool tool = new MyDeviceTool() ; int sum = tool.valueAdd(10 ,5); assertEquals(5 ,sum); } Instrumentation 方案 需要将整个项目打包成apk，上传到模拟器或真机上，就跟运行了一次app 。 最近的文章(20201222)讲到 Androidstudio +Instrumentation 比较少， Androidstudio3.4.1 默认生成的代码中也没有 Instrumentation 相关配置， 是被替代了吗，暂时去看看其他的方案。 robolectric 方案 With Robolectric, your tests run in a simulated Android environment inside a JVM, without the overhead of an emulator. http://robolectric.org https://github.com/robolectric/robolectric // 配置 testImplementation 'junit:junit:4.12' testImplementation 'org.robolectric:robolectric:4.1' testImplementation 'org.robolectric:shadows-multidex:4.1' testOptions { unitTests { includeAndroidResources = true } } // 会提示下载文件失败，你可以手动下载一下。 Downloading: org/robolectric/android-all/9-robolectric-4913185-2/android-all-9-robolectric-4913185-2.jar from repository sonatype at https://oss.sonatype.org/content/groups/public/ Transferring 118099K from sonatype 下载地址就是按提示拼接一下,将下载好的文件放到 android-all-9-robolectric-4913185-2.jar.tmp 目录下 ， 用 everything 全局搜索一下。 ----> https://oss.sonatype.org/content/groups/public/org/robolectric/android-all/9-robolectric-4913185-2/android-all-9-robolectric-4913185-2.jar // 简单示范 @RunWith(RobolectricTestRunner.class) @Config( sdk = 28) public class TestShow { @Test public void myTest(){ Context context = RuntimeEnvironment.application.getApplicationContext() ; MyDeviceTool myDeviceTool = new MyDeviceTool(); String packageName =myDeviceTool.getPackageName(context) ; WkLogTool.showLog(\"packageName=\"+packageName); } } 无版权 可以无限制使用！ all right reserved，powered by Gitbook该文件更新时间： 2020-12-23 15:22:07 "},"chinese/android基础/代码混淆.html":{"url":"chinese/android基础/代码混淆.html","title":"代码混淆","keywords":"","body":"代码混淆 混淆规则 guardsquare androidstudio 使用混淆 // build.gradle 文件下 (这是系统默认生成的，可以修改) 1、导入 xxx\\tools\\proguard\\proguard-android.txt 。 这里面是一些比较常规的不能被混淆的代码规则。 2、导入当前工程里面的 proguard-rules.pro 。这里是一些自定义的混淆规则。 proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.pro' //是否开启混淆 true or false minifyEnabled true 不参与混淆部分 混淆了这些内容，会导致出错。 1、 自定义控件 2、 枚举 3、 第三方库中的类 （作者一般会标明） 4、 运用了反射的类 5、 使用了 Gson 之类的工具的实体类 6、 WebView 的 JS 的接口方法 7、 Parcelable 的子类和 Creator 静态成员变量不混淆 保留整个包 # 保持该包下的类名 (子包下的会被混淆) -keep class cn.wk.test.* # 把本包和所含子包下的类名都保持 -keep class cn.wk.test.** # 保持类名和里面的内容不被混淆 -keep class com.example.bean.** { *; } 自用的 aar 混淆 # 代码混淆压缩比，在0~7之间，默认为5,一般不下需要修改 -optimizationpasses 5 # 混淆时不使用大小写混合，混淆后的类名为小写 -dontusemixedcaseclassnames # 不混淆第三方引用的库 不忽略library里面非public修饰的类 ？？？ -dontskipnonpubliclibraryclasses # 指定不忽略非public类里面的成员和方法 -dontskipnonpubliclibraryclassmembers # 不做预检验， 去掉这一步可以加快混淆速度 -dontpreverify # 把所有信息都输出，而不仅仅是输出出错信息 -verbose #apk 包内所有 class 的内部结构 ?? -dump class_files.txt # 列出了没有被混淆的类和成员 -printseeds seeds.txt #列出从 apk 中删除的代码 -printusage unused.txt #混淆前后的映射 -printmapping mapping.txt # 混淆时所采用的算法 ，后面的参数是一个过滤器 # 这个过滤器是谷歌推荐的算法，一般不改变 -optimizations !code/simplification/artithmetic,!field/*,!class/merging/* #保留Annotation不混淆 -keepattributes *Annotation*,InnerClasses # 避免混淆泛型 -keepattributes Signature # 保留异常 -keepattributes Exceptions # 抛出异常时保留代码行号 -keepattributes SourceFile,LineNumberTable # 不打印指定类的警告信息 -ignorewarnings #==================================【项目配置】================================== # 保留所有的本地native方法不被混淆 -keepclasseswithmembernames class * { native ; } # 保留了继承自Activity、Application (四大组件等)这些类的子类 -keep public class * extends android.app.Activity -keep public class * extends android.app.Application -keep public class * extends android.app.Service -keep public class * extends android.content.BroadcastReceiver -keep public class * extends android.content.ContentProvider -keep public class * extends android.app.backup.BackupAgentHelper -keep public class * extends android.preference.Preference -keep public class * extends android.view.View -keep public class com.android.vending.licensing.ILicensingService -keep public class * extends android.database.sqlite.SQLiteOpenHelper{*;} # 如果有引用android-support-v4.jar包，可以添加下面这行 -keep public class com.null.test.ui.fragment.** {*;} #如果引用了v4或者v7包 -dontwarn android.support.** # 保留Activity中的方法参数是view的方法 -keepclassmembers class * extends android.app.Activity { public void * (android.view.View); } # 枚举类不能被混淆 -keepclassmembers enum * { public static **[] values(); public static ** valueOf(java.lang.String); } # 不混淆反射 -keepattributes EnclosingMethod # 保留自定义控件(继承自View)不能被混淆 -keep public class * extends android.view.View { public (android.content.Context); public (android.content.Context, android.util.AttributeSet); public (android.content.Context, android.util.AttributeSet, int); public void set*(***); *** get* (); } # 保留Parcelable序列化的类不能被混淆 -keep class * implements android.os.Parcelable{ public static final android.os.Parcelable$Creator *; } # 保留Serializable 序列化的类不被混淆 -keepclassmembers class * implements java.io.Serializable { static final long serialVersionUID; private static final java.io.ObjectStreamField[] serialPersistentFields; !static !transient ; private void writeObject(java.io.ObjectOutputStream); private void readObject(java.io.ObjectInputStream); java.lang.Object writeReplace(); java.lang.Object readResolve(); } # 对R文件下的所有类及其方法，都不能被混淆 -keepclassmembers class **.R$* { *; } # 对于带有回调函数onXXEvent的，不能混淆 -keepclassmembers class * { void *(**On*Event); } #==================================【根据自己的项目（自己写的代码），配置需要 忽略混淆的类================================== -keep class org.litepal.** { *; } -keep class com.walkera.wktools.** { *; } #==================================【根据自己的项目（自己引用的第三方jar），配置需要 忽略混淆的类================================== # ant.jar #-libraryjars libs/ant.jar -keep class org.apache.** { *; } # ftp4j.jar #-libraryjars ./libs/ftp4j-1.7.2.jar -keep class it.sauronsoftware.** { *; } # guava.jar #-libraryjars ./libs/guava-17.0.jar -keep class com.google.** { *; } # netty.jar #-libraryjars ./libs/netty-all-4.0.25.Final.jar -keep class io.netty.** { *; } # nineoldandroids.jar #-libraryjars ./libs/nineoldandroids-2.4.0.jar -keep class com.nineoldandroids.** { *; } 无版权 可以无限制使用！ all right reserved，powered by Gitbook该文件更新时间： 2020-08-26 09:55:23 "},"chinese/android基础/Glide图片三级缓存.html":{"url":"chinese/android基础/Glide图片三级缓存.html","title":"Glide图片三级缓存","keywords":"","body":"Glide图片三级缓存 Glide 特点 https://github.com/bumptech/glide 1、Glide.with(xxx)方法 接受 Context、Activity 、 Fragment 。 建议使用后面两个。因为图片加载会和Activity 、Fragment的生命周期保持一致。 2、支持加载 gif 格式。 缓存类型 缓存类型 说明 原图 原始图片 处理图 经过压缩和变形等处理后的图片 缓存存储位置 可以设置 最大内存缓存空间大小、最大磁盘缓存空间大小、 缓存失效时间 。 存储位置 | 缓存策略 | 采用算法 -|-|- 1、内存缓存| 缓存处理图|LruCache + 弱引用 2、磁盘缓存|1、只缓存处理图 2、 只缓存原图 3、缓存原图和处理图 4、什么都不缓存| 3、网络资源|| LruCache 算法 Least Recently Used Cache /近期最少使用 。核心思想是当缓存满时，会优先淘汰那些近期最少使用的缓存对象。 Glide 简单使用 RequestOptions requestOptions = new RequestOptions() .placeholder(R.mipmap.icon_us) //.diskCacheStrategy(DiskCacheStrategy.NONE) //.skipMemoryCache(true) // 缓存失效策略 ，key 不一样 缓存就会失效 .apply(RequestOptions.signatureOf(new ObjectKey(getSignatureKey()))) .error(R.mipmap.icon_us); Glide.with(activity) // 根据路径、File 加载 .load(filePath) .apply(requestOptions) .into(userImg); private long getSignatureKey() { ///long key = System.currentTimeMillis() / INVALID_TIME long key = System.currentTimeMillis() ; return key ; } // 当通过get访问接口 ，直接返回图片流的时候。 可以直接加载这个接口也可以显示。 // 不需要 去 加载接口返回的值。 无版权 可以无限制使用！ all right reserved，powered by Gitbook该文件更新时间： 2020-08-26 09:51:56 "},"chinese/android基础/APP的启动流程.html":{"url":"chinese/android基础/APP的启动流程.html","title":"APP的启动流程","keywords":"","body":"android 相关 启动流程 本文的分析都是 基于 android-7.1.1-r1 的源码。 有些类可能在高版中会被废弃。 例如 自 API 26(android8.0 ) ，代理类 ActivityManagerProxy 已经被删除。 init 进程 它是内核启动的第一个用户级进程,它的进程号总是1 。 init的入口函数 // system/core/init/init.cpp int main(int argc, char** argv) { property_init(); // 对属性进行初始化 start_property_service(); // 启动属性服务 parser.ParseConfig(\"/init.rc\"); // 解析init.rc配置文件并启动zygote进程 } zygote 进程 ，受精卵 进程 zygote 由 init进程 通过 fork 的方式创建启动的。 zygote 是Android系统上所有应用进程的父进程，我们系统上app的进程都是由这个zygote分裂出来的。 SystemServer 进程 zygote 进程 fork 出 SystemServer 进程 android\\internal\\os\\ZygoteInit.java public static void main(String argv[]) { startSystemServer(abiList, socketName); // 启动 SystemServer 进程 ，根据反射 fork 出 } PackageManagerService 服务 、PMS 由 SystemServer 服务启动 。 // SystemServer.java , startBootstrapServices() mPackageManagerService = PackageManagerService.main(... ); ActivityManagerService 服务 、 AMS 由 SystemServer 服务启动 。 所有的APP应用都需要 与 AMS 打交道. // SystemServer.java , startBootstrapServices() mActivityManagerService = mSystemServiceManager.startService( ActivityManagerService.Lifecycle.class).getService(); Launcher 启动流程 、 Launcher3 app Launcher app 由 AMS 启动 。 // ActivityManagerService.java , Intent getHomeIntent() { // 启动 的 桌面程序 intent.addCategory(Intent.CATEGORY_HOME); } Launcher APP 启动流程 1、内核启动 2、内核启动 init 进程 3、init 进程 fork Zygote 进程 4、zygote 进程 fork 出 SystemServer 进程 5、SystemServer 服务 启动 AMS 、 PackageManagerService 服务 6、AMS 启动 Launcher app 点击桌面 app 图标 到打开 APP的流程 1、点击App图标，Launcher 用 Binder 跨进程 向 SystemServer 进程发起 startActivity 请求 2、SystemServer 进程接收到请求后，向 zygote 进程发送创建进程的请求 3、zygote 进程 fork 出新的子进程（即App进程） 4、App进程 通过 Binder 向 SystemServer 进程发起 attachApplication() 请求 5、SystemServer 进程在收到请求后，进行一系列准备工作后， 再通过 Binder 向App进程 发送 scheduleLaunchActivity() 请求； 6、App进程 的 binder 线程 ApplicationThread 在收到请求后， 通过handler向主线程发送 LAUNCH_ACTIVITY 消息； 7、主线程在收到 Message 后，通过 handler 机制 创建目标Activity，并回调 Activity.onCreate() 等方法。 Activity 启动流程 、startActivity 启动过程 整个流程有点复杂，不看着源码讲有点麻烦。可以参考这篇博客 http://gityuan.com/2016/03/12/start-activity/ 相关类 Instrumentation .java 每个 Activity 都持有 Instrumentation 对象的一个引用， 但是整个进程只会存在一个 Instrumentation 对象。 Instrumentation 这个类里面的方法大多数和 Application 和 Activity 有关， 这个类就是完成对 Application 和 Activity 初始化和生命周期的工具类 ,是一个大管家。 ActivityThread 在 ActivityThread .java 中定义 负责与 AMS 交互。 ApplicationThread 在 ActivityThread .java 中定义 ``` ### ActivityStack ### ActivityStackSupervisor ### ActivityManagerProxy ### ApplicationThreadProxy ## 如何判断一个 APP 在前台还是后台 借用系统 ActivityLifecycleCallbacks 的回调来进行判断。 进入后台后，有一些机型貌似弹不出toast，比如华为M3 。 暂时没找到解决办法，我试过一些银行的APP 和所得税APP，同样也弹不出来。 ```text // 原理：程序中任何一个activity处于后台时(onStope)都将触发提醒。 // 所以，如果顶层activity中onStope方法被执行，则认为程序处于后台。 public class MyAppLifecycleHandler implements Application.ActivityLifecycleCallbacks { private int started = 0; private int stopped = 0; private String lastActivitName ; private boolean flag = true; public MyAppLifecycleHandler(String name){ lastActivitName= name ; } @Override public void onActivityCreated(Activity activity, Bundle savedInstanceState) { } @Override public void onActivitySaveInstanceState(Activity activity, Bundle outState) { } @Override public void onActivityResumed(Activity activity) { } @Override public void onActivityPaused(Activity activity) { } @Override public void onActivityStarted(Activity activity) { ++started; } @Override public void onActivityStopped(final Activity activity) { ++stopped; if (!isApplicationInBackground()){ return; } flag = true; new Handler().postDelayed(new Runnable() { @Override public void run() { if ( flag ) { Toast.makeText(activity, \"WkPlayer被切换至后台\", Toast.LENGTH_SHORT).show(); } } // 延时的作用是用来等待一下，看 onActivityDestroyed 是否被执行了。 } ,500) ; } @Override public void onActivityDestroyed(Activity activity) { if (lastActivitName.contains(activity.getClass().getSimpleName())) { flag = false; } } private boolean isApplicationInBackground() { return started == stopped; } } // Application 中调用 MyAppLifecycleHandler lifecycleHandler = new MyAppLifecycleHandler( FileExplorerActivity.class.getSimpleName() ) ; unregisterActivityLifecycleCallbacks(lifecycleHandler); registerActivityLifecycleCallbacks( lifecycleHandler ) ; 无版权 可以无限制使用！ all right reserved，powered by Gitbook该文件更新时间： 2020-12-17 10:35:28 "},"chinese/android基础/屏幕适配.html":{"url":"chinese/android基础/屏幕适配.html","title":"屏幕适配","keywords":"","body":"屏幕适配 术语 术语 解释 屏幕尺寸 屏幕的对角线的长度 屏幕分辨率 屏幕的宽和高的像素数 density 屏幕密度，等于dpi/160 。 表示 每英寸有多少个显示点 dpi 像素密度 ， dots per inch px 每一个光点就是一个像素。 dp , dip device independent pixels ， 基于屏幕密度抽象长度单位，在每英寸160点的显示器上，1dp = 1px。 ppi pixels per inch 屏幕尺寸、屏幕分辨率、像素密度的关系 为什么规定160dpi规格的显示器上，1dp = 1px px=dp*（dpi/160） Google的官方文档中给出解释，因为第一款Android设备（HTC的T-Mobile G1）是属于160dpi的。于是就成为标准了。 常用公式 px = density * dp // 例如 density=2时 ，1dp =2px density = dpi / 160 // 例如 dpi=320时 ， density =2 px = (dpi / 160) * dp // 例如 dpi=320时 ， 1dp = 2px 引起适配问题的根源 1、屏幕密度不一样 density 。 举例： A 、B 手机的分辨率都是 1080 *1920 ， 但是 A的 密度为 160 ， B的密度为 320 。 此时你设置一条线的长度 为 1080dp ，在A手机上 刚好占满 长度， 但是在 B手机中只能占据一半 。 2、设备的长宽比例不一样。 假如 设计师的 基于 4：3 比例的屏幕设计的效果图 ，无论如何不可能跟 在 16：9上的效果一样的。 采用的适配方案一般是根据图片宽度 跟比等比例决定图片的高度。 适配思路 因为目前设备的长宽比是不一样的，所以一套设计图在不同的设备上的效果不可能是一模一样的。一般遵循以下原则即可。 1、可以上下滑动的界面，保证宽的纬度与设计图一致 。 2、不支持上下滑动的界面 ，保证高的纬度与设计图一致 。 //为了满足“显示比例和设计的长宽比例一致”，某些地方只能做留白处理。 3、 多使用 wrapcontent matchparent 以及线性布局的权重 4、多套xml 布局 方案 // 感觉很繁琐，基本很难采用。 布局限定符。 业界 推荐的 适配方案 1、今日头条的 代码 更改 屏幕密度 density 的方案。 缺点就是非常依赖设计图，假如引入的第三方的一些控件 跟设计图相差较大，效果就不太好。 2、多套 diments.xml 方案。将市面上主流的手机 收集起来，生成 values-sw320dp 等 values-xxx 的文件夹 ， 每个文件夹里 有同名文件 diments.xml , xxdp ,xx的值各不相同。 缺点是会增加 xml 文件数量 增加apk 大小。 其他 //以 设计师给定的 图片屏幕尺寸作为标准 ， 返回当前设备下的触摸点坐标 public static int getValues_x(Context context, int value_x){ return (int) ((float) value_x / 720 * MyDeviceInforHelper .getWindowWidth(context)); } 无版权 可以无限制使用！ all right reserved，powered by Gitbook该文件更新时间： 2020-10-15 17:28:54 "},"chinese/android基础/Android外挂.html":{"url":"chinese/android基础/Android外挂.html","title":"Android外挂","keywords":"","body":"安卓外挂 AccessibilityService https://gitee.com/hnyer/wechat-tool 安卓辅助功能服务 。简单的说无障碍就是一个后台监控服务，当你监控的内容发生改变时，就会调用后台服务的回调方法。 4.0以前，Accessibility功能单一，仅能过单向获取窗口信息(获取输入框内容)； 4.0及以后，Accessibility增加了与窗口元素的双向交互，可以操作窗口元素(点击按钮)。 具体案例可以参考 开头的demo 。 无版权 可以无限制使用！ all right reserved，powered by Gitbook该文件更新时间： 2020-09-18 14:43:22 "},"chinese/android基础/智能家居.html":{"url":"chinese/android基础/智能家居.html","title":"智能家居","keywords":"","body":"智能家居 http://hnyer.gitee.io/nativedev/chinese/linux/linux%E5%9F%BA%E7%A1%80.html?h=%E6%A0%91%E8%8E%93%E6%B4%BE 红外遥控器 红外遥控功能从Android4.4之后才开始支持。 家电遥控器通信距离往往要求不高，而红外的成本比其它无线设备要低的多，所以家电遥控器应用中红外始终占据着一席之地。 遥控器的基带通信协议很多，大概有几十种，常用的就有 ITT 协议、NEC 协议、Sharp 协议、Philips RC-5 协议、Sony SIRC 协议等。 用的最多的就是 NEC 协议了。 NEC协议 有开发需求的时候 再查文档 进行调试。 https://gitee.com/hnyer/ir_-remote-control 无版权 可以无限制使用！ all right reserved，powered by Gitbook该文件更新时间： 2020-10-19 16:07:18 "},"chinese/自定义控件/分贝波形图.html":{"url":"chinese/自定义控件/分贝波形图.html","title":"andrid自定义控件实例","keywords":"","body":"分贝波形图 /** * 声音波形的view * 波形能左右移动的原理： * 将自定义控件分成 listMaxSize 份，每份对应一个分贝值 ， * 根据分贝值的大小 来决定 线条的高度。 * 分贝值更新引起ui更新，所以会形成从左向右效果。 * mRecDataList.add(dbValue) ; * mRecDataList.remove(0) ; */ public class AudioWaveView extends View { private Bitmap mBackgroundBitmap; private Canvas mBackCanVans = new Canvas(); /**波浪的画笔*/ private Paint mPaint; /**绘制最终画面的 画笔*/ private Paint mViewPaint; private final ArrayList mRecDataList = new ArrayList<>(); private int mScale = 1; /**控件总长度*/ private int viewWidth; /**高度中间线 ，作为基准线*/ private int mBaseLine; /**波形之间线与线的间隔*/ private int smaleLineWidth = 0; /**一共画多少个小线条*/ int listMaxSize = 0 ; /**是否画出基线*/ private boolean mDrawBase = true; private boolean mPause = false; /**1 只画上面的波纹 ，2、上下都画*/ private int mWaveCount = 2; private Context context ; public AudioWaveView(Context context) { super(context); init(context, null); } public AudioWaveView(Context context, AttributeSet attrs) { super(context, attrs); init(context, attrs); } public AudioWaveView(Context context, AttributeSet attrs, int defStyleAttr) { super(context, attrs, defStyleAttr); init(context, attrs); } @Override protected void onDetachedFromWindow() { super.onDetachedFromWindow(); if (mBackgroundBitmap != null && !mBackgroundBitmap.isRecycled()) { mBackgroundBitmap.recycle(); } } public void init(Context context, AttributeSet attrs) { // 防止因为xml可视化失败导致编译错误 if (isInEditMode()){ return; } this.context = context ; mPaint = new Paint(); mPaint.setColor(Color.parseColor(\"#00ff33\")); mViewPaint = new Paint(); } @Override protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) { super.onMeasure(widthMeasureSpec, heightMeasureSpec); creatBackGroundBitmap(); } @Override protected void onVisibilityChanged(@NonNull View changedView, int visibility) { super.onVisibilityChanged(changedView, visibility); if (visibility == VISIBLE && mBackgroundBitmap == null) { creatBackGroundBitmap(); } } private void creatBackGroundBitmap() { ViewTreeObserver vto = getViewTreeObserver(); vto.addOnPreDrawListener(new ViewTreeObserver.OnPreDrawListener() { @Override public boolean onPreDraw() { if (getWidth() > 0 && getHeight() > 0) { smaleLineWidth = WkDeviceInforTool.getPixByDp( context ,2) ; listMaxSize = getWidth() / smaleLineWidth ; viewWidth = getWidth(); mBaseLine = getHeight() / 2; mBackgroundBitmap = Bitmap.createBitmap( getWidth(), getHeight(), Bitmap.Config.ARGB_8888); mBackCanVans.setBitmap(mBackgroundBitmap); mBackCanVans.drawColor(Color.TRANSPARENT, PorterDuff.Mode.CLEAR); ViewTreeObserver vto = getViewTreeObserver(); // 移除绘制回调函数 vto.removeOnPreDrawListener(this); } return true; } }); } private void updateDrawParam(){ ArrayList dataList = new ArrayList<>(); synchronized (mRecDataList) { if (mRecDataList.size() != 0) { try { dataList = (ArrayList) deepCopy(mRecDataList); } catch (Exception e) { e.printStackTrace(); } } } if (!mPause) { // 获得最新缩放参数 updateScale(dataList); if (mBackCanVans != null) { // 清除画布 mBackCanVans.drawColor(Color.TRANSPARENT, PorterDuff.Mode.CLEAR); // 绘制基准线 if (mDrawBase) { mBackCanVans.drawLine(0, mBaseLine, viewWidth, mBaseLine, mPaint); } //绘制小线条形成波浪 int dbSize = dataList.size(); for (int i = 0, j = 0; i list) { int allMax = 0; for (int i = 0; i allMax) { allMax = sh; } } int curScale = allMax / mBaseLine; if (curScale > mScale) { mScale = curScale == 0 ? 1 : curScale ; } } /** * 停止绘制 */ public void stopView( ) { mRecDataList.clear(); mBackCanVans.drawColor(Color.TRANSPARENT, PorterDuff.Mode.CLEAR); } public void updateDataList(int dbValue ){ if(mRecDataList.size() > listMaxSize){ mRecDataList.add(dbValue) ; mRecDataList.remove(0) ; }else{ mRecDataList.add(dbValue) ; } updateDrawParam(); } } 无版权 可以无限制使用！ all right reserved，powered by Gitbook该文件更新时间： 2020-08-19 17:20:00 "},"chinese/源码阅读/源码阅读配置.html":{"url":"chinese/源码阅读/源码阅读配置.html","title":"源码阅读","keywords":"","body":"源码阅读 androidstudio 查看自带的sdk中的源码 1、在 Androidstudio中点击自己的代码想往下查看源码时， throw new RuntimeException(\"Stub!\" 这是因为没有匹配到对应版本的源码，此时按提示下载源码即可。 2、有一些源码被加了 @hide标签，从 Androidstudio中看不到， 可以从 https://github.com/anggrayudi/android-hidden-api 下载对应版本的 android.jar 替换掉。 3、替换掉 android.jar 后，Androidstudio 报错 ERROR: Execution failed for MockableJarTransform 这是 com.android.tools.build:gradle:x.x.x 版本的问题, 高版本的 gradle中加了一些校验机制， https://github.com/anggrayudi/android-hidden-api/issues/46 4、最终配置 compileSdkVersion 27 targetSdkVersion 27 classpath 'com.android.tools.build:gradle:3.1.4' Androidstudio查看整个Android系统的源码 只能阅读，不能编译。 这里给出 android-8.1.0_r1 版本的源码。 源码地址 https://gitee.com/hnyer/android-8.1.0_r1_learning 1、下载好源码解压，此时导入Androidstudio 只能查看，不能点击跳转。 2、将 android.iml 、android.ipr 两个文件放到根目录。此时可能仍然不能跳转。 3、进入 project Structure --> Modules ，将所有文件都设置成 sources 选项。 4、如果查看源码的时候展示的是 xxx.class ，连接的是 android.jar ， 你将连接指向 F:\\sdk2\\sources\\android-29 即可(举例)。 无版权 可以无限制使用！ all right reserved，powered by Gitbook该文件更新时间： 2020-12-08 14:24:51 "},"chinese/人工智能/人工智能相关概念.html":{"url":"chinese/人工智能/人工智能相关概念.html","title":"人工智能","keywords":"","body":"人工智能 熵 就是对信息的不确定性，如果我们对一个信息掌握得好，对应的熵就会低，反之就高。信息熵是表示随机变不确定性的度量。熵越大，信息量越大，也就是越不确定。 拟合 形象的说，拟合就是把平面上一系列的点，用一条光滑的曲线连接起来。 因为这条曲线有无数种可能，从而有各种拟合方法。拟合的曲线一般可以用函数表示. 它是对我们数据点的一个近似表达。在开始阶段, 红线的表达能力不强, 误差很大。 不过通过不断的学习, 预测误差将会被降低. 所以学习到后来. 红线也能近似表达出数据的样子. 张量（Tensor) 零阶张量为 纯量或标量 (scalar) 也就是一个数值. 比如 [1] 一阶张量为 向量 (vector), 比如 一维的 [1, 2, 3] 二阶张量为 矩阵 (matrix), 比如 二维的 [[1, 2, 3],[4, 5, 6],[7, 8, 9]] 以此类推, 还有 三阶 三维的 … 无版权 可以无限制使用！ all right reserved，powered by Gitbook该文件更新时间： 2020-08-26 10:01:12 "},"chinese/人工智能/TensorFlow.html":{"url":"chinese/人工智能/TensorFlow.html","title":"TensorFlow","keywords":"","body":"TensorFlow 通过 Anaconda 来安装 tensorFlow 和其他依赖的库。 然后用 pycharm 来进行编写代码。 pycharm里面的 python.exe 要指定为 Anaconda 里面的那个 python.exe 。（否则 无法 import tensorflow） 无版权 可以无限制使用！ all right reserved，powered by Gitbook该文件更新时间： 2020-08-19 17:20:00 "},"chinese/产品经理/常用概念.html":{"url":"chinese/产品经理/常用概念.html","title":"产品经理","keywords":"","body":"工具 Axure 软件安装 Axure 原型制作工具 1、安装包 测试版本为8.1.0.3377 安装包在我百度盘有备份 2、汉化 汉化包也在百度盘 将汉化包解压，将其中的 lang文件夹, 复制到Axure 安装目录下即可。 3、破解 于20180907测试可用，以后可能会失效。 zdfans.com gP5uuK2gH+iIVO3YFZwoKyxAdHpXRGNnZWN8Obntqv7++FF3pAz7dTu8B61ySxli 类型 保真度 用途 特点 费用 线框图 低 文档、快速交流、表达设计思路和大纲 手绘草图，不能交互 低 原型 中 模拟成品的交互流程 可以交互 高 视觉稿 高 给非专业人看的，视觉感受 静态视觉设计，不能交互 中 类图(Class Diagram) 对象图(Object Diagram) 包图(Package Diagram) 组件图(Component Diagram) 部署图(Deployment Diagram) 用例图(User Case Diagram) 顺序图/序列图/时序图(Sequence Diagram) ---> 交互图 状态机图、状态图(State Machine Diagram) 协作图、通信图(Communlcation Diagram) 活动图(Activity Diagram) PERT图 项目评估与评审技术 Project Evaluation and Review Technique 可以使用亿图图示绘制 pert图示例 UML流程图 绘制软件 推荐使用 Visio 、processon 流程图符号 类型 作用 图形 开始 / 结束 代表“开始”、“结束” 过程 一个步骤或操作 判断 if else 数据 输入/ 输出 输入、输出的数据 箭头、连接线 工作流方向 文档 输入、输出的文件 多文档 外部数据 表示数据来自外部 数据库 表示从数据库中获取数据信息 内部存储 指数据提交之后，需要写入数据库 队列数据 表示数据处理的一种方式 直接数据 人工输入 用户通过键盘等手动输入的数据 人工操作 表示需要用户手动操作调整的内容 比如修改、搜索、删除、提交等 手动操作 卡片 穿孔卡是早期计算机的信息输入设备 纸带、条带 参考卡片 展示内容 在设备上展示信息 循环限值 是指循环开始或结束的条件 子流程 并行模式 表示同时进行 （在并行模式的框内可以添加其它的部件） 预定义流程 人员 注释 批注 页面内引用 相当于一个页面内的跳转 跨页引用 相当于一个跨页的连接器 预备 进入流程前的准备状态 推迟、延期 UML状态图 State Machine Diagram 用于描述一个特定的对象的所有可能状态以及由于各种事件的发生而引起的状态之间的转换。 概念 意义 图示 状态 开始 、其他状态、结束 转移 两个状态之间的一种关系 表示对象将在第一个状态中执行一定的动作， 并在某个特定事件发生而某个特定的条件满足时进入第二个状态 UML用例图 User Case Diagram 用例图从用户角度描述系统的静态使用情况 类型 作用 图示 角色、参与者 在系统外部与系统直接交互的人或事物 用例 系统外部可见的一个系统功能单元 系统边界、容器 用来展示系统的一部分功能，这部分功能联系紧密 关系 有4种：关联、泛化、包含、扩展 关系 意义 图示 备注 关联 箭头指向消息接收方 泛化 继承关系 箭头指向父类 包含 用来体现一个用例功能的多个子功能 拓展 是指用例功能的延伸，相当于为基础用例提供一个附加功能 UML类图 Unified Modeling Language 统一建模语言 绘制UML类图的软件推荐 Enterprise Architect 或 processon 作用域类型 符号 public + private - protected # 元素类型 图示 包 类 接口 元素之间的关系 定义 举例 备注 泛化（Generalization） 继承 箭头指向父类 实现（Realization） 类实现接口 箭头指向接口 关联（Association) 拥有关系 箭头指向被拥有者 聚合（Aggregation） 整体与部分的关系。部分可以单独存在。 菱形指向整体 组合(Composition) 整体与部分的关系 部分不能单独存在。 图标有2种菱形指向整体 依赖(Dependency) A需要B的协助才能完成某项功能 箭头指向被使用者 甘特图 甘特图最早由Henry L.Gantt在1917年提出。 甘特图是一个二维平面图， 横纬度 显示了每项工作的开始时间和结束时间，横道线的长度表示了该项工作的持续时间。 纵维表示工作内容 绘制工具可以使用 雁阵 其他 五大过程组 、十大知识领域 项目管理常用缩写 缩写 解释 AC 实际成本 。 Actual Cost : 在一个给定的时间段内，为完成进度活动或工作分解结构组成部分的工作，而实际发生并记录在案的总成本。实际成本有时仅为直接工时或直接成本，有时也为包括间接成本在内的所有成本。实际成本也称“已完工作实际成本（ACWP）”。参见“挣值管理”和“挣值技术”。 ACWP 已完成工作实际成本- Actual Cost of Work Performed : 见“实际成本”。AC BAC 完工预算- Budget At Completion：项目工作、工作分解结构组成部分或进度活动的所有预算之和，即项目的总计划价值。即PV之和 BCWP 已完成工作预算成本- Budgeted Cost of Work Performed：见“挣值”。EV BCWS 计划工作预算成本- Budgeted Cost of Work Scheduled：见“计划价值”。PV CCB 变更控制委员会-Change Control Board：由干系人正式组成的团体，负责审议、评价、批准、推迟或否决项目变更，所有决定和建议均应记录在案。 COQ 质量成本-Cost Of Quality：确定为保证质量而付出的成本的一种方法。预防和评估成本（一致性成本）包括为确保符合要求而进行质量规划、质量控制和质量保证的成本（即培训、质量控制体系等）。缺陷成本（非一致性成本）包括对不合格产品、部件或过程的返工成本，保修工作和废品的成本，以及名誉的损失。 CPF 成本加费用-Cost Plus Fee: CPFF 成本加固定费用- Cost Plus Fixed Fee [Contract]：成本补偿合同的一种类型，买方为卖方报销可列支成本（可列支成本由合同确定），再加上一笔固定数额的利润（费用）。 CPAF 成本加奖励费用- Cost Plus Award Fee [Contract]：为卖方报销履行合同工作所发生的一切合法成本，但是只有在满足了合同中规定的某些笼统、主观的绩效标准的情况下，才能向卖方支付大部分费用。完全由买方根据自己对卖方绩效的主观判断来决定奖励费用，并且卖方通常无权申诉。 CPIF 成本加激励费用- Cost Plus Incentive Fee [Contract]：成本补偿合同的一种类型，买方为卖方报销可列支成本（可列支成本由合同确定），并且卖方在达到规定绩效标准时赚取利润。 CPI 成本绩效指数-Cost Performance Index：项目成本效率的一种指标，是挣值（EV）与实际成本（AC）之比。CPI=EV／AC。 CPM 关键路径法-Critical Path Methodology：一种进度网络分析技术，用来确定项目进度网络中各条逻辑路径的灵活性大小（浮动时间大小），进而确定整个项目的最短工期。从规定的开始日期开始，利用顺推计算法计算最早开始和完成日期。从规定的完成日期（可能是顺推计算所得到的项目最早完成日期）开始，利用逆推计算法计算最晚开始和完成日期。 CV 成本偏差-Cost Variance：项目成本绩效的一种指标，是挣值（EV）与实际成本（AC）之差。CV=EV−AC。 DU or DUR Duration (DU or DUR) 持续时间：完成某进度活动或工作分解结构组成部分所需的工作时段总数（不包括节假日或其他非工作时段）。通常用工作日或工作周表示。有时被错误地等同于“自然流逝时间”。与“人力投入”比较。 EAC 完工估算[输出／输入] -Estimate at Completion [Output/Input] ：为完成某进度活动、工作分解结构组成部分或整个项目所需的预期总成本。EAC 既可以根据迄今为止的实际绩效进行计算，也可以由项目团队根据其他因素做出估算，后者也常称“最新修订估算”。参见“挣值技术”和“完工尚需估算”。 ETC 完工尚需估算[输出／输入] -Estimate to Completion[Output/Input ]：为完成某进度活动、工作分解结构组成部分或整个项目的所有剩余工作而预计需要的成本。参见“挣值技术”和“完工估算”。 EV 挣值-Earned Value Management ：进度活动或工作分解结构组成部分的已完成工作的价 值，用分配给该工作的预算数来表示。也称“已完工作预算成本（BCWP）”。 ES 最早开始时间-Earliest Start Date：在关键路径法中，基于进度网络逻辑、数据日期和所有进度制约因素，某进度活动（或项目）的未完部分可能开始的最早时点。最早开始日期可随项目的进展和项目管理计划的变更而改变。 EF 最早结束时间-Earliest Finish Date：在关键路径法中，基于进度网络逻辑、数据日期和所有进度制约因素，某进度活动（或项目）的未完部分可能完成的最早时点。最早完成日期可随项目的进展和项目管理计划的变更而改变。 EMV 预期货币价值分析- Expected Monetary Value Analysis：当某些情况在未来可能发生、也可能不发生时，计算平均结果的一种统计技术。这种技术经常在决策树分析中使用。 FF 完成到完成- Finish to Finish：只有当紧前活动完成，紧后活动才能完成的逻辑关系。参见“逻辑关系”。 FFP 固定总价[合同]- Firm Fixed Price [Contract]：不考虑卖方实际成本，由买方向卖方支付事先确定的金额（由合同规定）的一种总价合同。 FPIF 总价加激励费用- Fixed Price Incentive Fee FP-EPA 总价加经济价格调整- Fixed Price with Economic Price Adjustment FMEA 失效模式与影响分析[技术]：-Failure Mode and Effect Analysis [Technique]：一种分析程序用来分析产品的每个部件的每种可能失效模式及其对该部件的可靠性的影响，并确定每种失效模式本身或与其他失效模式联合将对产品或系统的可靠性的影响，或对该部件的必备功能的影响；或者，用来检查产品（在整个系统和／或较低层次上）的所有可能失效模式。对于每一种可能的失效，都要估计对整个系统的影响。此外，还应该审查为降低失效的概率和影响而计划采取的行动。 FS 完成到开始- Finish to Start：紧后活动的开始依赖于紧前活动的完成的逻辑关系。参见“逻辑关系”。 IFB 投标邀请书- Invitation For Bid：通常本术语等同于建议邀请书。但在某些应用领域，其含义可能更狭窄或更具体。 LS 最晚开始日期-Late Start Date：在关键路径法中，基于进度网络逻辑、项目完成日期和任何施加于进度活动的制约因素，在不违反进度制约因素或延误项目完成日期的条件下，允许某进度活动最晚开始的时点。最晚开始日期在项目进度网络的逆推计算中确定。 LF 最晚完成日期- Late Finish Date：在关键路径法中，基于进度网络逻辑、项目完成日期和任何施加于进度活动的制约因素，在不违反进度制约因素或延误项目完成日期的条件下，允许某进度活动最晚完成的时点。最晚完成日期在项目进度网络的逆推计算中确定。 LOE 人力投入量- Level of Effort OBS 组织分解结构[工具]- Organizational Breakdown Structure [Tool]：对项目组织的一种层级描述，以便把工作包与相应的执行部门联系起来。 PDM 紧前关系绘图法-Precedence Diagramming Method: 一种用方框（或节点）表示计划活动的进度网络图绘制技术。进度活动在图形中按一种或多种逻辑关系连接起来，以显示活动的实施顺序。 PMBOK 项目管理知识体系-Project Management Body of Knowledge：说明项目管理专业范围内的知识总和的概括性术语。与法律、医学、会计等其他专业一样，该知识体系掌握在应用和推进它的实践者和学者手中。完整的项目管理知识体系既包括已被验证并广泛应用的传统做法，也包括本专业新近涌现的创新做法。该知识体系包括已发表和未发表的材料。该知识体系正处于不断演进中。PMI的PMBOK® 指南识别了作为项目管理知识体系一部分的、被普遍公认的良好做法。 PMIS 项目管理信息系统-Project Management Information System：由收集、整合和传播项目管理过程成果的工具和技术所组成的信息系统。它为项目从启动到收尾的所有方面提供支持，可以包括人工和自动系统。 PV 计划价值-Planned Value：为某进度活动或工作分解结构组成部分的预定工作进度而分配且经批准的预算。也称“计划工作预算成本”。 QA 质量保证-Quality Assurance: 审计质量要求和质量控制测量结果，确保采用合理的质量标准和操作性定义的过程 QC 质量控制-Quality Control: 监测并记录执行质量活动的结果，从而评估绩效并建议必要变更的过程。 RACI 执行、负责、咨询、知情-Responsible、Accountable、Consult、Inform RAM 责任分配矩阵- Responsibility Assignment Matrix：一种将项目组织分解结构与工作分解结构联系起来的结构，有助于确保项目工作范围的每个组成部分都被分配给了某个人或某个团队。 RBS 风险分解结构- Risk Breakdown Structure：按风险类别和子类别来排列已识别的项目风险的一种层级结构图，用来显示潜在风险的所属领域和产生原因。风险分解结构通常依具体项目类型定制。 RFI 信息邀请书-Request For Information：采购文件的一种，买方借此邀请潜在卖方就某种产品、服务或卖方能力提供相关信息。 RFP 建议邀请书- Request For Proposal：采购文件的一种，用来向潜在卖方征求对产品或服务的建议书。在某些应用领域，其含义可能更狭窄或更具体。 RFQ 报价邀请书- Request For Quotation：采购文件的一种，用来向潜在卖方征求对普通或标准产品或服务的报价。有时可用来代替建议邀请书。在某些应用领域，其含义可能更狭窄或更具体。 SF 开始到完成- Start to Finish：紧后进度活动的完成取决于紧前进度活动的启 动的逻辑关系。参见“逻辑关系”。 SS 开始到开始- Start to Start：紧后进度活动的启动取决于紧前进度活动的启动的逻辑关系。参见“逻辑关系”。 SV 进度偏差-Schedule Variance：项目进度绩效的一种指标，是挣值（EV）与计划价值（PV）之差。SV=EV-PV。 SPI 进度绩效指数-Schedule Performance Index：项目进度效率的一种指标，是挣值（EV）与计划价值（PV）之比。SPI=EV/PV。 SOW 工作说明书-Statement of Work：对需提供的产品、服务或成果的叙述性说明。 SWOT 优势、劣势、机会、威胁-Strength、Weaknesses、Opportunities、Threats：这种信息收集技术从项目的每一个优势、劣势、机会和威胁的出发，对项目进行考察，以便更全面地考虑风险。 T&M 工料合同-Time & Material Contract：兼具成本补偿和总价合同特征的一种混合合同安排。与成本补偿合同相似，工料合同没有封顶价，因为签订合同时并没有确定合同总价。工料合同的合同价可以像成本补偿合同那样增长。另外，工料合同又与总价合同相似。例如，当买卖双方就某类高级工程师的单价达成一致意见时，该单价就被事先确定了。 TQM 全面质量管理-Total Quality Management WBS 工作分解机构-Work Breakdown Structure：以可交付成果为导向的工作层级分解。其分解的对象是项目团队为实现项目目标、提交所需可交付成果而实施的工作。工作分解结构组织并定义了项目的全部范围。 PERT （Program/Project Evaluation and Review Technique）即计划评审技术 ITTO 是一种输入输出工具法，类似于思维导图。用于项目管理中各种工作内容的计划的过程梳理，能够帮助人们在工作中理清工作思路，做好项目中的优先级排序。 NPV ROI IRR EVM 挣值计算 AT 实际时间 PMB 绩效测量基准 VAC 完工偏差 TCPI 完工尚需绩效指数 141个工具和技术 序号 名称 定义 1 专家判断 对某方面擅长的人就是专家，找专家协助就是专家判断，专家可能是顾问、干系人、团队成员 2 引导技术 用来协调干系人之间的矛盾，以及项目其他要素之间的矛盾。头脑风暴，冲突处理，问题解决和会议管理等，都是引导者可以用来帮助团队和个人完成项目活动的关键技术 3 项目管理信息系统 作为事业环境因素的一部分，项目管理信息系统提供下列工具：进度计划工具，工作授权系统，配置管理系统，信息收集与发布系统，或进入其他在线自动化系统的网络界面。也可用于自动收集和报告关键绩效指标KPI 4 会议 通过会议来讨论和解决项目的相关问题。参会者可包括项目经理，项目团队成员，以及与所讨论问题相关或会受该问题影响的干系人。按照会议目的分为三类：交换信息，头脑风暴或方案评估，制定决策。注意不要把各种会议类型混合在一起。 5 变更控制工具 为了便于开展配置和变更管理，可用一些手工或自动化的工具。工具的选择应基于项目干系人的需要，并考虑组织和环境情况或制约因素。可使用工具来管理变更请求和后续决策，还要关注沟通，以帮助CCB成员履行职责，以及向相关干系人传达决定。例如，变更管理软件，版本控制软件都是软件开发项目常用的变更控制工具 6 变更控制会 CCB开的会，重要干系人组成负责评审、批准变更请求，但不是所有变更都要由CCB来批准。是另一个工具“会议”的一种形式 7 分析技术 用来研究变量之间的复杂关系的各种技术的总称。可用的项目分析技术包括：回归分析，分组方法，因果分析，根本原因分析，预测方法，FMEA，FTA，储备分析，趋势分析，挣值管理，差异分析 8 配置管理系统 整个项目管理系统的一个子系统。它由一系列正式的书面程序组成，用于对以下工作提供技术和管理方面的指导与监督：识别并记录产品、成果、服务或部件的功能特征和物理特征；控制对上述特征的任何变更；记录并报告每一项变更及其实施情况；支持对产品、成果或部件的审查，以确保其符合要求。该系统包括文件和跟踪系统，并明确了为核准和控制变更所需的批准层次，包括变更控制系统 9 工作授权系统 整个项目管理系统的一个子系统。它是一系列正式书面程序的集合，规定如何授权（委托）项目工作，以保证该工作由正确的组织、在正确的时间、以正确的顺序执行。工作授权系统包括发布工作授权所需的步骤、文件、跟踪系统以及审批层次 10 访谈 与干系人直接交流，通常是一对一 11 焦点小组会议 有主持人，分主题、分小组讨论 12 引导式讨论会 跨职能人员讨论：IT行业JAD（联合应用开发）；制造业QFD（质量功能部署,倾听客户的声音） 13 头脑风暴法 面对面，快，容易受别人影响；属于群体创新技术 14 名义小组法 头脑风暴后，对创意进行排序；属于群体创新技术 15 德尔斐法 背靠背，匿名，客观，慢；属于群体创新技术 16 思维导图 圆圈、创意、线连起来；属于群体创新技术 17 亲和图 大量创意，然后找关系，同类的放在一起；属于群体创新技术 18 多标准决策分析 做决策时需要考虑多重相互矛盾的标准，可以建立矩阵表格，基于多重标准作出决策；属于群体创新技术 19 群体决策技术 为达成某种期望结果而对多个未来行动方案进行评估 20 问卷调查 通过设计书面问题，向为数众多的受访者快速收集信息 21 观察 直接观察个人在各自的环境中如何开展工作和实施流程 22 原型法 先造出该产品的实用模型 23 系统交互图 把某个系统置于大背景中，用图形直观地展示该系统与其他系统之间的接口关系。例如，该系统从哪里获得输入，又会向哪里输出什么，该系统与周围环境是什么关系等等 24 文件分析 从各种文件中识别并收集干系人的需求。可供分析的文件包括：商业计划，营销文献，协议，建议邀请书，现行流程，逻辑数据模型，业务规则库，应用软件文档，业务流程或接口文档，其他需求文档，问题日志，政策程序和法规文件 25 产品分析 产品分解、系统分析、需求分析、系统工程、价值工程和价值分析 26 备选方案识别 头脑风暴、横向思维和配对比较，条条大路通罗马 27 分解 把项目可交付成果划分为更小的、更便于管理的组成部分 28 检查 开展测量、审查与核实等活动，来判断工作和可交付成果是否符合要求及产品验收标准 29 滚动式规划 近期详细、远期粗略，计划反复进行 30 模板 过去的经验总结 31 PDM紧前关系图 节点法AON，方框代表活动，箭线代表逻辑关系，ADM，CDM 32 确定依赖关系 硬逻辑（客观，无法改变）、软逻辑（考验项目经理创造力，最佳实践）、外部逻辑（依赖其他项目的活动，隐含着风险，可以包含硬逻辑或软逻辑） 33 提前&滞后 提前或推迟（如水泥抹平晾干）某个活动的开始日期，不改变本来的逻辑关系 34 网络模板 标准化网络，某部分可以称为子网络，适合项目中存在重复性的成果时 35 出版的估算数据 外部公司发布的生产率和资源单价 36 自下而上估算 对活动估算，然后汇总到工作包，再汇总到项目总资源，比较准，比较慢 37 项目管理软件 不等于项目管理信息系统 38 类比估算 以过去项目信息做基础来估算未来项目信息（历时、资源、成本） 39 参数估算 利用历史数据与其它变量的关系，生产率、成果数量，铺电缆200ft/小时 40 三点估算以及标准差 用最悲观、最乐观、最可能三个来估算 41 储备分析 考虑应急储备（如缓冲时间或储备金）和/或管理储备 42 进度网络分析 包括CPM、关键链、资源平衡、假设情景分析等 43 关键路径法 不考虑资源限制的情况下，找出完成项目的最短时间 44 关键链：帕金森定律 关键路径-时差概念+时间缓冲+资源缓冲，越早越好 45 资源平衡 确保资源使用量稳定均衡，往往会造成关键路径的变化 46 资源平滑 对进度模型中的活动进行调整，从而使项目资源需求不超过预定的资源限制的一种技术，相对于资源平衡，资源平滑不会改变关键路径，完工日期也不会延迟 47 资源优化技术 包括了资源平衡和资源平滑，通常先做资源平滑，再做资源平衡 48 假设情景分析 考虑各种可能的情形，预测对项目目标的影响，属于建模技术 49 模拟 基于多种不同的活动假设（通常使用三点估算的概率分布）计算出多种可能的项目工期，以应对不确定性，最常用的模拟技术为蒙特卡洛分析；属于建模技术 50 建模技术 包括假设情景分析和模拟 51 进度压缩 不改变范围情况下，缩短项目历时：赶工（那资源换时间，但逻辑关系不变）与快速跟进（调整逻辑关系，会增大风险） 52 进度计划编制工具 和项目管理软件一起使用，应该也是自动化的工具 53 绩效审查 测量与对比分析进度绩效，可使用各种技术包括趋势分析，关键路径法，关键链法，挣值管理，偏差分析 54 质量成本（COQ） 一致、非一致成本（失败或缺陷成本）；一致中又分预防（培训）和评估（过程控制） 55 卖方投标分析 让卖方先报价，预估项目大概花费成本 56 成本汇总 以WBS中工作包为单位汇总，得出总成本 57 历史关系 感觉就是参数估算或类比估算的基础 58 资金限制平衡 平衡资金支出，不要有很大起伏，财务部很喜欢 59 挣值管理（EVM） PV、EV、AC、CV、SV、CPI、SPI、EAC、ETC、TCPI，属于偏差分析的一种 60 绩效审查 包括偏差分析（看节点）、趋势分析（一个区间段）、挣值绩效分析 61 成本效益分析 对质量活动进行分析评估是否合适 62 控制图 看过程是否稳定，7点规则、失控 63 标杆对照（基准对照） 将项目与其它项目对比找差距、制定改进措施 64 实验设计（DOE） 统计学方法，分析每个因素对开发的流程和产品的特定变量的影响 65 统计抽样 从目标总体中选样本进行检查，在规划确定次数规模，在控制实施 66 流程图 显示某个过程中各步骤之间的关系 67 其它质量规划工具 头脑风暴、力场分析、名义小组、质量管理和控制工具 68 质量管理和控制工具 亲和图，过程决策程序图（PDPC），关联图，树形图，优先矩阵，活动网络图，矩阵图 69 质量审计 独立的结构化审查，由内外部审计师进行 70 过程改进（过程分析） 识别所需要改进的过程，包括根本原因分析 71 因果图 石川图、鱼骨图 72 直方图 显示特定情况的发生次数 73 帕累托图 特殊的直方图，按每个情况发生次数排序，28原理，如银行存款28法则 74 核查表（计数表） 用于收集数据的查对清单，合理排列各种事项，以便有效地收集关于潜在质量问题的有用数据 75 散点图 显示两个变量（因变量、自变量）的关系 76 组织机构图（OBS） 按组织部门排列下面列出工作包 77 责任分配矩阵图（RAM） 显示工作包（活动）和成员（资源）之间的关系，RACI 78 人际交往 正式、非正式的行业、职业环境下的人际互动，有助于认识人才 79 组织理论 个人、团队、组织的行为方式 80 多标准决策分析 在组建团队过程中，经常需要使用团队成员选择标准。通过多标准决策分析，制定出选择标准，并据此对候选团队成员进行定级或打分。根据各种因素对团队的不同重要性赋予不同的权重。包括可用性，成本，经验，能力，知识，技能，态度，国际因素等等 81 预分派 事先选定的，三种情况：竞标过程承诺、取决于特定技能、项目章程承诺 82 谈判 就某个事情双方达成共识的过程 83 招募 从外部招聘人员 84 虚拟团队 为共同目标而努力可几乎大家不见面，凝聚力低，沟通麻烦 85 人际关系技能 软技能：领导力，团队建设，激励，沟通，影响力，决策，政治和文化意识，谈判，建立信任，冲突管理，教练技术 86 培训 能够提高团队成员能力的活动 87 团队建设活动 有专门和非专门之分，非正式沟通非常重要，需要持续进行 88 基础规则 对成员可接受行为进行明确规定 89 集中办公 “紧密矩阵”，把许多或全部最活跃的项目团队成员安排在同一个物理地点（作战室）工作，以增强团队工作能力。 90 认可与奖励 对优秀成员的行为给予认可和奖励，要根据对方需求进行奖励 91 人事测评工具 能帮助项目经理和项目团队洞察成员的优劣势，了解成员的偏好和愿望，如何与人交际等。如态度调查，细节评估，结构化面谈，能力测试及焦点小组讨论等 92 观察与交谈 了解团队的工作表现和态度动态 93 项目绩效评估 对成员表现进行评估 94 冲突管理 解决项目冲突，合作/解决问题（综合考虑不同意见引导各方达成共识）、强制/命令（问题解决了，人际关系破坏了，通常在紧急情况下）、撤退/回避、缓和/包容（求同存异），妥协/调解（各让一步） 95 问题日志 书面的记录下来项目出现的问题 96 干系人分析 系统收集和分析各种信息了解干系人的利益、影响、期望 97 沟通需求分析 确定项目干系人的信息需求 98 沟通技术 要不要使用自动化工具，网络系统、视频会议等等 99 沟通模型 显示发送者和接受者 100 沟通方法 推式（发email)、拉式(在线课堂、网站）、交互式（开会） 101 信息管理系统 用来管理和分发项目信息的工具，包括电子的、纸的、项目管理电子工具（门户网站） 102 报告绩效 收集和发布绩效信息，包括状况报告，进展测量结果及预测结果，可以是简单的状态报告，也可以是详尽的报告 103 管理技能 指导与控制一群人协调他们行动实现目标 104 规划会议和分析 项目干系人、项目经理、团队成员、组织内负责风险的人一起开会 105 文档审查 对项目文档（合同、计划、项目档案等）进行评估审查 106 信息收集技术 头脑风暴、德尔斐、访谈、根本原因分析 107 核对表分析 根据编制的风险识别清单来进行风险识别，优点快，缺点不够全面 108 假设分析 检验之前的假设是否还成立，如果不成立就是风险 109 图解技术 因果图、流程图、影响图 110 SWOT分析 从内部优势、劣势；外部机会和威胁不同角度进行分析 111 概率与影响评估 分析风险发生可能性和后果 112 概率影响矩阵 用来对比把某个风险放入，深灰色代表严重；中度灰色代表较轻 113 风险数据质量评估 对风险识别分析所依据的数据进行评估开是否可信 114 风险分类 根据WBS、根据阶段、根据干系人、根据RBS（类别）对风险分类 115 风险紧迫性评估 评估哪些风险现在需要应对，哪些需要过一段时间应对 116 数据收集与表现 包括访谈、概率分布（贝塔分布、三角分布） 117 敏感性分析 确定哪些风险对项目具有最大影响，用龙卷风图来表现 118 预期货币价值（EMV） 把各种可能的后果和概率相乘，常和决策树一起使用 119 消极风险和威胁应对 回避、转移、减轻、主动或被动接受 120 积极风险和机会应对 开拓、提高、分享、接受 121 应急应对策略 制定应急计划，当风险发生时再执行 122 风险再评估 对现有评估、识别新风险、删除过去的风险，团队成员作的，内部人做的 123 风险审计 评估风险管理过程的有效性，通常外部人来做 124 技术绩效衡量 对技术成果和项目计划进行比较 125 状态审查会 定义开会，顺便看风险状况 126 自制外购分析 确定某个工作是团队自己完成还是外部采购 127 市场调研 包括考察行业情况和供应商能力 128 合同类型 固定价（范围明确时使用，买方风险小，卖方风险大，可以加激励、加经济调整考虑利率）、成本补偿类（买方参与最多，卖方风险小，有加成、有激励、有奖励-主观的·虚的）、时间材料合同（二者混合，谈判速度快） 129 投标人会议 买方向所有潜在卖方召开，要公平，让每个卖方对项目有清楚认识 130 建议书评价技术 就是评标的方法 131 独立估算 买方或找第三方编写，用作标杆来和投标人的报价进行对比 132 广告 在报纸或网站宣传招标活动 133 采购谈判 作为买方和卖方谈判，谈判技巧很重要，黑脸白脸，最终期限，有限授权，继承事实 134 合同变更控制系统 文书工作、跟踪系统、争议解决程序、审批层次 135 采购绩效审查 根据合同对卖方审查业绩，结构化审查 136 检查和审计 买方开展的，卖方需要支持 137 绩效报告 用来向高层汇报说明卖方合同执行情况 138 支付系统 说明如何给卖方付款，需要先确定卖方工作完成了 139 索赔管理 就是针对争议性的变更如何进行管理，先按合同谈判，然后考虑仲裁，最后上法院 140 记录管理系统 属于项目管理信息系统的一部分用来记录合同执行过程的文档 141 采购审计 对项目采购过程进行审查，找出经验和教训 PMP相关文档 https://hnyer.gitee.io/2020/06/08/pmp-xiang-guan-wen-dang/ 技术选型的 考虑纬度 //需求的满足度 是否满足当前的业务需求 // 成熟度、使用人数、社区活跃度、替换成本 更新速度稳定、社区气氛活跃的框架优先考虑。 // 学习成本 学习使用、引入当前技术框架带来的学习和改造成本。 // 开发速度、代码可维护性、可阅读性 、易调试性 当前技术是否会降低开发速度，和维护难度。 // 执行效率 、性能 是否对产品的性能有影响。 //安全性 数据安全性，是否容易被攻击； 开源协议约束，是否对自己的商业产品有版权威胁。 无版权 可以无限制使用！ all right reserved，powered by Gitbook该文件更新时间： 2020-10-19 11:53:20 "}}