{"./":{"url":"./","title":"项目介绍","keywords":"","body":"说明 本博客不保证完整性和正确性。请自行甄别。 无版权 可以无限制使用！ all right reserved，powered by Gitbook该文件更新时间： 2019-04-12 16:02:00 "},"chinese/doc/开发规范.html":{"url":"chinese/doc/开发规范.html","title":"开发规范","keywords":"","body":"开发规范 Android开发规范 阿里巴巴Android开发规范 1.0.0 类型 规范 示例 资源文件 需带模块前缀 layout文件 - Activity 的 layout以 module_activity开头Fragment 的 layout 以 module_fragment 开头Dialog 的 layout 以 module_dialog 开头include 的 layout 以 module_include 开头ListView 的 item layout 以 module_list_item 开头GridView 的 item layout 以 module_grid_item 开头RecyclerView 的 item layout 以 module_recycle_item 开头 drawable 资源 小写单词+下划线 module_tabs_icon_home_normal module_login_btn_pressed anim 资源 - module_fade_out module_push_down_in color 资源 module_colors.xml 《color name=\"module_btn_bg_color\">#33b5e5e5 dimen 资源 module_dimens.xml 《dimen name=\"module_horizontal_line_height\">1dp style 资源 module_styles.xml 《style name=\"ParentTheme.ThisActivityTheme\"》 string 资源 module_strings.xml moudule_login_tips module_homepage_notice_desc 控件Id 资源 驼峰法命名 View 的缩写作为前缀 LinearLayout  ll RelativeLayoutnbsp   rlConstraintLayout   clListView   lvScollView   svTextView   tvButton   btnImageView   ivCheckBox   cbRadioButton   rbEditText   et //其它控件ProgressBar    progress_bar DatePicker    date_picker 无版权 可以无限制使用！ all right reserved，powered by Gitbook该文件更新时间： 2019-01-18 10:40:44 "},"chinese/doc/常用网站.html":{"url":"chinese/doc/常用网站.html","title":"常用网站","keywords":"","body":"常用网站 androidAPI android官方英文版 android官方中文版 民间组织-安卓中文组 android developer Java8 官方文档 谷歌开发者社区 在线工具 国家企业信用信息公示系统 中国版权保护中心 git标签生成工具 shields.io 在线流程图工具ProcessOn 代码高亮工具 tool oschina json格式化工具 正则表达式测试 在线图片压缩 Rar暴力破解 文本差异比较 行政区划分 GLSL在线编辑 Everything 电脑全局搜索 Snipaste 截图、贴图 ConEmu 比cmd好用的命令行工具 cports 端口查看工具 EVCapture录屏工具 AdvancedRenamer文件名批量相关 博客、网站 干货集中营 王垠的博客 wanandroid 代码家的博客 ~stormzhang的博客 掘金网 伯乐在线 猎云网 太平洋手机 人人都是产品经理 pmcaff python3基础语法 廖雪峰python3基础教程 崔庆才-静觅python博客 大鱼python博客 无版权 可以无限制使用！ all right reserved，powered by Gitbook该文件更新时间： 2018-12-07 17:21:03 "},"chinese/常用软件/常用软件和框架.html":{"url":"chinese/常用软件/常用软件和框架.html","title":"常用软件和框架","keywords":"","body":"androidstudio androidstudio官网 Androidstudio 模板 ctrl + J 快速查看Live Templates 打开 *设置 -> Editor -> Live Templates* ，可以看到默认已经有很多 *Live Templates* 了 ，可以自己自定义。 导入原有的模板： 将文件替换即可 （C:\\Users\\kaifa4k\\.AndroidStudio2.2 是你自己的安装路径） C:\\Users\\kaifa4k\\.AndroidStudio2.2\\config\\templates 我用的模板 androidstudio 插件 安装或更新后插件后都需要重启Androidstudio 。 CodeGlance 代码快速定位 插件 Android-Resource-Usage-Count 显示 Android 资源使用的次数。 翻译插件ECTranslation 原理是调用了有道词典的API 。可以自定义 快捷方式，我目前设置的是 alt + m 快捷键设置 Preferences -> Keymap -> 搜索Translate - > 右键 add Keyboard Shortcut. 输入你想要的快捷键。 Android Parcelable code generator 自动生成 Parcelable接口相关的代码。 public class FtpThumDownListInfo implements Parcelable{ /**当前这个指针 指向的文件需要下载*/ private int gotoDownFileIndex = 0; /**需要下载的文件列表- 这个列表会分批次增加 */ private List ftpNeddLoadList =null ; /**下载好的文件的byte[]*/ private List ftpDowndBytesList =null ; //以下代码是 用插件自动生成的 start protected FtpThumDownListInfo(Parcel in){ this.gotoDownFileIndex = in.readInt(); this.ftpNeddLoadList = new ArrayList(); in.readList(this.ftpNeddLoadList, FTPFile.class.getClassLoader()); this.ftpDowndBytesList = new ArrayList(); in.readList(this.ftpDowndBytesList, FTPFile.class.getClassLoader()); } /** * 内容接口描述，默认返回0就可以了 */ @Override public int describeContents(){ return 0; } /** * 写数据进行保存 */ @Override public void writeToParcel(Parcel dest, int flags){ dest.writeInt(this.gotoDownFileIndex); dest.writeList(this.ftpNeddLoadList); dest.writeList(this.ftpDowndBytesList); } /** 实例化静态内部对象 * 接口对象名必须为CREATOR. * 必须按成员变量声明的顺序读取数据 */ public static final Parcelable.Creator CREATOR = new Parcelable.Creator() { @Override public FtpThumDownListInfo createFromParcel(Parcel source) { return new FtpThumDownListInfo(source); } @Override public FtpThumDownListInfo[] newArray(int size) { return new FtpThumDownListInfo[size]; } }; // 以下代码是 用插件自动生成的 end } //赋值 Bundle mBundle = new Bundle(); mBundle.putParcelable(\"picBean\",picBean); intentToMatch.putExtras(mBundle); //获取： RecommendPicBean picBean = (RecommendPicBean)getIntent().getParcelableExtra(\"picBean\"); 无线调试 ADB WIFI 华为M2 ，无Root 1、 确保电脑和手机在同一个局域网 2、插上USB线 连上adb 3、adb tcpip 5555 ( 5555为端口号，可自由指定） 4、adb connect 192.168.x.x:5555 EventBus、 缺点： 不容易跟踪调试代码。逻辑不是很连贯。 https://github.com/greenrobot/EventBus compile 'org.greenrobot:eventbus:3.1.1' // 绑定 @Override public void onStart() { super.onStart(); EventBus.getDefault().register(this); } // 解绑 @Override public void onStop() { super.onStop(); EventBus.getDefault().unregister(this); } // 发送 EventBus.getDefault().post(new MessageEvent()); // 接收 @Subscribe(threadMode = ThreadMode.MAIN) public void onEventBusMsgCome(WkEventBean bean) { switch (bean.getCode()){ case WkEventBean.CODE_1: String msg = (String) bean.getData() ; WkLog.d(\"UI received = \"+msg); break; default: break; } public class WkEventBean { public static final int CODE_1 = 1; public static final int CODE_2 = 2; public WkEventBean(int code , Object data){ this.code = code ; this.data =data ; } private int code ; private Object data ; public int getCode() { return code; } } git操作 配置全局信息 git config --global user.name \"aivin666@qq.com\" git config --global user.email \"aivin666@qq.com\" //查看当前用户信息 git config --list 添加个人私钥到网站 这种情况下无需配置密码 - window10下测试 1、生成对应的文件 ssh-keygen -t rsa -C 'aivin666@qq.com' 2、将 id_rsa.pub 里面的内容填写到网站上。 3、测试是否成功 。 ssh -T git@gitee.com 配置密码方式 Ubuntu下测试 https模式，每次提交都需要输入密码。 1、在一个新目录 初始化 git init 2、将远程代码拉倒本地 git pull https://gitee.com/hnyer/java_android.git 3、关联远程端仓库 master 是远程端的一个支路。 git remote add master https://gitee.com/hnyer/java_android.git // git remote rm master , 删除关联 4、 将本地指定的版本推送到远程端指定的版本 的一个maser是远程的 ，第二个是本地的 git push -u master master 5、以后不用每次都用参数 u ,直接 git push 即可 Ubuntu下 SSH 配置 码云 1、进入 /home/用户名/.ssh 目录下 生成公钥 ssh-keygen -t rsa -C \"your_email@example.com\" 2、将 id_rsa.pub 文件中的内容填入码云网站中 。 3、即可正常拉取 、提交 gitbook windows 安装gitbook 安装gitbook过程中请优先连接VPN，如果没有请考虑更换淘宝源等方式。 安装过程 可以参考 https://segmentfault.com/a/1190000005859901 npm install gitbook -g npm install -g gitbook-cli gitbook -V gitbook常用的使用命令 // 安装依赖包 gitbook install //新建定义好的文件 gitbook init // 本地服务器测试 gitbook serve // 编译成html格式 gitbook build 安装错误 如果遇到 “ Error: ENOENT: no such file or directory ... ” 这个错误 ， 把.gitbook\\versions\\3.2.2\\lib\\output\\website\\copyPluginAssets.js 修改成 confirm：false ！！！ Protocol Buffer developers protobuf github protobuf 相比于XML或Json格式存储数据， 通过Protocol Buffers来定义的文件体积更小，解析速度更快 。 c++ 服务器 与 android端进行交互时可以用Protocol Buffer 。 ps 常用快捷键： 移动工具 V 裁剪工具 C shift+ctrl+alt+s 保存切片 放大视图 Ctrl+【+】 缩小视图 【Ctrl】+【-】 切图： ctrl + alt + shift + a 制作圆角矩形图片 参考资料 图片渐变、透明度渐变 参考资料 PS里怎么样将白色背景去掉，变成透明的背景？ 参考资料 要先解压图层锁定 打开图片，单纯白色背景的话则只需使用工具栏中的魔棒工具在白色部位点一下，跟着delete键删除，此时就是透明的背景图片了，但关键的是要选择合适的保存方式。点文件-存储为web和设备所用格式，在弹窗选择附图红框处的PNG格式就可以了。 方法一:用擦除工具组中的魔棒擦除,点选白色 方法二: 1、用选择工具中的魔棒工具选白色(勾选连续的). 2、然后反选,复制 3、再粘贴成新层 4、册掉背景层 5、完 xUtils https://github.com/wyouflf/xUtils3 compile 'org.xutils:xutils:3.5.0' // 1、在Application 初始化 // import org.xutils.x; x.Ext.init(this); x.Ext.setDebug(false); // get请求 private void loadData( ) { String API = Ipconfig.KEY_WORKNEWS_DetailItem; API = API.replace(\"{pageSize}\" ,\"10\") ; RequestParams params = new RequestParams(API); Callback.Cancelable cancelable = x.http().get(params, new Callback.CommonCallback() { @Override public void onSuccess(String result) { } @Override public void onError(Throwable ex, boolean isOnCallback) { } @Override public void onCancelled(CancelledException cex) { } @Override public void onFinished() { } }); } // post 请求 private void requestHost(String name, String pwd1 ) { String API = Ipconfig.KEY_userRegister; RequestParams params = new RequestParams(API); params.addBodyParameter(\"userName\",name); params.addParameter(\"password\",pwd1); x.http().post(params, new Callback.CommonCallback() { @Override public void onSuccess(String result) { } @Override public void onError(Throwable ex, boolean isOnCallback) { } @Override public void onCancelled(CancelledException cex) { } @Override public void onFinished() { } }); // 文件上传 String api =\"http://xxx\" ; RequestParams params = new RequestParams(api) ; params.setMultipart(true); params.addBodyParameter(\"userId\", MyApplication.getUserId(activity)); params.addBodyParameter(\"file\", new File( filePath)); Callback.Cancelable cancelable = x.http().post(params, new Callback.CommonCallback() { @Override public void onSuccess(String result) { } @Override public void onError(Throwable ex, boolean isOnCallback) { } @Override public void onCancelled(CancelledException cex) { } @Override public void onFinished() { } }); 虚拟机 VMware Workstation 12序列号 5A02H-AU243-TZJ49-GTC7K-3C61N RxJava 2.x 要在Android中使用RxJava2, 需要依赖 Rxjava2.x 、 RxAndroid 异步事件处理框架。 continued support for Java 6+ & Android 2.3+ 基于观察者设计模式。 RxJava1.x 跟 RxJava2.x 不能共存 ，会冲突。 RxJava组成元素 RxJava基本组成元素 说明 被观察者 数据源 发送数据 观察者 接收到（处理后的数据） 建立订阅关系 操作符 可以对数据进行过滤、转换等处理 线程切换 指定发送和接收的线程 RxJava 常用类 常用类 作用 Observable 被观察者 ObservableEmitter 用来发出事件的，它可以发出三种类型的事件 x.onNext() x.onComplete() x.onError() 发射规则如下： 1、上游可以发送无限个onNext ，下游也可以接收无限个onNext 2、当上游发送了一个onComplete后（只能发一次）, 上游onComplete之后的事件将会继续发送, 而下游收到onComplete事件之后将不再继续接收事件 3、当上游发送了一个onError后（只能发一次）, 上游onError之后的事件将继续发送, 而下游收到onError事件之后将不再继续接收事件 4、上游可以不发送onComplete或onError. 5、onComplete 和 onError 只能发送一个 , 不能都发送 ObservableOnSubscribe Observer 观察者 Disposable x.dispose() 切断订阅关系。 调用dispose()后 ，观察者接收不到数据，但是数据源还可以继续发送 CompositeDisposable Disposable 容器 x.add(...) x.clear() Flowable Rxjava2 新增的 。数据发送 。我们可以用Flowable + Subscriber 来解决 收发速度不一致问题 Subscriber 与Flowable搭配， 数据接收。 Subscription 切断订阅关系 Subscription.cancel() 观察者请求数据源发送多少个数据 subscription.request(Long.MAX_VALUE) FlowableEmitter 返回 观察者 能处理多少个数据 flowableEmitter.requested() Action BiConsumer BiFunction Predicate BiPredicate BooleanSupplier Cancellable Consumer Function Function3 Function4 Function5 Function6 Function7 Function8 Function9 IntFunction LongConsumer Schedulers 调度器。 当数据源和观察者在同一个线程时，这是一个同步的订阅关系 。 数据源每发送一个事件后必须等到观察者接收处理完了以后才能接着发送下一个。 当处于不同线程时 ,就是异步的订阅关系, 这个时候数据源可以自由发送数据。 //CPU计算密集型线程 默认线程数等于处理器的数量 Schedulers.computation() // 使用指定的Executor作为调度器 Schedulers.from() // io操作的线程 Schedulers.io() // 常规新线程 Schedulers.newThread() // Android主线程 AndroidSchedulers.mainThread() // 在当前线程执行 ，不过需要等队列中的其他任务完成后才执行 Schedulers.trampoline() BackpressureStrategy 背压策略 抗压力策略 背压是指在异步场景中，数据源发送事件速度远快于观察者的处理速度的情况下， 一种告诉 数据源 需要降低发送速度的策略 。 // 缓存区大小128，超过大小继续发就会报错 BackpressureStrategy.ERROR // 默认128，超过大小继续发就会 提示缓冲满了 BackpressureStrategy.MISSING // 默认大小128 ，大于128时就会修改为无限大。直到OOM BackpressureStrategy.BUFFER // 默认128 ，超过128后来的数据会被丢掉 BackpressureStrategy.DROP // 默认128 ，超过128就会只会保留最后的一个数据。 最后总个数 是 129 BackpressureStrategy.LATEST SingleEmitter 用来发射一条单一的数据，且一次订阅只能调用一次 singleEmitter.onSuccess() // onSuccess与onError只可调用一个 ，否则会报异常 singleEmitter.onError() Subject 主题 , 不支持背压控制 一种特殊的存在 ，同时是 数据接收者 和 发送者 AsyncSubject 无论输入多少参数，永远只输出最后一个参数 , 如果因为发生了错误而终止，AsyncSubject将不会发射任何数据 BehaviorSubject 会发送离订阅最近的上一个值，没有上一个值的时候会发送默认值。 如果遇到错误会直接中断 PublishSubject 一旦一个观察者订阅了该Subject，它会发送所有数据给订阅者。 如果接收者只关系自己订阅的信息 ，可以用ofType来过滤 订阅者只会接受订阅之后的来自PublishSubject发射的数据。 ReplaySubject 无论何时订阅，都会将所有历史订阅内容全部发出 Processor rxjava2.x新增的 ，作用与Subject一样 。 支持背压控制 AsyncProcessor BehaviorProcessor PublishProcessor ReplayProcessor Transformer 转换器 ， 实际上就是Func1， 换句话说就是提供给他一个Observable它会返回给你另一个Observable ObservableTransformer SingleTransformer CompletableTransformer FlowableTransformer MaybeTransformer RxJava2.0中的观察者模式 RxJava2.0中的观察者模式 说明 Observable / Observer 不支持背压，及无法处理发送数据速度不协调的问题。 Flowable/ Subscriber Single/ SingleObserver 只发射一条单一的数据，或者一条异常通知， 不能发射完成通知，其中数据与通知只能发射一个。 // 可以指定Schedulers实现异步处理 ，如果不被订阅是不会被调用的 Single.create // 接收传入的参数 ，是一种特殊的create() ，只会在当前线程里执行 , 不管是否被 订阅均会被调用 Single.just // 仅仅用来连接Single顺序执行的，比如顺序执行检查网络，检查内存 ，注意：如果某个Single调用了onError()会导致被中断 Single.concat // 将多个Single整合为一个 Single.zip // Observable.just().zipWith() //创建一个自定义的操作符，用来处理数据发送者 。 就是对当前Observable进行操作，然后再返回它 Single.compose // Single.subscribe // 返回一个错误， 一般用于调试 Single.error // 用于一对0~多的返回 Single.just( ... ).flatMap() // 一般map()是用于一对一的返回 Single.just( ).map() // 它支持将Single转化为Observable对象，可以返回多个值 Single.just( ).flatMapObservable() // 类似于concat ，如果有中断 ，后面都会中断 Single.merge() // Single.just().mergeWith() // 用于指定异步任务的线程 Single.just().subscribeOn() // 相当于try catch中的return，具体意思就是当函数抛出错误的时候给出一个返回值 Single.just().onErrorReturn() // 指定回调所在线程 Single.just().observeOn() // 超时设置 Single.just().timeout() // Single.just( ).toString() Completable/ CompletableObserver 只发射一条完成通知，或者一条异常通知， 不能发射数据，其中完成通知与异常通知只能发射一个 Maybe/ MaybeObserver 可发射一条单一的数据，以及发射一条完成通知， 或者一条异常通知，其中完成通知和异常通知只能发射一个， 发射数据只能在发射完成通知或者异常通知之前，否则发射数据无效。 RXjava2操作符 所谓的操作符就是一些被Rxjava封装好的方法或API ，使用这些操作符就可以完成线程调度，数据过滤等功能 。 操作符类型 说明 create() 创建被观察者对象 just() 快速的创建被观察者对象 fromArray() 将数组中的数据转换为Observable对象 fromIterable() 将List中的数据转换为Observable对象 empty() 用于测试 ，仅发送Complete事件 error() 用于测试 ，仅发送Error事件 never() 不发射数据，也永远不会结束 defer() 直到有观察者订阅时，才创建被观察者对象&发送事件 每次订阅后，都会得到一个刚创建的最新的Observable对象 timer() 延迟指定时间后，发送1个数值0 interval() 每隔指定时间就加n并发送出去 range() 连续发送一个事件序列，可指定范围 rangeLong() 跟 range()类似，支持数据类型为Long intervalRange() 每隔指定时间 就发送 事件，可指定发送的数据的数量 map() 将传入数据处理后返回 。 输入和输出是一对一 flatMap() 输入和输出可以是 一对多 不能保证 输出的顺序和输入的顺序一致 concatMap 输入和输出可以是一对对 输出和输入顺序 严格一致 buffer() 每次取n个事件放到缓存区中，n可配置 filter() 将符合自定义条件的事件过滤出来 ofType() 过滤 特定数据类型的数据 skip() 跳过正序的前 n 项 skipLast() 跳过正序的后 n 项 distinct() 去掉序列中重复的事件 distinctUntilChanged() 去掉序列中连续重复的事件 take() 指定观察者最多能接收到的事件数量 takeLast() 指定观察者只能接收到被观察者发送的最后几个事件 throttleFirst() 在某段时间内，只发送该段时间内第1次事件 throttleLast() 在某段时间内，只发送该段时间内 最后1次事件 sample() 指定时间内 取一次数据 ，其他的数据就会被丢掉 throttleWithTimeout() 在输出了一个数据后的一段时间内，没有再次输出新的数据， 则把这个数据真正的发送出去； 假如在这段时间内有新的数据输出，则以这个数据作为将要发送的数据项， 并且重置这个时间段，重新计时 debounce () 跟 throttleWithTimeout() 一样 firstElement() 仅选取第1个元素 lastElement() 仅选取最后一个元素 elementAt() 接收指定索引的某个元素 ， 索引越界也不会报异常 elementAtOrError() 接收指定索引的某个元素 ， 索引越界 会报异常 all() 判断发送的所有数据是否都满足自定义的条件 , true false takeWhile() 判断发送的每项数据是否满足 自定义条件 若满足条件则发送 ,不满足不发送 skipWhile() 一直跳过，直到满足自定义条件 skipUntil() - takeUntil() 一直发送 ，直到某个条件 sequenceEqual() 两个数据源的数据是否相同 isEmpty() 数据源的数据是否为空 contains() 数据源中是否包含指定数据 defaultIfEmpty( obj) 在不发送任何有效事件（ Next事件）、仅发送了 Complete 事件的前提下，发送个默认值obj amb() 当有多个数据源需要发送数据时 ， 只发送 先发送数据的Observable的数据，而其余 Observable被丢弃。 concat() 组合多个被观察者一起发送数据，合并后 按发送顺序串行执行 concatArray() 跟concat()类似 merge() 组合多个被观察者一起发送数据，合并后 按时间线并行执行 被观察者数量≤4 mergeArray() 被观察者数量 > 4 mergeWith() delay() 使被观察者延迟一段时间再发送事件 concatDelayError() 使用concat()，一旦某个被观察者发出onError事件，其他被观察者就会终止发送。 为了让其他被观察者继续发送，可以使用这个操作符 concatArrayDelayError() mergeDelayError() combineLatestDelayError() reduce() 把被观察者需要发送的事件聚合成1个事件、发送 collect() 将被观察者发送的数据事件收集到一个数据结构里 startWith() 在被观察者发送事件前，追加发送一些数据 startWithArray() count() 统计被观察者发送事件的数量 subscribe() 订阅， 连接观察者 和 被观察者 zip() 多个数据源Observable 发送数据，经过自定义组合处理后，观察者再收到 。 1、组合数据时严格按照顺序从多个数据源中拿数据。 2、最后观察者收到的数据个数 跟发送最少数据的数据源的数据个数相同。 x.zipWith() combineLatest() 如果子流1在等待其他流发射数据期间又发射了新数据， 则使用子流最新发射的数据进行合并 x.concatMap() x.scan() x.window() subscribeOn() 指定发送事件的线程 只有第一次指定有效，其余的指定线程无效 unsubscribeOn() 取消订阅 observeOn() 指定接收事件的线程 每次指定均有效 doOnEach() 每发送一次就会调用一次 doOnNext () 执行 next之前调用 doAfterNext() 执行 next之后调用 doOnError() doOnComplete() doOnTerminate() doFinally() doOnSubscribe() 观察者订阅时调用 onErrorReturn() 遇到错误时，发送1个特殊事件 & 正常终止 onErrorResumeNext() 拦截的错误 是Throwable 类型 onExceptionResumeNext() 拦截的错误 是 Exception类型 retry() 当捕捉到错误时，被观察者会重新发射数据 retryUntil() 遇到错误，重新发射，直到... retryWhen() repeat() 无条件地、重复发送事件 repeatWhen() repeatUntil() publish() share() connect() 补充知识点 链式调用 MsgInfo msgInfo = new MsgInfo(); // 链式调用 msgInfo.setOwnerId(\"100011002\") .setStatus(MsgInfo.Status.SENDING) .setTime(System.currentTimeMillis()); // 普通调用 msgInfo.setOwnerId(\"100011002\"); msgInfo .setStatus(MsgInfo.Status.SENDING) ; msgInfo .setTime(System.currentTimeMillis()); // 链式调用的关键在于方法的返回值！ public MsgInfo setStatus(int status) { this.status = status; // 注意返回的是 this return this; } Retrofit 2.x 一个支持 RxJava方式调用的网络请求框架 A type-safe HTTP client for Android and Java by Square, Inc. requires at minimum Java 7 or Android 2.3. Retrofit 提供2种风格的网络请求方式： 1、传统风格 (略过不看) 采用Callback 接口 2、RxJava 风格 (流行) 采用Observable接口 Retrofit2 + Rxjava2 依赖 // rxjava核心库 compile 'io.reactivex.rxjava2:rxjava:2.0.1' // Android 支持 Rxjava compile 'io.reactivex.rxjava2:rxandroid:2.0.1' // Android 支持 Retrofit compile 'com.squareup.retrofit2:retrofit:2.1.0' // 衔接 Retrofit & RxJava compile 'com.jakewharton.retrofit:retrofit2-rxjava2-adapter:1.0.0' // 支持Gson解析 compile 'com.squareup.retrofit2:converter-gson:2.1.0' 注解 作用 @GET get请求 @POST post请求 @DELETE delete请求 @HEAD head请求 @OPTIONS options请求 @PATCH patch请求 @Headers 添加请求头 @Path get请求 ，user/{password} 格式 @Query get请求 ， user/password?password=xxx 格式 @FormUrlEncoded 用表单数据提交 @Field post需要 post请求需要 ， 替换参数 //定义请求接口 public interface BlogService { /*** * get 方式 * https://www.aivin666.cn/AivinInfo/getAllMusicInfoGson?pageNum=2 */ @GET(\"getAllMusicInfoGson\") Call getBlogByGet(@Query(\"pageNum\") int pageNum); /*** * post 方式 * https://www.aivin666.cn/AivinInfo/getAllMusicInfoGson * @param pageNum 页码 */ @FormUrlEncoded @POST(\"getAllMusicInfoGson\") Call getBlogByPost(@Field(\"pageNum\") int pageNum); } //简单使用 Retrofit retrofit = new Retrofit.Builder() // url根目录 .baseUrl(\"https://www.aivin666.cn/AivinInfo/\") .build(); BlogService service = retrofit.create(BlogService.class); //Call call = service.getBlogByGet(2);//get方式 Call call = service.getBlogByPost(2);//post方式 call.enqueue(new Callback() { @Override public void onResponse(Call call, Response response) { try { String reslut = response.body().string(); tvHttpResult.setText(reslut); Log.i(TAG , reslut) ; } catch (Exception e) { } } @Override public void onFailure(Call call, Throwable t) { } }); Retrofit_RxJava_OkHttp Retrofit + RxJava + OkHttp Retrofit 负责请求的数据和请求的结果 RxJava 负责异步，各种线程之间的切换 OkHttp 负责请求的过程 添加依赖 // rxjava 核心库 compile 'io.reactivex.rxjava2:rxjava:2.1.14' // Android 支持 Rxjava compile 'io.reactivex.rxjava2:rxandroid:2.0.1' // retrofit 核心库 compile 'com.squareup.retrofit2:retrofit:2.4.0' // retrofit json 转换器 compile 'com.squareup.retrofit2:converter-gson:2.3.0' // 衔接 Retrofit & RxJava compile 'com.squareup.retrofit2:adapter-rxjava2:2.3.0' // okhttp 核心库 compile 'com.squareup.okhttp3:okhttp:3.10.0' // okhttp log 拦截器 compile 'com.squareup.okhttp3:logging-interceptor:3.8.1' 定义 订阅者 public class HttpSubscriber implements Observer { private PicInfoSubscriberListener subscriberOnListener; private Context context; private Disposable disposable; public HttpSubscriber( PicInfoSubscriberListener subscriberOnListener, Context context) { this.subscriberOnListener = subscriberOnListener; this.context = context; } @Override public void onSubscribe(@NonNull Disposable d) { disposable = d; } @Override public void onComplete() { if( (subscriberOnListener == null) || (context == null)) { if(disposable != null && !disposable.isDisposed()){ //切断订阅关系 disposable.dispose(); } } } @Override public void onError(Throwable e) { if(subscriberOnListener != null && context != null) { if (e instanceof SocketTimeoutException) { subscriberOnListener.onError(-1001, \"网络超时，请检查您的网络状态\"); } else if (e instanceof ConnectException) { subscriberOnListener.onError(-1002, \"网络链接中断，请检查您的网络状态\"); } else if(e instanceof MyException){ subscriberOnListener.onError(((MyException)e).getCode(), ((MyException)e).getMsg()); } else { subscriberOnListener.onError(-1003, \"未知错误:\" + e.getMessage()); } } else { if(disposable != null && !disposable.isDisposed()){ disposable.dispose(); } } } @SuppressWarnings(\"unchecked\") @Override public void onNext(T t) { if(subscriberOnListener != null && context != null) { // 收到想要的订阅信息 ，然后通过回到接口 发送到需要数据的地方 subscriberOnListener.onSucceed((List) t); } else { if(disposable != null && !disposable.isDisposed()){ disposable.dispose(); } } } } 定义 发布者 的能力接口 /** * 最终的访问地址是 主地址 + 尾地址 http://xxx/getAllPicInfoGson?pageNum=6 * 此处填写 尾地址 */ @GET(\"getAllPicInfoGson\") Observable> getPicListByGet(@Query(\"pageNum\") int pageNum ); @FormUrlEncoded @POST(\"getAllPicInfoGson\") Observable> getPicListByPost( @Field(\"pageNum\") int pageNum ); 封装发布者 /** * 封装 图片模块的http接口 */ public class PicInfoApi { private final String TAG=\"PicInfoApi\" ; private static PicInfoApi picInfoApi; private PicInfoService picInfoService; private PicInfoApi() { final String BASE_URL_PANDA = \"https://www.aivin666.cn/AivinInfo/\"; picInfoService = HttpClient.getInstance(BASE_URL_PANDA).createApi(PicInfoService.class); } public static PicInfoApi getInstance() { if(picInfoApi == null) { picInfoApi = new PicInfoApi(); } return picInfoApi; } public void getPicListByGet (Observer >subscriber , int pageNum) { // 通过操作符 map(...) 将接收的数据经过处理后再返回 Observable observable = picInfoService.getPicListByGet(pageNum) .flatMap( function ); // 将观察者 和订阅者 关联起来 toSubscribe(observable, subscriber); } public void getPicListByPost (Observer> subscriber , int pageNum) { // 通过操作符 map(...) 将接收的数据经过处理后再返回 Observable observable = picInfoService.getPicListByPost(pageNum) .flatMap( function ); // 将观察者 和订阅者 关联起来 toSubscribe(observable, subscriber); } private void toSubscribe( Observable> o, Observer> s){ // 运行在 io 线程中 o.subscribeOn(Schedulers.io()) // 取消订阅 .unsubscribeOn(Schedulers.io()) // 指定接收事件的线程 .observeOn(AndroidSchedulers.mainThread()) // 订阅 .subscribe(s); } /*** * 配合 操作符 map 使用 * Function, List> 第一个参数是输入数据类型 ， 第二个参数是输出类型 * List apply(List list) * 第一个 List 是返回数据类型 ， 第二个 List 是输入的数据类型 * */ private Function function = new Function, Observable > >() { @Override public Observable > apply(List list) throws Exception { // 可以在这个函数里面进行数据过滤等处理 if(list != null && list.size() > 0) { Log.i(TAG , \" 数据处理=\"+ list.size()) ; }else{ Log.i(TAG , \" 数据处理 没有获取到数据\") ; } return Observable.fromArray(list) ; } }; 进行http访问的相关配置 public class HttpClient { private static String token = \"\"; private static Retrofit retrofit; private static HashMap clients = new HashMap<>(); private HttpClient(String url) { retrofit = new Retrofit.Builder() // 设置接口主地址 .baseUrl(url) // 配置 HTTP 请求客户端 .client(getHttpRequestClient()) // 配置json 转换器 .addConverterFactory(GsonConverterFactory.create()) // 添加支持 - 返回值定义为Observable对象 .addCallAdapterFactory(RxJava2CallAdapterFactory.create()) .build(); } public T createApi(Class clazz) { // 获取接口实例 return retrofit.create(clazz); } public static HttpClient getInstance(String url){ if(!clients.containsKey(url)) { HttpClient httpClient = new HttpClient(url); clients.put(url, httpClient); } // 一个主地址 对应一个client return clients.get(url); } /** * 定制 http 访问访问器 */ private OkHttpClient getHttpRequestClient() { HttpLoggingInterceptor logging = new HttpLoggingInterceptor( new OkHttpLogTool()); // 打印获取到的信息。 （不设置不打印） logging.setLevel(HttpLoggingInterceptor.Level.BODY); //设置缓存路径 String cacheDir = MyApplication.getInstance().getExternalCacheDir().getAbsolutePath() ; File httpCacheDirectory = new File(cacheDir , \"OKHttpResponses\"); //设置缓存 大小 Cache cache = new Cache(httpCacheDirectory, 50 * 1024 * 1024); // 自定义拦截器 Interceptor interceptor = new Interceptor() { @Override public Response intercept(Chain chain) throws IOException { Request request = chain.request() .newBuilder() .addHeader(\"token\", token) .build(); // 无网络时 ，使用缓存 if (!NetUtil.isNetworkConnected(MyApplication.getInstance())) { request = request.newBuilder() .cacheControl(CacheControl.FORCE_CACHE) .build(); } Response response = chain.proceed(request); if (NetUtil.isNetworkConnected(MyApplication.getInstance())) { // 有网络时 设置缓存超时时间0个小时 int maxAge = 0 * 60; response.newBuilder() .addHeader(\"Cache-Control\", \"public, max-age=\" + maxAge) // 清除头信息，因为服务器如果不支持，会返回一些干扰信息，不清除下面无法生效 .removeHeader(\"Pragma\") .build(); } else { // 无网络时，设置超时为1周 int maxStale = 60 * 60 * 24 * 7; response.newBuilder() .addHeader(\"Cache-Control\", \"public, only-if-cached, max-stale=\" + maxStale) .removeHeader(\"Pragma\") .build(); } return response; } }; OkHttpClient httpClient = new OkHttpClient.Builder() .addInterceptor(logging) .cache(cache) .addInterceptor(interceptor) .build(); return httpClient; } } 如何使用 private int pageNum = 6 ; private void testUrlGet() { PicInfoApi.getInstance().getPicListByGet( new HttpSubscriber>(new PicInfoSubscriberListener () { @Override public void onSucceed(List data) { // 获取到数据 } @Override public void onError(int code, String msg) { } }, this) , pageNum); } private void testUrlPost( ) { PicInfoApi.getInstance().getPicListByPost( new HttpSubscriber>(new PicInfoSubscriberListener () { @Override public void onSucceed(List data) { } @Override public void onError(int code, String msg) { } }, this) , pageNum); } Hierarchyviewer 检验手机是否开启了View Server： adb shell service call window 3 //View Server处于关闭状态 返回：Result: Parcel(00000000 00000000 '........')\" //View Server处于开启状态 返回值：Result: Parcel(00000000 00000001 '........')\" 借助ViewServer这个工具可以在任何手机上使用 hierarchyviewer。 注：在 android device monitor 可以找到 hierarchyviewer。 react-native Windows下搭建React Native Android开发环境 //需要安装软件 1、python2.x 2、node.js 3、react-native-cli npm install -g yarn react-native-cli 4、webstorm 主流IED之一 5、android开发环境 jdk 、sdk之类的。为了方便可以通过通过Androidstudio来下载sdk。 开发过程用 webstorm即可。 //初始化项目 react-native init 你的项目名字 如果出现新建失败，可以尝试切换成淘宝源 npm config set registry https://registry.npm.taobao.org npm config set disturl https://npm.taobao.org/dist //安装新模块 npm install xxxxxx --save 安装成功后，库的依赖信息配置到package.json里面，具体内容被下载到node_module文件夹中。 //安装apk 在连接好设备的前提下 react-native run-android //调试项目(debug模式才能) 1、adb shell input keyevent 82 打开调试窗口。 2、手机和电脑处于同一个局域网，确保能互相ping通。 3、电脑浏览器填写 http://localhost:8081/debugger-ui/（用ip会遇到跨域方面的错误）。 手机APP上要填写电脑的ip。（192.168.2.170:8081） 启动react native 服务，如果出现默认端口8081被占用的情况，可以指定端口。 react-native start --port 9999 测试是否启动成功 http://localhost:9999/index.android.bundle?platform=android http://localhost:9999/ 查看版本、修改版本 //查看本地版本 react-native --version //查看最新版本 npm info react-native //在package.json文件中修改成对应版本 \"react-native\": \"^0.55.4\" //重新安装 npm install 项目结构说明 android 是一个可以用 Androidstudio 打开的android项目 ios ios项目 index.js 打包 app 时进入 react native（js 部分） 的入口文件 App.js 可以理解为 react native（js 部分） 代码部分的入口文件 app.json 项目说明，主要给原生 app 打包用 package.json 项目依赖包配置文件 node_modules 依赖包安装目录 yarn.lock yarn包管理文件 常用类和方法解释 常用类和方法 说明 ReactActivity 默认所有的Activity都继承它 ReactNativeHost ReactActivityDelegate ReactActivity的逻辑代理实现 ReactRootView React NativeUI的所在 ReactInstanceManager XReactInstanceManagerImpl ReactContext 管理React Native的状态等 NativeModule 继承它的module可以在js端使用 Callback／Promise 回调接口，与js端交互 ReactNativeHost Simple class that holds an instance of ReactInstanceManager . ReactInstanceManager ?? ReactPackage 可以看作是，向ReactNative注册了原生模块，这样在JS中你也可以使用原生模块的功能. NativeModule A native module whose API can be provided to JS catalyst instances SoLoader To load a native library getJSMainModuleName() Returns the name of the main module. Determines the URL used to fetch the JS bundle from the packager server . Props 、属性 大多数组件在创建时就可以使用各种参数来进行定制。用于定制的这些参数就称为props 。 props是内置的一个关键字 属性是不可以变的，一般用来传值 点击事件 onPress={this._onPressButton} _onPressButton() { Alert.alert('You tapped the button!') } State 、状态 state是系统关键字 一切界面变化都是状态state变化引起的 state的修改必须通过setState()方法，其他方式无效 setState 只修改指定属性，并不影响其他没有指定的属性 setState 是异步操作，修改不会马上生效 样式 style是系统关键字 实际开发中组件的样式会越来越复杂， 我们建议使用StyleSheet.create来集中定义组件的样式。 弹性宽高 flex 理解参考android的权重比例。 flex 是系统关键字 一般使用flex:1来指定某个组件扩张以撑满所有剩余的空间。 并列的子组件的flex值越大，占用的空间比例就越大。 如果没有指定 flex 和 width、height ，容器尺寸就会为0 ，无法显示。 组件 文本输入框 TextInput placeholder // 提示 onChangeText //监听内容变化 onSubmitEditing //监听提交 弹性布局 Flexbox Flexbox规则可以在不同屏幕尺寸上提供一致的布局结构。 // flexDirection 主轴的方向 (row 、column) flexDirection: 'column' // justifyContent 子元素沿着主轴的排列方式 (flex-start 、center、flex-end、space-around、space-between 、 space-evenly) justifyContent: 'space-evenly' //alignItems 决定其子元素沿着次轴的排列方式 (flex-start、center、flex-end 、 stretch) alignItems: 'flex-end' 滚动视图 ScrollView 可以横向或纵向滚动 普通长列表 FlatList data //数据源 renderItem //每一行的视图 带分组的 长列表 SectionList sections // 数据源 renderItem // 每一行的视图 renderSectionHeader //每一个组头的视图 keyExtractor //此函数用于为给定的item生成一个不重复的key。Key的作用是使React能够区分同类元素的不同个体 网络访问框架 Fetch react native 内置支持 XMLHttpRequest（ajax）和 fetch框架 。推荐使用fetch。 react native 不支持jQuery 。因为jQuery包含了一些 react native 没有的东西。 无版权 可以无限制使用！ all right reserved，powered by Gitbook该文件更新时间： 2019-04-12 16:48:29 "},"chinese/数据结构/常用数据结构.html":{"url":"chinese/数据结构/常用数据结构.html","title":"常用数据结构","keywords":"","body":"ArrayMap ArrayMap是Android api提供的 . Android里的Bundle内部就是ArrayMap 。 ArrayMap并不适用于数据量比较大的场景，它是一种以时间换空间的优化。 通常比HashMap要慢，因为在查找时需要进行二分查找，增加或删除时，需要在数组中插入或者删除键。而这种操作比较耗时。 ArrayMap有两个数组 。第一个数组存放存放item的hash值，第二数组是把key，value连续的存放在数组里，通过先算hash在第一个数组里找到它的hash index，根据这个index在去第二个数组里找到这个key-value。 HashMap Hashtable和HashMap的内部数据结构相似. HashMap由数组+链表组成的，数组是HashMap的主体，链表则是主要为了解决哈希冲突而存在的。 HashMap中的链表出现越少，性能才会越好。 加载因子(DEFAULT_LOAD_FACTOR)越大，对空间的利用更充分，后果是查找效率的降低； 加载因子太小，那么散列表的数据将过于稀疏，对空间造成严重浪费。 默认加载因子为0.75，一般情况下我们是无需修改。 当哈希表中的条目数超出了加载因子与当前容量的乘积时，则要对该哈希表进行重建内部数据结构. HashMap存储的步骤put（K,V） 传入key和value，计算key的hash值，根据hash值搜索在哈希表table中的索引位置，若当前索引位置不为null，则对该位置的Entry链表进行遍历，如果链中存在该key，则用传入的value覆盖掉旧的value，同时把旧的value返回。 否则调用addEntry，用key-value创建一个新的节点，并把该节点插入到该索引对应的链表的头部 HashMap的读取实现get（key，value） 读取的步骤比较简单，调用hash（key）求得key的hash值，然后调用indexFor（hash）求得hash值对应的table的索引位置，然后遍历索引位置的链表，如果存在key，则把key对应的Entry返回，否则返回null HashMap键的遍历，keySet() HashMap遍历时，按哈希表的每一个索引的链表从上往下遍历， 哈希表 Hashtable 和HashMap 的内部数据结构相似. Hash 是一种信息摘要算法，一般用于验证完整性，它还叫做哈希、散列。我们平时使用的MD5,SHA1,SSL中的公私钥验证都属于Hash算法。 Hash碰撞 好的Hash算法可以出计算几乎出独一无二的HashCode，如果出现了重复的hashCode，就称作碰撞; 不过就算是MD5这样优秀的算法也会发生碰撞，即两个不同的key也有可能生成相同的MD5。 hashmap和hashtable的区别 HashTable已经被淘汰了！！ 不用关注太多细节 。 知道以下几个区别就好了。 1、 一: HashMap可以允许key为null，value为null，HashTable都不允许为null 2 、HashMap没有提供同步机制，是线程不安全的，需要自己在外面写同步代码，HashTable 部分方法上有自己的 synchronize 同步，是线程安全的。 3、父类不一样 ， 各自拥有的方法不完全一样 ， 扩充机制（规则）不一样 。 栈 手写代码实现一个栈。 1、用数组实现 通过移动下标来模拟。 2、使用系统的 LinkedList 来实现。 Deque queue = new LinkedList(); queue.addFirst(e); queue.removeFirst(); 3、自己模拟单链表 实现栈 sample没有考虑线程安全等细节，只是简洁地展示关键思想 Node.java /** * 栈节点 */ public class Node { /**数据*/ public Object data; /**下一个节点*/ public Node next ; public Node(Object data ,Node next) { this.data=data ; this.next =next; } } MyStack.java public class MyStack { /**栈顶节点*/ private Node topNode ; /**栈大小*/ public int stackSize; /** * 入栈 */ public void push(Object data) { //新节点 Node newNode = new Node(data, topNode); //对外公布 新栈顶元素 topNode= newNode ; stackSize++ ; } /** * 出栈 */ public void pop() { //需要出栈的节点 Node temp= topNode ; //对外公布 新的栈顶元素 topNode = temp.next ; stackSize-- ; } /**打印该栈所有元素*/ public void showStackInfo() { Node temp =topNode ; if(temp==null) { System.out.println(\"空栈\"); return ; } while(temp !=null ) { System.out.println(\"栈节点值=\"+ temp.data); temp = temp.next; } System.out.println(\"---------end-------\"); } } 测试 public static void main(String[] args) { MyStack myStack = new MyStack(); myStack.showStackInfo(); myStack.push(1) ; myStack.push(2) ; myStack.showStackInfo(); myStack.pop(); myStack.showStackInfo(); } 队列 队列的特点是“先进先出”。 阻塞队列 与普通队列的区别在于：当阻塞队列为空时，从队列中获取元素的操作将会被阻塞，或者当队列是满时，往队列里添加元素会被阻塞。 阻塞双端队列 指允许两端都可以进行入队和出队操作的阻塞队列。 常用队列 特点 常用方法 安全性 LinkedBlockingQueue 基于链表的单向队列 线程安全 LinkedBlockingDeque 基于链表的双端队列 interface BlockingQueue extends Queue ... interface BlockingDeque extends BlockingQueue , Deque {... class LinkedBlockingDeque ... implements BlockingDeque {... class LinkedBlockingQueue implements BlockingQueue... 无版权 可以无限制使用！ all right reserved，powered by Gitbook该文件更新时间： 2019-04-12 16:52:49 "},"chinese/常用算法/常用算法.html":{"url":"chinese/常用算法/常用算法.html","title":"常用算法","keywords":"","body":"常用算法 无版权 可以无限制使用！ all right reserved，powered by Gitbook该文件更新时间： 2018-12-07 17:21:03 "},"chinese/常用算法/算法术语.html":{"url":"chinese/常用算法/算法术语.html","title":"算法术语","keywords":"","body":"算法术语 时间复杂度 在数据结构中,每个算法有他的时间复杂度 , 用O（）表示。括号里面是通过算法求出来的时间复杂度 , n*n 是n的平方，如果求出来是n*n+n 这时它的时间复杂度还是 0（n*n）, 因为规定时间复杂度是取它的最高次幂 递归 相同的结构层级嵌套，自我调用的过程。 迭代 迭代就像是操场永不回头的跑圈，不断利用相同的优化过程将输出作为新的输入，使问题推进到一个个里程碑，直到符合答案的要求。 计算1+2+3+…+n, sum1是递归, sum2是迭代. function sum1(n){ if (n == 0) { return 0; } else { return n + sum1(n - 1); } } function sum2(n){ var result = 0; for (var i = 1; i 无版权 可以无限制使用！ all right reserved，powered by Gitbook该文件更新时间： 2018-12-07 17:21:03 "},"chinese/常用算法/排序算法.html":{"url":"chinese/常用算法/排序算法.html","title":"排序算法","keywords":"","body":"排序算法 冒泡排序 核心思想是 \"冒泡\"。最后的效果是 第一个最小，最后一个最大，沉在最下。一次比较 可以让数值中最小的那个值冒出来。 然后依次比较，直到完成。 /** * int[] array = { 7, 3, 10, 0, 6 , 0 ,-56 }; * 冒泡排序 */ public static int[] sortBubble(int[] array){ //外层for 确定 排序趟次 for ( int i = 0 ; i i ; j--) { int temp; //将小的值往前移动 if(array[j] 归并排序 、合并排序 合并排序 体现了 分治思想 。 递归“分” 递归“分”的终止条件是“只剩下一个元素” 。 因为一个元素认为它有序 。 有序元素的“合” 先比一下 A指针 和 B指针 指向的两个元素谁比较小一点，然后把比较小的元素（此时假设A指针指向的元素小）放到C指针指的位置上。 A往前挪，C 往前挪 。然后继续比较A指针和B指针的两个元素。 合并排序缺点 需要额外的空间辅助。 /** * 归并 排序。 升序 */ public static void mergeSort(int[]array , int start , int end){ if(start>=end){ //递归终止条件 return ; }else{ int mid = (start + end )/2 ; //递归处理左边 mergeSort(array , start ,mid); //递归处理右边 mergeSort(array ,mid+1 ,end); //合并 排序好的左右 mergeAction(array ,start ,mid ,end); } } public static void mergeAction(int[]arr ,int start ,int mid , int end ){ //辅助数组空间 并不是 int[] tempArr = new int[arr.lengh] int[] tempArr = new int[end - start + 1]; //左数组的下标 int ptrA = start; //右数组的下标 int ptrB = mid +1; //辅助数组的下标 int ptrC=0; //循环比较，直至有一个区间被取完 while (ptrA 插入排序 无 递归排序 无 快速排序 之所以说它是快速的原因，不是因为它比其他的排序算法都要快。而是从实践中证明了快速排序在平均性能上的确是比其他算法要快一些 。 快速排序的基本思路 找一个基准元素，对数组进行调整， 调整的标准是，这个基准元素的左边存放的都是比这个元素小的，右边都是比这个元素大的。 然后分而治之，对左右两边的子数组利用同样的规则调整，调整到每一个子数组中都只有一个元素时结束。 （快排体现了分而治之的思想，一步步地把问题变小，最终解决。） 快排的理解 快排有多种理解角度，个人觉得从“挖坑填坑”的角度比较容易理解。 /**最基础的 快速排序*/ public void quickSort(int[] array, int left , int right){ if(left = base){ right-- ; } //找到坑值，填坑 array[left] = array[right] ; //从左边开始寻找坑值 while (left 选择排序 选择排序的思想：就是不断地从未排序的元素中选择最大（或最小）的元素放入已排好序的元素集合中，直到未排序中仅剩一个元素为止 。 选择排序 和冒泡排序有点类似，都是在一次排序后把最大(最小)的元素放到最前面。但是过程不同，冒泡排序是通过相邻的比较和交换。而选择排序是通过对整体的选择。 选择排序 可以看成 冒泡排序 的优化，只有在确定了最小数的前提下才进行交换，大大减少了交换的次数。 选择排序关键点 1、有序区间 、 无序区间 2、如何选出最大（/最小）元素 /** * 选择排序 升序 */ public static int [] sortSelect(int [] array){ int length = array.length; for(int i=0 ;i array[k]){ minPos=k ; } } //将当前趟次的结果放到 有序区间 if(array[minPos] 无版权 可以无限制使用！ all right reserved，powered by Gitbook该文件更新时间： 2018-12-07 17:21:03 "},"chinese/常用算法/查找算法.html":{"url":"chinese/常用算法/查找算法.html","title":"查找算法","keywords":"","body":"查找算法 二分查找 、折半查找 前提：数组是 排好序的。 （升序、降序都可以） 越界异常 int middle = (low+high)/2 // 错误写法 int middle = low + (high - low) / 2; // 正确写法 low 和 high 都是整形，当你的low和high很大的时候， low+high 就会产生溢出，low+high 的结果就会变为负数，数组越界了。 /** * @param array 升序 数组 * @param key 需要查找的值 */ public static int binarySearch(int[] array, int key) { int low = 0; int high = array.length - 1; while (low key) { high = middle - 1; } else if (array[middle] 顺序查找 优点： 算法简单 、 对线性链表也适用 缺点： 慢 public static int SequenceSearch(int[] array, int key){ int length = array.length ; for (int i=0 ;i 无版权 可以无限制使用！ all right reserved，powered by Gitbook该文件更新时间： 2018-12-07 17:21:03 "},"chinese/常用算法/大数相加.html":{"url":"chinese/常用算法/大数相加.html","title":"大数相加","keywords":"","body":"大数相加 如果利用java的 API ，就非常简单。 BigInteger value1= new BigInteger(\"-11\") ; BigInteger value2= new BigInteger(\"-11\"); BigInteger reslut = value1.subtract(value2) ; 无版权 可以无限制使用！ all right reserved，powered by Gitbook该文件更新时间： 2018-12-07 17:21:03 "},"chinese/常用算法/集合的所有子集.html":{"url":"chinese/常用算法/集合的所有子集.html","title":"获得集合的所有子集","keywords":"","body":"获得集合的所有子集 思想比较巧妙。 集合A={a,b,c}中的元素在每个子集中，要么存在，要么不存在。 映射关系： (1,1,1)->(a,b,c) --> 7 (1,1,0)->(a,b) --> 6 (1,0,1)->(a,c) --> 5 (1,0,0)->(a) --> 4 (0,1,1)->(b,c) --> 3 (0,1,0)->(b) --> 2 (0,0,1)->(c) --> 1 (0,0,0)->(空集) --> 0 public static void GetPowerSet(int nArray[] ) { // 一共多少种组合 0 ,1, 2 ... n-1 int end = 1 无版权 可以无限制使用！ all right reserved，powered by Gitbook该文件更新时间： 2018-12-07 17:21:03 "},"chinese/常用算法/扫描线种子填充算法.html":{"url":"chinese/常用算法/扫描线种子填充算法.html","title":"扫描线种子填充算法","keywords":"","body":"扫描线种子填充算法 一般用来 填充不规则多边形 该算法并不完美，对图片有要求，识别的也不是很精准 ，而且有锯齿。 ColourImageView.java public class ColourImageView extends ImageView { private Bitmap mBitmap; private Paint mPaint ; /** * 边界的颜色 */ private int mBorderColor = -1; private boolean hasBorderColor = false; private ImageTool imageTool; public ColourImageView(Context context, AttributeSet attrs) { super(context, attrs); imageTool = new ImageTool(mBorderColor, hasBorderColor ); mPaint = new Paint(); mPaint.setColor(Color.RED); } @Override protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) { super.onMeasure(widthMeasureSpec, heightMeasureSpec); // 规定让图片按比例显示 int viewWidth = getMeasuredWidth(); setMeasuredDimension(viewWidth, getDrawable().getIntrinsicHeight() * viewWidth / getDrawable().getIntrinsicWidth()); if (mBitmap == null) { Bitmap bm = ((BitmapDrawable) getDrawable()).getBitmap(); mBitmap = Bitmap.createScaledBitmap(bm, getMeasuredWidth(), getMeasuredHeight(), false); } } private int touchX ; private int touchY ; @Override public boolean onTouchEvent(MotionEvent event) { touchX = (int) event.getX(); touchY = (int) event.getY(); if (event.getAction() == MotionEvent.ACTION_DOWN) { fillColorToSameArea( ); } return super.onTouchEvent(event); } /** * 以触摸点为种子点 进行填充 */ private void fillColorToSameArea( ) { int bitmapWidth ; int bitmapHeight ; int[] pixels ; int currentTouchPixel ; currentTouchPixel = mBitmap.getPixel(touchX, touchY); if (currentTouchPixel == Color.TRANSPARENT || (hasBorderColor && mBorderColor == currentTouchPixel)) { return; } bitmapWidth = mBitmap.getWidth(); bitmapHeight = mBitmap.getHeight(); pixels = new int[bitmapWidth * bitmapHeight]; mBitmap.getPixels(pixels, 0, bitmapWidth, 0, 0, bitmapWidth, bitmapHeight); int newColor = randomColor(); //填色 imageTool.fillColor(pixels, bitmapWidth, bitmapHeight, currentTouchPixel, newColor,touchX, touchY); //重新设置bitmap mBitmap.setPixels(pixels, 0, bitmapWidth, 0, 0, bitmapWidth, bitmapHeight); setImageBitmap(mBitmap); invalidate(); } @Override protected void onDraw(Canvas canvas) { super.onDraw(canvas); canvas.drawCircle(touchX ,touchY ,10 ,mPaint); } /** * 返回一个随机颜色 */ private int randomColor() { Random random = new Random(); int color = Color.argb(255, random.nextInt(256), random.nextInt(256), random.nextInt(256)); return color; } } ImageTool.java public class ImageTool { private Stack mStacks = new Stack<>(); private int mBorderColor = -1; private boolean hasBorderColor = false; public ImageTool( int mBorderColor ,boolean hasBorderColor ){ this.mBorderColor = mBorderColor ; this.hasBorderColor= hasBorderColor ; } /** * @param pixels 像素数组 * @param currentTouchPixel 当前触摸点的 颜色 * @param newColor 填充色 */ public void fillColor(int[] pixels, int bitmapWidth, int bitmapHeight, int currentTouchPixel, int newColor, int x, int y) { //步骤1：将种子点(x, y)入栈； mStacks.push(new Point(x, y)); //步骤2：判断栈是否为空， // 如果栈为空则结束算法，否则取出栈顶元素作为当前扫描线的种子点(x, y)， // y是当前的扫描线； while (!mStacks.isEmpty()) { /* * 步骤3：从种子点(x, y)出发，沿当前扫描线向左、右两个方向填充，直到边界。 * 分别标记区段的左、右端点坐标为xLeft和xRight */ Point seed = mStacks.pop(); int count = fillLineLeft(pixels, currentTouchPixel, bitmapWidth, newColor, seed.x, seed.y); int left = seed.x - count + 1; count = fillLineRight(pixels, currentTouchPixel, bitmapWidth, newColor, seed.x + 1, seed.y); int right = seed.x + count; //从y-1找种子 if (seed.y - 1 >= 0){ findSeedInNewLine(pixels, currentTouchPixel, bitmapWidth, seed.y - 1, left, right); } //从y+1找种子 if (seed.y + 1 = 0) { int index = y * bitmapWidth + x; if (needFillPixel(pixels, pixel, index)) { pixels[index] = newColor; count++; x--; } else { break; } } return count; } /** * 往右填色，返回填充的个数 */ private int fillLineRight(int[] pixels, int currentTouchPixel, int bitmapWidth, int newColor, int x, int y) { int count = 0; while (x 0xFFBBBBBB ; // 直接跟当前pixel比较，有较明显的锯齿，原因不明 //return pixels[index] > pixel ; } } /** * 在新行找种子节点 */ private void findSeedInNewLine(int[] pixels, int currentTouchPixel, int bitmapWidth, int indexY, int left, int right) { // 获得该行的开始索引 int begin = indexY * bitmapWidth + left; // 获得该行的结束索引 int end = indexY * bitmapWidth + right; boolean hasSeed = false; int newSeedIndexX ; while (end >= begin) { if (pixels[end] == currentTouchPixel) { if (!hasSeed) { newSeedIndexX = end % bitmapWidth; mStacks.push(new Point(newSeedIndexX, indexY)); hasSeed = true; } } else { hasSeed = false; } end--; } } } 无版权 可以无限制使用！ all right reserved，powered by Gitbook该文件更新时间： 2018-12-07 17:21:03 "},"chinese/设计模式/设计模式.html":{"url":"chinese/设计模式/设计模式.html","title":"设计模式","keywords":"","body":"设计模式 参考资料教材 目前设计模式： 23个GoF设计模式 + 简单工厂模式 学习设计模式的意义 过多地使用 if else 会造成代码臃肿 ，维护困难（容易产生bug ，需要大量修改代码）。此时你应该要考虑用某种设计模式来解决这个问题。 简单的设计意味着缺少灵活性，我们将其称之为“一次性代码”，不能方便地被应用在其他项目。 而合适的设计模式，可以让你的代码可以被反复使用。 设计模式分类 创建模型 创建型模式用来处理对象的创建过程 模式类型 学习进度 工厂方法模式（Factory Method Pattern） 抽象工厂模式（Abstract Factory Pattern） 建造者模式（Builder Pattern） 原型模式（Prototype Pattern） 单例模式（Singleton Pattern） 附：简单工厂模式：又叫做静态工厂方法（StaticFactory Method）模式，是属于创建型模式，但不属于23种GOF设计模式之一。 结构型模式 用来处理类或者对象的组合 模式类型 学习进度 适配器模式（Adapter Pattern） 桥接模式（Bridge Pattern） 组合模式（Composite Pattern） 装饰者模式（Decorator Pattern） 外观模式（Facade Pattern） 享元模式（Flyweight Pattern） 代理模式（Proxy Pattern） 行为型模式 用来对类或对象怎样交互和怎样分配职责进行描述 模式类型 学习进度 责任链模式（Chain of Responsibility Pattern） 命令模式（Command Pattern） 解释器模式（Interpreter Pattern） 迭代器模式（Iterator Pattern） 中介者模式（Mediator Pattern） 备忘录模式（Memento Pattern） 观察者模式（Observer Pattern） 状态模式（State Pattern） 策略模式（Strategy Pattern） 模板方法模式（Template Method Pattern） 访问者模式（Visitor Pattern） 面向对象设计原则 面向对象设计原则蕴含在很多设计模式中，它们是从许多设计方案中总结出的指导性原则。是我们用于评价一个设计模式的使用效果的重要指标之一。 [x] 1、单一职责原则(Single Responsibility Principle, SRP) [x] 2、开闭原则(Open-Closed Principle, OCP) [x] 3、接口隔离原则(Interface Segregation Principle, ISP) [x] 4、依赖倒转原则(Dependency Inversion Principle, DIP) [x] 5、里氏代换原则(Liskov Substitution Principle, LSP) [x] 6、迪米特法则(Law of Demeter, LoD) [x] 7、合成复用原则(Composite Reuse Principle, CRP) 无版权 可以无限制使用！ all right reserved，powered by Gitbook该文件更新时间： 2019-04-12 16:37:22 "},"chinese/设计模式/模式详解.html":{"url":"chinese/设计模式/模式详解.html","title":"模式详解","keywords":"","body":" 依赖倒转原则(Dependency Inversion Principle, DIP) 抽象不应该依赖于细节，细节应当依赖于抽象。换言之，要针对接口编程，而不是针对实现编程。 DIP要求传递参数时或在关联关系中，尽量引用层次高的抽象层类，而不要用具体类。 我们需要针对抽象层编程。将具体类的对象通过依赖注入的方式注入到其他对象中。 依赖注入(DependencyInjection, DI) : 当一个对象要与其他对象发生依赖关系时，通过抽象来注入所依赖的对象。 常用的注入方式有三种： 1、构造注入。通过构造函数来传入具体类的对象； 2、设值注入。通过Setter方法来传入具体类的对象； 3、接口注入。通过在接口中声明的业务方法来传入具体类的对象。 依赖倒置和里氏替换的区别 在大多数情况下，这三个设计原则会同时出现，开闭原则是目标，里氏代换原则是基础，依赖倒转原则是手段，它们相辅相成，相互补充，目标一致，只是分析问题时所站角度不同而已。 1、定义的角度不同。里氏替换原则是关于子类和父类的原则;依赖倒置原则是关于抽象与细节的原则。 2、应用范围不同。依赖倒置原则使用范围更广。 在大多数情况下，OCP、LSP、DIP会同时出现。开闭原则是目标，里氏代换原则是基础，依赖倒转原则是手段，它们相辅相成，相互补充，目标一致，只是分析问题时所站角度不同而已。 单一职责 一个类只负责一个功能领域中的相应职责。 在软件系统中，一个类承担的职责越多，它被复用的可能性就越小。一个类承担的职责过多，就相当于将这些职责耦合在一起，当其中一个职责变化时，可能会影响其他职责的运作。 因此，要将这些职责进行分离，将不同的职责封装在不同的类中。 单一职责原则是实现高内聚、低耦合的指导方针，它是最简单但又最难运用的原则。 高内聚 是指一个模块是由相关性很强的代码组成，只负责一项任务。 低耦合 模块与模块之间，尽可能的使其独立存在。 里氏代换原则(Liskov Substitution Principle, LSP) LSP 是由麻省理工学院计算机科学实验室的Liskov女士提出来的。所以以她的名字命名。 里氏代换原则要求，在软件中将一个基类对象替换成它的子类对象，程序将不会产生任何错误和异常，反过来则不成立。 例如：我喜欢动物，那我一定喜欢狗，因为狗是动物的子类；但是我喜欢狗，不能据此断定我喜欢所有动物。 里氏代换原则是实现开闭原则的重要方式之一，因此在程序中尽量使用基类类型来对对象进行定义，而在运行时再确定其子类类型，用子类对象来替换父类对象。 //在使用LSP时需要注意如下问题： 1、子类的所有方法必须在父类中声明，或子类必须实现父类中声明的所有方法。 因为如果一个方法只存在子类中，在父类中不提供相应的声明，则无法在以父类定义的对象中使用该方法。 2、在运用LSP时，尽量把父类设计为抽象类或者接口，让子类继承父类或实现父接口，并实现在父类中声明的方法， 运行时，子类实例替换父类实例，我们可以很方便地扩展系统的功能，同时无须修改原有子类的代码。 附： 类似 List tempList= new ArrayList() ; ? //申明时用基类List ， 具体实现时用子类ArrayList 。 # 迪米特法则(Law of Demeter, LoD) 一个软件实体应当尽可能少地与其他实体发生相互作用。 迪米特法则可降低系统的耦合度，当其中某一个模块发生修改时，就会尽量少地影响其他模块。 //所以在类的结构设计上： - 1、每一个类都应当尽量降低其成员变量和成员函数的访问权限； - 2、在类的设计上，只要有可能，一个类型应当设计成不变类； - 3、在对其他类的引用上，一个对象对其他对象的引用应当降到最低。 迪米特法则还有几种定义形式，包括：不要和“陌生人”说话、只与你的直接朋友通信等 其朋友包括以下几类： - 1、当前对象本身(this)； - 2、以参数形式传入到当前对象方法中的对象； - 3、当前对象的成员对象； - 4、 如果当前对象的成员对象是一个集合，那么集合中的元素也都是朋友； - 5、当前对象所创建的对象。 任何一个对象，如果满足上面的条件之一，就是当前对象的“朋友”，否则就是“陌生人”。 迪米特法则要求我们在设计系统时，应该尽量减少对象之间的交互， 如果两个对象之间不必彼此直接通信，那么这两个对象就不应当发生任何直接的相互作用， 如果其中的一个对象需要调用另一个对象的某一个方法的话，可以通过第三者转发这个调用。 简言之，就是通过引入一个合理的第三者来降低现有对象之间的耦合度。 **附：** law of Demeter 有些书也译作 “得墨忒耳法则” 。 为什么叫做这个名字，我的猜测是根据[\"德墨忒尔\"](http://baike.baidu.com/item/德墨忒尔)的故事进行命名的。纯粹猜测 ，读者如果知道正确的原因请留言告知我。谢谢。 # 开闭原则 一个**软件实体**应当对扩展开放，对修改关闭。应尽量在不修改原有代码的情况下进行扩展。 //软件实体：可以指一个软件模块、一个由多个类组成的局部结构或一个独立的类。 当软件系统需要面对新的需求时，我们应该尽量保证系统的设计框架是稳定的。如果一个软件设计符合开闭原则，那么可以非常方便地对系统进行扩展，而且在扩展时无须修改现有代码，使得软件系统在拥有适应性和灵活性的同时具备较好的稳定性和延续性。 在Java中，可以为系统定义一个相对稳定的抽象层(抽象类或者接口)，而将不同的实现行为移至具体的实现层中完成。 增加新的具体类来实现新的业务功能，在不修改已有代码的基础上扩展系统的功能。 //注意： 因为xml和properties等格式的配置文件是纯文本文件，编辑后无须编译，因此在软件开发中，一般不把对配置文件的修改认为是对系统源代码的修改。 如果一个系统在扩展时只涉及到修改配置文件，而原有的Java代码没有做任何修改，则可认为该系统是一个符合开闭原则的系统。 # 合成复用原则(Composite Reuse Principle, CRP) 组合复用原则、聚合复用原则 尽量使用对象组合，而不是继承来达到复用的目的。 在面向对象设计中，可以通过两种方法在不同的环境中复用已有的设计和实现: 1、通过**组合/聚合**实现 组合/聚合可以使系统更加灵活，降低类与类之间的耦合度。请优先考虑。 2、通过**继承**实现 继承复用会破坏系统的封装性，因为继承会将基类的实现细节暴露给子类。 由于基类的内部细节通常对子类来说是可见的，所以这种复用又称“白箱”复用。 一般而言，如果两个类之间是“Has-A”的关系应使用组合或聚合； 如果是“Is-A”关系可使用继承。 附： 有一些书上没有列上CRP， 只说“六大设计原则” 。 # 接口隔离原则(Interface Segregation Principle, ISP) 使用多个专门的接口，而不使用单一的总接口。因为在面向对象编程语言中，实现一个接口就需要实现该接口中定义的所有方法，所以大的总接口使用起来不一定很方便。 //注意： 在使用接口隔离原则时，我们需要注意控制接口的粒度。 1、接口不能太小。接口太小会导致系统中接口泛滥，不利于维护； 2、接口也不能太大。太大的接口将违背接口隔离原则，灵活性较差，使用起来很不方便。 一般而言，接口中仅包含为某一类用户定制的方法即可。 //“接口”往往有两种不同的含义： 对于不同的含义，ISP的表达方式以及含义都有所不同。 1、把接口理解成角色，一个接口只能代表一个角色，每个角色都有它特定的一个接口，此时，这个原也可以叫做“角色隔离原则”。 2、如果把“接口”理解成狭义的特定语言的接口，那么ISP表达的意思是指接口仅仅提供客户端需要的行为。 # 回调机制 回调的简单理解： A需要做一件事情(不需要立刻知道结果)，给B设置一个回调对象，然后B在条件合适的时候执行得到一个结果， 然后通过A传过来的回调对象告诉A。 - 1、回调普通使用 1、定义回调接口： public interface IH264StoreFinishCallBack { public void onStoreAndParseFinished( boolean result, String msgStr) ; } 2、设置接口： private IH264StoreFinishCallBack ih264StoreFinishCallBack = new IH264StoreFinishCallBack() { @Override public void onStoreAndParseFinished(boolean result, String msgStr) { if(result) { disMissIosLoading(); } } } ; H264FileSotrPresenter h264FileSotrPresenter = new H264FileSotrPresenter(ih264StoreFinishCallBack); 3、触发回调： if(ih264StoreFinishCallBack!=null) { ih264StoreFinishCallBack.onStoreAndParseFinished(true ,\"切换到照片时自动触发结束录像命令\"); } ---- - 2、全局回调的使用方法(结合单例模式) 这种模式可以实现在不同的activity之间传递参数。 1、定义回调函数管理类： /** Created by Aivin on 2017/5/8. 单例模式 管理一个回调对象， 实现两个不同的activity实时通讯 用户手动改变计量单位后，通知另外一个activity做出相应的改变 / public class UnitsChangeCallBackManager { private IUnitsModeChangeCallBack iUnitsModeChangeCallBack ; /** *接受传入的回调实例 */ public void setiUnitsModeChangeCallBack(IUnitsModeChangeCallBack iUnitsModeChangeCallBack) { this.iUnitsModeChangeCallBack = iUnitsModeChangeCallBack; } /** * 用户手动改变电池的警报值 * @param type 标记是 哪一个电池被修改 * @param value 具体的修改值 * @param msgStr 拓展字段，备用。 */ public void sendUnitsChangedByUser(int type , int value , String msgStr) { if(iUnitsModeChangeCallBack !=null) { iUnitsModeChangeCallBack.onUnitsModeChange(type , value , msgStr); } }// /**私有化构造函数，防止被其他类实例化*/ private UnitsChangeCallBackManager() { //初始化操作 }// /**使用一个内部类来维护单例 *单例模式使用内部类来维护单例的实现。 *利用jvm提供的机制，加载类的线程互斥的，用来解决多线程访问的时候可能会遇到null的问题。 **/ private static class SingletonFactory { private static UnitsChangeCallBackManager instance = new UnitsChangeCallBackManager(); } /**获取实例,对外提供的接口 */ public static UnitsChangeCallBackManager getInstance() { return SingletonFactory.instance; } /**为了能在序列化过程仍能保持单例的特性，需要添加一个readResolve()方法 */ private Object readResolve() { return getInstance(); } } 2、设置回调： UnitsChangeCallBackManager.getInstance().setiUnitsModeChangeCallBack(this); public void onUnitsModeChange(int type, int value, String msgStr) { switch (type) { case 1: break; case 2: break; } } 3、触发回调： UnitsChangeCallBackManager.getInstance().sendUnitsChangedByUser(1,1 ,\"英尺\"); # 中介者模式 Mediator Pattern “中介者模式” 是 “迪米特法则” 的一个典型应用。（不要与陌生人说话）。 同事类之间没有直接显示交流 ，而是通过中介类（定义了行为接口）进行通信。 ![](https://gitee.com/hnyer/filesOfGitbook/raw/master/files/201803261940_osChina_网状结构_星形结构.png) ## 应用场景： 1、在有些软件中，某些类/对象之间的相互调用关系错综复杂，类似QQ用户之间的关系， 此时，我们特别需要一个类似“QQ群”一样的中间类来协调这些类/对象之间的复杂关系 。 2、 请结合现实生活中的 “中介”进行理解。 房产中介... ## 优点 1、 简化了对象之间的交互，将原本难以理解的网状结构转换成相对简单的星型结构。 2、 增加新的中介者和新的同事类都比较方便，更好地符合“开闭原则”。 ## 缺点 1、 中介者类中包含了大量同事类之间的交互细节，可能会导致中介者类非常复杂 。 # 享元模式 Flyweight Pattern 当系统中存在大量相似或相同的对象时，将会导致运行代价过高、OOM 等问题，享元模式正为解决之一类问题而诞生。 ## 注意 1、享元模式在使用时存在线程安全问题，需要考虑线程安全。 2、通常用一个 工厂类 类维护享元对象。 ## 内部状态 Internal State 存储在享元对象内部并且不会随环境改变而改变的状态，内部状态可以共享。 ## 外部状态 External State 随环境改变而改变的、不可以共享的状态。外部状态由客户端保存。 外部状态不可以影响享元对象的内部状态，它们是相互独立的。 ## 缺点 1、对象 需要分离出 内部状态 和 外部状态，这使得程序的逻辑复杂化。 2、读取外部状态使得运行时间变长。 ## [示例](https://blog.csdn.net/lovelion/article/details/7667860) ![](https://gitee.com/hnyer/filesOfGitbook/raw/master/files/201803271357_osChina_享元模式.png) 围棋棋盘中包含大量的黑子和白子，它们的形状、大小都一模一样，只是出现的位置不同而已。如果将每一个棋子都作为一个独立的对象存储在内存中，将导致该围棋软件在运行时所需内存空间较大。 ```java class Chessman { /**内部状态*/ private String color; /**外部状态*/ private Point location; public Chessman(String color) { ...} public String getColor() { ... } public String getLocation() { ...} /**更新外部状态 需要主要线程安全*/ public synchronized void updateLocation( Point loation) { ... } } public class ChessmanFactory { /**享元池*/ private static Map map=new HashMap<>(); public static ChessFlyWeight getChess(String color) { if(map.get(color)!=null){ return map.get(color); }else{ Chessman chessman=new Chessman(color); map.put(color, chessman); return chessman; } } } //多次调用 也只创建了一个 Chessman 对象 Chessman chessman=ChessmanFactory.getChess(\"黑色\"); 代理模式（Proxy Pattern） 当无法直接访问某个对象或访问某个对象存在困难时可以通过一个代理对象来间接访问。 关键点：代理对象控制对原对象的引用 。 静态代理 代理类与委托类有同样的接口　。通过代理对象访问目标对象。 1、可以在目标对象实现的基础上,增强额外的功能操作 。(这一点跟装饰者模式一样) 实现自定义的控制策略。 /** * 委托类 实现的接口 */ public interface IUser { /**获取用户信息*/ public String getUserInfo(); } /** * 委托类。对外提供 查询用户信息的功能。 */ public class UserTools implements IUser { public String getUserInfo(){ return \"he is tom\"; } } /** * 代理类。 实现的接口与委托类一模一样。 * 用户通过代理作为中间人去使用原对象拥有的功能。 * 但是真正执行的还是原来的对象。 */ public class UserToolsProxy implements IUser { private UserTools userTools ; public String getUserInfo() { //做授权判断 boolean isTheRightTime = true of false...; if(isTheRightTime) { return userTools.getUserInfo(); }else{ return \"wrong time\"; } } 动态代理 暂时没用过。 在java的动态代理机制中，有两个重要的类或接口，一个是 InvocationHandler(Interface)、另一个则是 Proxy(Class)，这一个类和接口是实现我们动态代理所必须用到的。~ 代理模式和接口回调的区别 跟做iOS的同事曾经讨论过，对方说代理模式和接口回调理解起来差不多。( 可能是iOS的代理的定义不一样?) 我个人认为这两者相差还是比较大的，出发点和定义都不一样。 单例模式（Singleton Pattern） 在Java应用中，单例对象能保证在一个JVM中，该对象只有一个实例存在。 使用场景： 1、某些大型的类创建频繁时会导致很大的系统开销。 2、软件系统中有些地方只能有一个实例，否则会出现各种问题。例如打印机为了避免状态不一致而采用单例模式。 缺点： 1、单例实例的生命周期和软件的生命周期一样长。如果它持有某些对象的引用 ，会导致该对象无法释放。 特点： 1、单例类只能有一个实例。 2、单例类必须自己自己创建自己的唯一实例。 3、单例类必须给所有其他对象提供这一实例。 4、构造方法限定为private，避免了类在外部被实例化，只能通过getInstance()方法访问。（此处不考虑反射机制） 单例模式分二种：饿汉式单例、懒汉式单例。 public class SingleTonBean { /**持有私有静态实例，防止被引用，此处赋值为null，目的是实现延迟加载*/ private static SingleTonBean instance = null ; /**私有化构造函数，防止被其他类实例化*/ private SingleTonBean() { //初始化操作 }// /**使用一个内部类来维护单例 *单例模式使用内部类来维护单例的实现。 *利用jvm提供的机制，加载类的线程互斥的，用来解决多线程访问的时候可能会遇到null的问题。 **/ private static class SingletonFactory { private static SingleTonBean instance = new SingleTonBean(); } /**获取实例,对外提供的唯一接口 */ public static SingleTonBean getInstance() { return SingletonFactory.instance; } /**为了能在序列化过程仍能保持单例的特性，需要添加一个readResolve()方法 */ private Object readResolve() { return getInstance(); } } 饿汉式单例 ： public class SingletonDemo1 { private SingletonDemo1(){ //构造方法是私有 } //饿汉式：被调用之前就自己创建好实例 private static final SingletonDemo1 singleton=new SingletonDemo1(); public SingletonDemo1 getIncetance(){ return singleton; } } 懒汉式单例 ： public class SingletonDemo2 { private static SingletonDemo2 singleton = null; private SingletonDemo2() { // 私有化构造方法 } public synchronized static SingletonDemo2 getIncetance() { if (singleton == null) { // 懒汉式：在调用的时候才实例化对象 singleton = new SingletonDemo2(); } return singleton; } } 使用类的静态方法也可以实现单例模式的效果，分析这两种方案的不同。 1、单例模式可以延迟初始化，有助于优化性能 。 2、待补充。 要点解析 1、单例模式和反序列化的问题 一般来说，一个类实现了Serializable接口，我们就可以将它写入内存然后再从内存中读取组装成一个跟原来一样的对象。此时，内存中存在N（N>=2）个相同的对象。 而单例模式要求JVM中只能有一个类的对象。如果不做特殊处理反序列就会违反单例模式的规则。 /** * 实现readResolve方法，一个class可以直接控制反序化返回的类型和对象引用。 * ObjectInputStream 会检查对象的class是否定义了readResolve方法。 * Method readResolveMethod = getInheritableMethod( cl, \"readResolve\", null, Object.class); */ private Object readResolve() throws ObjectStreamException { return INSTANCE; //直接返回已经存在单例对象，不再组装新的对象。确保唯一性。 } 原型模式 Prototype Pattern 原型模式特点 在于通过 克隆 一个已经存在的实例来返回新的实例，而不是新建实例。被复制的实例就是我们所称的“原型”。 特点 1、模型需要对外暴露自己实现的克隆接口。 使用场景 当创建新的对象实例较为复杂、成本较大时，使用原型模式可以简化对象的创建过程、节约资源。 // 创建原型对象 WeeklyLog log_previous = new WeeklyLog(); log_previous.setDate(\"第12周\"); //调用克隆方法创建克隆对象 WeeklyLog log_new = log_previous.clone(); log_new.setDate(\"第13周\"); 缺点 1、需要为每一个类配备一个克隆方法 ，当对已有的类进行改造时，需要修改源代码，违背了“开闭原则”。 2、如果对象复杂，实现深克隆的时候较麻烦。（每一层对象对应的类都必须支持深克隆）       注： 浅克隆、深克隆的概念请查阅其他资料。本章不予讲解。 命令模式 Command Pattern 类型 特点 命令 Command 有N种。包含具体的接收者。 接收者 Receiver 有N种 。执行具体逻辑的地方 。 请求者 Invoker 1种 。 只负责 接收命令并调用命令的执行方法。 示例 /**调用者 */ public class Invoker { /**接收具体命令 并执行*/ public void executeCmd(Command command) { command.execute(); } } /**具体的命令,例如打开连接 */ public class CommandOpenConnection implements Command { 　　private Receiver receiver; /**命令 和 接收者 绑定*/ 　　public CommandOpenConnection(Receiver receiver) { ...} /**执行命令*/ 　　public void execute() { 　　 receiver.doSomeThing(...); 　　} } /**具体的接收者*/ public class ReceiverOpenConnection implements Receiver { public void doSomeThing(...) { 具体的逻辑.... } } //使用场景 Receiver receiver=... ; Invoker invoker = ...; Command cmd1 = ... ; //Command cmd2 = ... ; // 调用者 更新命令 并发起执行 invoker.executeCmd(cmd1);    优点 1、请求者（Invoker） 和执行者（Receiver） 完全解耦。 2、添加新的命令 符合 “开闭原则” 。 缺点 1、一种命令 对应 一个命令类(xxx.java)。导致 类个数过多 。    命令模式 和 策略模式 的区别 1、命令模式 只是强调解耦合，调用者只是负责发起调用。不同的命令得到不同的处理结果 。 2、策略模式 强调 一个问题可以用多种策略方法来 获得相同的处理结果 。 备忘录模式 Memento Pattern 、快照模式 在不破坏封闭的前提下，保存对象当前状态，并且在需要的时候可以再次恢复到此状态。 数据库的 回滚操作、编辑器的 Ctrl+Z恢复 都有用到 备忘录模式。 如何理解“不破坏封闭的前提” 发起者只提供有限的接口（保存、恢复数据）。不暴露其他不该暴露的信息。 缺点 消耗资源。 /**发起者*/ public class Game { /**游戏开始时间*/ private int time; /**游戏人头数*/ private int killPeople; /** 将信息保存到备忘录*/ public GameInfo saveGameInfo() { ... GameInfo gameInfo= new GameInfo(time, killPeople); return gameInfo; } /** * 根据备忘录 恢复 信息 。 */ public void loadGame(GameInfo gameInfo) { ... time = gameInfo.getTime(); killPeople = gameInfo.getKillPeople(); ... } } /**备忘录角色 ,保存指定的状态信息*/ public class GameInfo { private int time; private int killPeople; public GameInfo(int time, int killPeople) { ... } } //使用 Game dota = new Game(); // 将状态保存到备忘录中 GameInfo info = dota.saveGameInfo(); // 根据备忘录 恢复数据 dota.loadGame(info); 外观模式 Facade Pattern 、门面模式 有一个系统 很大、很复杂，以至于一般的人不会用。即使会用也很麻烦。 这时，我们可以对这个系统做封装 ，让大家通过封装后的接口很方便地使用原来的系统 。 示例 开启电脑 需要经过多个步骤，接通电源、启动BIOS、加载系统等等。显然，用户不需要去操作这么繁琐复杂的流程 。 所以我们给用户暴露了一个简单的接口，只要一按开机键 就可以启动电脑了 。大大减小了系统使用的复杂度。 缺点 1、如果子系统做了修改 ， 外观类可能需要做相应修改。违背了开闭原则。 代理模式 、外观模式 的区别 1、侧重点不同， 代理强调 不直接访问原系统（因为权限等） 。 外观模式 强调 复杂系统的简化。 工厂方法模式（Factory Method Pattern） 又被称为多态工厂模式。 通常我们所说的工厂模式是指工厂方法模式。 工厂方法是针对每一种产品提供一个工厂类。通过不同的工厂实例来创建不同的产品实例。 反射生成对象只能适用一些最简单的情况，简单的创建一个对象。如果对象的创建过程比较复杂，例如要调用有参构造函数、创建之前要配置环境等等，需要将这些代码封装到工厂中。 /** * 定义工厂的公共行为。 * 可以用接口或抽象类。 */ public interface Factory { public Product produceProduct() ; } /** * 具体的产品 car */ public class Car implements Product { @Override public void getProductInfo() { System.out.println(\"汽车产品\"); }// }// /** * 具体的产品 bicycle */ public class Bicycle implements Product { @Override public void getProductInfo() { System.out.println(\"自行车产品\"); }// }// /** * 定义工厂的公共行为。 * 可以用接口或抽象类。 */ public interface Factory { public Product produceProduct() ; } /** * 具体的工厂类。BicycleFactory */ public class BicycleFactory implements Factory { @Override public Product produceProduct() { //做一些复杂的操作。比如连接数据库等 // ... //调用有参构造等 Bicycle bicycle = new Bicycle(); return bicycle; } }// /** * 具体的工厂类。CarFactory */ public class CarFactory implements Factory { @Override public Product produceProduct() { //做一些复杂的操作。比如连接数据库等 // ... //调用有参构造等 Car car = new Car(); return car; } }// /**使用场景*/ public static void main(String[] args) { //根据相关参数 生成具体的工厂对象。例如根据配置文件或者网络参数来决定 Factory factory ; factory= new CarFactory() ; //factory= new BicycleFactory() ; Product product = factory.produceProduct() ; product.getProductInfo(); }// 工厂方法模式优点： 1、它能够让工厂可以自主确定创建何种产品对象，而如何创建这个对象的细节则完全封装在不同的具体工厂内部。 2、加入新产品时，无须修改抽象工厂和抽象产品提供的接口，也无须修改其他的具体工厂和具体产品，而只要添加一个具体工厂和具体产品就可以了。 工厂方法模式缺点： 1、在添加新产品时，需要新加新的具体产品类和与之对应的具体工厂类，在一定程度上增加了系统的复杂度，有更多的类需要编译和运行，会给系统带来一些额外的开销。 策略模式和工厂模式有什么区别 1、侧重点不一样 。 工厂模式侧重构建过程，使用者拿到最终的“生产物”即可。 策略模式侧重 事件的行为，使用可互换的规则创建成功业务。 策略模式是开放的，大多数事情要你自己亲力亲为。而工厂模式作是封闭的，很多事情都帮组你做好了，你直接“点”就可以了。 工厂相当于黑盒子，策略相当于白盒子? 参考资料 建造者模式 Builder Pattern 适用于 构建流程非常复杂的 对象。 定义 将一个复杂对象的构造与它的表示分离，使同样的构建过程可以创建不同的表示。 1、对象的构建：对象的组装生成过程。 2、对象的表示：产品本身。产品的特性。 3、同样的创建过程：指挥者中定义的创建的相同流程。 4、创建不同的表示：不同的创建细节区分在构建者当中，调用不同的构建者会有不同的结果。 具有指挥者的建造者模式 （完整模式） // 具体的构建者 只负责 最后的构建细节。 // 不负责这些细节如何组装 class DevilBuilder extends ActorBuilder{ public void buildType() { ...} public void buildSex() { ... } public void buildFace() { ... } public void buildCostume() {...} public void buildHairstyle() {...} } // 指挥者 只负责构建顺序 class ActorController{ public Product getProduct(ActorBuilder ab) { ab.buildType(); ... ab.buildCostume(); // Product在ActorBuilder的构造函数中创建好 return ab.createAProduct(); } } //测试 // 构建顺序定义在 ActorController 中 ActorController controller = ...; // 产品不同部位的构建能力 定义在 builer 中 ActorBuilder builer=...; //根据构建者不同返回产品不同 Product product = controller.getProduct(builer); 没有指挥者的建造者模式（简略模式） 构建顺序 和构建能力 全部定义在 ActorBuilder 中 class DevilBuilder extends ActorBuilder{ public void buildType() { ...} public void buildSex() { ... } public void buildFace() { ... } public void buildCostume() {...} public void buildHairstyle() {...} public Product getProduct() { buildType(); ... buildCostume(); return createAProduct(); } } 建造者模式 和 工厂模式 的区别 工厂模式与 建造者模式的完整模式相比，就多了一个 指挥者。 不同的构建者的 构建流程 抽象出来放在一起了。 与简略模式相比，我感觉没啥区别。 建造者模式 和 策略模式 的区别 个人感觉只是定义的出发点不同。 从形式上看，都是根据传入不同的策略，获得不同的结果。（一种构建者可以看做一种策略） 抽象工厂模式（Abstract Factory Pattern） 工厂方法模式是一个具体工厂生产一种具体产品，抽象工厂模式是一个具体工厂生产一个品牌下的多种产品。 工厂方法模式解决了简单工厂模式中工厂类职责太重的问题。但由于工厂方法模式中的每个工厂只生产一类产品，可能会导致系统中存在大量的工厂类，势必会增加系统的开销。 此时，我们可以考虑将一些相关的产品组成一个“产品族”，由同一个工厂来统一生产，这就是抽象工厂模式的基本思想。 产品等级结构： 类似手机与androdi手机、mac手机的关系。手机和Android手机、mac手机具体手机产品之间构成了一个产品等级结构。 产品族: 同一个品牌下的各种产品，比如android手机和Android电视属于同一个产品族。 Abstract Factory Pattern优点： 1、隔离了具体类的生成，更换一个具体工厂就变得相对容易。 2、增加新的产品族很方便，无须修改已有系统，符合“开闭原则”。 Abstract Factory Pattern 缺点： 1、增加新的产品等级结构麻烦，违背了“开闭原则”。 增加新的产品族很方便，但是增加新的产品等级结构很麻烦，抽象工厂模式的这种性质称为“开闭原则”的倾斜性。 /** * 抽象产品 *Iphone */ public interface Iphone { public void getInfo(); } /** * 抽象产品 *Iphone */ public interface TV { public void getInfo(); } /** * 具体产品。 */ public class AndroidIphone implements Iphone { @Override public void getInfo() { System.out.println(\"mac 手机\"); } } /** * 具体产品。 */ public class MacIphone implements Iphone { @Override public void getInfo() { System.out.println(\"android 手机\"); } } /** * 具体产品。 */ public class AndroidTv implements TV { @Override public void getInfo() { System.out.println(\" Android 电视\"); } } /** * 具体产品。 */ public class MACTv implements TV { @Override public void getInfo() { System.out.println(\" MAC 电视\"); } } /** * 抽象工厂 */ public interface IFactory { public Iphone createPhone() ; public TV createTV() ; } /** * 具体工厂。 */ public class AndroidFactory implements IFactory { @Override public Iphone createPhone() { return new MacIphone(); } @Override public TV createTV() { return new MACTv(); } } /** * 具体工厂 */ public class MacFactory implements IFactory { @Override public Iphone createPhone() { return new AndroidIphone(); } @Override public TV createTV() { return new AndroidTv(); } } /*** * 测试场景 */ public static void main(String[] args) { IFactory factory = new AndroidFactory() ; //根据配置文件或者网络参数，动态决定采用哪一个工厂。 //IFactory factory = new MacFactory() ; //批量得到属于同一品牌下的产品。 Iphone phone = factory.createPhone() ; TV tv = factory.createTV() ; tv.getInfo(); }// 桥接模式 Bridge Pattern 如果一个类有多个变化维度。此时可以使用继承的方法进行组合 ，但是这样会产生大量的派生类 才能满足要求。 此时我们的桥接模式，采用聚合而非继承的方式 也可以实现同样的效果。但是需要的派生类就大大减少了。 抽象部分 、实现部分 概念参考自刘伟 。 假如一个类有两个独立的纬度，我们将与这个类关系最密切、最本质的那个纬度 称之为 “抽象部分”。而另外的一个纬度称之为“实现部分” 。 例如 一支毛笔，有“大小型号” 和\"能绘制的颜色\" 两个纬度 。因为毛笔一旦生产它的大小型号就已经被固定了，而能绘制的颜色可以根据沾染的涂料不同而变化。 所以， “型号”这个纬度划分为 “抽象部分” ，“颜色”划分为 “实现部分” 。 示意图 采用继承的方式去实现效果。需要较多的派生类。 采用桥接的方式去实现效果。型号和颜色互相组合即可实现。 //实现部分 public class Color{ String color=\"\"; public Color(String color) {...} } // 抽象部分 public class Size { Color color; String size =\"大号\" ; public Size(Color color){...} public void disPlay() { System.out.println(size+\" \"+ color.color+ \" 笔\"); } } //组合 Color white =new Color(\"白色 \"); Size size = new Size(white); size.disPlay(); //获得 大号白色笔 模板模式 、模板方法模式 、Template Method Pattern 模板方法使得子类可以在不改变算法结构的情况下，重新定义算法中的某些步骤。 为防止恶意操作，一般模板方法都加上 final 防篡改。 示例 /**抽象类*/ public abstract class AbstractComputer { /**开机*/ protected void powerOn() { ... } /**常规硬件检查*/ protected void checkHardware() { ...} /**加载 操作系统*/ protected void loadOS() { ...} /**默认无密码验证，直接进入系统*/ protected void login() { ... } /** * 模板方法，用 final修饰，防止被篡改 算法流程。 */ public final void startUp() { //公共方法 powerOn(); //有差异性的方法 checkHardware(); //公共方法 loadOS(); //有差异性的方法 login(); } } // 程序员的电脑 CoderComputer extends AbstractComputer... @Override protected void login() { // 验证用户名和密码 } //军用计算机 class MilitaryComputer extends AbstractComputer... @Override protected void checkHardware() { //进行 硬件防火墙 等安全设备是否正常 ... } @Override protected void login() { //验证 指纹 、 用户名、密码等 } AsyncTask 应用 模板方法 @MainThread public final AsyncTask execute(Params... params) { return executeOnExecutor(sDefaultExecutor, params); } @MainThread public final AsyncTask executeOnExecutor( Executor exec, Params... params) { ... onPreExecute(); ... exec.execute(mFuture); return this; } 状态模式 State Pattern 某种业务情况下，确实可以用 if else 来完成 ，但是由于 不同状态下的处理方法不一样。会导致大量的 if else 代码。 会造成代码复杂，不易维护等问题。 此时可以考虑用 状态模式 解决。 示例 一个订单的状态： 未支付、正在支付、已支付、申请退款，退款中，退款完成 //直接采用简单的 if else 方式 public void 支付（） { if(未支付) { //处理 支付操作 }else if(正在支付){ //提示 不符合操作条件。 } else if(退款完成){ //提示 不符合操作条件。 } } public void 退款（） { if(未支付) { //提示 不符合操作条件。 }else if(正在支付){ //提示 不符合操作条件。 } else if(退款完成){ //提示 不符合操作条件。 }else if(已支付){ // 处理退款操作.. } } //如果要新增 一个 \"退款审核\"状态 。 //此时需要去修改以上所有的 if else ,严重破坏 开闭原则 。 //采用状态模式 /**未支付状态*/ public class NoPayStatus { public NoPayStatus(Order order,String name) { //初始化订单信息 } public OrderStatus processOrder(Order order) { //处理当前状态下的订单， ... //根据处理结果，设置订单新的状态 OrderStatus state=new PayStatus(order,\"已支付\"); order.setStatus(state); return state; } } /**申请退款*/ public class ApplyDrawbackStatus { private Order order; private String name; public ApplyDrawbackStatus(Order order, String name) { //初始化订单信息 } @Override public OrderStatus processOrder(Order order) { //处理当前状态下的订单， ... //根据处理结果，设置订单新的状态 return new DrawbackStatus(order, \"订单回款中\"); } } //使用场景 //某个时刻根据情况根据具体情况给订单设置状态 Order order=new Order(); order.setStatus( 某个状态); .... //在另一个时刻，处理订单。 OrderStatus status=order.getStatus(); status.processOrder(order); 缺点 并没有完全符合 开闭原则 。 @Override public OrderStatus processOrder(Order order) { //如果要新增 一个 \"退款审核\"状态 。 //也需要修改相关代码 //return new DrawbackStatus(order, \"订单回款中\"); return new CheckDrawbackStatus(order, \"退款审核中\"); }       策略模式 和 状态模式 的区别 1、策略模式只是一个解决方案的封装 。重在外部对策略的选择或动态的切换。策略模式每个算法是相对独立的。 2、状态模式是初始化一个状态，之后的每个状态的变化都会指定下一个状态。状态模式中每个状态是存在相互转化的， 策略模式 Strategy Pattern /**抽象接口，定义共同操作*/ public interface Strategy { public double getValue(double paramA, double paramB); } /*** * 加法策略 */ public class AddStrategy implements Strategy { @Override public double getValue(double paramA, double paramB) { return paramA + paramB; } }// /*** * 减法策略 */ public class SubStrategy implements Strategy { @Override public double getValue(double paramA, double paramB) { return paramA - paramB; } }// /** * 根据传入的策略类型返回计算结果。 辅助类。 */ public class CalcClient { private Strategy strategy; public void setStrategy(Strategy strategy) { this.strategy = strategy; } public double calc(double paramA, double paramB) { return this.strategy.getValue(paramA, paramB); } } /////////////// 演示 ///////////////////// public static void main(String[] args) { double paramA = 5; double paramB = 21; //用if-else实现 （ 普通形式） System.out.println(\"普通方法-加法结果是：\" + calc(\"+\", paramA, paramB)); System.out.println(\"普通方法-减法结果是：\" + calc(\"-\", paramA, paramB)); //System.out.println(\"乘法结果是：\" + calc(\"*\", paramA, paramB)); //System.out.println(\"除法结果是：\" + calc(\"/\", paramA, paramB)); //策略模式 System.out.println(\"策略模式-加法结果是：\" + calc(new AddStrategy(), paramA, paramB)); System.out.println(\"策略模式-减法结果是：\" + calc(new SubStrategy(), paramA, paramB)); //System.out.println(\"乘法结果是：\" + calc(new MultiStrategy(), paramA, paramB)); //System.out.println(\"除法结果是：\" + calc(new DivStrategy(), paramA, paramB)); } /*** * 用if-else实现 （ 普通形式） */ public static double calc(String op, double paramA, double paramB) { if (\"+\".equals(op)) { return paramA + paramB; } else if (\"-\".equals(op)) { return paramA - paramB; } else if (\"*\".equals(op)) { return paramA * paramB; } else if (\"/\".equals(op)) { return paramA / paramB; } else { throw new IllegalArgumentException(\"未找到计算方法!\"); } } /*** * 策略模式 实现 */ public static double calc(Strategy strategy, double paramA, double paramB) { CalcClient calc = new CalcClient(); calc.setStrategy(strategy); return calc.calc(paramA, paramB); } 前者通过简单的if-else来解决问题，在解决简单问题事会更简单、方便; 后者则是通过给予不同的具体策略来获取不同的结果，对于较为复杂的业务逻辑显得更为直观，扩展也更为方便。 策略模式的优缺点： 优点： 1、结构清晰明了、使用简单直观。 2、耦合度相对而言较低，扩展方便。 3、操作封装也更为彻底，数据更为安全。 缺点： 1、随着策略的增加，子类也会变得繁多。 简单工厂模式（Simple Factory Pattern） 又叫做静态工厂方法（StaticFactory Method）模式。 注：简单工厂模式实际上不属于23个GOF模式。 工厂类根据传入的参量,动态的决定应该创建出哪一个产品类的实例的设计模式。一个工厂可以生产多种产品。 优点 使用者不需要去负责具体的创建过程，只需要向工厂传递参数信息就可以获得自己想要的产品。 缺点： 因为工厂类集中了所有实例的创建逻辑， 如果需要增加新的产品，就需要修改工厂类，不利于代码的维护。违背了“开闭原则” 。所以不推荐使用这种设计模式。 客户很爽，工厂很被动。 //demo: /** * 产品抽象类，定义产品共同的特效 */ public interface Product { public void getProductInfo() ; } /** * 具体的产品 car */ public class Car implements Product { @Override public void getProductInfo() { System.out.println(\"汽车产品\"); }// }// /** * 具体的产品 bicycle */ public class Bicycle implements Product { @Override public void getProductInfo() { System.out.println(\"自行车产品\"); }// }// /** * 简单工厂。 */ public class SimpleFactory { /** * 根据不同的参数进行判断，返回不同的结果。 * 如果增加了产品类，需要修改判断代码。 * 静态工厂方法 的“静态”体现在这个 static方法上 */ public static Product getProductInfo(String productType ) { Product product = null ; if(\"car\".equals(productType)){ product = new Car() ; }else{ product = new Bicycle() ; } return product; }// } /** * 测试场景 */ public static void main(String[] args) { //直接调用工厂类的 静态方法或的产品。 Product product =SimpleFactory.getProductInfo(\"car\") ; product.getProductInfo() ; }// 组合模式 Composite Pattern 、 整体-部分模式 组合模式将一批有共同特征的对象组合成 “树形结构”。 关键点是定义了一个抽象构件类，它既可以代表叶子，又可以代表容器，而客户端针对该抽象构件类进行编程，无须知道它到底表示的是叶子还是容器，可以对其进行统一处理。 透明组合模式 （推荐使用） 强调透明性一致性。 因为叶子节点不存在子节点，所以一些方法是无效的。可以用过 “提供异常处理或相关提示”来解决 。 安全组合模式 /**抽象节点 */ abstract class AbstractFile { public abstract void add(AbstractFile file); public abstract AbstractFile getChild(int i); public abstract void killVirus(); } /**叶子节点*/ class ImageFile extends AbstractFile { private String name; public ImageFile(String name) { ...} public void add(AbstractFile file) { // 子节点 不支持 当前方法 的相关提示 } public AbstractFile getChild(int i) { // 子节点 不支持 当前方法 的相关提示 return null; } public void killVirus() { //模拟杀毒 ... } } /**容器节点*/ class Folder extends AbstractFile { private ArrayList fileList=new ArrayList<>(); private String name; public Folder(String name) {...} public void add(AbstractFile file) { fileList.add(file); } public AbstractFile getChild(int i) { return (AbstractFile)fileList.get(i); } public void killVirus() { //递归调用 for(AbstractFile obj : fileList) { obj .killVirus(); } } } //使用 。针对抽象构件编程 // 子节点 AbstractFile folder2 = new Folder(\"图像文件夹\"); folder2.add(new ImageFile(\"xxx.jpg\")); folder2.add(new ImageFile(\"xxxx.gif\")); // 容器节点 AbstractFile file1 = new Folder(); folder1.add(folder2); folder1.killVirus(); 优点 1、将对象们进行树形分层，方便对整个某个层次的所有对象进行处理。 2、使用透明组合模式时， 新增节点(容器节点、子节点) 符合 “开闭原则” 。 装饰者模式 、Decorator Pattern 、包装模式 、Wrapper Pattern 在不改变一个对象原有结构和功能的前提下，给它新加一些额外的功能。 装饰模式是一种用于替代继承的技术。 /**被装饰的原始对象*/ public class ConcreteComponent extends MyComponent { /**原有功能*/ @Override public void operation() { ... } } 透明装饰模式 (尽量使用这种方式) 要求完全针对抽象编程。可以透明地使用装饰之前的对象和装饰之后的对象。 为了达到这种效果， 必须在构件对象的方法中调用 增强方法。 但是缺点是用户不能单独地调用那些增强的方法 。 /**具体装饰器*/ public class ConcreteDecoratorA extends MyComponent { MyComponent component ; /**持有被装饰的对象*/ public ConcreteDecoratorA(MyComponent component) { ... } public int operationA(){ ... 增强方法 ... } @Override public void operation() { // 区别点！！里面调用了 operationA（） operationA(); component.operation(); } } MyComponent myComponet1= new ConcreteComponent(...); // 针对MyComponent抽象编程 MyComponent myComponet2 = new ConcreteDecoratorA(myComponet1); myComponet1.operation(); //不能在外面调用额外功能 。- 编译 出错 myComponet2.operationA(); myComponet2.operation(); 半透明装饰模式 /**具体装饰器*/ public class ConcreteDecoratorA extends MyComponent { MyComponent component ; /**持有被装饰的对象*/ public ConcreteDecoratorA(MyComponent component) { ... } public int operationA(){ ... 增强方法 ... } @Override public void operation() { // 区别点！！ 在里面并没有调用 operationA() component.operation(); } } MyComponent myComponet1= new ConcreteComponent(...); ConcreteDecoratorA myComponet2 = new ConcreteDecoratorA(myComponet1); //透明装饰者模式 myComponet1.operation(); // 可以在外 调用增强方法 - 编译ok myComponet2.operationA(); myComponet2.operation(); 如何理解 “半透明装饰模式不能实现对同一个对象的多次装饰” 首先明确一点：半透明装饰模式 是将 增强方法 和原有方法 独立开来的。在装饰器中 原有方法并没有调用过增强方法。 因为装饰类持有的是 MyComponent 类型的引用，而 MyComponent 并不能调用增强方法。所以导致如下结果： 多次装饰的情况下，无法使用那些增强方法。 代理模式 与 装饰者模式 区别 代理模式的目标是控制对被代理对象的访问（强调控制） ，而装饰模式是给原对象增加额外功能 （强调增加功能）。 观察者模式 Observer Pattern 观察者模式 1、Observer Pattern用于建立一种对象与对象之间的依赖关系。 一个对象发生改变时将自动通知其他对象，其他对象将相应作出反应。 2、Observer Pattern包含1个观察目标和n(n>=1)观察者两类对象。一旦观察目标的状态发生改变，所有的观察者都将得到通知。 3、这种交互也称为发布-订阅(Publish-Subscribe)。 发布者发出通知时并不需要知道谁是它的观察者，可以有任意数目的观察者订阅它并接收通知。 4、凡是涉及到一对一或者一对多的对象交互场景都可以使用观察者模式。 观察者模式的应用 1、交通信号灯是汽车（驾驶员）的观察目标，而汽车是观察者。 随着交通信号灯的变化，汽车的行为也将随之而变化，一盏交通信号灯可以指挥多辆汽车。 2、在当前流行的MVC架构中也应用了观察者模式，它包含三个角色：模型(Model)，视图(View)和控制器(Controller)。 其中模型可对应于观察者模式中的观察目标，而视图对应于观察者，控制器可充当两者之间的中介者。 当模型层的数据发生改变时，视图层将自动改变其显示内容。 观察目标 Observer Pattern中，发生改变的对象称为观察目标。 观察者 而被通知的对象称为观察者。 1、一个观察目标可以对应多个观察者。 2、这些观察者之间可以没有任何相互联系。 3、可以根据需要增加和删除观察者，使得系统更易于扩展。 Observer Pattern优点 1、观察者模式可以实现表示层和数据逻辑层的分离，定义了稳定的消息更新传递机制，并抽象了更新接口，使得可以有各种各样不同的表示层充当具体观察者角色。 2、观察者模式在观察目标和观察者之间建立一个抽象的耦合。观察目标只需要维持一个抽象观察者的集合，无须了解其具体观察者。 3、观察者模式支持广播通信，观察目标会向所有已注册的观察者对象发送通知，简化了一对多系统设计的难度。 4、观察者模式满足“开闭原则”的要求，增加新的具体观察者无须修改原有系统代码，而且观察目标和观察者没有紧密地耦合在一起，因此它们可以属于不同的抽象化层次。在具体观察者与观察目标之间不存在关联关系的情况下，增加新的观察目标也很方便。 Observer Pattern缺点： 1、若一个观察目标对象有很多直接和间接观察者，将所有的观察者都通知到会耗时过多。 2、若观察者和观察目标之间存在循环依赖，观察目标会触发它们之间进行循环调用，可能导致系统崩溃。 3、Observer Pattern没有相应的机制让观察者知道所观察的目标对象是怎么发生变化的，而仅仅只是知道观察目标发生了变化。 Observer Pattern应用场景 1、邮件订阅和RSS订阅，当我们浏览一些博客或wiki时，当你订阅了该文章，如果后续有更新，会及时通知你。 demo: /** * 观察者抽象类，定义共同的行为 */ public interface Observer { public void update(); } /*** * 具体的观察者 1 */ public class Observer1 implements Observer { @Override public void update() { System.out.println(\"观察者 1收到通知\"); } }// /*** * 具体的观察者 2 */ public class Observer2 implements Observer { @Override public void update() { System.out.println(\"观察者 2收到通知\"); } }// /** * 被观察者接口。 * 定义一些 方法用来管理 观察者集合。 */ public interface Subject { /**添加观察者*/ public void addObserver(Observer observer) ; /**删除观察者*/ public void delObserver(Observer observer) ; /**通知观察者*/ public void notifyAllObservers(); }// /*** * 具体的 被观察者 （观察目标）。 */ public class MySubject implements Subject { /**线程安全的集合*/ private Vector myObservers ; /**构造函数*/ public MySubject () { myObservers = new Vector(); } @Override public void addObserver(Observer observer) { myObservers.add(observer) ; } @Override public void delObserver(Observer observer) { myObservers.remove(observer) ; } @Override public void notifyAllObservers() { //使用迭代器获取所有观察者 并通知 Iterator iterator = myObservers.iterator() ; while (iterator.hasNext()) { Observer observer = iterator.next(); observer.update(); }// }// } /**实际场景应用*/ public static void main(String[] args) { Observer1 ob1 = new Observer1() ; Observer2 ob2 = new Observer2() ; MySubject mySubject = new MySubject() ; mySubject.addObserver(ob1); mySubject.addObserver(ob2); mySubject.notifyAllObservers() ; }// 解释器模式 Interpreter Pattern 还未完全理解。 等过段时间再来更新.... 解释器模式为自定义语言的设计和实现提供了一种解决方案，它用于定义一组文法规则并通过这组文法规则来解释自定义语言中的句子。 #### 应用场景 1、正则表达式解释器 2、SQL语法的解释器 相关概念 特点 举例 终结符（表达式） 不可拆分的最小元素。 一个语法的规则不能改变终结符。 x -> xa a是终结符 非终结符（表达式） 可拆分元素。 非终结符是可以被取代的元素。运算符也是非终结符 x -> xa x 是非终结符 语言的文法规则 即语法规则。拥有自己的表达式和结构。 抽象语法树(Abstract Syntax Tree, AST) 用来直观地表示语言的构成。 每一棵抽象语法树对应一个语言实例。 终结符表达式类的实例作为树的叶子节点，非终结符表达式类的实例作为非叶子节点。 通过对抽象语法树的分析，可以识别出语言中的终结符类和非终结符类。 环境角色 存放文法中各个终结符所对应的具体值 #### 示例 Java无法直接解释类似“1+ 2 + 3 – 4 + 1”这样的字符串。 我们可以自己定义 一个解释器来解释这个语句 。 一些重复发生的问题，比如加减乘除四则运算，但是公式每次都不同，有时是a+b-cd，有时是ab+c-d，等等等等个，公式千变万化，但是都是由加减乘除四个非终结符来连接的，这时我们就可以使用解释器模式。 ``` ~~#### 缺点 1、 执行效率低。 2、 维护困难。~~ # 访问者模式 Visitor Pattern 访问者模式把 数据结构 和 作用于结构上的操作 解耦合 。适用于数据结构相对稳定算法又易变化的场景。 ## [示例](https://blog.csdn.net/lovelion/article/details/7433576) 以公司员工和部门的关系为场景。 ```java /**全职员工*/ public class FulltimeEmployee implements Employee { public FulltimeEmployee(String name, int workTime) {...} /**每个对象都会实现这个方法*/ @Override public void accept(Department handler) { //每个访问者都会有这个方法 handler.visit(this); } } /**人力资源部类：具体访问者类*/ public class HRDepartment implements Department { /**所有访问者都会重载 所有 visit方法*/ @Override public void visit(FulltimeEmployee employee) { ... } /***所有访问者都会重载 所有 visit方法 */ @Override public void visit(ParttimeEmployee employee) { ... } } //使用。访问者不同，会做出不同的处理结果 Employee employee = new FulltimeEmployee(...); Department dep = new HRDepartment(....) ; //Department dep = new FADepartment (....) ; employee.accept(dep); 优点 1、方便定义 新的访问者，实现新的数据操作。 //Department dep = new HRDepartment(....) ; //定义新的访问者 Department dep = new FADepartment (....) ; 缺点 1、违背了\"依赖倒置原则\" 。访问者依赖的是具体元素，而不是抽象元素。 public void visit(FulltimeEmployee employee) { ... } 2、增加新的元素类比较困难。 每增加一个元素类 , 访问者就要多加一个visit()。 // 有 n个元素类 就有 n 个visit 方法 @Override public void visit(FulltimeEmployee employee) { ... } .... @Override public void visit(ParttimeEmployee employee) { ... }    访问者模式 和 策略模式 的区别 我个人感觉这两个模式差不多。 个人体会到的区别： 1、策略模式是通过构造方法将策略传进去的 。 访问者模式 是通过普通的方法 accept() 将访问者（策略）传进的。 2、 体现在定义架构上 public class HRDepartment implements Department { @Override public void visit(FulltimeEmployee employee) { ... } ... @Override public void visit(ParttimeEmployee employee) { ... } } 责任链模式 Chain of Responsibility Pattern 其实 ，swith 、if-else 体现了最简单的责任链思想 。只是这种写法 比较臃肿、耦合度高。 优点 1、一个请求沿着一条“链”传递，申请者不需要知道是谁来批准这个请求。 批阅者也不需要这个请求来自谁。 这样将 申请者和批阅者优雅地解耦了。 2、容易拓展责任链 缺点 1、需要对链中责任人的遍历，如果责任人太多那么遍历必定会影响性能。 2、请求不一定会被处理掉。 代码示例 /**责任人的处理方法*/ public void handleRequest(ProgramApe ape) { if ( 有处理权限) { // 自己处理掉... } else { if (null != mSuperiorLeader) { //如果自己没有权限处理， 就交给上级处理 } else { //如果自己没有权限处理， 也没有其他领导。就抛出错误，提示该 //请求没有被处理掉 } } } //应用场景 //先来一个程序猿 这里给他一个三万以内的随机值表示需要申请的差旅费 ProgramApe ape = new ProgramApe((int) (Math.random() * 30000)); //再来四个领导 Leader leader = new GroupLeader(); Leader director = new Director(); Leader manager = new Manager(); Leader boss = new Boss(); //事先设置好 责任链之间的连接关系 leader.setLeader(director); director.setLeader(manager); manager.setLeader(boss); // 提交申请（不用写 if else 繁琐代码） leader.handleRequest(ape); 迭代器模式 Iterator Pattern 、游标模式 迭代器模式 提供一种机制 遍历一个聚合对象中的各个元素，而又不暴露其他细节。 /**具体迭代器*/ class ConcreteIterator implements MyIterator{ private List list = new ArrayList (); private int cursor =0; public ConcreteIterator(List list){ this.list = list; } public boolean hasNext(){ return !(cursor == list.size()); } public Object next(){ if(hasNext()){ return list.get(cursor++); } return null; } } /**具体的聚合类*/ class ConcreteAggregate { private List list = new ArrayList(); public MyIterator iterator(){ return new ConcreteIterator(list); } /** * 聚合类中的其他方法 ，处理其他逻辑 * fun1 、saveObj 、removeObj */ public void saveObj(Object obj) { ... } ... 其他逻辑... } //使用 // 聚合类 ConcreteAggregate ag = new ConcreteAggregate(); ag.saveObj(\"obj1\"); ag.saveObj(\"obj2\"); // 获取迭代器 MyIterator it = ag.iterator(); //根据迭代器 遍历 while(it.hasNext()){ ... } 优点 1、将聚合类 的 “数据存储” 和 \"数据遍历\" 分离 。 2、自定义的迭代器可以实现一些自己想要的遍历效果（逆序遍历、只遍历符合自己指定条件的对象等）。 缺点 1、一个具体的聚合类 对应一个 迭代器 ，略显繁琐。 注 由于java已经为我们对容器对象（Collection，List、Set、Map等）做了很好的封装，我们平时其实很少会自己实现迭代器模式。 适配器模式 Adapter Pattern 解决接口不兼容的问题。 A 需要 C接口， 但是系统只提供了B接口。 同时, A 和B 都不想改或者不能改。 如果，我们将B封装一下，改成C接口的规范。就解决了问题。 被适配者 ：即源接口 一、类适配器 （不推荐） 采用继承方案。 // 旧接口 提供220V电压 public class Voltage220 { public int output220V() { return 220; } } // 用户需要 5V的电压 public interface Voltage5 { int output5V(); } //新建适配器 public class VoltageAdapter extends Voltage220 implements Voltage5 { @Override public int output5V() { //获得旧接口的数据， 转换成用户需要的数据 int src = output220V(); return src / 44; } } 二、对象适配器 （推荐） 采用持有方案。 // 新建适配器 public class VoltageAdapter2 implements Voltage5 { private Voltage220 mVoltage220; public VoltageAdapter2(Voltage220 voltage220) {...} @Override public int output5V() { int src = mVoltage220.output220V(); return src / 44; } } 三、缺省适配器 、接口适配器模式（推荐） 原接口是 interface 。 // 原接口 public interface AnimatorPauseListener { void onAnimationStart(Animator animation); void onAnimationEnd(Animator animation); ... void onAnimationResume(Animator animation) ; } // 新建适配器 public abstract class AnimatorListenerAdapter implements AnimatorListener { @Override public void onAnimationEnd(Animator animation){...} @Override public void onAnimationStart(Animator animation){...} @Override public void onAnimationResume(Animator animation) {...} } // 使用 XXX.addListener(new AnimatorListenerAdapter() { @Override public void onAnimationStart(Animator animation) { // 重新 需要的那个方法就行。 // 而不必 要实现 interface 中所有的方法，从而简化代码 } }); 四、双向适配器 （不推荐） 同时持有原接口和旧接口的对象。 class Adapter implements DesInterface,SrcInterface { private Des des; private Src src; public Adapter(Des des) {... } public Adapter(Src src) {...} public void() func1(){ src.xxx(); }; public void() func2(){ des.xxx(); }; } 1 无版权 可以无限制使用！ all right reserved，powered by Gitbook该文件更新时间： 2019-04-12 16:36:22 "},"chinese/设计模式/mvc等.html":{"url":"chinese/设计模式/mvc等.html","title":"mvc等","keywords":"","body":"mvc 1979年，Trygve Reenskaug 在Smalltalk-80系统上首次提出了MVC的概念， 最初的时候叫做Model-View-Controller-Editor。 MVC并不是一种设计模式，不在23种经典设计模式中。 可以理解为 MVC是一种架构模式，一种架构可能 运用到了多种设计模式。 MVC不是一种设计模式，而是多种设计模式的具体应用。 Model 、 模型 适合做一些业务逻辑处理，比如数据库存取操作，网络操作，复杂的算法，耗时的任务等都在model层处理。 View 、 视图 处理数据显示的部分，XML布局可以视为V层，显示Model层的数据结果。 Controllor 、控制器 处理用户交互问题。 mvc架构图 mvc优点 1、实现了分层开发 2、降低了代码的耦合 mvc不足 1、增加了代码编写的复杂性 2、解耦合不够彻底(MVC中允许Model和View进行交互) MVP mode 业务逻辑和实体模型层 view 视图展示层。 V层没有任何的逻辑部分又不用主动监听数据，被称之为“被动视图”。 Presenter 负责view和model层的交互。 mvp 特点 于mvc相比，mvp有以下特点 1、 mode层和view层只能通过 Presenter层进行交互 2、view层和Presenter层通过接口进行交互 3、一个复杂的view层可以对应多个presenter mvp架构图 mvp优点 1、相对mvc解耦更彻底 mvp缺点 1、多了很多接口文件。 在实际的开发过程中，很难严格遵循。（繁多的接口，繁琐的接口通信） mvp demo(Android应用场景) /** * mode层中的接口 */ public interface OnLoginListener{ void loginSuccess(User user); void loginFailed(); } /** * mode层 ，实体对象 */ public class User{ private String username ; private String password ; } /** * mode层，业务逻辑 */ public class UserBiz{ public void login(final String username, final String password, final OnLoginListener loginListener) { //模拟子线程耗时操作 new Thread() { @Override public void run() { try { Thread.sleep(2000); } catch (Exception e) { } if (\"fuckName\".equals(username) && \"fuckPwd\".equals(password)) { User user = new User(); user.setUsername(username); user.setPassword(password); loginListener.loginSuccess(user); } else { loginListener.loginFailed(); } } }.start(); }// } /** * view层和present层 通信的公共接口 */ public interface IUserLoginView{ String getUserName(); String getPassword(); void toMainActivity(User user); void showFailedError(); } /** * presenter层。 */ public class UserLoginPresenter{ private IUserLoginView userLoginView; private UserBiz userBiz; public UserLoginPresenter(IUserLoginView userLoginView){ this.userLoginView = userLoginView; this.userBiz = new UserBiz(); } /** * 对view开发的接口。 * 与view进行交互 */ public void login() { /** * present与mode层进行交互 */ userBiz.login(userLoginView.getUserName(), userLoginView.getPassword(), new OnLoginListener() { @Override public void loginSuccess(final User user) { //与view进行交互(反馈信息) userLoginView.toMainActivity(user); } @Override public void loginFailed() { //登录失败 userLoginView.showFailedError(); } }); } } /** * View层。 * View通过接口与Presenter进行交互 */ public class UserLoginActivity extends Activity implements View.OnClickListener ,IUserLoginView{ private UserLoginPresenter mUserLoginPresenter = new UserLoginPresenter(this); @Override public void onClick(View v) { mUserLoginPresenter.login(); }// @Override public String getUserName() { return \"fuckName\"; } @Override public String getPassword() { return \"fuckPwd\"; } public void toMainActivity(User user){ //presenter 反馈登录成功 } public void showFailedError() { //presenter 反馈登录失败 } } 第三方MVP框架 1、mosby 2、MVPArms MVVM MVVM架构在一定程度上减少了MVP存在的以下缺点。 1、P层与V层是通过接口进行交互的，接口粒度不好控制。 粒度太小，就会存在大量接口的情况，使代码太过碎版化; 粒度太大，解耦效果不好。 2、V层与P层还是有一定的耦合度。 一旦V层某个UI元素更改，那么对应的接口就必须得改， 数据如何映射到UI上、事件监听接口这些都需要转变，牵一发而动全身。 3、复杂的业务同时也可能会导致P层太大，代码臃肿的问题依然不能解决， 这已经不是接口粒度把控的问题了，一旦业务逻辑越来越多，View定义的方法越来越多， 会造成Activity和Fragment实现的方法越来越多，依然臃肿。 MVVM模块 模块 说明 M,model 业务逻辑和实体模型 V ,view 视图展示 VM , viewModel 完全是跟逻辑相关的代码 mvvm的缺点 它将 View 的显示逻辑包含到了 View 中。不仅会造成混乱， 也让我们的测试和调试变的更加困难，因为它将逻辑和布局混淆在一起。 DataBinding 我个人并不喜欢 DataBinding 这种方式 ，感觉挺麻烦，而且容易导致写出“面条代码”。 Data Binding Library 谷歌官方出品的一款数据绑定工具 ， 是以MVVM思想指导实现的。 可以实现单向绑定或双向绑定，做到UI和数据的相互监听 。 DataBinding 使用了观察者模式实现的数据驱动。 DataBinding 简单使用 1、开启android内置的 DataBinding dataBinding { enabled true } 2、.xml布局 3、java代码赋值部分 //注意这个类的命名规则 ActivityMainBinding binding = DataBindingUtil.setContentView(this ,R.layout.activity_main) ; User user = new User(\"tom\" ,20); binding.setUser(user); 无版权 可以无限制使用！ all right reserved，powered by Gitbook该文件更新时间： 2018-12-07 17:21:03 "},"chinese/通信方式/通信方式.html":{"url":"chinese/通信方式/通信方式.html","title":"通信方式","keywords":"","body":"通信方式 http 、https 方式 1、http是基于 TCP/IP 的应用层协议 。 2、 采用 “一问一答” 模式 ，并不会保持长连接。 3、HTTP允许传输任意类型的数据对象。传输的类型由Content-Type加以标记。 Content-type HTTP Content-type 手册 文件扩展名 Content-Type .*（ 二进制流，不知道下载文件类型） application/octet-stream .txt text/plain .xml text/xml .css text/css .html text/html .js application/x-javascript 以下是RFC1867协议为HTTP协议的基础上|-为INPUT标签增加了file属性 文件扩展名 Content-Type 无文件的表单提交 application/x-www-form-urlencoded 有文件的表单提交 multipart/form-data 没查到何人何时 添加支持“json提交格式 ”的。 文件扩展名 Content-Type json格式的请求 application/json 建立、断开 http连接 http建立连接，底层是通过 Tcp协议 经过了3次握手、断开经过4次挥手。具体请查看tcp的相关知识。 TCP/IP协议族 https请求 即使采用了 HTTPS，也可以实现中间人攻击，或者进行数据解密等，但是，目前 HTTPS 目前使用的加密算法需要巨大的计算量才能破解 HTTPS 的目的主要有三个， 一个是数据的保密性，你给别人送个邮包，但邮包是打了封印的，快递员不知道包里装的是啥。 第二是数据的完整性，快递员不知道邮包是啥，但可以掉包啊，HTTPS 发现了掉包的数据，可以拒收。 第三就是身份验证，HTTPS 可以保证邮包被正确的送到指定的接收方，而不是第三方。 https相关术语 专业名词 解释 其他 SSL（Secure Sockets Layer） 网景公司设计的 单向证书认证 任何客户端都可以访问服务器 双向证书认证 被允许的客户端才能访问服务器 对称加密 加密和解密时使用的是同一个秘钥 非对称加密 用公钥加密，私钥解密 公钥 负责加密 在网络上传输 私钥 负责解密 本地保管，别人无法获取 ftp 第三方工具ftp4j ftp登录 @Override public void run(){ //标记是否登录成功 boolean loginError = false ; try { mFTPClient.setType(FTPClient.TYPE_BINARY); //中文文件名 乱码处理 mFTPClient.setCharset(\"GBK\"); //登录成功后FTP服务器返回的欢迎语句 String[] welcome = mFTPClient.connect(FTP.HOST_IP, FTP.HOST_PORT); mFTPClient.login(FTP.HOST_USER, FTP.HOST_PASSWORD); mHandler.sendEmptyMessage(FTP.MSG_CMD_CONNECT_OK); }catch (Exception e) { loginError = true ; } if(loginError && FTP.mDameonRunning){ mHandler.sendEmptyMessageDelayed(FTP.MSG_CMD_CONNECT_FAILED, 2000); } } ftp删除文件（夹） @Override public void run(){ try { if (isDirectory) { //删除文件夹 mFTPClient.deleteDirectory(realivePath); } else { //删除文件 mFTPClient.deleteFile(realivePath); } mHandler.sendEmptyMessage(FTP.MSG_CMD_DELE_OK); } catch (Exception ex) { mHandler.sendEmptyMessage(FTP.MSG_CMD_DELE_FAILED); } } ftp断开连接 if (mFTPClient != null){ try { mFTPClient.disconnect(true); } catch (Exception ex) { ex.printStackTrace(); } } ftp文件下载 if(! localFile.exists()){ long fileSize = ftpFile.getSize() ; if(fileSize > 0){ mFTPClient.download( ftpFile.getName(), new File(localFilePath), new DownloadFTPDataTransferListener(ftpFile.getSize())); }else{ //文件异常的情况 下载发生异常the size of file muset be larger than zero. } } ftp 获取文件列表 @Override public void run(){ try { mFTPClient.changeDirectory(FTP.FTPSMAllPICDIR); FTPFile[] ftpFiles = mFTPClient.list(); synchronized (mLock){ mFileList.clear(); //数组拷贝到list中去 mFileList.addAll(Arrays.asList(ftpFiles)); } mHandler.sendEmptyMessage(FTP.MSG_CMD_LIST_OK); } catch (Exception ex) { mHandler.sendEmptyMessage(FTP.MSG_CMD_LIST_FAILED); } }// ftp 文件上传（进度条） try { File file = new File(path); mFTPClient.upload(file, new DownloadFTPDataTransferListener( file.length())); } catch (Exception ex) { return false; } ftp 连接守护进程 //在子线程中定时判断 if (mFTPClient != null && !mFTPClient.isConnected()){ try { //解决中文件名乱码问题 mFTPClient.setType(FTPClient.TYPE_BINARY); mFTPClient.setCharset(\"GBK\"); mFTPClient.connect(FTP.HOST_IP, FTP.HOST_PORT); mFTPClient.login(FTP.HOST_USER, FTP.HOST_PASSWORD); Thread.sleep(FTP.MAX_DAMEON_TIME_WAIT); } catch (Exception ex) { } } FTP 传输进度 回调 public class DownloadFTPDataTransferListener implements FTPDataTransferListener{ /**已经传送量*/ private int totolTransferred = 0; /**数据总量*/ private long fileSize = -1; public DownloadFTPDataTransferListener(long fileSize){ if (fileSize 使用场景 FtpManager ftpManager = new FtpManager(); //然后 ftp 的相关操作 要放到子线程中去执行。 建议使用线程池。 sockt tcp_udp 进行tcp通信时，需要注意处理 粘包的问题。然后控制好休眠时间 和 接收的 buffer[] 大小。 TCP标志位 (位码) 标记 含义 SYN synchronous 建立联机 ACK acknowledgement 确认 PSH push传送 FIN finish结束 RST reset重置 URG urgent紧急 术语 Sequence number 顺序号码 Acknowledge number 确认号码 MSL Maximum Segment Lifetime ，报文最长存活时间 tcp相关问题 为什么连接的时候是三次握手，2次不行吗? 为了让服务器、客户端端彼此知道 自己+对方的 接收、发送功能正常。 自己模拟一下就知道至少需要三次。 为什么连接的时候是三次握手，关闭的时候却是四次挥手？ 关闭连接时，当Server端收到FIN报文时，很可能并不会立即关闭SOCKET， 所以只能先回复一个ACK报文，告诉Client端，\"你发的FIN报文我收到了\"。 只有等到我Server端所有的报文都发送完了，我才能发送FIN报文，因此不能一起发送。 故需要四步挥手。 （为了争取一段缓冲时间，完成正在进行的数据传输） 为什么客户端在TIME-WAIT状态必须等待2MSL的时间？ 为了保证客户端发送的最后一个ACK报文段能够到达服务器。 因为这个ACK报文段有可能丢失，因而使处在LAST-ACK状态的服务器收不到对已发送的FIN+ACK报文段的确认。 服务器会超时重传这个FIN+ACK报文段。而客户端就能在2MSL时间内收到这个重传的FIN+ACK报文段。 接着客户端重传一次确认，重新启动2MSL计时器。 最后客户端和服务器都正常进入到CLOSED状态。 粘包处理 目前不是最优方法，速度有点慢。想到高效的方法再补充。 public class AirUnPackTools{ /**帧头*/ private static final byte packHead1= (byte) 0xDD; /**是否在有效数据之内*/ private static boolean isContinue = false ; private static byte mlastByte =(byte) 0x00 ; /**byte索引 ， 用来指示 关键字 和 长度 */ private static int mByteIndex = 0; /**当前帧的长度*/ private static int mFrameLengh =0 ; /**临时list*/ private static List lastBytesList = new ArrayList<>() ; /**数据段 数据长度 */ private static int mbyteCount = 0; /**遥控器返回的消息类型 = 0x55 ,5a ,5b ， 00为默认状态，无意义*/ private static byte msgType =0x00 ; /** * 对来自 遥控端的 bytes数据解包 */ public static DronePacket320 unPackageofGround(byte mByte){ DronePacket320 packetGround = null ; //判断是否是帧开头 switch (mByte) { case packHead1: // 连续出现2个DD ，说明这是帧头 if(mlastByte == packHead1 ) { lastBytesList.clear(); lastBytesList.add(packHead1) ; mByteIndex = 0; isContinue = true ; } break; } if(isContinue) { boolean reslut = getUnpackagedFrame(mByte); if(reslut) { packetGround = new DronePacket320() ; packetGround.msgType = msgType ; packetGround.bytes = listToBytesArray(lastBytesList) ; }else{ packetGround = null ; } }else{ packetGround = null ; } mlastByte = mByte ; return packetGround ; } public static byte [] listToBytesArray(List list) { byte[] bytes = new byte[list.size()] ; for(int i= 0; i public class DronePacket320{ public short msgType; public byte[] bytes; } //使用 for (int i = 0; i 第三方库 netty 用来连接tcp、接收 和发送数据的 public interface MyNettyCallBack{ /**tcp成功建立连接*/ public static final int Key_State_connect=1 ; /**tcp断开*/ public static final int Key_State_disConnect=2 ; /**tcp正在重连*/ public static final int Key_State_isReConnect=3 ; /**连接发生异常*/ public static final int Key_State_error=4; /**连接手动关闭*/ public static final int Key_State_close=5; /**连接正常-正在接收数据*/ public static final int Key_State_recevieData=6; /**服务器返回信息给客户端*/ public void sendMsgToUser(byte[] reslut , int state ,String stateMsg) ; } public class NettyTcpTools{ private int port; private String host; private SocketChannel socketChannel; private Bootstrap bootstrap; private boolean isConnect = false; /**是否需要重连*/ private boolean isRepeate = false; /**用来区分是用户主动断开还是异常导致断开用户主动断开的话就不用去重连*/ private boolean isStopByUser =false ; /**通信管道*/ private ChannelFuture future = null; /**状态回调*/ private MyNettyCallBack myNettyCallBack ; /**线程池工具*/ private MyThreadPoolTools myThreadPoolTools ; public NettyTcpTools(String host , int port){ this.port = port; this.host = host; bootstrap = new Bootstrap(); bootstrap.channel(NioSocketChannel.class); //保持长连接 bootstrap.option(ChannelOption.SO_KEEPALIVE, true); //自动调整下一次缓冲区建立时分配的空间大小，避免内存的浪费 bootstrap.option(ChannelOption.RCVBUF_ALLOCATOR, new AdaptiveRecvByteBufAllocator(1024, 1024 * 32, 1024 * 64)); bootstrap.group( new NioEventLoopGroup()); bootstrap.remoteAddress(host, port); bootstrap.handler(new ChannelInitializer() { @Override protected void initChannel(SocketChannel socketChannel) throws Exception { //超时处理 socketChannel.pipeline().addLast(new IdleStateHandler(3, 3, 3 ,TimeUnit.SECONDS)); //接收服务器信息 socketChannel.pipeline().addLast( new NettyClientHandler()); } }); } private void gotoConnectTcp(){ closeThreadPool(); myThreadPoolTools= new MyThreadPoolTools(); Runnable task = new Runnable() { @Override public void run() { isStopByUser = false ; try { if (future != null) { boolean isActive = future.channel().isActive() ; boolean isOpen = future.channel().isOpen() ; MyLogUtils.mLog_iNormal(\"连接测试：isActive=\" + isActive +\" isOpen=\"+ isOpen); /* 这个地方注意了： 如果 没有关闭，会导致多个tcp连接 使用 网络调试助手.exe 进行调试查看*/ future.channel().close(); } future = bootstrap.connect(new InetSocketAddress(host, port)).sync(); if (future.isSuccess()) { socketChannel = (SocketChannel) future.channel(); sendMsgToUser(null ,MyNettyCallBack.Key_State_connect ,\"connect server Success\"); isConnect = true; return; } } catch (Exception cause) { sendMsgToUser(null ,MyNettyCallBack.Key_State_error ,\"error2:\"+cause.toString()); } //连接状态在此处处理 repeateTcp(); } }; if (myThreadPoolTools == null) { myThreadPoolTools= new MyThreadPoolTools(); } myThreadPoolTools.addTask(task); } public void startTcpTools(){ gotoConnectTcp(); } private void closeThreadPool(){ if(myThreadPoolTools!=null) { myThreadPoolTools.shutdownThreadPool(); myThreadPoolTools=null ; } } public void nettySendBytes(final byte[] bytesSend) { Runnable runnable = new Runnable() { @Override public void run() { if (isConnect) { ByteBuf buf = Unpooled.buffer(bytesSend.length); buf.writerIndex(); buf.writeBytes(bytesSend); socketChannel.writeAndFlush(buf); } } } ; if (myThreadPoolTools == null) { myThreadPoolTools= new MyThreadPoolTools(); } myThreadPoolTools.addTask(runnable); } public class NettyClientHandler extends SimpleChannelInboundHandler{ @Override protected void channelRead0(ChannelHandlerContext channelHandlerContext,ByteBuf byteBuf) throws Exception { //这里是接受服务端发送过来的消息 byte[] result = new byte[byteBuf.readableBytes()]; byteBuf.readBytes(result); /*这种方式会定长读取，后面有很多00 00 00 byte[] bytes = byteBuf.array();*/ sendMsgToUser(result ,MyNettyCallBack.Key_State_recevieData ,\"channelRead0\"); } /**这里是断线要进行的操作*/ @Override public void channelInactive(ChannelHandlerContext ctx) throws Exception { super.channelInactive(ctx); ctx.close() ; if(!isStopByUser) { sendMsgToUser(null ,MyNettyCallBack.Key_State_disConnect ,\"channelInactive\"); repeateTcp(); } } /**这里是出现异常的话要进行的操作*/ @Override public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception { //ctx.close() ; sendMsgToUser(null ,MyNettyCallBack.Key_State_error ,\"error1:\"+cause.toString()); repeateTcp(); } /**用来处理读写超时的 自定义操作*/ @Override public void userEventTriggered(ChannelHandlerContext ctx, Object evt) throws Exception { super.userEventTriggered(ctx, evt); if (evt instanceof IdleStateEvent) { IdleStateEvent event = (IdleStateEvent) evt; if (event.state().equals(IdleState.READER_IDLE)) { // 在指定的时间内没有收到服务器的反馈信息 } else if (event.state().equals(IdleState.WRITER_IDLE)) { //在指定的时间内没有像服务器发送过信息 } else if (event.state().equals(IdleState.ALL_IDLE)) { //在指定的时间内 既没有收到过信息 也没有发送过信息 } } } } /** * 设置消息回调接口，用来获取从服务器返回的消息。 */ public void setMyNettyCallBack(MyNettyCallBack myNettyCallBack) { this.myNettyCallBack = myNettyCallBack ; } private void sendMsgToUser(byte[] result , int state ,String sendMsgToUser) { if (myNettyCallBack != null) { myNettyCallBack.sendMsgToUser(result ,state ,sendMsgToUser); } } /** * tcp重连 */ private void repeateTcp() { if(isStopByUser) { return; } if (!isRepeate) { if (isConnect) { isConnect = false; //断线监听在此处处理 } isRepeate = true; sendMsgToUser(null ,MyNettyCallBack.Key_State_isReConnect ,\"repeateTcp\"); try { TimeUnit.SECONDS.sleep(5); } catch (InterruptedException e) { e.printStackTrace(); } isRepeate = false; startTcpTools(); } } /*** * 关闭 tcp连接 */ public void nettyToolsClose() { resetState(); closeThreadPool(); if (future != null && future.channel() != null) { if (future.channel().isOpen()) { sendMsgToUser(null ,MyNettyCallBack.Key_State_close ,\"close\"); future.channel().close(); } } } private void resetState() { isConnect = false; isRepeate=false; isStopByUser = true ; } } usb 通信 AOA协议 Google推出的 Android开放配件协议AOA（Android Open Accessory Protocol）及配件开发工具包ADK（Accessory Development Kit） 提供了Android设备与Android配件通过USB或蓝牙进行通信的API， 为基于Android系统的智能设备控制外设提供了条件。 利用Android，系统可以连接从家用电器到重型机械、机器人等多种设备。 当前项目用到的是 android 的AOA协议。遥控器作为主机供电，移动设备（手机、平板）作为从机。 使用方法请自行查阅相关文档。 使用场景一 ：android设备作为从机 参考资料 这种模式是Android定义的一种新的通讯模式，它将usb配件作为协议交互的主要角色，配件内置USB Embedded Host端，可以为Android手机供电，并且识别Android手机，建立数据通道。使得配件成为一个简化版的PC Host端。 usb通信demo MusbAccessoryManager.java /** * usb 操作管理类 */ public class MusbAccessoryManager { private Context mCtx; /**文件操作符*/ private ParcelFileDescriptor fileDescriptor; /**输入流*/ private FileInputStream inputStream; /**输出流*/ private FileOutputStream outputStream; /**读线程*/ private AccessoryReadThread readThread; /**写线程*/ private AccessoryWriteThread writeThread; /**解析线程*/ private BytesDataRepackThread repackThread ; /**usb 通信是否在进行*/ private boolean enableThread; /**发送队列*/ private BlockingQueue outQueue; /**读取队列*/ private BlockingQueue readQuene; /**回调接口 - 状态标记*/ private IOperateResultCallBack iUsbResultCallBack ; /**回调接口 - byte[] 传输*/ //private IBytesTransferInterface iGetBytesInterface ; /**解析后的数据对象 回调-*/ private IUsbPackageTransferInterface iusbpackageTransInterface ; /**读入流 时的休眠间隔 微秒*/ private final long READ_STRING_SLEEPTIME= 20L; /**写入流 时的休眠间隔*/ private final long WRITE_STRING_SLEEPTIME= 60L; /**解析 byte[] 时的休眠间隔*/ private final long REPACKAGE_SLEEPTIME= 0L; /** 调整读取大小*/ private byte[] buffer= new byte[2048 * 3] ; public MusbAccessoryManager(Context context , IOperateResultCallBack iUsbResultCallBack , IUsbPackageTransferInterface iusbpackageTransInterface) { this.mCtx = context; fileDescriptor = null; inputStream = null; outputStream = null; readThread = null; writeThread = null; repackThread =null ; enableThread = false; this.iUsbResultCallBack= iUsbResultCallBack; this.iusbpackageTransInterface = iusbpackageTransInterface; outQueue = new LinkedBlockingQueue(Integer.MAX_VALUE); readQuene = new LinkedBlockingQueue<>(Integer.MAX_VALUE) ; } /** * 添加数据 到发送队列 */ public void addMessage(MyBytesTransfer msg) { try { outQueue.put(msg); }catch (Exception e) { MyLogUtils.mLog_iNormal(\"usb设备== 发送异常1 =\"+e.getMessage()); } } /** * 打开USB通信 */ public void OpenAccessory(UsbAccessory accessory) { if (!enableThread) { fileDescriptor = ((UsbManager) mCtx.getSystemService(Context.USB_SERVICE)).openAccessory(accessory); if (fileDescriptor != null) { FileDescriptor fd = fileDescriptor.getFileDescriptor(); inputStream = new FileInputStream(fd); outputStream = new FileOutputStream(fd); if (inputStream == null || outputStream == null) { // 读取流异常 iUsbResultCallBack.onResultCallBack(MyStateConfig.STATE_2); return; } //连接成功 iUsbResultCallBack.onResultCallBack(MyStateConfig.STATE_14); enableThread = true; readThread = new AccessoryReadThread(inputStream); readThread.start(); writeThread = new AccessoryWriteThread(outputStream); writeThread.start(); repackThread = new BytesDataRepackThread() ; repackThread.start(); }else{ toastMsg(\"fileDescriptor==null \" ) ; } } }// /** * 关闭连接、清空队列、停止线程 */ public void CloseAccessory() { try { if (fileDescriptor != null) { fileDescriptor.close(); } if (outputStream != null) { outputStream.close(); } if (inputStream != null) { inputStream.close(); } }catch (Exception ie) { ie.printStackTrace(); } outQueue.clear(); readQuene.clear(); enableThread = false; fileDescriptor = null; outputStream = null; inputStream = null; } /** 读取子线程 */ private class AccessoryReadThread extends Thread { private FileInputStream inStream; public AccessoryReadThread(FileInputStream stream) { this.inStream = stream; } @Override public void run() { while (enableThread) { try { int realReaded = inStream.read(buffer); // 将Buffer中有效的数据拷贝出来 if(realReaded>0) { byte [] realBytes = MyStringUtils.subBytes(buffer, 0 , realReaded) ; readQuene.put(realBytes); } } catch (Exception e) { com.walkera.base.utils.MyLogUtils.mLog_iNormal(\"usb设备== 接收异常=\"+e.getMessage()); MyApplication.usbReadStreamState= MyStateConfig.STATE_8; //发生异常，继续执行 continue; } MyApplication.usbReadStreamState= MyStateConfig.STATE_9; try { TimeUnit.MICROSECONDS.sleep(READ_STRING_SLEEPTIME); } catch (InterruptedException e) { e.printStackTrace(); } } // end while } // end run }// /** *发送子线程 */ private class AccessoryWriteThread extends Thread { private FileOutputStream outStream; public AccessoryWriteThread(FileOutputStream outputStream) { this.outStream = outputStream; } @Override public void run() { MyBytesTransfer msg; while (enableThread){ try{ if (outStream != null) { msg = outQueue.poll(); if (msg != null) { sendByteDataToServer(msg.bytes ); msg = null; }else{ } } else{ MyApplication.usbWriteStreamState= MyStateConfig.STATE_11; outQueue.clear(); } MyApplication.usbWriteStreamState= MyStateConfig.STATE_10; try { Thread.sleep(WRITE_STRING_SLEEPTIME); } catch (InterruptedException e) { e.printStackTrace(); } }catch (Exception ex) { com.walkera.base.utils.MyLogUtils.mLog_iNormal(\"发送测试3= msg=\"+ex.getMessage()); MyApplication.usbWriteStreamState= MyStateConfig.STATE_11; } } } /** * 将数据发送给服务器 */ private void sendByteDataToServer(byte[] buffer) { try { if (outStream != null) { iUsbResultCallBack.onResultCallBack(MyStateConfig.STATE_13); outStream.write(buffer, 0, buffer.length); outStream.flush(); } }catch (IOException ex) { iUsbResultCallBack.onResultCallBack(MyStateConfig.STATE_12); } }// } /** * 解析 重组包 子线程 */ private class BytesDataRepackThread extends Thread{ @Override public void run() { while (enableThread) { if(readQuene!=null) { byte[] realBytes = readQuene.poll() ; if(realBytes!=null) { rePackageForBytes(realBytes) ; } } try { Thread.sleep(REPACKAGE_SLEEPTIME); } catch (InterruptedException e){ e.printStackTrace(); } } // while }//end run } /*** * 重组包 ， 将遥控器 、 飞控、视屏数据分开 . */ private void rePackageForBytes(byte[] bytes) { if(bytes!=null) { int size =bytes.length ; for(int i=0 ; i UsbMsgClient.java /** * 功能描述： 负责 用usb方式的通信方式 给其他部件提供发送和接收数据的功能 */ public class UsbMsgClient{ private Context mCtx ; /**usb管理类*/ private UsbManager usbmanager ; /**usb 操作管理类*/ private MusbAccessoryManager mubAccessoryManager; /**对外暴露的接口 ，以便其他模块获取 对应的数据*/ private IUsbMsgBackInterface iUsbMsgBackInterface ; /** * @param iUsbMsgBackInterface 对外暴露的接口 ，以便其他模块获取 对应的数据 * @param iUsbResultCallBack usb 返回状态码 */ public UsbMsgClient (Context mCtx ,IUsbMsgBackInterface iUsbMsgBackInterface ,IOperateResultCallBack iUsbResultCallBack) { this.mCtx = mCtx; this.iUsbMsgBackInterface= iUsbMsgBackInterface ; usbmanager=((UsbManager) mCtx.getSystemService(Context.USB_SERVICE)) ; mubAccessoryManager = new MusbAccessoryManager(mCtx , iUsbResultCallBack ,iusbpackageTransInterface); discoverAccessories(); }// /**回调 来自usb的数据*/ private IUsbPackageTransferInterface iusbpackageTransInterface = new IUsbPackageTransferInterface() { @Override public void transferUsbPackageBean(MyBytesTransfer myBytesTransfer) { if(myBytesTransfer != null) { // 4759图传 - 3678飞控 - 5869 遥控器 if( Arrays.equals(myBytesTransfer.msgType, MyStateConfig.VEDEO_DATA_RECEIVE)) { //视屏数据 iUsbMsgBackInterface.getUsbVedioByte(myBytesTransfer); }else if(Arrays.equals(myBytesTransfer.msgType, MyStateConfig.FC_DATA_RECEIVE)) { //飞控数据 iUsbMsgBackInterface.getUsbFcByte(myBytesTransfer); }else if(Arrays.equals(myBytesTransfer.msgType, MyStateConfig.RC_DATA_RECEIVE)) { //遥控器数据 iUsbMsgBackInterface.getUsbRcByte(myBytesTransfer); } } } } ; /** * 扫描usb设备 发现从设备 */ private void discoverAccessories() { UsbAccessory[] list = usbmanager.getAccessoryList(); if (list != null && list.length!=0) { openTheAccessory(list[0]); }else { //MyToastTools.toastWarning(mCtx ,mCtx.getString( R.string.v5_str_1)); } }// /** * 连接 指定设备 */ private void openAccessory(UsbAccessory accessory) { mubAccessoryManager.OpenAccessory(accessory); // 延时 n秒 发送打开session命令 new Handler().postDelayed(new Runnable() { @Override public void run() { byte[] openSession = { (byte)0xDD , (byte)0xDF ,(byte)0x06 ,(byte)0x00 } ; sendBytesToDevices(openSession); } } , 2000) ; } /** * 连接USB设备 */ private void openTheAccessory(UsbAccessory accessory) { if (accessory == null) { MyToastTools.toastWarning(mCtx ,mCtx.getString( R.string.v5_str_2)); }else { if (usbmanager.hasPermission(accessory)) { openAccessory(accessory); }else { com.walkera.base.utils.MyLogUtils.mLog_iNormal(\"usb设备== 无权限1\"); } } } /** * 通知遥控器关闭 */ private void closeSession() { byte[] closeSession = { (byte)0xDD , (byte)0xDF ,(byte)0x07 ,(byte)0x00 } ; sendBytesToDevices(closeSession); } /** * 关闭usb收发工具 */ public void closeUsbMsgClinet() { closeSession(); new Handler().postDelayed(new Runnable() { @Override public void run() { closeAccessory(); } }, 500); } /** * 断开设备 */ private void closeAccessory(){ if (mubAccessoryManager != null) { mubAccessoryManager.CloseAccessory(); } } /** * 发送数据 */ public void sendBytesToDevices( byte[] data ) { if (mubAccessoryManager != null) { mubAccessoryManager.addMessage(new MyBytesTransfer(data , MyStateConfig.STATE_6,null)); } } } MyStateConfig.java public class MyStateConfig{ /**请求usb访问的自定义权限*/ public static final String ACTION_USB_ACCESSORY_PERMISSION = \"com.wk.USB_ACCESSORY_PERMISSION\"; /**当前参数无意义 */ public final static int STATE_NULL = -100 ; /**所有的状态的初始化状态 */ public final static int STATE_0 = 0 ; /** usb退出 */ public final static int STATE_1 =1 ; /** usb连接异常 , 读取流异常 */ public final static int STATE_2 =2 ; /** usb 权限被拒绝了 */ public final static int STATE_3 =3; /**接收usb byte 正式*/ public final static int STATE_4 =4; /**接收usb byte 测试*/ public final static int STATE_5 =5; /**发送的bytes[]*/ public final static int STATE_6 =6; /**接收到的byte[]*/ public final static int STATE_7 =7; /**usb输入流异常*/ public final static int STATE_8 =8; /**usb输入流正常*/ public final static int STATE_9 =9; /**usb输出流正常*/ public final static int STATE_10 =10; /**usb输出流异常*/ public final static int STATE_11 =11; /**发送失败*/ public final static int STATE_12 =12; /**发送成功*/ public final static int STATE_13 =13; /**Usb连接成功*/ public final static int STATE_14 =14; /**属于相机数据 */ public final static int STATE_15 = 15 ; } xml中的一些配置、usb插入、拔出监听 请参考官网 使用 /**usb收发工具*/ private UsbMsgClient usbMsgClient ; //初始化usb数据接收器 usbMsgClient = new UsbMsgClient( mContext ,iUsbMsgBackInterface ,iUsbResultCallBack) ; //发送byte[]数据 usbMsgClient.sendBytesToDevices(code); //关闭连接 usbMsgClient.closeUsbMsgClinet(); /** * 接收 usb 返回数据 */ private IUsbMsgBackInterface iUsbMsgBackInterface = new IUsbMsgBackInterface(){ /**视屏数据*/ @Override public void getUsbVedioByte(MyBytesTransfer vedioData) { //解码... } /**飞控数据*/ @Override public void getUsbFcByte(MyBytesTransfer fcData) { //解析飞控数据 } /**遥控器数据*/ @Override public void getUsbRcByte(MyBytesTransfer rcData) { //解析遥控器数据 } } ; /** * 接收 usb 操作、状态码 */ private IOperateResultCallBack iUsbResultCallBack = new IOperateResultCallBack(){ @Override public void onResultCallBack(int state ){ //状态码 } }; 私有协议 参数类型对应的字节数 类型 对应字节数 备注 bit 1/8 byte 1 char 1 boolean 1 uint8 1 uint8_t 1 uint16 2 int16 2 short 2 int 4 float 4 int32 4 uint32_t 4 double 8 long 8 常用的方法 获得byte[] 校验值 /** * 获得校验位。 * 计算规则： * SUM等于从该数据帧第一字节开始，也就是帧头开始，至该帧数据的最后一字节所有字节的和， * 只保留低八位，高位舍去。 * P1=s/256; //整除高8位s P0=s%256; //取余是低八 */ public static byte[] getVerifyValue(byte [] lastBytes){ byte checksum = 0; for (int i = 0; i 数组动态扩充容量 /** * 数组动态扩充容量 * 代码并没有真正增加原数组a的容量，只是将a内容复制到新的大数组， * 然后让a重新引用大数组。由于Java数组存贮在堆中，原a数组无需释放，会被自动回收。 */ public static String [] getNewArrayWithMoreSpaceString( String [] oldArray , String [] increceData){ //新数组 String [] lastArray=new String[oldArray.length+increceData.length]; //将a数组内容复制新数组b System.arraycopy(oldArray, 0, lastArray, 0, oldArray.length); for(int i=0 ;i 指定数组中复制内容到新的数组 /*** * 指定数组中复制内容到新的数组 src:源数组 srcPos:源数组要复制的起始位置 dest:目的数组 destPos:目的数组放置的起始位置 length:要复制的长度 */ public static void copyDataToNewByteteArray(byte[] src, int srcPos , byte[] dest, int destPos , int length){ System.arraycopy(src, srcPos , dest, destPos, length); } 数组截取 /** * 数组截取 * @param srcByte 源数组 * @param begin 源数组要复制的起始位置 * @param count 要复制的长度 * @return */ public static byte[] subBytes(byte[] srcByte, int begin, int count){ byte[] result = new byte[count]; System.arraycopy(srcByte, begin, result, 0, count); return result; } 将byte转换为一个长度为8的byte数组 /** * 将byte转换为一个长度为8的byte数组，数组每个值代表bit */ public byte[] get8bitsOfOneByte(byte mByte) { byte[] array = new byte[8]; byte h01= (byte)0x01; for (int i = 7; i >= 0; i--) { //与1与运算- > 0000 0001 array[i] = (byte)(mByte & h01); mByte = (byte) (mByte >> 1); } return array; } 获取byte的高四位 public byte gethe4BitOfByte(byte mByte) { //0xF0换成二进制 -> 1111 0000（0xF0相当于高四位保留，低四位置为0） return (byte)((mByte & 0xF0) >> 4); } 获取byte的低四位 public byte getLow4BitOfByte(byte mByte) { //0x0F换成二进制 -> 0000 1111 （0xF0相当于低四位保留，高四位置为0） return (byte) (mByte & 0x0F); } bytes转换成十六进制字符串 /** * bytes转换成十六进制字符串 * @param b byte数组 * @return String 每个Byte值之间空格分隔 */ public static String byte2HexStr(byte[] b) { String stmp ; StringBuilder sb = new StringBuilder(\"\"); for (int n = 0; n 将一个byte 转为十六进制 public static String byteOne2HexStr(byte b) { String stmp = Integer.toHexString( b & 0xFF); return (stmp.length() == 1) ? \"0\" + stmp : stmp ; } public static String byte1ToHexStr(byte mByte) { String stmp = Integer.toHexString(mByte & 0xFF); return stmp.toUpperCase().trim(); } int 类型 转为 1个字节长度的 byte /*** * int 类型 转为 1个字节长度的 byte */ public static byte intTo1ByteHex(int intVaue ) { return new Integer(intVaue & 0xff).byteValue(); } int 类型 转为 1个字节长度的 byte数组 * int 类型 转为 1个字节长度的 byte数组、 * ？？ */ public static byte[] intTo1ByteHexArray(int intVaue ) { byte[] array = new byte[1] ; array[0] = new Integer(intVaue & 0xff).byteValue(); return array ; } int 类型 转为 4个字节长度的 byte数组。 /*** * int 类型 转为 4个字节长度的 byte数组。 * 大端小端翻转 。 */ public static void intTo4ByteArrayHex(int intVaue, byte[] byteVauesHex) { for (int i = 0; i > 8; } } int 类型 转为 4个字节长度的 byte数组。 /*** * int 类型 转为 4个字节长度的 byte数组。 * 正常顺序 。不考虑大端小端翻转 。 */ public static void intTo4ByteArrayHexNormal(int intVaue, byte[] byteVauesHex){ for (int i = byteVauesHex.length - 1; i >= 0; i--) { byteVauesHex[i] = new Integer(intVaue & 0xff).byteValue(); intVaue = intVaue >> 8; } } 将一个short转为2个字节的数组 /** * 将一个short转为2个字节的数组 * 算法来源 网络 * http://blog.csdn.net/thanklife/article/details/17002641 * 如: pitch = 1900 = 0x076c => 发送顺序：先发0x07，再发0x6c * 高位在前，低位在后 */ public static byte[] shortTobytes2HeightLow(short number) { int temp = number; byte[] b = new byte[2]; for (int i = b.length - 1; i >= 0; i--) { b[i] = new Integer(temp & 0xff).byteValue(); temp = temp >> 8; } return b; } public static byte[] shortTobytes2_low_height(short number){ int temp = number; byte[] b = new byte[2]; for (int i = 0; i > 8; } return b; } intTo4ByteArray public static byte[] intTo4ByteArrayHex_height_low (int intVaue) { byte[] byteVauesHex = new byte[4] ; for (int i = byteVauesHex.length -1; i >=0 ; i--) { byteVauesHex[i] = new Integer(intVaue & 0xff).byteValue(); intVaue = intVaue >> 8; } return byteVauesHex ; } public static byte[] intTo4ByteArrayHex_low_height(int intVaue){ byte[] byteVauesHex = new byte[4] ; for (int i = 0; i > 8; } return byteVauesHex ; } floatTo4ByteArrayHex public static byte[] floatTo4ByteArrayHex_height_low (float intVaue){ byte[] byteVauesHex = new byte[4] ; int fbit = Float.floatToIntBits(intVaue); for (int pos = 3; pos >= 0 ; pos -- ) { byteVauesHex[pos] = new Integer(fbit).byteValue(); fbit = fbit >> 8; } return byteVauesHex ; } public static byte[] floatTo4ByteArrayHex_low_height(float intVaue) { byte[] byteVauesHex = new byte[4] ; int fbit = Float.floatToIntBits(intVaue); for (int pos = 0; pos > 8; } return byteVauesHex ; } 将2个字节的 16进制数组 转化为 一个short /*** * 将2个字节的 16进制数组 转化为 一个short * 高位在前，低位在后 的bytes数组 */ public static short bytes2ToShort(byte[] srcBytes){ short result; short v1 = (short) (srcBytes[0] & 0xFF); short v2 = (short) (srcBytes[1] & 0xFF); result = (short) (v1 * 256 + v2); return result; } /*** * 将2个字节的 16进制数组 转化为 一个short * 低位在前，高位在后 的bytes数组 */ public static int bytes2ToShort_low_hight(byte[] src) { return ((src[0] & 0xFF) | ((src[ 1] & 0xFF) 将2个字节的 16进制数组 转化为 一个 double /*** * 将2个字节的 16进制数组 转化为 一个 double * 高位在前，低位在后 的bytes数组 */ public static double bytes2ToDouble(byte[] srcBytes){ double result; short v1 = (short) (srcBytes[0] & 0xFF); short v2 = (short) (srcBytes[1] & 0xFF); result = (double) (v1 * 256 + v2); return result; } 两个byte转 int /** * 两个byte转整形，add zc */ public static int byte2int(byte[] res) { // 一个byte数据左移24位变成0x??000000，再右移8位变成0x00??0000 return (res[0] & 0xff) | ((res[1] int 类型 转为 2个字节长度的 byte数组 /*** * int 类型 转为 2个字节长度的 byte数组。 * 大端小端翻转 。 * @param intVaue int * @param byteVauesHex byte[] */ public static void intTo2ByteArrayHex(int intVaue, byte[] byteVauesHex){ for (int i = 0; i > 8; } } /*** * int 类型 转为 2个字节长度的 byte数组。 * 正常顺序。 */ public static byte[] intTo2ByteArrayHexNormal(int intVaue ) { byte[] byteVauesHex = new byte[2] ; for (int i = byteVauesHex.length - 1; i >= 0; i--) { byteVauesHex[i] = new Integer(intVaue & 0xff).byteValue(); intVaue = intVaue >> 8; } return byteVauesHex; } 将4个字节长度的 byte数组转为int /** * 将4个字节长度的 byte数组转为int。 * 本方法适用于(低位在后，高位在前)的顺序 */ public static int bytes4HeightAndLowToInt(byte[] src, int offset){ return (((src[offset] & 0xFF) * 本方法适用于(低位在前，高位在后)的顺序 * 320项目中用到 */ public static int bytes4LowAndHeightToInt(byte[] src, int offset) { return ((src[offset] & 0xFF) | ((src[offset + 1] & 0xFF) 将1个字节长度的 byte数组转为int /** * 将1个字节长度的 byte数组转为int。 */ public static int bytes1ToInt(byte[] src){ return src[0] & 0xFF; } /** * 将一个字节长度的byte 转为 int */ public static int byte1ToInt(byte src) { return src & 0xFF; } getStrByByte public static String getStrByByte(StringBuilder sb , byte byte0){ sb.replace(0, sb.length(), \"\") ; sb.append(Integer.toHexString( byte0 & 0xFF).toUpperCase()) ; if(sb.length()==1) { sb.insert(0, \"0\") ; } return sb.toString() ; } 无版权 可以无限制使用！ all right reserved，powered by Gitbook该文件更新时间： 2019-04-12 16:41:42 "},"chinese/java基础/原码补码反码.html":{"url":"chinese/java基础/原码补码反码.html","title":"java基础","keywords":"","body":"原码补码反码 类型 正数规则 负数规则 其他 原码 0表示正号，1表示负号，后面是数值部分 跟正数一样 反码 与原码相同 原码的符号位不变，其它位取反 补码 与原码相同 反码+1 加法运算 只能通过 补码来运算，因为通过原码不能保证所有的计算都是正确的。 例如 ： 6+（-3） 补码存在的意义 1、 因为采用原码或反码 进行 减法运算 ，并不能保证结果正确。 为了保证计算正确， 因此设计了补码的规则 。至于为什么采用这样的设计就能保证结果正确。请查阅其他资料。 无版权 可以无限制使用！ all right reserved，powered by Gitbook该文件更新时间： 2018-12-07 17:21:03 "},"chinese/java基础/常用代码片段.html":{"url":"chinese/java基础/常用代码片段.html","title":"java常用代码片段","keywords":"","body":"java常用代码片段 list去重 将重复值去掉，同时不能破坏现有的顺序。 private List removeDuplicate(List list) { Set set = new HashSet(); List newList = new ArrayList(); for (String str : list) { // 借助set的特性 if (set.add(str)) { newList.add(str); } } return newList; } String 操作 字符串切割 String [] array= myString.split(\"[.]\"); 分割字符 表达 . \"[.]\" | \"\\\\|\" * \"\\\\*\" \\ \"\\\\\\\\\" [ \"\\\\[\" ] \"\\\\]\" String 简单格式化 return String.format(\"bookId= %s, bookName=%s]\", bookId, bookName); 代码超时 函数超时、 执行超时、等待超时、连接超时 final ExecutorService exec = Executors.newFixedThreadPool(1); Callable call = new Callable() { public String call() throws Exception { // 耗时操作... Thread.sleep(1000 * 3); return \"执行结果(成功或失败)\"; } }; try { Future future = exec.submit(call); // 超时时间 设置 String result = future.get(1000 * 5, TimeUnit.MILLISECONDS); System.out.println(\"执行未超时:\" + result); } catch (TimeoutException ex) { System.out.println(\"处理超时\"); ex.printStackTrace(); } catch (Exception e) { System.out.println(\"处理失败.\"); e.printStackTrace(); } exec.shutdown(); } 对象排序 Collections.sort(mBeanList, new Comparator() { @Override public int compare(MyBean bean1, MyBean bean2) { // 按照对象属性排序 return = bean1.xx - bean2.xx; } }); 数组操作 数组相等 Arrays.equals(myArray, NSS_MSG_TYPE_GET_MAIN_STREAM); 数组打印 System.out.println(Arrays.toString(myArray)); 数组扩容 public String [] getNewArrayWithMoreSpaceString( String [] oldArray ,String [] increceData){ String [] lastArray=new String[oldArray.length+increceData.length]; //数组复制 System.arraycopy(oldArray, 0, lastArray, 0, oldArray.length); System.arraycopy(increceData, 0, lastArray, oldArray.length+1, increceData.length); return lastArray ; } 文件操作 获得指定文件的byte数组 public byte[] getBytesFromFile(File file){ byte[] buffer = null; try { if(!file.exists()){ file.createNewFile(); } FileInputStream fis = new FileInputStream(file); ByteArrayOutputStream bos = new ByteArrayOutputStream(1000); byte[] b = new byte[1000]; int n; while ((n = fis.read(b)) != -1) { bos.write(b, 0, n); } fis.close(); bos.close(); buffer = bos.toByteArray(); } catch ( Exception e) { e.printStackTrace(); } return buffer; } 根据byte数组，生成文件 public void getFileFromBytes(byte[] bfile, File file ,boolean isAppend){ BufferedOutputStream bos = null; FileOutputStream fos = null; try { fos = new FileOutputStream(file ,isAppend); bos = new BufferedOutputStream(fos ); bos.write(bfile); } catch (Exception e) { e.printStackTrace(); } finally { if (bos != null) { try { bos.close(); } catch (IOException e1) { e1.printStackTrace(); } } if (fos != null) { try { fos.close(); } catch (IOException e1) { e1.printStackTrace(); } } } } 保存String到本地 public boolean saveTxtToSdWithAppend(String messgeStr, String filePath, boolean isAppend){ File file = new File(filePath); try { file.createNewFile(); } catch (IOException e) { e.printStackTrace(); } boolean resultFlage = true; try { // 打开一个写文件器，是否追加形式 FileWriter writer = new FileWriter(filePath, isAppend); writer.write(messgeStr + \"\\r\\n\"); writer.close(); } catch (IOException e) { resultFlage = false; e.printStackTrace(); } return resultFlage; } 从txt(小文件) 获取String public String getStringFromTxt(File file) { StringBuffer sb = new StringBuffer(); try { BufferedReader rd = new BufferedReader(new FileReader(file)); String s = rd.readLine(); while (null != s) { sb.append(s); s = rd.readLine(); } } catch (FileNotFoundException e) { e.printStackTrace(); } catch (IOException e) { e.printStackTrace(); } return sb.toString(); } 按行读取(较大文件) 、解决乱码问题 public void read(String filePath, String logPath) throws Exception { RandomAccessFile raf = new RandomAccessFile(filePath, \"r\"); // 设置指针的位置为文件的开始部分 raf.seek(currentInex); long totalLenth = raf.length(); while (currentInex 递归 遍历文件夹 public void getFileList(String strPath) { File dir = new File(strPath); File[] files = dir.listFiles(); if (files != null) { for (File file : files) { if (file.isDirectory()) { getFileList(file.getAbsolutePath()); } else { // 文件 } } } } 时间间隔 public static String getConversationDateString(String result) throws Exception{ if(!result.equals(\"\")){ SimpleDateFormat sdf = new SimpleDateFormat(\"MM-dd HH:mm\"); SimpleDateFormat sdfDay = new SimpleDateFormat(\"MM-dd\"); String now = sdf.format(new Date()); Date oldTime = null; Date newTime = null; oldTime = sdf.parse(result); newTime = sdf.parse(now); long time = newTime.getTime() - oldTime.getTime(); int day; String[] olds = sdfDay.format(oldTime).split(\"-\"); String[] news = sdfDay.format(newTime).split(\"-\"); if(news[0].equals(olds[0])){ day = Integer.valueOf(news[1]) - Integer.valueOf(olds[1]); }else{ Calendar cal = Calendar.getInstance(); //月份设置要减1，所以设置1月就是1-1，设置2月就是2-1，如此类推 cal.set(Calendar.MONTH, 1-1); cal.add(Calendar.MONTH, -(Integer.valueOf(news[0]) - Integer.valueOf(olds[0]))); //得到上一个月最最后一天日期(31/30/29/28) int oldDay=cal.getActualMaximum(Calendar.DAY_OF_MONTH) - Integer.valueOf(olds[1]); day = oldDay + Integer.valueOf(news[1]); } if(time 求夹角 根据正切公式 /**根据两个点获取 斜率*/ public static double getXl(MyPointBean bean1, MyPointBean bean2) { double xlValue = 0; xlValue = (bean2.getY() - bean1.getY()) / (bean2.getX() - bean1.getX()); return xlValue; } /**根据2条线的斜率 获得之间的夹角*/ public static double getAngle(double xl_1, double xl_2) { double angleValue = 0; // 反正切 angleValue = Math.atan((xl_2 - xl_1) / (1 + xl_1 * xl_2)); // 将弧度转为度数 return Math.toDegrees(angleValue); } 遍历map 遍历set Map map=new HashMap(); //方法一 ，需要遍历 两次 for (Object object : map.keySet()) { String key = (String) object; Integer value = (Integer) map.get(key); } // 方法二， 只需遍历一次 （推荐） Set> entrySet = map.entrySet(); for (Entry object : entrySet){ Object key = object.getKey(); Object value = object.getValue(); } //遍历set Set set=new HashSet(); Iterator iterator=set.iterator(); while (iterator.hasNext()) { String obj = iterator.next(); } 随机数 Random Math.Random() 范围是 [0,1) 生成 [startNum,endNum) public int getRadomInt(int startNum, int endNum){ return new Random().nextInt(endNum - startNum) + startNum; } 生成 [startNum,endNum] public int getRadomInt2(int startNum, int endNum){ return new Random().nextInt(endNum - startNum + 1) + startNum; } 文件解压缩 zip解压缩是基于 pache的 ant.jar 实现 。 /** * 解压耗时操作应该在子线程中进行。 */ public class ZipUtil{ private byte[] buf; public ZipUtil(){ this.buf = new byte[ 1024*4]; } /** * @param zipFileAbsulutPaht 压缩文件的绝对路径 xxx/xxx.zip * @param destFileDir　　　解压到的目录　 */ public void unZip(String zipFileAbsulutPaht, String destFileDir) { FileOutputStream fileOut; File file; InputStream inputStream; try { //生成一个zip的文件 ZipFile zipFile = new ZipFile(zipFileAbsulutPaht); //遍历zipFile中所有的实体，并把他们解压出来 for (@SuppressWarnings(\"unchecked\") Enumeration entries = zipFile.getEntries(); entries.hasMoreElements();) { ZipEntry entry = entries.nextElement(); //生成他们解压后的一个文件 String tempNameFile=entry.getName() ; file = new File(destFileDir+File.separator+tempNameFile.replace(\"\\\\\", \"/\")); if (entry.isDirectory()) { file.mkdirs(); } else { File parent = file.getParentFile(); if (!parent.exists()) { parent.mkdirs(); } //获取出该压缩实体的输入流 inputStream = zipFile.getInputStream(entry); fileOut = new FileOutputStream(file); int length = 0; //将实体写到本地文件中去 while ((length = inputStream.read(this.buf)) > 0) { fileOut.write(this.buf, 0, length); } fileOut.close(); inputStream.close(); } } zipFile.close(); } catch (IOException ioe) { ioe.printStackTrace(); } } } // 使用 new ZipUtil().unZip(mnt/xxx/xxx.zip , mnt/xx/xx/); 无版权 可以无限制使用！ all right reserved，powered by Gitbook该文件更新时间： 2018-12-07 17:21:03 "},"chinese/java基础/类加载机制.html":{"url":"chinese/java基础/类加载机制.html","title":"类加载机制","keywords":"","body":"类的生命周期 java类加载器分类 从虚拟机层面角度 讲分为两大类型的类加载器，一是Bootstrap Classloader即启动类加载器（C++实现），它是虚拟机的一部分，二是其他类型类加载器（JAVA实现），在虚拟机外部，并全部继承ClassLoader类。 从加载顺序 角度来分类。 1、Bootstrap ClassLoader 主要负责加载JVM自身工作所需要的类 。 是由C/C++编写的，它本身是虚拟机的一部分，所以它并不是一个JAVA类，也就是无法在java代码中获取它的引用。 所以getClass().getName()返回null。 System.out.println(System.getProperty(\"sun.boot.class.path\")); xxx\\jre\\lib\\resources.jar; xxx\\jre\\lib\\rt.jar; xxx\\jre\\lib\\sunrsasign.jar; xxx\\jre\\lib\\jsse.jar; xxx\\jre\\lib\\jce.jar; xxx\\jre\\lib\\charsets.jar; xxx\\jre\\lib\\jfr.jar; xxx\\jre\\classes 2、ExtClassLoader 负责装载JRE扩展目录ext下的jar类包。一般为JVM平台扩展工具. System.out.println(System.getProperty(\"java.ext.dirs\")); xxx\\jre\\lib\\ext; C:\\Windows\\Sun\\Java\\lib\\ext 3、AppClassLoader(SystemAppClass) 如果应用程序中没有自定义过自己的类加载器，一般情况下这个就是程序中默认的类加载器。 System.out.println(System.getProperty(\"java.class.path\")); //这个路径其实就是当前java工程目录bin，里面存放的是编译生成的class文件。 F:\\aivin_space\\myEclipseSpace\\MySample\\bin 类加载之间的父子关系是怎样的 子类加载器和父类加载器的关系，是委派关系并不是继承关系。 双亲委派（parent delegation）模型 在加载类别时，每个类别加载器会先将加载类别的任务交由其parent，如果parent找不到，才由自己负责加载，如果自己也找不到，就会丢出 NoClassDefFoundError。 为什么要用“双亲委派模型” 防止内存中出现多份同样的字节码 。比如两个类A和类B都要加载System类：如果不用委托而是自己加载自己的，那么类A就会加载一份System字节码，然后类B又会加载一份System字节码，这样内存中就出现了两份System字节码。 自定义类加载器的意义和使用场景 1、为了实现jdk的类加载器没有的某些功能。例如Tomcat使用自定义的类加载器实现了热部署功能。 2、将java写的核心代码编译成.clas文件，然后将lass文件就加密。只有使用在自己的类加载器才能正确使用这些核心代码。 （个人认为这种方案不太好，因为只要获得了这个加载器，就可以轻易被获取） 如何自定义和使用类加载器 还没用过，有需求时再查资料。 无版权 可以无限制使用！ all right reserved，powered by Gitbook该文件更新时间： 2018-12-07 17:21:03 "},"chinese/java基础/内存.html":{"url":"chinese/java基础/内存.html","title":"内存","keywords":"","body":"运行时数据区域： 分为5块内存空间。 附：栈是运行的单位，而堆是存储的单元。 1、程序计数器 当前线程所执行的字节码的行号指示器。用来记录程序运行到哪里了，下一步又该执行哪一步操作。 2、本地方法栈 存储本地方法执行过程中的栈数据。 3、JVM栈（Java栈） 存放一个Java线程的运行状态 4、堆 存放运行时产生的对象的。Java只能在堆中存放对象 5、方法区 方法区主要是用来存类型数据的，与类型相关的东西，比如常量，静态变量。 注：运行时常量池是方法区的一部分，用来存放编译器生成的各种字面量和符号引用。 (绿色部分是每个线程私有的，白色部分是线程共享的) Java内存模型 其他语言，例如c/c++直接使用了物理硬件或操作系统的内存模型，由于不同平台上内存模型的差异性，需要开发者针对不同的平台做相应的兼容处理。 Java内存模型是为了屏蔽各种硬件和系统的访问差异，达到一致的并发效果。进一步解决多线程编程中的线程安全等问题。 基本概念 1、主内存： 进程内存？ 所有线程共享主内存。 2、工作内存： 线程内存? 每个线程都有自己的执行空间(即工作内存)，线程执行的时候用到某变量，首先要将变量从主内存拷贝的自己的工作内存空间，然后对变量进行操作：读取，修改，赋值等，这些均在工作内存完成，操作完成后再将变量写回主内存； 3、可见性 各个线程都从主内存中获取数据，线程之间数据是不可见的；打个比方：主内存变量A原始值为1，线程1从主内存取出变量A，修改A的值为2，在线程1未将变量A写回主内存的时候，线程2拿到变量A的值仍然为1； 4、指令重排序参考资料 (即生成的机器指令与字节码指令顺序不一致。) 为什么会有重排序? 为了提高执行效率，目前大多数现代微处理器都会采用将指令乱序执行。在条件允许的情况下，直接运行当前有能力立即执行的后续指令，避开获取下一条指令所需数据时造成的等待。 int a = 1; int b = 2; int c = a + b; 将上面的代码编译成Java字节码或生成机器指令，大致可视为展开成了以下几步动作： 对a赋值1 对b赋值2 取a的值 取b的值 将取到两个值相加后存入c 在上面5个动作中，动作1可能会和动作2、4重排序， 动作2可能会和动作1、3重排序，动作3可能会和动作2、4重排序， 动作4可能会和1、3重排序。但动作1和动作3、5不能重排序。 动作2和动作4、5不能重排序。因为它们之间存在数据依赖关系， 一旦重排，as-if-serial语义便无法保证。 5、as-if-serial语义 所有的动作都可以为了优化而被重排序，但是必须保证它们重排序后的结果和程序代码本身的应有结果是一致。所以，重排序不会发生在有数据依赖的操作之中。 (java内存模型) 8大原子操作： 为了解决主内存和工作线程的一致性问题，Java定义了如下原子操作. 1、 lock 锁定 作用于主内存，把变量标记为一条线程独占状态。 2、unlock 解锁。 作用于主内存，释放后的变量才能被其他线程锁定。 3、 read读取 作用于主内存。 将变量的值从主内存传输到工作内存中。 4、load 载入 作用于工作内存。将从主内存中得到的变量值放入工作内存的变量副本中。 5、 use 使用。 作用于工作内存。 将工作内存中的变量的值传递给执行引擎。 6、assign 赋值 作用于工作内存。将执行引擎传递过来的值赋值给工作内存中的变量副本。 7、store 存储 作用于工作内存。 将工作内存中的变量值传递到主内存。 8、write 写入 作用于主内存。将从工作内存中传递过来的值 赋值给主内存的变量。 线程同步机制 1、同步方法 //锁住整个方法 public synchronized void save(){} 2、同步代码块 synchronized(object) { //同步是一种高开销的操作，通常没有必要同步整个方法， //使用synchronized代码块同步关键代码即可。 } 3、使用volatile轻量级同步机制 //一个变量使用volatile后，它将具有以下两种特性： ①、此变量对所有线程可见。 当一条线程修改了这个变量的值，新的值对于其他线程来说是立即得知的。普通变量不能实现这一点。 (注：因为Java里的运算并非原子操作，所以volatile只能保证了可见性，仍然需要通过加锁来保证数据的一致性) ②、 volatile 禁止CPU进行指令重排序优化。 普通的变量可能会进行指令重排序，所以不能保证变量赋值操作的顺序与程序代码中的执行顺序一致。 4、重入锁 ReentrantLock // ?? 5、使用ThreadLocal // ?? 6、使用阻塞队列实现同步 // ?? 7、使用AtomicInteger 实现原子变量 原子操作就是指将读取变量值、修改变量值、保存变量值看成一个整体来操作 即-这几种行为要么同时完成，要么都不完成。 // ??? 问题： 1、内存分为哪几部分，这些部分分别都存储哪些数据？ 答案：略。 2、一个对象从创建到销毁都是怎么在这些部分里存活和转移的？ 3、内存的哪些部分会参与GC的回收？ ///?? 4、Java的内存模型是怎么设计的？ 答案：略。 5、为什么要这么设计？ 答案：略。 6、结合内存模型的设计谈谈volatile关键字的作用？ 答案：略。 7、接着可见性这三个字，还可以继续问你并发的内容。 无版权 可以无限制使用！ all right reserved，powered by Gitbook该文件更新时间： 2018-12-07 17:21:03 "},"chinese/java基础/GC机制.html":{"url":"chinese/java基础/GC机制.html","title":"GC机制","keywords":"","body":"gc机制 GC机制的诞生时间大于Java。在早期的一些语言也曾使用过GC机制。 经过多年的发展，GC机制已经已经进入了“自动化”时代了，我们为什么还要去了解GC机制呢？ 因为深入了解GC机制能更好地排查内存溢出泄露问题。 当GC机制成为高并发的瓶颈时，我们可以通过监控和调节GC过程，采取合适的优化方案。 普通的程序员也可以从GC机制中学习到它们优秀的策略。 判断对象是否存活的方法 1、引用计数算法 (Reference Counting) 给对象中添加一个引用计数器,每当有一个地方引用它时,计数器值就加1; 当引用失效时,计数器值就减1;任何时刻计数器为0的对象就是不可能再被使用的。 java已经摈弃了这种方案。因为很难解决对象之间的互相循环引用的问题。 2、可达性分析算法( Reachability Analysis) / 根搜索算法( GC Root Tracing) 目前主流编程语言(java,C#等)中,都是称通过可达性分析来判定对象是否存活的。 该算法的基本思路就是通过一系列的“GC Roots”对象作为起始点,从这些节点开始向下搜索(搜索所走过的路径称为引用链), 当一个对象到GC Roots没有任何引用链相连(用图论的话来说,就是从GC Roots到这个对象不可达)时,则证明此对象是不可用的。 如下图所示，对象object 5、object 6、object 7虽然互相有关联,但是它们到GC Roots是不可达的,所以它们将会被判定为是可回收的对象。 Java语言中 可作为GC Roots的对象 1、虚拟机栈(栈帧中的**本地变量表**)中引用的对象。 2、持久代中类**静态属性引用的对象**。 3、持久代中**常量引用的对象**。 4、本地方法栈中JNI(即一般说的Native方法)引用的对象。 垃圾收集算法 标记-清除算法 首先标记出所有需要回收的对象，标记完成后统一回收被标记过的对象。 缺点： 1、效率不高。标记和清除过程效率都不高。 2、空间问题。标记清除后会产生大量不连续的内存碎片。 复制算法 将内存均分为两块，每次只用其中一块。当着一块的内存用完了，就将还存活的对象复制到另一块内存上。 然后将已经使用过的这块内存一次性清理掉。 优点： 实现简单，运行高效。 缺点： 浪费内存，可用内存较少。 标记-整理 算法 标记过程与 “标记-清除”算法一样。然后，让所有存活的对象向一端移动，最后直接清理掉端边界以外的内存。 分代收集算法 该算法是目前大部分JVM的垃圾收集器采用的算法。 核心思想是根据对象存活的生命周期将内存划分为若干个不同的区域。然后根据各个年代的特点采用适当的收集算法。 内存划分类型 内存被分为下面三个区域 。 Enden、form survicor space、to survivor space。 新生代 绝大多数最新被创建的对象会被分配到这里。对象从这个对象消失的过程称为”minor GC”。 特征： （1）GC的发生相对比较频繁和迅速高效。 （2）包含了许多短周期对象。 老年代 (1)、从新生代存活下来的对象会被拷贝到这里，它的空间比新生代要大 (2)、GC操作不是很频繁，但是耗时比新生代中的GC要长。 内存占用的增长比较缓慢。 对象从老年代消失的过程称为”major GC”或者”full GC”。 永久代 (方法区/持久代) 用来存放类常量和字符串常量(并不是用来存储那些从老年代存活下来的对象)。它也会发生GC操作。 内存分配与回收机制 对象优先在Eden分配 对象一般在新生代Eden区中分配，当Eden区没有足够的空间进行分配时，虚拟机将发起一次Minor GC 。 大对象直接就进入老年代 大对象(类似很长的字符串或数组 需要大量连续内存空间的对象)。 长期存活的对象将进入老年代 虚拟机给每个对象定义了一个对象年龄计数器。对象再Survivor区中每熬过一次Minor GC,年龄就会增加1岁。当年龄增加到一定程度(默认配置15岁)，对象就会被移动到老年代中。 动态对象年龄判定 并不是一定要达到规定的年龄，对象才会被移动到老年代中。 如果Survivor空间中相同年龄 所有对象的大小的总和大于Survivor空间的一半，年龄>=该年龄的对象就会直接被移动到老年代中。 空间分配担保 在执行Minor GC之前，虚拟机先检查老年代最大可用的连续空间是否大于新生代所有对象总空间，如果ok，那么此次Minor GC可以安全进行。否则，虚拟机会查看HandlePromotionFailure设置值是否允许担保失败。如果允许，那么会继续检查老年代最大可用的连续空间是否大于历次晋升到老年代对象的平均大小，如果大于，将尝试着进行一次Minor GC，(尽管此次 Minor GC是有风险的)；如果小于，或者HandlePromotionFailure设置不允许冒险，就改为执行 Full GC（不执行 Minor Gc）。 拓展知识点 Java中引用的类型 1、强引用 类似Object obj= new Object(); 只要强引用还存在，GC永远不会回收掉被引用的对象。 2、软引用 可用SoftReference实现软引用。 系统内存不足时，会把软引用关联的对象加入回收范围并进行回收，回收后如果内存还是不足才会抛出内存溢出异常。 3、弱引用。 可用WeakReference实现。 当GC执行时，无论当前内存是否充足，都会将若引用关联的对象回收掉。 4、虚引用 可用PhantomReference实现。 为一个对象设置虚引用的唯一目的就是希望对象被回收时系统能提供一个系统通知。 finalize() finalize()的发明是为了向c/c++程序员妥协。 在Java中使用finalize()方法反而会带来更多的不确定性。 所以在Java中不推荐使用这个方法，不建议对象进行自我拯救。 类似于“关闭外部资源”之类的工作可以交给try-finally或其他方式完成。 被GC判断为”垃圾”的对象一定会回收吗 在可达性分析算法中不可达的对象,也并非是“非死不可”的, 这时候它们暂时处于“缓刑”阶段,要真正宣告一个对象死亡,至少要经历 两次标记过程。 如果对象在进行可达性分析后发现没有与GC Roots相连接的引用链,那它将会被第一次标记并且进行一次筛选, 筛选的条件是此对象是否有必要执行finalize()方法。 当对象没有覆盖finalize()方法,或者finalize()方法已经被虚拟机调用过,虚拟机将这两种情况都视为“没有必要执行”。(即意味着直接回收)。 如果这个对象被判定为有必要执行finalize()方法,那么这个对象将会放置在一个叫做F-Queue的队列之中, 并在稍后由Finalizer线程(虚拟机建立的、低优先级)去触发finalize()方法。 finalize()方法是对象逃脱死亡命运的最后一次机会,稍后GC将对F-Queue中的对象进行第二次小规模的标记, 如果对象要在finalize()中成功拯救自己——只要重新与引用链上的任何一个对象建立关联即可, 譬如把自己(this关键字)赋值给某个类变量或者对象的成员变量,那在第二次标记时它将被移除出“即将回收”的集合; 如果对象这时候还没有逃脱,那基本上它就真的被回收了。 任何一个对象的finalize()方法只能被系统自动调用一次。所以对象自我拯救的次数有限。 无版权 可以无限制使用！ all right reserved，powered by Gitbook该文件更新时间： 2018-12-07 17:21:03 "},"chinese/java基础/内部类.html":{"url":"chinese/java基础/内部类.html","title":"内部类","keywords":"","body":"可以将一个类的定义放在另一个类的定义内部，这就是内部类。 对于初学者来说内部类实在是使用的不多 . 其实使用内部类最大的优点就在于它能够非常好的解决多重继承的问题，但是如果我们不需要解决多重继承问题，那么我们自然可以使用其他的编码方式 。 内部类是个编译时的概念，一旦编译成功后，它就与外围类属于两个完全不同的类（当然他们之间还是有联系的）。 内部类它可以无限制地访问外围类的元素。 Java中内部类主要分为成员内部类、局部内部类、匿名内部类、静态内部类。 实现多重继承 ： 1、接口 （无需多说了） 、 2、内部类 太赞同它是实现多重继承 也不习惯这种方式，所以不太用。 个人感觉就是一个组合而已。 https://www.cnblogs.com/chenssy/p/3389027.html 匿名内部类 匿名内部类没有名字 ，创建格式如下 。 new 父类构造器（参数列表）|实现接口（） { //匿名内部类的类体部分 } 匿名内部类参数为何要为final 1、首先在内部类编译成功后，它会产生一个class文件，该class文件与外部类并不是同一class文件，仅仅只保留对外部类的引用。 2、内部类并不是直接调用方法传递的参数，而是利用自身的构造器对传入的参数进行备份，自己内部方法调用的实际上时自己的属性而不是外部方法传递进来的参数。 3、在内部类中的属性和外部方法的参数两者从外表上看是同一个东西，但实际上却不是，也就是说在内部类中我对属性的改变并不会影响到外部的形参，而然这从程序员的角度来看这是不可行的，毕竟站在程序的角度来看这两个根本就是同一个，如果内部类该变了，而外部方法的形参却没有改变这是难以理解和不可接受的，所以为了保持参数的一致性，就规定使用final来避免形参的不改变。 （规定的！！） 无版权 可以无限制使用！ all right reserved，powered by Gitbook该文件更新时间： 2018-12-07 17:21:03 "},"chinese/java基础/线程相关/线程池.html":{"url":"chinese/java基础/线程相关/线程池.html","title":"线程池","keywords":"","body":"线程池 为什么要用线程池: 1.减少了创建和销毁线程的次数，每个工作线程都可以被重复利用，可执行多个任务。 2.可以根据系统的承受能力，调整线程池中工作线线程的数目，防止因为消耗过多的内存 //创建一个单线程的线程池。如果这个唯一的线程异常结束，会有一个新的线程来替代它。 //此线程池保证所有任务的执行顺序按照任务的提交顺序执行。 ExecutorService pool1 = Executors.newSingleThreadExecutor(); pool1.execute(command); //每次提交一个任务就创建一个线程，直到线程达到线程池的最大大小。 ExecutorService pool2 =Executors.newFixedThreadPool(10); pool2.execute(command); //如果有线程超过一定时间(60秒)，就会被回收。 //当线程不够时，又会新建线程。 //线程池大小完全依赖于当前JVM能够创建的最大线程大小。 ExecutorService pool3=Executors.newCachedThreadPool(); pool3.execute(command); //支持定时及周期性任务执行 ScheduledExecutorService pool4 =Executors.newScheduledThreadPool(10); pool4.scheduleAtFixedRate(command, initialDelay, period, unit); //跟Executors出来的差不多 ScheduledThreadPoolExecutor pool5 =new ScheduledThreadPoolExecutor(10); pool5.scheduleAtFixedRate(command, initialDelay, period, unit); pool5.execute(command);       线程池demo public class MyThreadPoolTools { private ExecutorService singleThreadPool = null ; private ExecutorService getThreadPoolsIncetance() { //guava-17.0.jar ThreadFactory threadFactory = new ThreadFactoryBuilder().setNameFormat(\"wk-pool-%d\").build(); RejectedExecutionHandler handler =new ThreadPoolExecutor.AbortPolicy(); /*核心线程数量newSingleThreadExecutor 最大线程数量ScheduledThreadPoolExecutor 当线程池数量超过核心线程数量以后，空闲时间超过这个值的线程会被终止 KeepAlive时间单位 任务队列 创建线程的工厂对象 任务被拒绝后调用的handler*/ ExecutorService threadPool = new ThreadPoolExecutor( 5 , 10 , 3 , TimeUnit.MICROSECONDS , new LinkedBlockingQueue(Integer.MAX_VALUE) , threadFactory , handler ) ; return threadPool ; } /**提交任务并执行*/ public void addTask(Runnable runnable) { if (singleThreadPool == null) { singleThreadPool= getThreadPoolsIncetance(); } //运行线程池中的任务 singleThreadPool.submit(runnable) ; } /**关闭线程池*/ public void shutdownThreadPool() { if (singleThreadPool != null) { if(!singleThreadPool.isShutdown()) { singleThreadPool.shutdownNow() ; } } } } //使用 MyThreadPoolTools myThreadPoolTools= new MyThreadPoolTools(); Runnable task = new Runnable() { @Override public void run() { //耗时操作 } }; myThreadPoolTools.addTask(task); myThreadPoolTools.shutdownThreadPool(); 无版权 可以无限制使用！ all right reserved，powered by Gitbook该文件更新时间： 2018-12-07 17:21:03 "},"chinese/java基础/线程相关/进程和线程的区别.html":{"url":"chinese/java基础/线程相关/进程和线程的区别.html","title":"进程和线程的区别","keywords":"","body":"~一个程序至少有一个进程,一个进程至少有一个线程。~ 区别的本质 - 操作系统对他们的调度和资源分配不同 从逻辑角度来看，多线程的意义在于一个应用程序中，有多个执行部分可以同时执行。 但操作系统并没有将多个线程看做多个独立的应用，来实现进程的调度和管理以及资源分配。          进程在执行过程中拥有独立的内存单元，而多个线程共享内存，从而极大地提高了程序的运行效率。 进程是具有一定独立功能的程序关于某个数据集合上的一次运行活动,进程是系统进行资源分配和调度的一个独立单位. 进程和线程的主要差别在于它们是不同的操作系统资源管理方式。进程有独立的地址空间，一个进程崩溃后，在保护模式下不会对其它进程产生影响.所以多进程的程序要比多线程的程序健壮，但在进程切换时，耗费资源较大，效率要差一些。 dvm指dalivk的虚拟，每一个Android应用程序都在它自己的进程中运行,都拥有一个独立的 Dalvik虚拟机实例。而每一个DVM都是在Linux 中的一个进程,所以说可以认为是同一个概念. 无版权 可以无限制使用！ all right reserved，powered by Gitbook该文件更新时间： 2018-12-07 17:21:03 "},"chinese/java基础/线程相关/并发编程_多线程.html":{"url":"chinese/java基础/线程相关/并发编程_多线程.html","title":"并发编程_多线程","keywords":"","body":"并发编程_多线程 从以下几个的角度来考虑。 1、java内存模型。 主内存和线程内存。 2、线程状态的转换。 3、锁机制 。 防止死锁的机制。 同步的机制等。 无版权 可以无限制使用！ all right reserved，powered by Gitbook该文件更新时间： 2018-12-07 17:21:03 "},"chinese/java基础/线程相关/线程阻塞.html":{"url":"chinese/java基础/线程相关/线程阻塞.html","title":"线程阻塞","keywords":"","body":"线程阻塞 阻塞指的是暂停一个线程的执行以等待某个条件发生（如某资源就绪）。 阻塞机制： 1、sleep() sleep() 允许线程在指定的时间内进入阻塞状态，不能得到CPU 时间，指定的时间一过，线程重新进入可执行状态。 只是不参与cpu时间的竞争， 已经拿到手的锁资源并不释放 （此时不一定占有锁）。 sleep 方法时间到了会自动醒过来， 时间没到可以用interrupt方法强行唤醒。 @Override public void run() { while (!isStoped) { try { Thread.sleep(50); //todo... } catch (Exception e) { } } } 2、 suspend() 和 resume() 两方法配套使用，调用suspend()进入阻塞状态（不会立即的停止，而是执行到一个安全点后挂起 。不会自动恢复）。调用resume()进入唤醒状态。 在多线程场景中很容易造成死锁，目前这2个方法已经被废弃。 ~suspend() 、 resume() 、 stop()~ 3、yield() 线程礼让、让步。 yield()方法让当前正在执行的线程放弃当前分得的CPU时间（并不是阻塞该线程），它只是将该线程从运行状态转入就绪状态。 只是礼让当前的cpu使用权，让系统的线程调度器重新调度一次。很有可能，当这个线程调用了yield()方法后它又马上抢占了CPU的执行权，继续执行。 Thread t = new Thread; t.sleep(); t.yield(); 4、 wait() 、 notify() 、notify 两个方法配套使用 。 都是Object的方法。并不是Thread独有的。 这里要明确 线程等待的就是一个对象发出的信号，所以要基于对象而存在。 wait() 、 notify() 必须在 synchronized 同步方法或块中调用 。 否则运行时会抛出 IllegalMonitorStateException 异常 。 调用wait进入阻塞后，会释放占用的锁。 obj.wait( time ) ， 超时自动唤醒或者由notify( )、notifyAll()唤醒 进入就绪状态。 obj.wait( ) ，由notify( )、notifyAll( )唤醒 进入就绪状态。 调用wait会让当前线程释放这个对象的锁。 （线程此时不一定持有锁，如果没有锁就忽略，如果占有锁就会释放） 如果多个线程调用了某个对象的 wait() ， 对象的notify()被调用时 是随机选择一个线程唤醒 。 如果多个线程调用了某个对象的 wait() ， notifyAll()被调用时 将这些线程全部唤醒，抢到锁的那个线程 进入就绪状态 。 线程竞争对象的锁。 class NumberPrint implements Runnable { public static void main(String args[]) { // 以该对象为共享资源 final byte a[] = { 0 }; new Thread(new NumberPrint((1), a), \"1\").start(); new Thread(new NumberPrint((2), a), \"2\").start(); } private int number; public byte res[]; public static int count = 5; public NumberPrint(int number, byte a[]) { this.number = number; res = a; } @Override public void run() { synchronized (res) { while (count-- > 0) { try { res.notify(); System.out.println(\" \" + number); res.wait(); System.out.println(\"------线程\" + Thread.currentThread().getName() + \"获得锁，wait()后的代码继续运行：\" + number); } catch (InterruptedException e) { } }// end of while return; }// synchronized } } 为什么java规定 wait()，notify()和notifyAll()必须在同步块或同步方法中调用。而suspend()、 resume()可以在任何地方都调用？ 以下是个人感觉比较靠谱一点的网络解释。 1、首先suspend()、 resume()是基于线程存在的。 wait()、notify()基于对象存在的。 2、既然是基于对象的，此时在这个对象上可能同时有多个线程调用wait()/notify()方法， 依然存在并发的问题，理论上也需要一个锁来控制。    join()方法的作用 线程A 里面 调用了 线程B.join() 。 此时线程A进入阻塞状态 ，线程B执行。 直到线程B执行完毕或者被打断，线程A才能恢复继续执行 。 主要用于线程之间的交互。 · 无版权 可以无限制使用！ all right reserved，powered by Gitbook该文件更新时间： 2018-12-07 17:21:03 "},"chinese/java基础/线程相关/线程同步.html":{"url":"chinese/java基础/线程相关/线程同步.html","title":"线程同步","keywords":"","body":"线程同步 同步是一种计算机术语，一般指的是在多个数据库、文件、模块、线程之间用来保持数据内容一致性的机制。 程同步的真实意思和字面意思恰好相反，其实是“线程排队”：几个线程之间要排队，一个一个对共享资源进行操作，而不是同时进行操作。 核心点 1、java的每个对象都有一个内置锁 . 2、同步高开销，尽量减少同步的内容。一般同步关键代码（代码块）即可。 线程同步的实现方式 1、同步方法 public synchronized void funcA() { //锁住 当前方法 } public static synchronized void funcB() { //锁住 当前类 } 2、同步代码块 public synchronized void funcC() { //其他操作... synchronized (this) { //同步 操作共享资源... } //其他操作... } 3、关键字volatile 个人感觉跟同步没啥关系。！！ 没实际用过 1、对于volatile修饰的变量，只保证从主内存加载到线程工作内存的值是最新的。保证不了线程安全 。 2、volatile关键字所在的代码块 禁止指令重排。 4、使用重入锁 ReentrantLock 实现线程同步 //fair为true表示是公平锁 。默认非公平。 boolean fair= false ; ReentrantLock reentrantLock = new ReentrantLock(fair) ; private void func1(ReentrantLock lock) { //如果已经被锁定了 就会忽略。不会等待。 if(lock.tryLock()) { try{ //执行相关操作 }finally{ //释放锁 lock.unlock(); } } } private void func2(ReentrantLock lock) throws InterruptedException { //如果被锁定了，就会尝试等待指定时长。如果还没有就放弃 if(lock.tryLock(5 , TimeUnit.SECONDS)) { try{ //执行相关操作 }finally{ //释放锁 lock.unlock(); } } } private void func3(ReentrantLock lock) { //如果已经被锁定了 ,会在此等待 try{ lock.lock(); //执行相关操作 }finally{ //释放锁 lock.unlock(); } } /*** * 如果指定时间内没有完成操作。就中断当前线程，释放锁 * @param lock */ private void func4(ReentrantLock lock) { //tryLock和lockInterruptibly方法在申请锁的过程中是可以被中断的 . //如果线程被中断，抛出一个InterruptedException异常 try { lock.lockInterruptibly(); // } catch (InterruptedException e) { //执行相关操作 }finally{ //释放锁 lock.unlock(); } } 5、使用 ThreadLocal线程局部变量 实现线程同步。 Aivin感觉跟线程同步有毛关系！！ 以下来自网络解释 ~“作为Thread的一个局部变量 。为解决多线程程序的并发问题提供了一种新的思路。ThreadLocal会为每一个线程维护一个和该线程绑定的变量的副本，从而隔离了多个线程的数据，每一个线程都拥有自己的变量副本，从而也就没有必要对该变量进行同步了。 ”~ ~通俗的解释，threadlocal就跟自助餐的餐盘一样，外面一堆人排队，进去的一人一个餐盘，装一堆，再慢慢消化，有这个场景的应该都可以用~ //使用场景： 暂时没有这方面的需求，没用过。 6、使用 阻塞队列 LinkedBlockingQueue 实现线程同步 使用java封装的帮助类，实现多线程安全。 每次只允许 一个线程去队列里面存放对象 。 BlockingQueue outQueue = new LinkedBlockingQueue<>(Integer.MAX_VALUE); outQueue.put(msg); msg = outQueue.poll(); 7、使用 Atomic 原子变量实现线程同步 根据java 定义，原子操作是不会被打断地的操作，因此被认为是线程安全的。 java.util.concurrent.atomic包提供 Atomic 用CAS方式实现 原子操作。 /**原子更新基本类型类 （没有 double 和float的封装类型） */ AtomicInteger atomicInt = new AtomicInteger(100); AtomicBoolean atomicBoolean = new AtomicBoolean(false); AtomicLong atomicLong = new AtomicLong(1000000); private void func1( ) { //原子更新数组类 int[]arrayInt ={1,30}; AtomicIntegerArray atomicIntArray = new AtomicIntegerArray(arrayInt); atomicIntArray.getAndSet(i, newValue); atomicIntArray.addAndGet(i, delta); //AtomicReferenceFieldUpdater 一个基于反射的工具类，它能对指定类的指定的volatile引用字段进行原子更新。(这个字段不能是private的) AtomicReferenceFieldUpdater updater=AtomicReferenceFieldUpdater.newUpdater(Dog.class,String.class,\"name\"); updater.compareAndSet(dog1,dog1.name,\"test\") ; //AtomicMarkableReference ,为解决CAS操作中潜在的ABA问题 设计的解决方案。 AtomicMarkableReference atomicMarkRef= new AtomicMarkableReference (\"StrMsg\", false) ; if(!atomicMarkRef.isMarked()) { atomicMarkRef.set(\"bbb\", true); }; //AtomicStampedReference 用法与 AtomicMarkableReference 类似 } 无版权 可以无限制使用！ all right reserved，powered by Gitbook该文件更新时间： 2018-12-07 17:21:03 "},"chinese/java基础/线程相关/可重入.html":{"url":"chinese/java基础/线程相关/可重入.html","title":"可重入","keywords":"","body":"可重入 可重入函数保证了在多线程条件下，函数的状态不会出现错误。 以下分别是一个不可重入和可重入函数的示例： static int tmp; void func1(int* x, int* y) { tmp=*x; *x=*y; *y=tmp; } void func2(int* x, int* y) { int tmp; tmp=*x; *x=*y; *y=tmp; } func1是不可重入的，func2是可重入的。因为在多线程条件下，操作系统会在func1还没有执行完的情况下，切换到另一个线程中，那个线程可能再次调用func1，这样状态就错了。 无版权 可以无限制使用！ all right reserved，powered by Gitbook该文件更新时间： 2018-12-07 17:21:03 "},"chinese/java基础/线程相关/线程进程中的相关概念.html":{"url":"chinese/java基础/线程相关/线程进程中的相关概念.html","title":"线程进程中的相关概念","keywords":"","body":"线程进程中的相关概念 公平锁（Fair） 加锁前检查是否有排队等待的线程，优先排队等待的线程，先来先得。 非公平锁（Nonfair） 加锁时不考虑排队等待问题，直接尝试获取锁，获取不到自动到队尾等待 独享锁/共享锁 独享锁(例如synchronized )是指该锁一次只能被一个线程所持有。 共享锁是指该锁可被多个线程所持有。 ReadWriteLock rtLock = new ReentrantReadWriteLock(); //共享锁 rtLock.readLock(); //互斥锁 rtLock.writeLock(); ReadWriteLock rtLock = new ReentrantReadWriteLock(); 死锁 多个线程同时被阻塞，它们中的一个或者全部都在等待某个资源被释放。由于线程被无限期地阻塞。 //java 死锁产生的四个必要条件： 1、互斥使用，即当资源被一个线程使用(占有)时，别的线程不能使用. 2、不可抢占，资源请求者不能强制从资源占有者手中夺取资源，资源只能由资源占有者主动释放。 3、请求和保持，即当资源请求者在请求其他的资源的同时保持对原有资源的占有。 4、循环等待，即存在一个等待队列：P1占有P2的资源，P2占有P3的资源，P3占有P1的资源。 这样就形成了一个等待环路。 当上述四个条件都成立的时候，便形成死锁。当然，死锁的情况下如果打破上述任何一个条件，便可让死锁消失。 线程中断 中断本质是一种特殊的电信号。处理器接受到中断后，会马上向操作系统反映此信号的到来，然后就由os负责处理这些新到来的数据。 要中断一个Java线程，可调用线程类对象的实例方法：interrupte()。其本质只是设置该线程的中断标志，将中断标志设置为true，并根据线程当前的状态决定做出不同的响应。 CAS / 非阻塞同步 CAS(Compare-and-Swap) 。基于冲突检测的乐观并发策略 ，先将内存的值进行保存，当操作完成时再判断保存的值和当前内存的值是否相同，如果不同则说明其他线程操作了该数据，所以需要重试或者放弃。这种乐观的并发策略不需要把线程挂起，因此这种同步措施称为非阻塞同步。 ABA问题 是指在CAS操作中带来的一个潜在问题。例如，线程1将初始值为A的变量 先修改成B，再修改回成A。线程B的CAS操作无法分辨当前V值是否发生过变化。 原子操作 是指不会被线程调度机制打断的操作机制。这种操作一旦开始，就一直运行到结束，中间不会有任何 context switch （切换到另一个线程）。根据java 定义，原子操作是不会被打断地的操作，因此被认为是线程安全的。java中可以通过锁和循环CAS的方式来实现原子操作。 无版权 可以无限制使用！ all right reserved，powered by Gitbook该文件更新时间： 2018-12-07 17:21:03 "},"chinese/java基础/equals，hashcode和==的区别.html":{"url":"chinese/java基础/equals，hashcode和==的区别.html","title":"equals，hashcode和==的区别","keywords":"","body":"相等判断 针对基本数据类型 == 比较的是它们的值是否相同 。 针对(类、接口、数组)这样的引用数据类型 。 == 比较的是它们在内存中的地址（在栈中）。 如果要比较引用对象的值是否相同，就需要重写equals方法。可以根据自己定义的规则判断对象是否相同。 hashCode()在hashSet这种集合中的使用 java规定： Set中元素无序，元素不可重复。 需要解决的问题：如何高效地判断新加的元素是否与集合中的元素不一样，从而保证保证元素不重复 ？ 解决办法： 我们可以用equals方法依次判断是否相等。但是，每增加一个元素就检查一次，那么当元素很多时，后添加到集合中的元素比较的次数就非常多了。这显然会大大降低效率。 于是，Java采用了哈希表的原理： 当集合要添加新的元素时， 先调用这个元素的hashCode方法，就一下子能定位到在hash表中的位置。 如果这个位置上没有元素，它就可以直接存储在这个位置上，不用再进行任何比较了； 如果这个位置上已经有元素了（hash碰撞现象），就调用它的equals方法与新元素进行比较，相同的话就不存，不相同就（再次求hashcode）散列其它的地址。 这样一来实际调用equals方法的次数就大大降低了，几乎只需要一两次。 如何重写hashCode() hashSet这种集合判断集合中对象是否相同，为了提升效率 ，首先进行hashCode比较 ，然后再调用 equals比较 。 @Override public int hashCode(){ int hashCode = 0; //自定义系数，随意写。只要不是特别大或特别小 导致最后hash值查出int的范围即可 int k1=5 ; //最后的hash值生成原则： 用到类里面的所有属性。 hashCode = k1 * age + name.hashCode(); return hashCode ; } @Override public boolean equals(Object obj){ //对象地址完全一样，对象肯定相等 if (obj == this){ return true; } //如果类型都不一样了，肯定不相等 if (!(obj instanceof Bean1)) { return false; } //根据自定义规则判断是否相等 Bean1 bean = (Bean1)obj; return bean.name.equals(name) && bean.age == age; } 开发中需要注意的问题 重写了equals() 就必须重写 hashCode()方法。 同一个对象，hashCode 一定相同。 否则就会违背以下的规则： equal objects must have equal hash codes · 无版权 可以无限制使用！ all right reserved，powered by Gitbook该文件更新时间： 2018-12-07 17:21:03 "},"chinese/java基础/java多态.html":{"url":"chinese/java基础/java多态.html","title":"java多态","keywords":"","body":"从一定角度来看，封装和继承几乎都是为多态而准备的。 多态的定义：指允许不同类的对象对同一消息做出响应。即同一消息可以根据发送对象的不同而采用多种不同的行为方式。 以下是现实生活中多态的例子。比方说按下 F1 键这个动作，如果当前在 Word 下弹出的就是 Word 帮助； 在 Windows 下弹出的就是 Windows 帮助和支持。同一个事件发生在不同的对象上会产生不同的结果。 Java中多态的实现方式： 1、接口实现 2、继承父类进行方法重写 3、同一个类中进行方法重载 。（特殊- 有争议） 方法重载 为什么可以实现多态？？ 多态分为编译时多态和运行时多态。 其中编译时多态是静态的，主要是指方法的重载，它是根据参数列表的不同来区分不同的函数，通过编辑之后会变成两个不同的函数，在运行时谈不上多态。 注意 方法重载这个多态和另外另个多态方式的不同 。 （个人感觉跟上面那个多态的定义不太符合。） Java实现多态有三个必要条件： 1、继承 （extends 、 implements） 2、重写 3、向上转型 //例如 ： Object cat = new Cat() 无版权 可以无限制使用！ all right reserved，powered by Gitbook该文件更新时间： 2018-12-07 17:21:03 "},"chinese/java基础/java虚拟机.html":{"url":"chinese/java基础/java虚拟机.html","title":"java虚拟机","keywords":"","body":"参考资料： 1、 深入理解Java虚拟机 无版权 可以无限制使用！ all right reserved，powered by Gitbook该文件更新时间： 2018-12-07 17:21:03 "},"chinese/java基础/抽象类_接口.html":{"url":"chinese/java基础/抽象类_接口.html","title":"抽象类_接口","keywords":"","body":"抽象类接口区别 以下是常用的几点区别。 另外的小细节可以在编码的时候体会得到。 1、抽象类可以有构造器 ，接口不能有构造器 抽象类不能new，但抽象类里为什么还要有构造方法 抽象类可以有成员变量，他们的初始化怎么做呢？这么一样你就明白为什么抽象类可以有构造函数了。 2、接口和抽象类可以被new吗 Java语言规范规定了抽象类不能实例化 。 接口也不能被new出来 。 但是我们平时有时会见到一些迷惑性的代码，其实那是创建了 匿名内部类 。 具体请参考匿名内部类的定义。 final int value0 = 0 ; //匿名内部类 造成 new 出一个 抽象函数或接口实例 的假象 。 // java编译器特有的写法？？ AbstractClassA test1= new AbstractClassA() { int value ; @Override public void func1() { value = value0 ; System.out.println(\"value=\"+value); } }; test1.func1(); //错误写法，无法通过编译 AbstractClassA test2= new AbstractClassA(); 无版权 可以无限制使用！ all right reserved，powered by Gitbook该文件更新时间： 2018-12-07 17:21:03 "},"chinese/java基础/泛型通配符extends与super的区别.html":{"url":"chinese/java基础/泛型通配符extends与super的区别.html","title":"泛型通配符extends与super的区别","keywords":"","body":"泛型的作用 泛型，就是将类型参数化， 就是在定义的时候你不知道这个地方需要什么类型的数据 ，只有实际使用的时候才会知道 。 让编译器在编译期间帮忙检查类型错误。 未使用泛型： Object是所有类的根类，任何类的对象都可以设置给该Object引用变量，使用的时候可能需要类型强制转换 。(程序员手动做的强制转换是否正确 是要等到运行时才会发现，这样就晚了！！) 使用了泛型： 这样设计的容器在使用时编译器就可以帮忙做很大一部分的类型安全检查工作了，这就避免了很多运行时的ClassCastException异常，程序员也无需记住各种对象的类型和担心类型匹配问题了。 （编译器在编译是就帮我们做检查，更容易发现错误！！） 定义泛型常用的字母 原则上来讲，使用任何字母或字符串都是可以的 。 但是为了代码的可读性，我们一般有如下 约定； //在集合中使用，因为集合中存放的是元素) E - Element // 类型 T - Type //键 K - Key // 值 V - Value // 数字 N - Number //表示不确定的java类型 ? - 泛型的应用范围 说明 泛型类 泛型接口 泛型方法 泛型类 // 申明 泛型 T ， 不申明 ，无法使用 。（也可以将T写成其他乱七八糟的字母） public class Tool { private T value ; } 泛型接口 public interface Person { T getType(); }} 泛型方法 // 说明当前是一个 泛型方法 ， 并且将类型定义为 T200 // 返回值 为 T200 public T200 showKeyName (List list) { return list.get(0) ; } public class Tool { // 静态方法不能使用类定义的泛型。 public static void show(T200 t){ // 这样使用编译器会报错 } } 泛型与 可变参数 //printMsg(\"111\",222,\"aaaa\",\"2323.4\",55.55); public static void printMsg( T300... args){ for(T300 t : args){ System.out.println(\"t is \" + t); } } 泛型中 extends 和 super的区别 参考资料 ：是指 “上界通配符（Upper Bounds Wildcards）” Plate 翻译成人话就是：一个能放水果以及一切是水果派生类的盘子。再直白点就是：啥水果都能放的盘子。 ：是指 “下界通配符（Lower Bounds Wildcards）” Plate 一个能放水果以及一切是水果基类的盘子。 为什么要用通配符和边界 优点： 让Java不同泛型之间的转换更容易了。 使用泛型、通配符提高了代码的复用性。 缺点： 容器的部分功能失效。 （从类型转换的角度去理解 ，编译器不能确定具体类型，但是要确保不报错，所以不能给你强制转换） 1、上界不能往里存，只能往外取 2、下界不影响往里存，但往外取只能放在Object对象里 - 无版权 可以无限制使用！ all right reserved，powered by Gitbook该文件更新时间： 2018-12-07 17:21:03 "},"chinese/java基础/父类的静态方法能否被子类重写.html":{"url":"chinese/java基础/父类的静态方法能否被子类重写.html","title":"父类的静态方法能否被子类重写","keywords":"","body":"静态方法：java中，static修饰符修饰的方法就是静态方法。所谓静态就是指：在编译之后所分配的内存会一直存在（不会被回收），直到程序退出内存才会释放这个空间。 Java静态方法形式上可以重写，但从本质上来说不是Java的重写。 static方法不是后期绑定的，它在编译期就绑定了。 静态方法是不需要对象的。自然无法根据对象的类去覆盖方法. 如果父类中定义的静态方法在子类中被重新定义，那么定义在父类中的静态方法将被隐藏。 可以使用语法：父类名.静态方法名调用隐藏的静态方法 //举例验证 public class Fu { public static void show() { System.out.println(\"父类的静态方法\"); } public void method() { System.out.println(\"父类的普通方法\"); } } public class Zi extends Fu { public static void main(String[] args) { /**如果能被重写，new出子类实例，然后转为父类。 * fu.show(); 输出的就应该是 “子类的静态方法” */ Fu fu = new Zi(); fu.show(); fu.method(); } public static void show() { System.out.println(\"子类的静态方法\"); } public void method() { System.out.println(\"子类的普通方法\"); } } 输出的结果是： 父类的静态方法 子类的普通方法 无版权 可以无限制使用！ all right reserved，powered by Gitbook该文件更新时间： 2018-12-07 17:21:03 "},"chinese/java基础/容器类之间的区别.html":{"url":"chinese/java基础/容器类之间的区别.html","title":"容器类之间的区别","keywords":"","body":"容器类之间的区别 Array ，Arrays Array：就是数组。（我没怎么用过） Arrays：是Array的工具类，其静态方法定义了对Array的各种操作。 Collection 、 Collections Collection是接口，集合。 Collections是工具类。提供静态方法 封装了一些对集合的操作。 无版权 可以无限制使用！ all right reserved，powered by Gitbook该文件更新时间： 2018-12-07 17:21:03 "},"chinese/java基础/为什么要使用泛型.html":{"url":"chinese/java基础/为什么要使用泛型.html","title":"为什么要使用泛型","keywords":"","body":"http://blog.csdn.net/wgp15732622312/article/details/63683751 还未整理。。。 无版权 可以无限制使用！ all right reserved，powered by Gitbook该文件更新时间： 2018-12-07 17:21:03 "},"chinese/java基础/Java枚举.html":{"url":"chinese/java基础/Java枚举.html","title":"Java枚举","keywords":"","body":"Java枚举 [JDK1.5 ,+∞ ) 支持枚举 为了唯一性，所以规定了构造函数不能为public、protected 只能是private 或 不写 简单枚举 public enum CarType { BWO ,DZ ,AD } CarType type= CarType.DZ ; switch (type) { case BWO: System.out.println(\"宝马\"); break; case DZ: System.out.println(\"大众\"); break; case AD: System.out.println(\"奥迪\"); break; default: break; } 枚举类 public enum CarType { //初始化枚举实例 ，必须在构造函数前面 BWOINFO(1 ,\"宝马\" ,500.0), // 初始的值 对应构造函数的顺序 DZINFO( 2 ,\"大众\" ,600.0), ADOINFO(3 ,\"奥迪\" ,700.0) ; private int carId ; private String carName ; private double price ; private CarType(int id ,String name ,double price){ this.carId =id ; this.carName = name ; this.price = price ; } ... get set 方法 ... } // 单个实例 CarType car = CarType.BWOINFO; System.out.println(car.getCarName() + \" \" + car.getPrice()); // 修改枚举实例的值 car.setPrice(888.0); // 遍历枚举类中的所有实例 for (CarType temp : CarType.values()) { System.out.println(temp.getCarName() + \" \" + temp.getPrice()); } 枚举的缺点 每一个枚举值都是一个对象,在使用它时会增加额外的内存消耗 ，同时也会增加 DEX文件的大小 。 所以android官方文档建议尽量避免使用枚举。 Android 中枚举的替代方案 @IntDef 1、添加依赖 implementation 'com.android.support:support-annotations:28.0.0-rc02' 2、定义 public class MyDefBean { //先定义 常量 public static final int SUNDAY = 0; public static final int MONDAY = 1; public static final int TUESDAY = 2; //用 @IntDef \"包住\" 常量 声明构造器 @IntDef({SUNDAY, MONDAY,TUESDAY }) // @Retention 定义策略 @Retention(RetentionPolicy.SOURCE) // 定义‘接口’ public @interface WeekDays {} } 3、使用 @MyDefBean.WeekDays int currentDay = SUNDAY; void test(@MyDefBean.WeekDays int today) { switch (today) { case MyDefBean.MONDAY: break; case SUNDAY: break; case MyDefBean.TUESDAY: break; default: break; } } 无版权 可以无限制使用！ all right reserved，powered by Gitbook该文件更新时间： 2018-12-07 17:21:03 "},"chinese/java基础/深度拷贝.html":{"url":"chinese/java基础/深度拷贝.html","title":"深度拷贝","keywords":"","body":"深度拷贝 /** * @param src list * @return dest */ public List deepCopy(List src) throws IOException, ClassNotFoundException { ByteArrayOutputStream byteOut = new ByteArrayOutputStream(); ObjectOutputStream out = new ObjectOutputStream(byteOut); out.writeObject(src); ByteArrayInputStream byteIn = new ByteArrayInputStream(byteOut.toByteArray()); ObjectInputStream in = new ObjectInputStream(byteIn); List dest = (List) in.readObject(); return dest; } 无版权 可以无限制使用！ all right reserved，powered by Gitbook该文件更新时间： 2018-12-07 17:21:03 "},"chinese/java基础/自定义异常.html":{"url":"chinese/java基础/自定义异常.html","title":"自定义异常","keywords":"","body":"自定义异常 自定义异常方式我用的较少，一般都习惯用回调的方式回调逻辑错误。 不过，自定义错误有一个优点，方便定位异常具体地点。 (点击即可跳转) public class WkException extends Exception { private static final long serialVersionUID = 1L; private String errorInfo ; private int errorCode= -100 ; public WkException(String errorInfo){ this.errorInfo = errorInfo ; } public WkException(int errorCode ,String errorInfo){ this.errorCode = errorCode ; this.errorInfo = errorInfo ; } @Override public String toString() { return errorCode+\" \"+errorInfo; } } // 使用 public static void checkValue(int value ) throws WkException{ if(value>4){ throw new WkException(1001, \"数据错误\"); } } try { checkValue(10); } catch (WkException e) { e.printStackTrace(); } 无版权 可以无限制使用！ all right reserved，powered by Gitbook该文件更新时间： 2018-12-07 17:21:03 "},"chinese/java基础/json解析.html":{"url":"chinese/java基础/json解析.html","title":"json解析","keywords":"","body":"json解析 fastjson 阿里出品 ，零依赖 compile 'com.alibaba:fastjson:1.1.70.android' //json字符串转对象 InfoDetailItem item = JSON.parseObject(result, InfoDetailItem.class); 无版权 可以无限制使用！ all right reserved，powered by Gitbook该文件更新时间： 2018-12-07 17:21:03 "},"chinese/java基础/java注解.html":{"url":"chinese/java基础/java注解.html","title":"java注解","keywords":"","body":"java注解 注解 是在 Java SE 5.0 版本中开始引入的概念。 元注解 元注解是一种基本注解， 它能够应用到其它的注解上面。 元注解类型 说明 其他 @Retention 说明了这个注解的的存活时 @Retention(RetentionPolicy.RUNTIME) @Retention(RetentionPolicy.SOURCE ) @Retention(RetentionPolicy.CLASS ) @Documented 能将注解中的元素包含到Javadoc中去 - @Target 指定了注解运用的地方 @Target(ElementType.ANNOTATION_TYPE ) //可以给一个注解进行注解 @Target(ElementType.CONSTRUCTOR ) //可以给构造方法进行注解 @Target(ElementType.FIELD ) // 可以给属性进行注解 @Target(ElementType. LOCAL_VARIABLE) //可以给局部变量进行注解 @Target(ElementType.METHOD ) // 可以给方法进行注解 @Target(ElementType. PACKAGE) //可以给一个包进行注解 @Target(ElementType.PARAMETER ) //可以给一个方法内的参数进行注解 @Target(ElementType.TYPE ) //可以给一个类型进行注解，比如类、接口、枚举 @Inherited 如果一个f类被 @Inherited 注解过的注解 进行注解的话， 那么如果它的子类没有被任何注解应用的话， 那么这个子类就继承了超类的注解。 - @Repeatable Java 1.8 重复注解 ， 注解的值可以同时取多个 @Person(role=\"coder\") @Person(role=\"PM\") public class SuperMan{... Java内置的注解 说明 备注 @Deprecated 标记过时 - @Override 标记复写 - @SuppressWarnings 阻止编译器报警告提示 @SuppressWarnings(\"all\") // 抑制所有警告 @SuppressWarnings(\"boxing\") // 抑制装箱、拆箱操作时候的警告 @SuppressWarnings(\"cast\") // 抑制映射相关的警告 @SuppressWarnings(\"dep-ann\") // 抑制启用注释的警告 @SuppressWarnings(\"deprecation\") // 抑制过期方法警告 @SuppressWarnings(\"fallthrough\") // 抑制确在switch中缺失breaks的警告 @SuppressWarnings(\"finally\") // 抑制finally模块没有返回的警告 @SuppressWarnings(\"hiding\") // 忽略 关于隐藏的本地变量的警告 @SuppressWarnings(\"incomplete-switch\") // 忽略没有完整的switch语句 @SuppressWarnings(\"nls\") // 忽略非nls格式的字符 @SuppressWarnings(\"null\") // 忽略对null的操作 @SuppressWarnings(\"rawtypes\") // 使用generics时忽略没有指定相应的类型 @SuppressWarnings(\"restriction\") // 忽略 使用不建议或者禁止的引用的警告 @SuppressWarnings(\"serial\") // 忽略在serializable类中没有声明serialVersionUID变量 @SuppressWarnings(\"static-access\") // 抑制不正确的静态访问方式警告 @SuppressWarnings(\"synthetic-access\") // 抑制子类没有按最优方法访问内部类的警告 @SuppressWarnings(\"unchecked\") // 抑制没有进行类型检查操作的警告 @SuppressWarnings(\"unqualified-field-access\") // 抑制没有权限访问的域的警告 @SuppressWarnings(\"unused\") // 抑制没被使用过的代码的警告 @SafeVarargs JDK 7 阻止编译器产生 unchecked 这样的警告，效果跟 @SuppressWarnings(\"unchecked\")相同 注意：使用了这种注解后，开发者要确保自己的类型转换是没有问题的，否则运行时会报错的 @FunctionalInterface Java 1.8 当你写的接口不符合函数式接口定义的时候，编译器会报错 注解的属性 (成员变量) 注解只有属性，没有方法。 注解的属性在注解的定义中以“无形参的方法”形式来声明， 其方法名定义了该成员变量的名字，其返回值定义了该成员变量的类型。 自定义注解 一般在制作自己的框架 或者某种小工具时， 我们可以使用自定义注解 。 注意： 如果仅仅自定义了注解，并使用在代码中。这些注解并不会起作用。 如果想要真正使用上它们，你还得写一个其他工具类，利用反射等原理。 @Retention(RetentionPolicy.RUNTIME) public @interface TestAnnotation { public int id() default -1; public String msg() default \"Hi\"; } 注解与反射 通过反射获取 注解的内容。 private void testAninotation(Class clz) throws Exception { // 检测 某个类是否应用了 指定的注解 boolean hasAnnotation = clz.isAnnotationPresent(TestAnnotation.class); if(hasAnnotation){ TestAnnotation testAnnotation = clz.getAnnotation(TestAnnotation.class); //testAnnotation.id()+\" \"+testAnnotation.msg() } // 检测 某个 属性 是否应用了 指定的注解 // private void test( int age , String name ){...} /// 获取所有属性 Field[] fields = clz.getDeclaredFields(); Field a = MainActivity.class.getDeclaredField(\"testMsg\"); a.setAccessible(true); TestAnnotation testAnnotation1 = a.getAnnotation(TestAnnotation.class); if ( testAnnotation1 != null ) { // } ///检测 某个 方法 是否应用了 指定的注解 . test 是方法名 ///获取所有的类 Method[] method = clz.getDeclaredMethods(); Method testMethod = clz.getDeclaredMethod(\"test\" ,int.class ,String.class); if ( testMethod != null ) { Annotation[] ans = testMethod.getAnnotations(); for( Annotation annotation : ans) { // annotation.annotationType().getName() if(annotation instanceof TestAnnotation){ testMethod.setAccessible(true); // 在反射中调用 某个类的方法 // 第一个参数 是类的实例 ， 以后的多个参数都是方法需要的参数 testMethod.invoke( new MainActivity() , 20 , \"aivin\") ; } } } } 无版权 可以无限制使用！ all right reserved，powered by Gitbook该文件更新时间： 2018-12-07 17:21:03 "},"chinese/java基础/java8新特性.html":{"url":"chinese/java基础/java8新特性.html","title":"java8新特性","keywords":"","body":"java8新特性 java8新特性 说明 1、Lambda表达式 - 2、接口的默认方法与静态方法 - 3、方法引用 - 4、重复注解 - 5、扩展注解的支持 6、Optional - 7、Stream - 8、Date/Time API (JSR 310) - 9、JavaScript引擎Nashorn 10、Base64 java8对Base64进行优化后，放到java.util包下 Java Lambda Lambda是Java8的新特性 ，是一个语法糖 // 语法格式 (params) -> expression (params) -> statement (params) ->{ statements; } // List循环 List list = ...; list.forEach( reslut -> { reslut +=\"_修改过\" ; }); // 循环输出 list.forEach(System.out::println); //Map循环 Map map =...; map.forEach( (key ,value)-> { value +=100 ; }); map.forEach( ( key ,value ) -> System.out.println( \"key=\"+key +\" value=\"+value) ); // List 条件过滤 List result1 = // 将list转为 流 list.stream() // 将符合条件的元素过滤出来 .filter( line -> line.contains(\"aa\")) // 收集并将输出的流转为 list .collect(Collectors.toList()); result1.forEach(System.out::println); // 对象排序 List listSort= ... ; listSort.sort( (Student stu1 , Student stu2) -> stu1.age- stu2.age); listSort.forEach( (sutdent) -> { System.out.println(sutdent.name+\" : \"+sutdent.age); }); 接口的默认方法与静态方法 public interface MyMathTool { // 被 default关键字 修饰过的 sqrt 方法 将在子类上可以直接使用. // 可以有多个 默认方法 default double sqrt(int a) { return Math.sqrt(a); } } // 被 static修饰的方法 ，跟普通类的静态方法一样可以直接调用 // 可以有多个 静态方法 static double cacle(int a, int b){ return a+b ; } 函数式编程 函数式接口是Java支持函数式编程的基础。 \"函数式编程\"是一种\"编程范式\" 方法引用 方法引用是lambda表达式的一种语法糖, 为了简化代码和加速开发。 当我们想要实现一个函数式接口的那个抽象方法，但是已经有类实现了我们想要的功能， 这个时候我们就可以用方法引用来直接使用现有类的功能去实现。（至于为什么可以这样，我暂时还不知道，没看源码。） 方法引用规定：实现抽象方法的参数列表，必须与方法引用方法的参数列表保持一致。返回值就不作要求。 引用分类 分类 说明 引用方法 类名::静态方法名 类名::实例方法名 实例::实例方法名 引用构造器 引用数组 // 实例::实例方法名 Consumer consumer = System.out::println; consumer.accept(\"This is Major Tom\"); // 类名::静态方法名 Function f = Math::abs; Long result = f.apply(-3L); // 类名::实例方法名 // 这个地方有点不太好理解。 // 可以暂时这样理解： 生成了一个 BiPredicate 实例b ， // 并且 b中的 方法 test里面的内容和 String类的静态方法 equals 一模一样 BiPredicate b = String::equals; b.test(\"abc\", \"abcd\"); // 引用构造器 Function fun = StringBuffer::new; StringBuffer buffer = fun.apply(10); // 引用数组 Function fun2 = Integer[]::new; Integer[] arr2 = fun2.apply(10); 函数式接口 为了更友好的支持Lambda表达式，Java 8引入了函数式接口的概念。 所谓的函数式接口，当然首先是一个接口，然后就是在这个接口里面只能有一个抽象方法。 1、Java 8为函数式接口引入了一个新注解 @FunctionalInterface，主要用于编译级错误检查， 加上该注解，当你写的接口不符合函数式接口定义的时候，编译器会报错。 2、加不加@FunctionalInterface对于接口是不是函数式接口没有影响， 该注解知识提醒编译器去检查该接口是否仅包含一个抽象方法 3、函数式接口里是可以包含默认方法 、静态方法、Object里的public方法 @FunctionalInterface public interface Consumer { void accept(String msg); } 内置的函数式接口 为了方便开发者，java8内置了一批函数式接口。 Java8内置的函数式接口 参数类型 返回类型 用途 Consumer T void 对类型T参数操作，无返回结果，包含方法 void accept(T t) Supplier 无 T 返回T类型参数，方法时 T get() Function T R 对类型T参数操作，返回R类型参数，包含方法 R apply（T t） Predicate T boolean 断言型接口，对类型T进行条件筛选操作，返回boolean，包含方法 boolean test（T t） BinaryOperator T,T T 对类型T对象进行二元运算，并返回T类型的结果，包含方法T apply(T t1,T t2) BigConsumer T,U void 对类型T，u参数进行操作，包含方法void accept（T t,U u） BiConsumer 代表了一个接受两个输入参数的操作，并且不返回任何结果 BiFunction 代表了一个接受两个输入参数的方法，并且返回一个结果 BinaryOperator 代表了一个作用于于两个同类型操作符的操作，并且返回了操作符同类型的结果 BiPredicate 代表了一个两个参数的boolean值方法 BooleanSupplier 代表了boolean值结果的提供方 Consumer 代表了接受一个输入参数并且无返回的操作 DoubleBinaryOperator 代表了作用于两个double值操作符的操作，并且返回了一个double值的结果。 DoubleConsumer 代表一个接受double值参数的操作，并且不返回结果。 DoubleFunction 代表接受一个double值参数的方法，并且返回结果 DoublePredicate 代表一个拥有double值参数的boolean值方法 DoubleSupplier 代表一个double值结构的提供方 DoubleToIntFunction 接受一个double类型输入，返回一个int类型结果。 DoubleToLongFunction 接受一个double类型输入，返回一个long类型结果 DoubleUnaryOperator 接受一个参数同为类型double,返回值类型也为double 。 IntBinaryOperator 接受两个参数同为类型int,返回值类型也为int 。 IntConsumer 接受一个int类型的输入参数，无返回值 。 IntFunction 接受一个int类型输入参数，返回一个结果 。 IntPredicate 接受一个int输入参数，返回一个布尔值的结果。 IntSupplier 无参数，返回一个int类型结果。 IntToDoubleFunction 接受一个int类型输入，返回一个double类型结果 。 IntToLongFunction 接受一个int类型输入，返回一个long类型结果。 IntUnaryOperator 接受一个参数同为类型int,返回值类型也为int 。 LongBinaryOperator 接受两个参数同为类型long,返回值类型也为long。 LongConsumer 接受一个long类型的输入参数，无返回值。 LongFunction 接受一个long类型输入参数，返回一个结果。 LongPredicate R接受一个long输入参数，返回一个布尔值类型结果。 LongSupplier 无参数，返回一个结果long类型的值。 LongToDoubleFunction 接受一个long类型输入，返回一个double类型结果。 LongToIntFunction 接受一个long类型输入，返回一个int类型结果。 LongUnaryOperator 接受一个参数同为类型long,返回值类型也为long。 ObjDoubleConsumer 接受一个object类型和一个double类型的输入参数，无返回值。 ObjIntConsumer 接受一个object类型和一个int类型的输入参数，无返回值。 ObjLongConsumer 接受一个object类型和一个long类型的输入参数，无返回值。 Predicate 接受一个输入参数，返回一个布尔值结果。 Supplier 无参数，返回一个结果。 ToDoubleBiFunction 接受两个输入参数，返回一个double类型结果 ToDoubleFunction 接受一个输入参数，返回一个double类型结果 ToIntBiFunction 接受两个输入参数，返回一个int类型结果。 ToIntFunction 接受一个输入参数，返回一个int类型结果。 ToLongBiFunction 接受两个输入参数，返回一个long类型结果。 ToLongFunction 接受一个输入参数，返回一个long类型结果。 UnaryOperator 接受一个参数为类型T,返回值类型也为T。 匿名函数 参考匿名类。 匿名函数就是一个没有名字的函数。 常与 Lambda 搭配使用 // 新建了一个Runnable 对象。省略了 Runnable 的run函数的名字，并在函数里面打印了一句话 Runnable r = () -> System.out.println(\"Thread start...\"); // 使用这个新建的对象 new Thread(r).start(); Optional 是一个封装了一个元素的容器，而这个元素可以是null也可以是其它任意类型的。 Optional 的方法 说明 Optional.of(T t) 创建一个 Optional 实例 Optional.ofNullable(T t) 若 t 不为 null,创建 Optional 实例,否则创建空实例 Optional.empty() 创建一个空的 Optional 实例 optional.get() 获取Optional中的值 optional.isPresent() 判断optional对象是否有值 Stream 这个Stream并不是我们以前认识的IO流， 而是一个数据渠道，用于操作数据源（集合、数组等）所生成的元素序列。 Stream API 提供了一种高效且易于使用的处理数据的方式 ，例如 非常复杂的查找、过滤和映射数据等 。 注意：Stream 不会改变源对象。它会返回一个持有结果的新Stream（这样可以链式编程）。 Stream 延迟执行 只要Stream的方法返回的对象是Stream，这些方法就是延迟执行的方法 。 一般在Stream流中，一个方法返回的不是Stream，基本就是迫切方法 。 // 由集合创建 Stream List list = new ArrayList<>(); //获取一个顺序流 Stream stream = list.stream(); //获取一个并行流 Stream parallelStream = list.parallelStream(); // 由数组创建流 Integer[] nums = new Integer[8]; Stream stream3 = Arrays.stream(nums); // 由值创建流 Stream stream4 = Stream.of(1,2,3,4,5); // 由函数创建流 , 会不停打印一个随机数 Stream.generate(() -> Math.random()).forEach(System.out::println); Stream.iterate(1, (x) -> x + 1).forEach(System.out::println); // 筛选 ,自定义 List list2 = Arrays.asList(2, 3, 5, 4, 4,4, 1, 8, 10, 9, 7, 6); list2.stream() .filter((e) -> e > 5).forEach(System.out::println); // 筛选 ，去重 list2.stream() .distinct() .forEach(System.out::println); // 切割 ，限定个数 list2.stream().limit(3).forEach(System.out::println); // 返回一个去掉了前 n 个元素的流。若元素不足 n 个，则返回一个空流。 list.stream().skip(3).forEach(System.out::println); // 映射 , 将 参数 经过自定义处理后 再返回 list2.stream() .map(x -> x*x) .forEach(System.out::println); // 特殊的 映射操作 ， 结果一定要是 double类型 list2.stream() .mapToDouble(x -> x+0.1) .forEach(System.out::println); // 特殊的映射 ， 将流中的每个元素映射成一个流 list2.stream() .flatMap( xxx ) .forEach(System.out::println); // 按自然顺序排序 list2.stream() .sorted() .forEach(System.out::println); // 自定义排序 list.stream() .sorted( (x,y) -> -x.compareTo(y) ) .forEach(System.out::println); // 检查是否匹配所有元素 ,(是否全部元素都大于2) boolean allMatch = list2.stream() .allMatch(x -> x > 2); // 匹配元素位置 Optional first = list2.stream() .findFirst(); int val = first.get(); // 求最大值 最小值 Optional first1 = list2.stream() .min(Integer::compareTo); Optional first2 = list2.stream() .max(Integer::compareTo); Integer val1 = first.get(); // 将流中元素收集到List中 List resultList = list2.stream() .collect(Collectors.toList()); // 将流中元素收集到Set中 Set resultSet = list2.stream() .collect(Collectors.toSet()); 日期时间 API 在旧版的 Java 中，日期时间 API 存在很多问题，比如线程安全问题 、命名、设计、分包不合理等问题。 Java 8 提供的日期时间 API都在java.time包下， 这个包涵盖了所有处理日期(date)，时间(time)，日期/时间(datetime)， 时区（zone)，时刻（instant），间隔（duration）与时钟（clock）的操作 // 获取当前日期时间 LocalDateTime now = LocalDateTime.now(); int year = now.getYear(); int month = now.getMonthValue() ; int day = now.getDayOfMonth() ; // 将当前日期时间减去两天 LocalDateTime dateTime2 = now.minusDays(2); // 将当前日期时间加上五天 LocalDateTime dateTime3 = now.plusDays(5); // 构造一个指定日期时间的对象 , 年 月 日 时 分 LocalDateTime dateTime = LocalDateTime.of(2016, 10, 23, 8, 20); // 获取当前时间的时间戳 Instant instant = Instant.now(); // 结果跟System.currentTimeMillis()一样 long milli = instant.toEpochMilli(); // 时区偏移 OffsetDateTime dateTime4 = instant.atOffset(ZoneOffset.ofHours(8)); //时间间隔 LocalTime start = LocalTime.now(); LocalTime end = LocalTime.now(); Duration duration = Duration.between(start, end); // 日期间隔 LocalDate startDate = LocalDate.of(2015, 3, 4); LocalDate endDate = LocalDate.of(2017, 8, 23); Period period = Period.between(startDate, endDate); // 日期格式化 为字符串 ， 内置格式 LocalDate now6 = LocalDate.now(); String strNow = now6.format(DateTimeFormatter.BASIC_ISO_DATE); // 日期格式化 为字符串 ， 自定义格式 String strNow2 = now6.format(DateTimeFormatter.ofPattern(\"yyyy年MM月dd日\")); // 将字符串转换成日期 LocalDate date = LocalDate.parse(strNow2, DateTimeFormatter.ofPattern(\"yyyy年MM月dd日\")); // 目前支持的时区 Set set = ZoneId.getAvailableZoneIds(); //获取当前时区的日期时间 ZonedDateTime now3 = ZonedDateTime.now(); //获取美国洛杉矶时区的日期时间 ZonedDateTime USANow = ZonedDateTime.now(ZoneId.of(\"America/Los_Angeles\")); 重复注解 在 java8 以前，同一个程序元素前最多只能有一个相同类型的注解； 如果需要在同一个元素前使用多个相同类型的注解，则必须使用注解“容器”。 java8简化了使用的步骤，虽然仍然要定义“容器” 。但是直接使用的就是注解。 // java8 之前的写法 @Retention(RetentionPolicy.RUNTIME) public @interface Authority { String role(); } @Retention(RetentionPolicy.RUNTIME) public @interface Authorities { Authority[] value(); } @Authorities({@Authority(role = \"Admin\"), @Authority(role = \"Manager\")}) private void test( ) { ... } // java8 及之后的写法 @Retention(RetentionPolicy.RUNTIME) @Repeatable(Authorities.class) public @interface Authority { String role(); } @Retention(RetentionPolicy.RUNTIME) public @interface Authorities { Authority[] value(); } @Authority( role = \"Admin\" ) @Authority( role = \"Manager\" ) private void test( ) { ... } 无版权 可以无限制使用！ all right reserved，powered by Gitbook该文件更新时间： 2018-12-07 17:21:03 "},"chinese/java基础/心跳机制.html":{"url":"chinese/java基础/心跳机制.html","title":"心跳机制","keywords":"","body":"心跳机制 心跳包机制、延迟发送任务 public abstract class HeartBeatTask implements Runnable { private String taskName ; public HeartBeatTask( ){ taskName = \"beatTask_\"+System.nanoTime() ; } public String getTaskName() { return taskName; } } /** * 优点除了线程池的特性以外，可以实现循环或延迟任务 */ public class WkHeartBeatTool { private ScheduledExecutorService mScheduledExecutorService; private HashMap map ; public WkHeartBeatTool() { initTool(); } /** * 获取 任务总数 */ public int getTaskNum(){ return map==null? 0 : map.size() ; } /** * 初始化 */ private void initTool() { /// 线程池大小 5 mScheduledExecutorService = Executors.newScheduledThreadPool(5); map = new HashMap() ; } /** * 开始一个心跳 任务. TimeUnit.MILLISECONDS , */ public void startTheBeatAction(HeartBeatTask task , int period){ if(map.containsKey(task.getTaskName())){ System.out.println(\"心跳正在进行，无需重复添加\"); return ; } Future future = mScheduledExecutorService.scheduleAtFixedRate( task , 0, period, TimeUnit.MILLISECONDS); map.put(task.getTaskName() , future) ; } /** * 关闭指定的心跳任务 */ public void shutDownTheBeatAction(HeartBeatTask task ){ Future future = map.get(task.getTaskName()) ; // 传入true会中断线程停止任务 if(future!=null){ future.cancel(true) ; map.remove(task.getTaskName()) ; }else{ System.out.println(\"你指定的这个心跳任务已经不存在，无需关闭\"); } } /** * 延时任务 , TimeUnit.MILLISECONDS */ public void startDelayedAction( HeartBeatTask task , int delayTime){ mScheduledExecutorService.schedule( task, delayTime ,TimeUnit.MILLISECONDS ); } /** * 销毁所有变量 */ public void shutDownAll() { if (mScheduledExecutorService != null) { // 强制关闭 mScheduledExecutorService.shutdownNow(); mScheduledExecutorService = null; } map.clear(); map=null ; } } 测试 WkHeartBeatTool heartBeatTool = new WkHeartBeatTool() ; HeartBeatTask task1 = new HeartBeatTask() { public void run() { ...} }; // 开始心跳 heartBeatTool.startTheBeatAction(task1, 1000) ; // 停止心跳 heartBeatTool.shutDownTheBeatAction(task1) ; // 发送延时任务 heartBeatTool.startDelayedAction(task1, 5 * 1000) ; // 获取 心跳任务总数 int sum = heartBeatTool.getTaskNum() ; // 关闭所有任务 并销毁工具 heartBeatTool.shutDownAll() ; 无版权 可以无限制使用！ all right reserved，powered by Gitbook该文件更新时间： 2018-12-07 17:21:03 "},"chinese/android基础/android相关概念.html":{"url":"chinese/android基础/android相关概念.html","title":"android基础","keywords":"","body":"自定义View的意义 1、实现基础控件无法做到的效果 2、代码封装后实现代码代码复用、解耦。 Android自定义View类型 1、组合控件 将基础控件(TextView、ProgressBar等)组合而成，比如下拉刷新控件等。 难点在于程序的逻辑处理。 2、完全自定义控件 继承 View、ViewGroup 等顶级控件或 SurfaceView 特定控件 。 难点在于程序的设计、事件传递处理、效率优化。 双缓冲 两个线程配合完成某一项工作，一个线程做A部分（例如绘制UI），另一个线程做B事情（例如读取资源，计算数据）。 常见的例子： 1、TCP数据传输， 数据的收发速度不一致可能导致数据的丢失。数据线发送到缓冲区中，然后从缓冲区中取走。有效地防止了数据的丢失。 2、复杂图像绘制过程中。 线程A将一帧的计算结果放在缓冲区中，线程中绘制完当前帧后就去缓冲区中取下一帧完整的绘制资源。 这样就可以避免画面闪烁结果。 很多图形的操作都很复杂需要大量的计算，很难访问一次显示缓冲区就能写入待显示的完整图形数据，通常需要多次访问显示缓冲区，每次访问时写入最新计算的图形数据。而这样造成的后果是一个需要复杂计算的图形，你看到的效果可能是一部分一部分地显示出来的，造成很大的闪烁不连贯。 throw new RuntimeException(\"Stub!\"); 代表没找到对应的android。下载对应版本的源码就可查看。 android内部API 有些类可以在源码中调用，但是在Androidstudio中找不到，是因为这是 内部API 不允许用户调用。 例如 com.android.internal.policy; 注意关键字“internal” 。 其中 PhoneWindow 就是一个私有API . 硬件加速 硬件加速使用GPU进行View上的绘制操作。 硬件加速可以在一下四个级别开启或关闭： Application ： 关、开 Activity： 关、开 Window： 开 View： 关 并非所有的2D绘图操作支持硬件加速。所以硬件加速的开关分为四个层次。 以下是已知不支持硬件加速的绘图操作(需要最新的请查阅官网) 支持硬件加速情况 Canvas 第一次支持 Paint 第一次支持 drawBitmapMesh() (colors array) 18 setAntiAlias() (for text) 18 drawPicture() 23 setAntiAlias() (for lines) 16 drawPosText() 16 setFilterBitmap() 17 drawTextOnPath() 16 setLinearText() ✗ drawVertices() ✗ setMaskFilter() ✗ setDrawFilter() 16 setPathEffect() (for lines) ✗ clipPath() 18 setRasterizer() ✗ clipRegion() 18 setShadowLayer() (other than text) ✗ clipRect(Region.Op.XOR) 18 setStrokeCap() (for lines) 18 clipRect(Region.Op.Difference) 18 setStrokeCap() (for points) 19 clipRect(Region.Op.ReverseDifference) 18 setSubpixelText() ✗ clipRect() with rotation/perspective 18 Xfermode 第一次支持 Shader 第一次支持 PorterDuff.Mode.DARKEN (framebuffer) ✗ ComposeShader inside ComposeShader ✗ PorterDuff.Mode.LIGHTEN (framebuffer) ✗ Same type shaders inside ComposeShader ✗ PorterDuff.Mode.OVERLAY (framebuffer) ✗ Local matrix on ComposeShader 18 Drawing operation to be scaled 第一次支持 drawText() 18 drawPosText() ✗ drawTextOnPath() ✗ Simple Shapes* 17 Complex Shapes* ✗ drawPath() ✗ Shadow layer ✗ 无版权 可以无限制使用！ all right reserved，powered by Gitbook该文件更新时间： 2018-12-07 17:21:03 "},"chinese/android基础/权限配置.html":{"url":"chinese/android基础/权限配置.html","title":"权限配置","keywords":"","body":"权限配置 动态权限申请第三方辅助工具 一般权限 这类权限一般不涉及用户隐私，是不需要用户进行授权的，比如手机震动、访问网络等 危险权限 1、需要用户授权。必须在Manifest中申明，否则申请时不提示用户，直接回调开发者权限会被拒绝。 2、同一个权限组的任何一个权限被授权了，这个权限组的其他权限也自动被授权。 3、申请某一个权限的时候系统弹出的Dialog是对整个权限组的说明，而不是单个权限。 4、Android 6.0开始需要动态权限申请 危险权限 含义 READ_CALENDAR WRITE_CALENDAR 日历 CAMERA 相机 READ_CONTACTS WRITE_CONTACTS GET_ACCOUNTS 联系人 ACCESS_FINE_LOCATION ACCESS_COARSE_LOCATION 位置 RECORD_AUDIO 麦克风 READ_PHONE_STATE CALL_PHONE READ_CALL_LOG WRITE_CALL_LOG ADD_VOICEMAIL USE_SIP PROCESS_OUTGOING_CALLS 手机 BODY_SENSORS 传感器 SEND_SMS RECEIVE_SMS READ_SMS RECEIVE_WAP_PUSH RECEIVE_MMS 短信 READ_EXTERNAL_STORAGE WRITE_EXTERNAL_STORAGE 存储 正常权限 含义 ACCESS_LOCATION_EXTRA_COMMANDS 访问额外的位置提供命令 ACCESS_NETWORK_STATE 访问有关GSM网络信息 ACCESS_NOTIFICATION_POLICY ？ ACCESS_WIFI_STATE 访问Wi-Fi网络状态信息 BLUETOOTH 连接到已配对的蓝牙设备 BLUETOOTH_ADMIN 允许程序发现和配对蓝牙设备 BROADCAST_STICKY 允许一个程序广播常用intents CHANGE_NETWORK_STATE 允许程序改变网络连接状态 CHANGE_WIFI_MULTICAST_STATE ？ CHANGE_WIFI_STATE 允许程序改变Wi-Fi连接状态 DISABLE_KEYGUARD 允许程序禁用键盘锁 EXPAND_STATUS_BAR 允许一个程序扩展收缩在状态栏 GET_PACKAGE_SIZE 允许一个程序获取任何package占用空间容量 INSTALL_SHORTCUT ？ INTERNET 允许程序打开网络套接字 KILL_BACKGROUND_PROCESSES ？ MODIFY_AUDIO_SETTINGS 　允许程序修改全局音频设置 NFC ？ READ_SYNC_SETTINGS 允许程序读取同步设置 READ_SYNC_STATS 　允许程序读取同步状态 RECEIVE_BOOT_COMPLETED 允许程序接收到 REORDER_TASKS 允许程序改变Z轴排列任务 REQUEST_INSTALL_PACKAGES ？ SET_ALARM ？ SET_TIME_ZONE 允许程序设置时间区域 SET_WALLPAPER 允许程序设置壁纸 SET_WALLPAPER_HINTS 允许程序设置壁纸hits TRANSMIT_IR ？ UNINSTALL_SHORTCUT ？ USE_FINGERPRINT ？ VIBRATE 允许访问振动设备 WAKE_LOCK ？ WRITE_SYNC_SETTINGS 允许程序写入同步设置 常用权限配置 无版权 可以无限制使用！ all right reserved，powered by Gitbook该文件更新时间： 2018-12-07 17:21:03 "},"chinese/android基础/android坐标体系.html":{"url":"chinese/android基础/android坐标体系.html","title":"android坐标体系","keywords":"","body":"屏幕坐标系 在Android系统中，屏幕的左上角是坐标系统的原点（0,0）坐标。 原点向右延伸是X轴正方向，原点向下延伸是Y轴正方向。       View坐标系 View坐标系以父视图的左上角为坐标原点。 getTop(); //获取子View左上角距父View顶部的距离 getLeft(); //获取子View左上角距父View左侧的距离 getBottom(); //获取子View右下角距父View顶部的距离 getRight(); //获取子View右下角距父View左侧的距离       //触摸点相对于其所在视图坐标的坐标 event.getX(); event.getY(); //触摸点相对于屏幕的坐标 event.getRawX(); event.getRawY(); 无版权 可以无限制使用！ all right reserved，powered by Gitbook该文件更新时间： 2018-12-07 17:21:03 "},"chinese/android基础/view的加载流程-原理.html":{"url":"chinese/android基础/view的加载流程-原理.html","title":"view的加载流程-原理","keywords":"","body":"Activity.java Activity是通过Window间接的操纵View实例。      Window.java、PhoneWindow.java Window是抽象类。PhoneWindow是Window的唯一实现类， 主要是为View提供展示策略，比如标题栏，默认背景颜色等。      DecorView.java 继承自FramentLayout 。 DecorView为整个Window界面的最顶层View。 用 Hierarchy Viewer这个工具查看DecorView的布局，发现继承自Activity和AppCompatActivity后的结构是不一样的。如果选用的主题不一样，结构也会不一样。具体结构请自行用工具查看分析。 但是我们自己添加的布局一般都是加载到 id/content的ViewGroup中去了。      ViewRootImpl.java 作为DecorView和WindowManager之间的桥梁。      WindowManager.java 管理Window。      WindowManagerService.java android的窗口管理服务      Activity、Window、DecorView的关系 Activity中包含一个Window ,Window中包含一个DecorView . MainActivity.this.getWindow() .getDecorView();      setContentView()后的加载流程 一路追踪源码，发现用户的view是被添加到mContentParent中。 ViewGroup mContentParent = generateLayout(mDecor); ViewGroup contentParent = (ViewGroup)findViewById(ID_ANDROID_CONTENT); public static final int ID_ANDROID_CONTENT = com.android.internal.R.id.content; 无版权 可以无限制使用！ all right reserved，powered by Gitbook该文件更新时间： 2018-12-07 17:21:03 "},"chinese/android基础/事件分发机制.html":{"url":"chinese/android基础/事件分发机制.html","title":"事件分发机制","keywords":"","body":"View不存在分发，所以也没有拦截方法onInterceptTouchEvent( )，它只能在onTouchEvent方法中进行处理消费或者不消费。 事件分发概念是针对ViewGroup而言的。 一个事件包括三个部分： ACTION_DOWN 、ACTION_MOVE、ACTION_UP 。 如果事件被拦截了导致 ACTION_DOWN都没能接收到，后面两个步骤肯定是没有的。 一个事件会被 分发、拦截、响应 。 return true： 事件已被我当处理了，无需传递。 return false ：我对事件不感兴趣，继续传下去。 事件在哪些对象之间进行传递？ 答：Activity、ViewGroup、View Touch事件的传递顺序为 Activity–>外层ViewGroup–>内层ViewGroup–>View Touch事件的消费顺序为 View–>内层ViewGroup–>外层ViewGroup–>Activity 在Touch事件的传递过程中，如果上一级拦截了Touch那么其下一级就无法在收到Touch事件。 在Touch事件的消费过程中，如果下一级消费Touch事件那么其上一级就无法处理Touch事件。 事件传递情景： 1、默认情况 即不对控件里的方法进行重写或更改返回值 。 2、处理事件 3、拦截DOWN事件 4、拦截后续事件（MOVE、UP） 无版权 可以无限制使用！ all right reserved，powered by Gitbook该文件更新时间： 2018-12-07 17:21:03 "},"chinese/android基础/自定义View相关的类-方法-工具.html":{"url":"chinese/android基础/自定义View相关的类-方法-工具.html","title":"自定义View相关的类-方法-工具","keywords":"","body":"View UI在主线程中绘制. SurfaceView 继承自View，UI在一个子线程中进行绘制。 onMeasure() 测量View与Child View的大小 layout() 确定View自己的位置. onLayout() 确定Child View的位置 onSizeChanged() View的大小不仅由View本身控制，而且受父控件的影响，所以我们在确定View大小的时候最好使用系统提供的onSizeChanged回调函数。 onDraw() 绘制View自己 dispatchDraw() 绘制 子View onTouchEvent() 处理屏幕触摸事件 invalidate() 调用onDraw方法，重绘View中变化的部分 dispatchDraw MeasureSpec android使用MeasureSpec这类通过一个int数值计算“模式”和“大小”，前2位表示“大小的模式” ，后30bit表示 “尺寸大小” //MeasureSpec 源码 public static int getSize(int measureSpec) { return (measureSpec & ~MODE_MASK); } public static int getMode(int measureSpec) { return (measureSpec & MODE_MASK); } //父容器已经检测出子View所需要的精确大小。在该模式下，View的测量大小即为SpecSize。 MeasureSpec.EXACTLY ; //父容器未能检测出子View所需要的精确大小，但是指定了一个可用大小即specSize //在该模式下，View的测量大小不能超过SpecSize。 MeasureSpec.UNSPECIFIED; //父容器不对子View的大小做限制.用得少。 MeasureSpec.AT_MOST; dispatchTouchEvent() 当点击事件能够传递给当前View时，该方法就会被调用。 一个View接收到Touch，那么该Touch事件首先会传入到它的dispatchTouchEvent( )。 onInterceptTouchEvent() 事件拦截。当一个ViewGroup在接到MotionEvent事件序列时候，首先会调用此方法判断是否需要拦截。 ViewGroup特有的方法，View并没有。 onTouch() performClick( ) 这个方法会去调用onClick( )方法。所以在代码中调用performClick 来达到模拟人工点击的效果。 # # # # Configuration 获取 输入模式，屏幕大小， 屏幕方向等 ViewConfiguration 提供了一些标准常量，比如尺寸大小，滑动距离，敏感度等 GestureDetector Android系统提供的手势监听类。可以简化许多操作。 VelocityTracker 用于跟踪触摸屏事件的速率。 Scroller 滑动、滚动工具类 。 ViewDragHelper 它提供了一系列用于处理用户拖拽子View的辅助方法和与其相关的状态记录。实现手指拖动其内部的某个View。 无版权 可以无限制使用！ all right reserved，powered by Gitbook该文件更新时间： 2018-12-07 17:21:03 "},"chinese/android基础/view自定义属性.html":{"url":"chinese/android基础/view自定义属性.html","title":"view自定义属性","keywords":"","body":"view自定义属性 无版权 可以无限制使用！ all right reserved，powered by Gitbook该文件更新时间： 2018-12-07 17:21:03 "},"chinese/android基础/LayoutInflater.html":{"url":"chinese/android基础/LayoutInflater.html","title":"LayoutInflater","keywords":"","body":"LayoutInflater 它的作用类似于 findViewById(),不同点是LayoutInflater是用来找layout下xml布局文件，并且实例化！而findViewById()是找具体xml下的具体 widget控件。 LayoutInflater inflater1 = activity.getLayoutInflater(); LayoutInflater inflater2 = LayoutInflater.from(this); LayoutInflater inflater3 = (LayoutInflater)activity.getSystemService(LAYOUT_INFLATER_SERVICE); // XmlPullParser parser, ViewGroup root, boolean attachToRoot // 参数意义：parser :R.layout.abc , root :root布局 attachToRoot :是否加到root布局中 View itemView=inflater1.inflate(R.layout.abc, null); 注意： 通过 inflate 获得的view 是获取到的长宽都是为0 。 // itemView.getWidth() 、itemView.getHeight() 都会为0 为了能获得长宽，我目前采用的是如下方式 ： 将这个布局放到启动页下 ，通过 findViewById 的方式获取到后 保存起来给其他用 。 无版权 可以无限制使用！ all right reserved，powered by Gitbook该文件更新时间： 2018-12-07 17:21:03 "},"chinese/android基础/进程通信.html":{"url":"chinese/android基础/进程通信.html","title":"进程通信","keywords":"","body":"进程通信 、 多进程通信 、 进程间通信 多进程的使用场景 1、将核心模块跑在一个进程中， 降低被系统kill的概率。 2、android系统的内存限制是针对进程的，多开几个进程 可以获得更多的内存。 3、模块化开发，子进程中崩溃并不会导致主进程崩溃。提高程序的健壮性 。 4、需要调用其他应用提供的数据。 相关术语 RPC Remote Procedure Call Protocol， 远程过程调用协议 。 IPC inter process communication ，多进程通信的过程。 oom_adj 对于每一类别的进程会有其oom_adj值的取值范围。在系统执行低杀操作时，会从oom_adj值越高的开始杀。 AIDL 和binder的关系 Binder是一种架构(定义了一种通信机制)，这种架构提供了服务端接口、Binder驱动、客户端接口三个模块。 Binder使用Client-Server通信方式，安全性好，简单高效，再加上其面向对象的设计思想，独特的接收缓存管理和线程池管理方式，成为Android进程间通信的中流砥柱。 ？？？？？？ Binder ~public class Binder implements IBinder 。~ 一种用来实现进程间通信的架构。 Binder不是Android提出来的一套新的进程间通信机制，它是基于OpenBinder实现的。       进程级别 1、 前台进程 2、可见进程 3、服务进程 4、后台进程 5、空进程 进程间通信的注意点 1、jvm不同，内存空间独立。 会导致一些常规的特效失效。 2、传递的信息要么是 基本数据类型 ，要么就必须能被序列化 。 android 进程间通信方案 1、 Intent + Bundle 同一个app中的 不同进程 单向通信 。 一般用于四大组件中。 2、socket socket都可以实现网络通信，那么实现跨进程通信自然是ok的。开销大。 3、通过文件 不同的进程通过对同一个文件进行读写来实现信息交互。 4、ContentProvider 基于 Binder的 ContentProvider 可以让 一个应用向其他应用暴露接口，提供数据。 5、BroadcastReceiver 通过广播播放实现单方面通知。 6、android.os.Messenger 基于AIDL。串行通信。 一个 server 运行在一个 apk 中 ， 另一个apk 绑定服务，发送和接收信息。 7、AIDL 支持并发 交互。 当作为客户的一方和要和作为服务器的一方进行通信时，需要指定一些双方都认可的接口， 这样才能顺利地进行通信。 而AIDL就是定义这些接口的一种工具。为什么要借助AIDL来定义，而不直接编写接口呢（比如直接通过Java定义一个Interface）？ 里涉及到进程间通信（IPC）的问题。和大多数系统一样，在Android平台下,各个进程都占有一块自己独有的内存空间，各个进程在通常情况下只能访问自己的独有的内存空间，而不能对别的进程的内存空间进行访问。 进程之间如果要进行通信，就必须先把需要传递的对象分解成操作系统能够理解的基本类型，并根据你的需要封装跨边界的对象。而要完成这些封装工作，需要写的代码量十分地冗长而枯燥。因此Android提供了AIDL来帮助你完成这些工作。 无版权 可以无限制使用！ all right reserved，powered by Gitbook该文件更新时间： 2018-12-19 11:36:46 "},"chinese/android基础/Binder详解.html":{"url":"chinese/android基础/Binder详解.html","title":"Binder详解","keywords":"","body":"Binder详解 从英文字面上意思看， Binder 具有粘结剂的意思，那么它把什么东西粘结在一起呢？在Android系统的Binder机制中，Binder由 Client、Server、Service Manager和Binder驱动组成。Binder就是一种把这四个组件粘合在一起的粘结剂了。 为什么要采用Binder Linux已经有多种跨进程通信方式，Android为何还要采用Binder？ 因为 更高效、更安全。 方式 缺点 优点 数据拷贝次数 共享内存 控制机制复杂 0 Binder 可以建立私有通道、有UID鉴别身份 1 socket 开销大、效率低 2 管道、消息队列 效率低 2 Binder 通信采用 C/S架构。 Binder框架定义了四个角色：Server、Client、ServiceManager 、驱动。 这四个角色的关系和互联网类似：Server是服务器，Client是客户终端，SMgr是域名服务器（DNS），驱动是路由器。 1、BinderDriver 尽管名叫“驱动”实际上和硬件设备没有任何关系，存在于内核空间中。 Android系统已经实现。 2、ServerManager 提供了查询服务和注册服务的功能。 Android系统已经实现。 Service Manager是一个守护进程。 3、BinderClient 调用其他进程中的相关服务。由开发者实现。 4、Binder Server 提供相关的服务。由开发者实现。 关键类、方法 1、Native端： IBinder 、 BBinder 、 BpBinder 、 IPCThread 、 ProcessState、 IInterface 、JavaBBinder jni端： android_util_Binder.cpp 、 2、Java端： IBinder 、 Binder、 BinderProxy （Binder的一个内部类）、 Stub、 Proxy 、ServiceManager（Java源码 被@hide了） 3、Binder Driver 端： binder_proc、 binder_thread、 binder_node 、ioctl（是一个函数） 关键名词 实名Binder 注册了名字的Binder。 Binder实体 Binder实体实际上是binder_node结构体的对象。 Binder引用 每一个Binder引用都是某一个Binder实体的引用。 0号引用 我们可能会发现一个细节：SMgr是一个进程，Server是另一个进程，Server向SMgr注册Binder必然会涉及进程间通信。当前实现的是进程间通信却又要用到进程间通信，这就好象蛋可以孵出鸡前提却是要找只鸡来孵蛋。 Binder的实现比较巧妙：预先创造一只鸡来孵蛋：系统给Smgr创建一个特殊专门的Binder实体。 它没有名字也不需要注册。一个Server若要向SMgr注册自己Binder就必需通过0这个引用号和SMgr的Binder通信。类比网络通信，0号引用就好比域名服务器的地址。 匿名 Binder Server端可以通过已经建立（通过实名Binder实现）的Binder连接将创建的Binder实体传给Client 。由于这个Binder没有向SMgr注册名字，所以是个匿名Binder。 匿名Binder为通信双方建立一条私密通道，只要Server没有把匿名Binder发给别的进程，别的进程就无法通过穷举或猜测等任何方式获得该Binder的引用。 为什么Binder只进行了一次数据拷贝？ mmap()分配的内存除了映射进了接收方进程里，还映射进了内核空间。所以调用copy_from_user()将数据拷贝进内核空间也相当于拷贝进了接收方的用户空间 。 数据从发送方的缓存区拷贝到内核的缓存区，而接收方的缓存区与内核的缓存区被是映射到同一块物理地址的，因此只需要一次拷贝即可。 先把数据拷贝到内核的缓存区，然后再从内核的缓存区拷贝给接收方。这样做会产生两次数据的拷贝。linux中的管道通信就是采取这种方式。 简单理解                   Binder 通信模型、 Binder 架构       Binder 机制 Binder 驱动       Binder 进程与线程       ServiceManager启动       ServiceManager 注册服务       ServiceManager 获取服务       进行一次完整通讯 Binder通信命令字 命令 含义 说明 BINDER_WRITE_READ 该命令向Binder写入或读取数据 常用的命令 BINDER_SET_MAX_THREADS 该命令告知Binder驱动接收方线程池中最大的线程数 - BINDER_SET_CONTEXT_MGR 将当前进程注册为SMgr。 - BINDER_THREAD_EXIT 通知Binder驱动当前线程退出了。 - BINDER_VERSION 获得Binder驱动的版本号 - Binder写操作命令字 命令 含义 说明 BC_TRANSACTION Client向Server发送请求数据 最常用 BC_REPLY Server向Client发送回复数据 最常用 BC_ACQUIRE_RESULT、 BC_ATTEMPT_ACQUIRE 尚未实现 BC_FREE_BUFFER 释放一块映射的内存 BC_INCREFS、BC_ACQUIRE 、BC_RELEASE 、BC_DECREFS 增加或减少Binder的引用计数 BC_INCREFS_DONE 、BC_ACQUIRE_DONE 处理完毕反馈信息 BC_REGISTER_LOOPER 通知驱动线程池中一个线程已经创建了 BC_ENTER_LOOPER 通知驱动该线程已经进入主循环，可以接收数据 BC_EXIT_LOOPER 通知驱动该线程退出主循环，不再接收数据 BC_REQUEST_DEATH_NOTIFICATION 要求驱动在Binder实体销毁得到通知 BC_DEAD_BINDER_DONE 收到销毁通知的进程在删除引用后用本命令告知驱动 Binder读操作命令字 命令 含义 说明 BR_ERROR 发生内部错误 BR_OK 、BR_NOOP 操作完成 BR_SPAWN_LOOPER 向接收方发送该命令要求创建更多线程以备接收数据 BR_TRANSACTION 、BR_REPLY 表示当前接收的数据是请求还是回复 BR_ACQUIRE_RESULT 、BR_ATTEMPT_ACQUIRE 、BR_FINISHED 尚未实现 BR_DEAD_REPLY 交互过程中如果发现对方进程或线程已经死亡则返回该消息 BR_TRANSACTION_COMPLETE 发送数据包后，收到该消息做为成功发送的反馈 BR_INCREFS 、BR_ACQUIRE 、BR_RELEASE 、BR_DECREFS 用于管理强/弱指针的引用计数 BR_DEAD_BINDER 、BR_CLEAR_DEATH_NOTIFICATION_DONE 收到死亡通知书 BR_FAILED_REPLY 如果发送非法引用号则返回该消息 Binder接收/发送数据包的标准格式 成员 含义 说明 union {     size_t handle;void *ptr;} target; 指明发送目的地 void *cookie; 存放的是创建Binder实体时由该接收方自定义的任意数值，做为与Binder指针相关的额外信息存放在驱动中。 unsigned int code; 存放收发双方约定的命令码 unsigned int flags; 与交互相关的标志位 pid_t sender_pid;、uid_t sender_euid; 该成员存放发送方的进程ID和用户ID，由驱动负责填入 size_t data_size; 缓冲区存放的数据长度。 size_t offsets_size; 偏移位置 union { struct { const void buffer; const void offsets; } ptr; uint8_t buf[8]; } data; 放要发送或接收到的数据, 无版权 可以无限制使用！ all right reserved，powered by Gitbook该文件更新时间： 2018-12-07 17:21:03 "},"chinese/android基础/Binder与安卓Service.html":{"url":"chinese/android基础/Binder与安卓Service.html","title":"Binder与安卓Service","keywords":"","body":"Binder与安卓Service Service的意义 1、优先级高，不容易被系统杀死。用来实现需要稳定、长时间运行的模块。(Service的优先级高于后台挂起的Activity， 也高于Activity所创建的Thread) 2、用在一些不适合activity的的场景。例如音乐播放和文件下载等场景 。 注意 Service 是运行在主线程中的， 如果有耗时操作在Service里，就必须开启一个单独的线程来处理 。 Service有两种启动形式： 1、start模式。 一旦启动，Service将一直运行在后台，即便启动Service的组件已被destroy。 //启动服务 Intent intent = new Intent(this, MyNormalService.class); startService(intent); //停止服务 stopService(intent) ; //或在服务类中 调用 stopSelf(); 2、bind模式。 通过绑定方式启动的Service是一个client-server结构。多个组件可与一个service绑定，service不再与任何组件绑定时，该service会被destroy。 //MainActivity.java Intent intent = new Intent(MainActivity.this, MyNormalService.class) ; this.bindService( intent, serviceConnection , BIND_AUTO_CREATE ); this.unbindService(serviceConnection); ServiceConnection serviceConnection = new ServiceConnection() { @Override public void onServiceConnected(ComponentName name, IBinder service) { MyNormalService.MyBinder myBinder = (MyNormalService.MyBinder) service ; //调用自定义Binder中的方法 myBinder.func1(); } @Override public void onServiceDisconnected(ComponentName name) { } } ; //MyNormalService.java @Override public IBinder onBind(Intent intent) { return new MyBinder(); } class MyBinder extends Binder { public void func1() { ... } } //bindService( , ,)第三个参数 flags 值 含义 BIND_AUTO_CREATE 1 ? BIND_DEBUG_UNBIND 2 ? BIND_NOT_FOREGROUND 4 ? BIND_ABOVE_CLIENT 8 ? BIND_WAIVE_PRIORITY 32 ? - 0 若不打算指定模式，可传入0 3、bindService + startService 两种模式混合使用 。 暂时还没用过。 前台服务、后台服务 1、前台服务 前台服务必须给状态栏提供一个通知 。 系统内存不足的时候不允许系统杀死的服务。 // 参数一：唯一的通知标识；参数二：通知消息。 startForeground(12345, notification);// 开始前台服务 stopForeground(true);// 停止前台服务--参数：表示是否移除之前的通知       public class MyNormalService extends Service { @Override public void onCreate() { super.onCreate(); } /** * 通过start方式启动 时回调的方法 */ @Override public IBinder onBind(Intent intent) { return null; } /** * 通过bind方式启动 回调的方法 */ @Override public int onStartCommand(Intent intent, int flags, int startId) { //return super.onStartCommand(intent, flags, startId); //START_STICKY、START_REDELIVER_INTENT return START_NOT_STICKY ; } @Override public void onDestroy() { super.onDestroy(); } } public class MyIntentService extends IntentService { public MyIntentService(String name) { super(name); } @Override protected void onHandleIntent(@Nullable Intent intent) { //耗时操作 } }       同一个进程中Activity与service通信方案 1、借助 EventBus 等第三方框架 。 2、 binder + 回调(listener)。 不同进程间Activity与service通信 ？？？ 进程重启、进程保活 ？？？ IntentService 1、public abstract class IntentService extends Service.. 2、HandlerThread thread = new HandlerThread(\"IntentService[\" + mName + \"]\").. 3、mServiceHandler = new ServiceHandler(mServiceLooper).. 1、内部已经采用了独立的子线程处理问题。 无需手动开启子线程。 2、内部采用队列处理问题。 不用考虑多线程并发问题。 3、任务结束后会自动停止。无需手动调用停止代码。 解决Service内存泄漏问题。       PendingIntent       onStartCommand()的返回值 命令 含义 START_NOT_STICKY 若执行完onStartCommand()方法后，系统就kill了service，不要再重新创建service，除非系统回传了一个pending intent。 START_STICKY 若系统在onStartCommand()执行并返回后kill了service，那么service会被recreate并回调onStartCommand() START_REDELIVER_INTENT 若系统在onStartCommand()执行并返回后kill了service，那么service会被recreate并回调onStartCommand()并将最后一个Intent回传至该方法。 无版权 可以无限制使用！ all right reserved，powered by Gitbook该文件更新时间： 2018-12-07 17:21:03 "},"chinese/android基础/AIDL详解.html":{"url":"chinese/android基础/AIDL详解.html","title":"AIDL详解","keywords":"","body":"AIDL Android Interface definition language ，是一种android内部进程通信接口的描述语言。用来定义进程间的通信接口。 AIDL 支持的数据类型 1、Java 的基本数据类型 2、List 和 Map 元素必须是 AIDL 支持的数据类型 Server 端具体的类里则必须是 ArrayList 或者 HashMap 3、其他 AIDL 生成的接口 4、实现 Parcelable 的实体 无版权 可以无限制使用！ all right reserved，powered by Gitbook该文件更新时间： 2018-12-19 11:39:31 "},"chinese/android基础/Handler详解.html":{"url":"chinese/android基础/Handler详解.html","title":"Handle详解","keywords":"","body":"Handle详解 Handle、Looper 、Message、MessageQueue 1、Message 定义了消息必要的描述和属性数据。 public final class Message implements Parcelable { //用来标识一个消息.区分来源 public int what; //简单消息 public int arg1; public int arg2; //任意类型数据 public Object obj; public Messenger replyTo; //存储复杂点的对象 Bundle data; //发送和处理消息关联的 Handler Handler target; //消息的回调 Runnable callback; ...... } //不推荐 Message msg = new Message(); msg.what =100; //推荐 msg= Message.obtain(); //有多个方法重载 msg= Message.obtain(Handler h, int what) //推荐 msg= handler.obtainMessage(); msg= handler.obtainMessage(int what); 2、MessageQueue 消息队列 ,提供入队、出队等功能 。系统只会自动给主线程建立MessageQueue。 boolean enqueueMessage(Message msg, long when) Message next() 3、 Handle 负责Message 的发送和执行处理等。 handler.post(Runnable r) ; handler.postAtFrontOfQueue(Runnable r); handler.postDelayed(Runnable r, long delayMillis); handler.sendEmptyMessage(int what); //往队列里添加一条信息 handler.sendMessage(Message msg); handler.sendMessageDelayed(Message msg, long delayMillis); //接收Msg (重写当前方法，处理接收的值) handler.handleMessage(Message msg); //分发消息，可以做拦截操作 handler.dispatchMessage(Message msg); public void dispatchMessage(Message msg) { //Runnable getCallback() if (msg.callback != null) { handleCallback(msg); } else { if (mCallback != null) { if (mCallback.handleMessage(msg)) { return; } } // handleMessage(msg); } } //在子线程中调用post() //handler是在主线程中创建的 handler.post(new Runnable() { @Override public void run() { //此种写法是匿名内部类，简化代码书写 //为什么此处可以更新UI？ //因为跟踪源码发现，最后会跟sendMessage()一样调用enqueueMessage()从而进入队列 } }); 在子线程中调用post(Runnable r) handler.post(new Runnable() { @Override public void run() { //为什么此处可以更新UI？ //因为 1 、在 UI线程中创建并发送的+ 2、回调机制 + // 3、跟踪源码发现，最后会跟sendMessage()一样调用enqueueMessage()从而进入队列 } }); 4、Looper 主线程中的Looper生命周期和当前应用一样长。 一个MessageQueue 对应一个Looper。 //线程中默认没有 Looper，调用 Looper.prepare() 方法为当前线程创建一个 Looper Looper.prepare(); private static void prepare(boolean quitAllowed) { if (sThreadLocal.get() != null) { //确保一个线程中只有一个Looper对象 throw new RuntimeException(\"Only one Looper may be created per thread\"); } sThreadLocal.set(new Looper(quitAllowed)); } //调用 loop() 方法调度消息。 Looper.loop(); public static void loop() { final Looper me = myLooper(); if (me == null) { throw new RuntimeException(\"No Looper; Looper.prepare() wasn't called on this thread.\"); } final MessageQueue queue = me.mQueue; //无限循环 for (;;) { //取出一条消息，如果没有消息则阻塞。 Message msg = queue.next(); //... try { //将消息进行分发 处理 msg.target.dispatchMessage(msg); } finally { } //... } } 当前线程如何和Looper关联的 public class ThreadLocal {... private static void prepare(boolean quitAllowed) { .... //ThreadLocal.set()将新创建的对象的引用保存到各线程的自己的一个map中. sThreadLocal.set(new Looper(quitAllowed)); } public static @Nullable Looper myLooper() { //执行ThreadLocal.get()时，各线程从自己的map中取出放进去的对象， //因此取出来的是各自自己线程中的对象 return sThreadLocal.get(); } 判断是否是主线程 public static boolean isMainThread() { boolean resul = Looper.myLooper() == Looper.getMainLooper(); return resul ; }// public static @Nullable Looper myLooper() { return sThreadLocal.get(); } public static Looper getMainLooper() { synchronized (Looper.class) { return sMainLooper; } } Android如何保证一个线程最多只能有一个Looper？ private static void prepare(boolean quitAllowed) { if (sThreadLocal.get() != null) { //确保一个线程中只有一个Looper对象 throw new RuntimeException(\"Only one Looper may be created per thread\"); } sThreadLocal.set(new Looper(quitAllowed)); } 主线程中的Looper.loop()一直无限循环为什么不会造成ANR？ ActivityThread.java （被打了@hide标记） 的main方法，是整个应用进程的入口。 只是传递、分发消息而已，不会耗时多少，当然不会ANR. public static void main(String[] args) { ... //为主线程创建了 Looper Looper.prepareMainLooper(); if (false) { Looper.myLooper().setMessageLogging(new LogPrinter(Log.DEBUG, \"ActivityThread\")); } //进入消息循环 loop()里面有死循环。 for (;;) Looper.loop(); ... } public void handleMessage(Message msg) { switch (msg.what) { case LAUNCH_ACTIVITY: break; case RELAUNCH_ACTIVITY: break; case PAUSE_ACTIVITY: break; ... } }       子线程与子线程通信、 主线程往子线程发送信息 1、全局变量方式。 2、使用 EventBus 等第三方框架 的总线方式 。 3、使用 Android handler机制 。 //接收的一端（A线程）： Looper.prepare(); new Handler() , 重写 handleMessage() 接收 Looper.loop(); //发送的一端（B线程）： 持有A线程的handler，直接发送就OK。       HandlerThread public class HandlerThread extends Thread.. HandlerThread 是一个内部实现了 Looper循环的线程 。 具有以下特点： 当有耗时任务投放到该循环线程中时，线程执行耗时任务，执行完之后循环线程处于等待状态，直到下一个新的耗时任务被投放进来。 减少不停地新建、销毁线程带来的资源消耗。 （我目前还没用过这个东西，遇到此种需求我用线程池解决。） 无版权 可以无限制使用！ all right reserved，powered by Gitbook该文件更新时间： 2018-12-07 17:21:03 "},"chinese/android基础/Fragment详解.html":{"url":"chinese/android基础/Fragment详解.html","title":"Fragment详解","keywords":"","body":"Fragment详解 一个Fragment总是嵌入到一个Activity，是一个模块化的View，它的生命周期受它所嵌入的Activity生命周期的的影响。可以动态的添加、替换、移除某个Fragment。 fragment的优势 同样的界面 ， fragment 比activity 占用内存更少 ，响应速度更快 。 Fragment生命周期 activity与fragment生命周期的关系 与activity相同的生命周期函数 onCreate 、onStart 、onResume、onPause、onStop 、onDestroy 与activity相比多出的生命周期函数 onAttach 、onDetach 、onActivityCreated 、onViewCreated 、onCreateView 、onDestroyView 常用函数 getSupportFragmentManager 获得碎片管理者 getChildFragmentManager 获取自己的FragmentManager对象。 getFragmentManager 获取的是父Fragment(如果没有，则是FragmentActivity)的FragmentManager对象。 getBackStackEntryCount 从管理器中得到Fragment当前已加入Fragment回退栈中的fragment的数量。 无版权 可以无限制使用！ all right reserved，powered by Gitbook该文件更新时间： 2018-12-17 14:45:15 "},"chinese/android基础/Android启动模式.html":{"url":"chinese/android基础/Android启动模式.html","title":"Android启动模式","keywords":"","body":"Android启动模式 多种启动模式的意义 通过使用不同的启动模式，来控制是否生成唯一的activity实例 还是 多个activity实例 。来满足不同的使用场景 。       启动模式类型 模式类型 意义 使用场景 standard 默认模式。每当有一次Intent请求，就会创建一个新的Activity实例 。并且被放到启动它的那个Activity所属的任务栈中。 如果有10个撰写邮件的Intent，就会创建10个activity给不同的人写信。 singleTop 栈顶复用。栈顶有此实例就使用（调用onNewIntent()方法） ，没有就重新创建。(调用onCreate()方法) 当前正在新闻页面A，此时来了关于新闻A的推送消息，点击推送消息，进入新闻页面A singleTask 栈内复用。若栈中已有该Activity的实例，就重用该实例(调用onNewIntent()方法)。并且，会将它所在任务栈之前的所有activity实例移除掉。因此该实例就处于栈顶了。若栈中不存在该实例，将会onCreate()。 用来消除交互界面的嵌套循环 singleInstance 全局唯一。Activity单独占用一个Task栈 。整个系统中是单例的。 还未完全理解使用场景       任务栈 （task stack ） 、 后退栈 （back stack） 1、一个应用程序一被启动系统就给它分配一个任务栈 。 2、android存在多个任务栈，一个应用程序一个任务栈。 3、一个任务栈中存放多个activity（可以来自不同的应用程序）。       如何查看当前系统的任务栈 adb shell dumpsys activity 不同task之间的关系 相互独立的？ 每次启动新的Activity都将被添加到Activity Stack。用户返回就会将当期的activity实例出栈。如果当前栈空了，就会进入 Home screenn 所在的栈 。       指定启动模式 （xml方式） 属性 意义 备注 taskAffinity 指定Activity希望归属的栈 allowTaskReparenting 任务状态是否始终由系统来维护 默认false clearTaskOnLaunch 默认false finishOnTaskLaunch alwaysRetainTaskState 指定启动模式 （代码方式） 优先级大于xml方式。 Intent intent = new Intent( this ,TestActivity.class); intent.addFlags(Intent.FLAG_ACTIVITY_SINGLE_TOP); this.startActivity(intent); 官网flags Intent的Flag标志 意义 备注 FLAG_ACTIVITY_NEW_TASK 默认的跳转类型 FLAG_ACTIVITY_SINGLE_TOP singletop模式 FLAG_ACTIVITY_BROUGHT_TO_FRONT FLAG_ACTIVITY_CLEAR_TOP SingleTask模式 FLAG_ACTIVITY_NO_HISTORY Activity不会保留在栈中 FLAG_ACTIVITY_NO_ANIMATION 不使用过渡动画 FLAG_ACTIVITY_EXCLUDE_FROM_RECENTS 最近应用里面查看不到这个activity的启动记录 FLAG_GRANT_READ_URI_PERMISSION FLAG_GRANT_WRITE_URI_PERMISSION FLAG_FROM_BACKGROUND FLAG_DEBUG_LOG_RESOLUTION FLAG_EXCLUDE_STOPPED_PACKAGES FLAG_INCLUDE_STOPPED_PACKAGES FLAG_GRANT_PERSISTABLE_URI_PERMISSION FLAG_GRANT_PREFIX_URI_PERMISSION FLAG_RECEIVER_REGISTERED_ONLY FLAG_RECEIVER_REPLACE_PENDING FLAG_RECEIVER_FOREGROUND FLAG_RECEIVER_NO_ABORT FLAG_ACTIVITY_FORWARD_RESULT FLAG_ACTIVITY_PREVIOUS_IS_TOP FLAG_ACTIVITY_EXCLUDE_FROM_RECENTS FLAG_RECEIVER_VISIBLE_TO_INSTANT_APPS FLAG_ACTIVITY_LAUNCHED_FROM_HISTORY FLAG_ACTIVITY_NEW_DOCUMENT FLAG_ACTIVITY_NO_USER_ACTION FLAG_ACTIVITY_REORDER_TO_FRONT FLAG_ACTIVITY_CLEAR_TASK FLAG_ACTIVITY_TASK_ON_HOME FLAG_ACTIVITY_RETAIN_IN_RECENTS FLAG_ACTIVITY_LAUNCH_ADJACENT 无版权 可以无限制使用！ all right reserved，powered by Gitbook该文件更新时间： 2018-12-07 17:21:03 "},"chinese/android基础/动画详解.html":{"url":"chinese/android基础/动画详解.html","title":"动画详解","keywords":"","body":"动画详解 Android动画类型 特点 大类 帧动画 Frame Animation 容易OOM 视图动画 补间动画 TweenedAnimation 只能平移、缩放、旋转、透明度。不能拓展效果。 视图动画 属性动画 Property Animation 可以拓展动画效果。可以作用于View和非View对象 属性动画、值动画 一、帧动画 将一个完整的动画拆分成一张张单独的图片，然后再将它们连贯起来进行播放，类似于动画片的工作原理。 二、补间动画 特点 1、XML声明文件存放在res/anim目录； 2、基于Animation和AnimationSet的类结构； 3、效果由四个因素决定：1）初始状态；2）结束状态；3）持续时间；4）Interpolator 劣势： 1、只能够作用在View上 。 2、补间动画机制是使用硬编码的方式来完成的，功能限定死 淡入淡出(透明度)、缩放(大小)、平移(位置)、旋转四种，基本上没有任何扩展性可言。例如不能实现对View的背景色进行动态地改变。 3、它只是改变了View的显示效果而已，而不会真正去改变View的属性。例如 现在屏幕的左上角有一个按钮，补间动画将它移动到了屏幕的右下角，你点击这个按钮，点击事件不会触发，因为实际上这个按钮还是停留在屏幕的左上角，只不过补间动画将这个按钮绘制到了屏幕的右下角而已。（想真正移动某组件，需要在动画结束后添加代码实现。） 三、属性动画（Property Animation） 特点 1、需要Android API level 11 （android3.0）以上使用。 2、XML文件存放在res/animator目录下； 3、基于Animator和AnimatorSet的类结构； 优点： 1、可以对所有的Object对象（View和非View对象）的任意属性进行操作。 2、动画效果不局限于淡入淡出(透明度)、缩放(大小)、平移(位置)、旋转四种效果 3、因为是一种不断地对值进行操作的机制，并将值赋值到指定对象的指定属性上，所以不仅仅是一种视觉上的动画效果了。例如我们通过属性动画来移动一个按钮，那么这个按钮就是真正的移动了，而不再是仅仅在另外一个位置绘制了而已。 Activity 转场动画 overridePendingTransition(...) Fragment 转场动画 fragmentCloseEnterAnimation(...)       帧动画实现原理 顺序播放事先做好的图像，跟电影类似。 Android 补间动画的实现原理 / View 动画 Animation 运行原理解析 参考 1、当调用了 View.startAnimation() 时动画并没有马上就执行，而是通过 invalidate() 层层通知到 ViewRootImpl 发起一次遍历 View 树的请求，而这次请求会等到接收到最近一帧到了的信号时才去发起遍历 View 树绘制操作。（底层 每 16.6ms 发送一个 VSync 信号。详情请参考 屏幕刷新机制 ） 2 、从 DecorView 开始遍历，遍历时会调用到 View 的 draw() 方法，如果有绑定动画，会去调用applyLegacyAnimation()，然后调用 getTransformation() 来根据当前时间计算动画进度，紧接着调用 applyTransformation() 并传入动画进度来应用动画。 3、 applyLegacyAnimation() 会根据 getTransformation() 的返回值来决定是否通知 ViewRootImpl 再发起一次遍历请求，返回值是 true 表示动画没结束，那么就去通知 ViewRootImpl 再次发起一次遍历请求。然后当下一帧到来时，再从 DecorView 开始遍历 View 树绘制，重复上面的步骤，这样直到动画结束。 private void testAnimation(View view) { Animation anim= new RotateAnimation(0.0f,+360.0f); anim.setInterpolator(new AccelerateDecelerateInterpolator()); anim.setDuration(3000); view.startAnimation(anim); } public void startAnimation(Animation animation) { ... invalidate(true); } public void invalidate(boolean invalidateCache) { invalidateInternal(0, 0, mRight - mLeft, mBottom - mTop, invalidateCache, true); } void invalidateInternal(int l, int t, int r, int b, boolean invalidateCache, boolean fullInvalidate) { ... final ViewParent p = mParent; if (p != null && ai != null && l 矢量动画 svg SVG（Scalable Vector Graphics）是Android 5.0中新加入的一个新特性 。 svg文件 使用xml格式定义 。 svg图片可以无限拉伸并不会变形和锯齿。 // svg在安卓上使用稍显复杂 ， 使用 Lottie 库 + AE 导出的json文件 可以更方便快捷地实现同样的效果 。 同时 Lottie 兼容 android 、ios、React Native 、web 。 https://github.com/airbnb/lottie-android 无版权 可以无限制使用！ all right reserved，powered by Gitbook该文件更新时间： 2018-12-07 17:21:03 "},"chinese/android基础/屏幕刷新机制.html":{"url":"chinese/android基础/屏幕刷新机制.html","title":"屏幕刷新机制","keywords":"","body":"屏幕刷新机制 CPU 计算屏幕数据、GPU 进一步处理和缓存、最后 display 再将缓存中（buffer）的屏幕数据显示出来。 屏幕每一帧的画面可以持续 16.6ms，当过了 16.6ms，底层就会发出一个屏幕刷新信号，而屏幕就会去显示下一帧的画面。 当屏幕刷新信号到的时候，屏幕就去将 CPU 计算的屏幕画面数据显示出来；同时 CPU 也接收到屏幕刷新信号，所以也开始去计算下一帧的屏幕画面数据。 在每一次屏幕刷新信号来的时候都会去切换这一帧的画面，这点我们是控制不了的，是底层的工作机制。 当用户不操作了、当前界面也没动画 时 ，CPU没有 下一帧画面数据需要计算，但是底层仍然会以固定的频率来切换每一帧的画面，只是它后面切换的每一帧画面都一样，所以给我们的感觉就是屏幕没刷新。 CPU 绘制视图树来计算下一帧画面数据的工作是在屏幕刷新信号来的时候才开始工作的，而当这个工作处理完毕后，也就是下一帧的画面数据已经全部计算完毕，也不会马上显示到屏幕上，而是会等下一个屏幕刷新信号来的时候再交由底层将计算完毕的屏幕画面数据显示出来。 https://www.jianshu.com/p/0d00cb85fdf3 无版权 可以无限制使用！ all right reserved，powered by Gitbook该文件更新时间： 2018-12-07 17:21:03 "},"chinese/android基础/sdk开发.html":{"url":"chinese/android基础/sdk开发.html","title":"sdk开发","keywords":"","body":"sdk开发 将一些业务逻辑独立出来，打包成jar、so、aar，暴露一些APIs给外部调用，也可以称为SDK。SDK 不同于普通应用,不能频繁的进行更新,以免让开发者觉得 SDK 不稳定或者让开发者频繁的集成 。 1、为了安全起见,数据加密类、模块算法类都都应该采用NDK开发 。 SDK 版本号命名及修改原则 SDK版本号命名和我们以往的命名规则并无太大不同,通由4部分组成,格式为: V主版本号_子版本号_阶段版本号_日期版本号_希腊字母版本号 比如：V1_1_2_161209_beta. 希腊字母版本号说明 1、Alpha版:内部测试版。此版本表示该软件在该阶段主要是以实现功能为主,Bug相对较多,需要继续修改,通常只在内部流通流通而不对外开放。 2、Beta版:外部测试版。该版本相对Alpha已经有了很大的改进,不存在严重的Bug,但还是存在一些缺陷,需要进一步的测试以检查和消除Bug。 3、RC版: 该版本已经相当成熟,不存在导致错误的Bug，与正式版相差无几。 4、Release版:该版本意味着”最终版本”,是最终交付用户或者公开发布的版本,也称为标准版。在发布的时候回以符合R来代替Release单词。 版本号修改规则 1、 主版本号变化:当功能模块有较大的变化或者整体架构发生变化 2、子版本号变化:当功能有一定变化 3、阶段版本号变化:一般是Bug修复或者较小的变动,根据反馈,需要经常发布修订版本. 4、日期版本号(161209):用于记录修改项目的当前日期,每天对项目的修改都要更改日期版本号. 5、希腊字母版本号:此版本号用于标注当前软件处于那个开发阶段,当软件进入到另一个阶段是需要修改. API版本管理 原则上SDK API一旦公开发布后其状态应为不可变。 1、对于特殊情况下API的变更,需要遵守”开闭原则” 2、在需要废除某些方法时,需要在正式版发版前使用 @deprecated 标识。并给出替代方案和开始废弃的 SDK版本号。 SDK二次打包 ????????? theme、icon资源合并 ????????? Application多继承 ?????????       无版权 可以无限制使用！ all right reserved，powered by Gitbook该文件更新时间： 2018-12-07 17:21:03 "},"chinese/android基础/sdk开发-Module支持c++.html":{"url":"chinese/android基础/sdk开发-Module支持c++.html","title":"sdk开发-Module支持c++","keywords":"","body":"sdk开发-Module支持c++ 1、按照正常流程创建一个支持c++的项目。 此时 CMakeLists.txt 文件在 app 这个项目里面。 2、新建一个module ，并添加到app中。 3、将 CMakeLists.txt 剪切到 module对应的 目录下。 4、 同理 ，以下代码也剪切到 module对应的文件中去。 externalNativeBuild { cmake { path \"CMakeLists.txt\" } } externalNativeBuild { cmake { cppFlags \"-std=c++11 -frtti -fexceptions\" } } 5、刷新工程即可。 无版权 可以无限制使用！ all right reserved，powered by Gitbook该文件更新时间： 2018-12-07 17:21:03 "},"chinese/android基础/相机模块.html":{"url":"chinese/android基础/相机模块.html","title":"相机模块","keywords":"","body":"相机模块 从Android 5.0(21)开始， android.hardware.Camera 被废弃 ，启用 android.hardware.Camera2 。 Android相机兼容性问题非常大,如果只是拍照,尽量调用系统相机,如果需要预览和拿视频流, 可以基于某些第三方库开发。 natario1 CameraView     谷歌非官方 cameraview     基于谷歌非官方 cameraview     camerakit-android 参考资料 拍出来的照片旋转了 获取照片的角度值，然后再用矩阵纠正过来。 拍照后闪退 部分机型对自家相机做了优化，会销毁我们的activity。 根据调试情况，在onSaveInstanceState()中保存对应状态即可。 图片无法显示 图片太大导致OOM ，对图片进行压缩即可。 自拍镜像 开启前置摄像头后，预览的画面和拍照后的画面是左右相反的。进行图片翻转即可。 预览画面 贴图 相机 + opengl es 方案。 无版权 可以无限制使用！ all right reserved，powered by Gitbook该文件更新时间： 2018-12-07 17:21:03 "},"chinese/android基础/WebView详解.html":{"url":"chinese/android基础/WebView详解.html","title":"WebView详解","keywords":"","body":"WebView详解 [ Android4.4, +∞) Chromium内核取代了Webkit内核。 [ Android5.0, +∞) WebView移植成了一个独立的apk，可以不依赖系统而独立存在和更新。 [ Android7.0, +∞) 如果用户手机里安装了 Chrome ， 系统优先选择 Chrome 为应用提供 WebView 渲染。 [ Android8.0, +∞) 默认开启WebView多进程模式，即WebView运行在独立的沙盒进程中。 无版权 可以无限制使用！ all right reserved，powered by Gitbook该文件更新时间： 2018-12-07 17:21:03 "},"chinese/android基础/图表绘制.html":{"url":"chinese/android基础/图表绘制.html","title":"图表绘制","keywords":"","body":"图表绘制 MPAndroidChart https://github.com/PhilJay/MPAndroidChart 是 Android 中一个较流行的第三方开源库 。 适用于 Android 2.2 ( API 8 ) 及以上。 本次讲解基于 v3.0.3 版本。 MPAndroidChart 的动画机制只在Android API 11 及以上有效 。 无版权 可以无限制使用！ all right reserved，powered by Gitbook该文件更新时间： 2018-12-07 17:21:03 "},"chinese/android基础/沉浸式.html":{"url":"chinese/android基础/沉浸式.html","title":"沉浸式","keywords":"","body":"沉浸式 Android 至4.4才开始支持沉浸式状态栏 。 所谓的 沉浸式 就是 可以设置手机状态栏的背景 。 实际的效果其实就是透明的状态栏，然后在状态栏的位置显示我们自定义的颜色 或图片 。 这里 有一个比较好用的第三方库 ImmersionBar 无版权 可以无限制使用！ all right reserved，powered by Gitbook该文件更新时间： 2018-12-07 17:21:03 "},"chinese/android基础/svg绘制不规则图形.html":{"url":"chinese/android基础/svg绘制不规则图形.html","title":"svg绘制不规则图形","keywords":"","body":"svg绘制不规则图形 思路一： 参考 https://github.com/zhangjundi/taiwanDemo 1、加载、解析 svg文件（一般为.xml） ，获得 path 数据 2、将path数据转换为 Path 对象。 谷歌官方有现成的工具类 PathParser.java。 3、将解析出来的所有path绘制出来 4、判断点击点是否在当前path范围内。 public boolean isInArea(Path mPath ,float x, float y){ RectF r=new RectF(); mPath.computeBounds(r, true); Region re=new Region(); re.setPath(mPath, new Region((int)r.left,(int)r.top,(int)r.right,(int)r.bottom)); return re.contains((int)x, (int)y); } vector Android 5.0发布的时候，Vector只支持Android 5.0+。 不过自从AppCompat 23.2之后，Google做了兼容处理 ， 只需要引用com.android.support:appcompat-v7:23.2.0以上的版本就 适用于Android 2.1以上的所有系统 。 //SVG（Scalable Vector Graphics ）矢量图 这种图像格式在前端中已经使用的非常广泛了 //Vector (Vector Drawable) 就是Android中的矢量图，可以说Vector就是Android中的SVG实现， 因为Android中的Vector并不是支持全部的SVG语法（也没有必要） vector标签属性 意义 width 图形宽度 height 图形高度 viewportHeight 画布高度 viewportWidth 画布宽度 group 对Path进行分组 path 对应一个Pathname // path名字fillAlpha//填充透明度fillColor //填充颜色strokeColor//线条颜色 pathData //path指令strokeWidth//线条宽度 Android基于vector文件绘制不规则图形的例子 无版权 可以无限制使用！ all right reserved，powered by Gitbook该文件更新时间： 2018-12-07 17:21:03 "},"chinese/andrid进阶/虚拟机对比.html":{"url":"chinese/andrid进阶/虚拟机对比.html","title":"andrid进阶","keywords":"","body":"虚拟机对比 JVM (Java Virtual Machine) 基于栈 。 运行java字节码。 DVM (Dalvik Virtual Machine) 运行自定义的 .dex字节码格式。 Dalvik 基于寄存器的架构， 更适合资源紧张的系统。 ART (Android runtime) Android 4.4 开始加入 ART模式。 ART下，应用在第一次安装的时候，字节码就会预编译成机器码，首次启动会变慢，但是以后每次启动执行的时候，都可以直接运行。（空间换时间） 无版权 可以无限制使用！ all right reserved，powered by Gitbook该文件更新时间： 2018-12-07 17:21:03 "},"chinese/andrid进阶/多渠道打包.html":{"url":"chinese/andrid进阶/多渠道打包.html","title":"多渠道打包","keywords":"","body":"多渠道打包 无版权 可以无限制使用！ all right reserved，powered by Gitbook该文件更新时间： 2018-12-07 17:21:03 "},"chinese/andrid进阶/热补丁动态修复.html":{"url":"chinese/andrid进阶/热补丁动态修复.html","title":"热补丁动态修复","keywords":"","body":"热补丁动态修复 无版权 可以无限制使用！ all right reserved，powered by Gitbook该文件更新时间： 2018-12-07 17:21:03 "},"chinese/andrid进阶/apk瘦身.html":{"url":"chinese/andrid进阶/apk瘦身.html","title":"apk瘦身","keywords":"","body":"apk瘦身 最主要的是 从图片资源 、第三方库 和 .so 方面考虑 。 1、 用lint检查， 删除无用资源 2、 用tinypng等压缩图片。 3、用webp格式图片 4、开启代码混淆 5、删除冗余代码。 无版权 可以无限制使用！ all right reserved，powered by Gitbook该文件更新时间： 2018-12-07 17:21:03 "},"chinese/andrid进阶/性能优化.html":{"url":"chinese/andrid进阶/性能优化.html","title":"性能优化","keywords":"","body":"性能优化 、 APP优化 启动优化 1、Application中对 第三方的SDK进行异步或延时初始化 。 2、做一个闪屏界面。 UI流畅度优化 1、UI的层级别太大 内存优化 1、别频繁GC 2、控制好对象的引用，防止对象一直无法释放。 无版权 可以无限制使用！ all right reserved，powered by Gitbook该文件更新时间： 2018-12-07 17:21:03 "},"chinese/andrid进阶/SDK开发.html":{"url":"chinese/andrid进阶/SDK开发.html","title":"SDK开发","keywords":"","body":"SDK开发 sdk加密方案 方案名字 缺点 优点 代码混淆 1、有些类不能混淆（例如工具类，自定义控件等，如果被混淆了用户就不方便调用），所以对代码架构要求比较高。2、混淆后的代码虽然不易识别了，但是仔细分析还是能看懂的。 修改class的字段 某些字段对运行没有影响，但是能导致别人无法反编译。 自定义类加载器ClassLoader ClassLoader容易被攻破 jvmti 不适用于Android平台？（我暂时还未测试成功） 无版权 可以无限制使用！ all right reserved，powered by Gitbook该文件更新时间： 2018-12-07 17:21:03 "},"chinese/andrid进阶/代码混淆.html":{"url":"chinese/andrid进阶/代码混淆.html","title":"代码混淆","keywords":"","body":"代码混淆 混淆规则 guardsquare androidstudio 使用混淆 // build.gradle 文件下 (这是系统默认生成的，可以修改) 1、导入 xxx\\tools\\proguard\\proguard-android.txt 。 这里面是一些比较常规的不能被混淆的代码规则。 2、导入当前工程里面的 proguard-rules.pro 。这里是一些自定义的混淆规则。 proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.pro' //是否开启混淆 true or false minifyEnabled true 不参与混淆部分 混淆了这些内容，会导致出错。 1、 自定义控件 2、 枚举 3、 第三方库中的类 （作者一般会标明） 4、 运用了反射的类 5、 使用了 Gson 之类的工具的实体类 6、 WebView 的 JS 的接口方法 7、 Parcelable 的子类和 Creator 静态成员变量不混淆 保留整个包 # 保持该包下的类名 (子包下的会被混淆) -keep class cn.wk.test.* # 把本包和所含子包下的类名都保持 -keep class cn.wk.test.** # 保持类名和里面的内容不被混淆 -keep class com.example.bean.** { *; } 自用的 aar 混淆 # 代码混淆压缩比，在0~7之间，默认为5,一般不下需要修改 -optimizationpasses 5 # 混淆时不使用大小写混合，混淆后的类名为小写 -dontusemixedcaseclassnames # 不混淆第三方引用的库 不忽略library里面非public修饰的类 ？？？ -dontskipnonpubliclibraryclasses # 指定不忽略非public类里面的成员和方法 -dontskipnonpubliclibraryclassmembers # 不做预检验， 去掉这一步可以加快混淆速度 -dontpreverify # 把所有信息都输出，而不仅仅是输出出错信息 -verbose #apk 包内所有 class 的内部结构 ?? -dump class_files.txt # 列出了没有被混淆的类和成员 -printseeds seeds.txt #列出从 apk 中删除的代码 -printusage unused.txt #混淆前后的映射 -printmapping mapping.txt # 混淆时所采用的算法 ，后面的参数是一个过滤器 # 这个过滤器是谷歌推荐的算法，一般不改变 -optimizations !code/simplification/artithmetic,!field/*,!class/merging/* #保留Annotation不混淆 -keepattributes *Annotation*,InnerClasses # 避免混淆泛型 -keepattributes Signature # 保留异常 -keepattributes Exceptions # 抛出异常时保留代码行号 -keepattributes SourceFile,LineNumberTable # 不打印指定类的警告信息 -ignorewarnings #==================================【项目配置】================================== # 保留所有的本地native方法不被混淆 -keepclasseswithmembernames class * { native ; } # 保留了继承自Activity、Application (四大组件等)这些类的子类 -keep public class * extends android.app.Activity -keep public class * extends android.app.Application -keep public class * extends android.app.Service -keep public class * extends android.content.BroadcastReceiver -keep public class * extends android.content.ContentProvider -keep public class * extends android.app.backup.BackupAgentHelper -keep public class * extends android.preference.Preference -keep public class * extends android.view.View -keep public class com.android.vending.licensing.ILicensingService -keep public class * extends android.database.sqlite.SQLiteOpenHelper{*;} # 如果有引用android-support-v4.jar包，可以添加下面这行 -keep public class com.null.test.ui.fragment.** {*;} #如果引用了v4或者v7包 -dontwarn android.support.** # 保留Activity中的方法参数是view的方法 -keepclassmembers class * extends android.app.Activity { public void * (android.view.View); } # 枚举类不能被混淆 -keepclassmembers enum * { public static **[] values(); public static ** valueOf(java.lang.String); } # 不混淆反射 -keepattributes EnclosingMethod # 保留自定义控件(继承自View)不能被混淆 -keep public class * extends android.view.View { public (android.content.Context); public (android.content.Context, android.util.AttributeSet); public (android.content.Context, android.util.AttributeSet, int); public void set*(***); *** get* (); } # 保留Parcelable序列化的类不能被混淆 -keep class * implements android.os.Parcelable{ public static final android.os.Parcelable$Creator *; } # 保留Serializable 序列化的类不被混淆 -keepclassmembers class * implements java.io.Serializable { static final long serialVersionUID; private static final java.io.ObjectStreamField[] serialPersistentFields; !static !transient ; private void writeObject(java.io.ObjectOutputStream); private void readObject(java.io.ObjectInputStream); java.lang.Object writeReplace(); java.lang.Object readResolve(); } # 对R文件下的所有类及其方法，都不能被混淆 -keepclassmembers class **.R$* { *; } # 对于带有回调函数onXXEvent的，不能混淆 -keepclassmembers class * { void *(**On*Event); } #==================================【根据自己的项目（自己写的代码），配置需要 忽略混淆的类================================== -keep class org.litepal.** { *; } -keep class com.walkera.wktools.** { *; } #==================================【根据自己的项目（自己引用的第三方jar），配置需要 忽略混淆的类================================== # ant.jar #-libraryjars libs/ant.jar -keep class org.apache.** { *; } # ftp4j.jar #-libraryjars ./libs/ftp4j-1.7.2.jar -keep class it.sauronsoftware.** { *; } # guava.jar #-libraryjars ./libs/guava-17.0.jar -keep class com.google.** { *; } # netty.jar #-libraryjars ./libs/netty-all-4.0.25.Final.jar -keep class io.netty.** { *; } # nineoldandroids.jar #-libraryjars ./libs/nineoldandroids-2.4.0.jar -keep class com.nineoldandroids.** { *; } 无版权 可以无限制使用！ all right reserved，powered by Gitbook该文件更新时间： 2018-12-07 17:21:03 "},"chinese/andrid进阶/Glide图片三级缓存.html":{"url":"chinese/andrid进阶/Glide图片三级缓存.html","title":"Glide图片三级缓存","keywords":"","body":"Glide图片三级缓存 glide地址 Glide 特点 1、Glide.with(xxx)方法 接受 Context、Activity 、 Fragment 。建议使用后面两个。因为图片加载会和Activity 、Fragment的生命周期保持一致。 2、支持加载 gif 格式。    缓存类型 说明 原图 原始图片 处理图 经过压缩和变形等处理后的图片    缓存类型 缓存策略 采用算法 1、内存缓存 缓存处理图 LruCache + 弱引用 2、磁盘缓存 1、只缓存处理图 2、 只缓存原图 3、缓存原图和处理图 4、什么都不缓存 3、网络资源    注： 1、根据项目实际情况 ，可以设置 最大内存缓存空间大小、最大磁盘缓存空间大小、 缓存失效时间 。 LruCache 算法 （Least Recently Used Cache）近期最少使用 。核心思想是当缓存满时，会优先淘汰那些近期最少使用的缓存对象。 Glide 简单使用 RequestOptions requestOptions = new RequestOptions() .placeholder(R.mipmap.icon_us) //.diskCacheStrategy(DiskCacheStrategy.NONE) //.skipMemoryCache(true) // 缓存失效策略 ，key 不一样 缓存就会失效 .apply(RequestOptions.signatureOf(new ObjectKey(getSignatureKey()))) .error(R.mipmap.icon_us); Glide.with(activity) // 根据路径、File 加载 .load(filePath) .apply(requestOptions) .into(userImg); private long getSignatureKey() { ///long key = System.currentTimeMillis() / INVALID_TIME long key = System.currentTimeMillis() ; return key ; } // 当通过get访问接口 ，直接返回图片流的时候。 可以直接加载这个接口也可以显示。 // 不需要 去 加载接口返回的值。 无版权 可以无限制使用！ all right reserved，powered by Gitbook该文件更新时间： 2018-12-07 17:21:03 "},"chinese/andrid进阶/APP的启动流程.html":{"url":"chinese/andrid进阶/APP的启动流程.html","title":"APP的启动流程","keywords":"","body":"APP的启动流程 https://www.jianshu.com/p/a72c5ccbd150 专业名词 作用 zygote进程 在系统发出请求时，负责分裂出其它的进程。 SystemServer进程 android系统里面重要的服务都是在这个进程里面开启的 ActivityManagerService(AMS) 负责系统中所有Activity的生命周期。 Instrumentation 完成对Application和Activity初始化和生命周期的工具类 启动流程 一、创建进程 二、绑定Application 三、显示Activity界面 无版权 可以无限制使用！ all right reserved，powered by Gitbook该文件更新时间： 2018-12-07 17:21:03 "},"chinese/andrid进阶/屏幕适配.html":{"url":"chinese/andrid进阶/屏幕适配.html","title":"屏幕适配","keywords":"","body":"屏幕适配 术语 解释 屏幕尺寸 屏幕的对角线的长度 屏幕分辨率 屏幕的宽和高的像素数 density 屏幕密度，等于dpi/160 。 表示 每英寸有多少个显示点 dpi 像素密度 ， dots per inch px 每一个光点就是一个像素。 dp , dip device independent pixels ， 基于屏幕密度抽象长度单位，在每英寸160点的显示器上，1dp = 1px。 ppi pixels per inch 屏幕尺寸、屏幕分辨率、像素密度的关系 为什么规定160dpi规格的显示器上，1dp = 1px Google的官方文档中给出解释，因为第一款Android设备（HTC的T-Mobile G1）是属于160dpi的。 常用公式 px = density * dp // 例如 density=2时 ，1dp =2px density = dpi / 160 // 例如 dpi=320时 ， density =2 px = (dpi / 160) * dp // 例如 dpi=320时 ， 1dp = 2px 适配思路 因为目前设备的长宽比是不一样的，所以一套设计图在不同的设备上的效果不可能是一模一样的。一般遵循以下原则即可。 1、可以上下滑动的界面，保证宽的纬度与设计图一致 。 2、不支持上下滑动的界面 ，保证高的纬度与设计图一致 。 //为了满足“显示比例和设计的长宽比例一致”，某些地方只能做留白处理。 其他 //以 设计师给定的 图片屏幕尺寸作为标准 ， 返回当前设备下的触摸点坐标 public static int getValues_x(Context context, int value_x) { return (int) ((float) value_x / 720 * MyDeviceInforHelper .getWindowWidth(context)); } 无版权 可以无限制使用！ all right reserved，powered by Gitbook该文件更新时间： 2018-12-07 17:21:03 "},"chinese/自定义控件/分贝波形图.html":{"url":"chinese/自定义控件/分贝波形图.html","title":"andrid自定义控件实例","keywords":"","body":"分贝波形图 /** * 声音波形的view * 波形能左右移动的原理： * 将自定义控件分成 listMaxSize 份，每份对应一个分贝值 ， * 根据分贝值的大小 来决定 线条的高度。 * 分贝值更新引起ui更新，所以会形成从左向右效果。 * mRecDataList.add(dbValue) ; * mRecDataList.remove(0) ; */ public class AudioWaveView extends View { private Bitmap mBackgroundBitmap; private Canvas mBackCanVans = new Canvas(); /**波浪的画笔*/ private Paint mPaint; /**绘制最终画面的 画笔*/ private Paint mViewPaint; private final ArrayList mRecDataList = new ArrayList<>(); private int mScale = 1; /**控件总长度*/ private int viewWidth; /**高度中间线 ，作为基准线*/ private int mBaseLine; /**波形之间线与线的间隔*/ private int smaleLineWidth = 0; /**一共画多少个小线条*/ int listMaxSize = 0 ; /**是否画出基线*/ private boolean mDrawBase = true; private boolean mPause = false; /**1 只画上面的波纹 ，2、上下都画*/ private int mWaveCount = 2; private Context context ; public AudioWaveView(Context context) { super(context); init(context, null); } public AudioWaveView(Context context, AttributeSet attrs) { super(context, attrs); init(context, attrs); } public AudioWaveView(Context context, AttributeSet attrs, int defStyleAttr) { super(context, attrs, defStyleAttr); init(context, attrs); } @Override protected void onDetachedFromWindow() { super.onDetachedFromWindow(); if (mBackgroundBitmap != null && !mBackgroundBitmap.isRecycled()) { mBackgroundBitmap.recycle(); } } public void init(Context context, AttributeSet attrs) { // 防止因为xml可视化失败导致编译错误 if (isInEditMode()){ return; } this.context = context ; mPaint = new Paint(); mPaint.setColor(Color.parseColor(\"#00ff33\")); mViewPaint = new Paint(); } @Override protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) { super.onMeasure(widthMeasureSpec, heightMeasureSpec); creatBackGroundBitmap(); } @Override protected void onVisibilityChanged(@NonNull View changedView, int visibility) { super.onVisibilityChanged(changedView, visibility); if (visibility == VISIBLE && mBackgroundBitmap == null) { creatBackGroundBitmap(); } } private void creatBackGroundBitmap() { ViewTreeObserver vto = getViewTreeObserver(); vto.addOnPreDrawListener(new ViewTreeObserver.OnPreDrawListener() { @Override public boolean onPreDraw() { if (getWidth() > 0 && getHeight() > 0) { smaleLineWidth = WkDeviceInforTool.getPixByDp( context ,2) ; listMaxSize = getWidth() / smaleLineWidth ; viewWidth = getWidth(); mBaseLine = getHeight() / 2; mBackgroundBitmap = Bitmap.createBitmap( getWidth(), getHeight(), Bitmap.Config.ARGB_8888); mBackCanVans.setBitmap(mBackgroundBitmap); mBackCanVans.drawColor(Color.TRANSPARENT, PorterDuff.Mode.CLEAR); ViewTreeObserver vto = getViewTreeObserver(); // 移除绘制回调函数 vto.removeOnPreDrawListener(this); } return true; } }); } private void updateDrawParam(){ ArrayList dataList = new ArrayList<>(); synchronized (mRecDataList) { if (mRecDataList.size() != 0) { try { dataList = (ArrayList) deepCopy(mRecDataList); } catch (Exception e) { e.printStackTrace(); } } } if (!mPause) { // 获得最新缩放参数 updateScale(dataList); if (mBackCanVans != null) { // 清除画布 mBackCanVans.drawColor(Color.TRANSPARENT, PorterDuff.Mode.CLEAR); // 绘制基准线 if (mDrawBase) { mBackCanVans.drawLine(0, mBaseLine, viewWidth, mBaseLine, mPaint); } //绘制小线条形成波浪 int dbSize = dataList.size(); for (int i = 0, j = 0; i list) { int allMax = 0; for (int i = 0; i allMax) { allMax = sh; } } int curScale = allMax / mBaseLine; if (curScale > mScale) { mScale = curScale == 0 ? 1 : curScale ; } } /** * 停止绘制 */ public void stopView( ) { mRecDataList.clear(); mBackCanVans.drawColor(Color.TRANSPARENT, PorterDuff.Mode.CLEAR); } public void updateDataList(int dbValue ){ if(mRecDataList.size() > listMaxSize){ mRecDataList.add(dbValue) ; mRecDataList.remove(0) ; }else{ mRecDataList.add(dbValue) ; } updateDrawParam(); } } 无版权 可以无限制使用！ all right reserved，powered by Gitbook该文件更新时间： 2018-12-07 17:21:03 "},"chinese/其他语言/python.html":{"url":"chinese/其他语言/python.html","title":"其他语言","keywords":"","body":"python 推荐使用 PyCharm 这个IDE进行代码编写。 python 缺点 python的源码不能加密。 python是解释型语言，运行速度比java慢。 python3 数据类型 Python中的变量不需要声明。 1、字符串 2、数字 3、列表 4、元组 5、集合 6、字典 7、日期 if 判断 age = 20 if age > 18: print('aaa') elif age >= 6: print('bbb') else: print('ccc') for 循环 list = [100, 200, 300] for temp in list: print(temp) while 循环 N = 10 x = 0 while x 6: break 列表 # 集合中数据类型可以不一样的 mList = ['Michael', 100, True] print(\"第一个数据=\" + mList[0]) print(\"最后一个数据=\" + str(mList[-1])) print(\"数组大小=\" + str(len(mList))) mList.append('AA') mList.insert(0, 'BB') # 删除最后一个 mList.pop() # 删除指定索引的数据 mList.pop(1) 元组 类似java中的数组 t = ('AA', 1 , True) print (t) 字典 dict = { 'Adam': 95, 'Lisa': \"aaaaaaa\", 'Bart': True } # 根据 key 获得 值 for mkey in dict: print(dict[mkey]) # 获得全部的值 for temp in dict.values(): print(temp) # 取出键值对 for key, value in dict.items(): print(key, ' ，', value) 类、对象 # 继承自 object class Person3(object): # 类属性 address='地球' # 构造方法 def __init__(self, name): # 对象属性 # 公开 self.name = name # 公开 self._sex = '女' #私有 self.__job = '学生'#外部不可以访问 # 类方法 @classmethod def getAddress(self): return self.address # 对象方法 def printInfo(self): print(\"当前对象名字是：\", self.name) # 设置、获取属性 p= Person3('小芳') setattr(p, 'name', 'small dog') msg = getattr(p, 'name') # 对象类型判断 if isinstance(p,object): print('类型判断正确') else: print('类型判断错误') 连接 mysql 安装 pymysql 插件。 如果使用的是pycharm， 是可以指定python环境目录的。方便灵活切换2.x和3.x . import pymysql from poetry.author import Author conn= pymysql.connect( host='114.xx.xx.65', port=3306, user='xx', passwd='xx',db='xx',charset='UTF8') print(\"获得数据库连接:\") print(conn) cursor = conn.cursor() def addAuthor(author): sql = ' insert into poetryauthor( mname, msex , mdesc, mpic,mtime,mtype ) values( \"%s\" ,\"%s\" ,\"%s\" ,\"%s\" ,\"%s\" ,\"%s\" ) '\\ % (author.mname, author.msex, author.mdesc, author.mpic, author.mtime, author.mtype) cursor.execute( sql) newId = int(conn.insert_id()) conn.commit() print(\"插入 新记录的id是: \", newId) def deleteAuthorById( mId): sql = 'delete from poetryauthor where mId = %d '% (mId) count = cursor.execute(sql) conn.commit() print(\"删除结果：\", count) def updateAutorById(author ,mId): sql = 'update poetryauthor set mname=\"%s\", msex=\"%s\", mdesc=\"%s\", mpic=\"%s\", mtime=\"%s\" , mtype=\"%s\" where mId=%d ' \\ % (author.mname, author.msex, author.mdesc, author.mpic, author.mtime, author.mtype, mId) count = cursor.execute(sql) print(\"更新结果：\", count) conn.commit() def queryAuthor(): count=cursor.execute('select * from poetryauthor') print('共有'+str(count)+' 条记录') rows = cursor.fetchall() for row in rows: mid = row[0] mname = row[1] msex = row[2] mdesc = row[3] mpic = row[4] mtime = row[5] mtype = row[6] print(mid, mname, msex , mdesc, mpic,mtime,mtype) # 测试 author = Author(\"李白2\", \"男1\" , \"牛逼诗人1\", \"baidu.com...png1\", \"唐代1\" , \"浪漫主义1\") # addAuthor(author) # queryAuthor() # deleteAuthorById(5) # updateAutorById(author , 6) # queryAuthor() # 关闭连接等... cursor.close() conn.commit() conn.close() 古诗文网 爬取作者信息 (静态页面) 数据库帮助类 class MySqlTool(object): def __init__(self): self.conn = pymysql.connect(host='xx.xx.xx.xx65', port=3306, user='xx', passwd='xx', db='xx', charset='UTF8') print(\"获得数据库连接:\") print(self.conn) self.cursor = self.conn.cursor() def addAuthor(self ,author): sql = \" insert into poetryauthor( mname, msex , mdesc, mpic,mtime,mtype ) values( '%s','%s','%s','%s','%s','%s' ) \" \\ % (author.mname, author.msex, author.mdesc, author.mpic, author.mtime, author.mtype) self.cursor.execute(sql) newId = int(self.conn.insert_id()) self.conn.commit() print(\"插入 新记录的id是: \", newId) def deleteAuthorById(self, mId): sql = 'delete from poetryauthor where mId = %d ' % (mId) count = self.cursor.execute(sql) self.conn.commit() print(\"删除结果：\", count) def updateAutorById(self, author, mId): sql = \" update poetryauthor set mname= '%s', msex='%s', mdesc='%s', mpic='%s', mtime='%s' , mtype='%s' where mId=%d \" \\ % (author.mname, author.msex, author.mdesc, author.mpic, author.mtime, author.mtype, mId) count = self.cursor.execute(sql) print(\"更新结果：\", count) self.conn.commit() def queryAuthor(self): count = self.cursor.execute('select * from poetryauthor') print('共有' + str(count) + ' 条记录') rows = self.cursor.fetchall() for row in rows: mid = row[0] mname = row[1] msex = row[2] mdesc = row[3] mpic = row[4] mtime = row[5] mtype = row[6] print(mid, mname, msex, mdesc, mpic, mtime, mtype) def closeConnection(self): # 关闭连接等... self.cursor.close() self.conn.commit() self.conn.close() 作者类 class Author(object): # 构造方法 def __init__(self ,mname, msex , mdesc, mpic,mtime,mtype): self.mname = mname self.msex = msex self.mdesc = mdesc self.mpic = mpic self.mtime = mtime self.mtype = mtype # 对象方法 def printInfo(self): print(\"当前对象信息：\", self.mname, self.msex, self.mtime, self.mtype, self.mpic, self.mdesc) 入口程序 user_agent = 'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_11_5)' headers = {'User-Agent': user_agent} session = requests.session() sqlTool = MySqlTool() def getAsleep(): sleepTime = random.uniform(0, 2) print(\"休眠：\", sleepTime) time.sleep(sleepTime) def getUrlData( url ,mTime): # print(\"--------------------------------------\") # print(url) page = session.get(url, headers=headers) soup = BeautifulSoup(page.text, 'lxml') # contents = soup.findAll('div', class='left') datas = soup.findAll(name='div', attrs={\"class\": \"left\"}) for data in datas: items = data.findAll( name= 'div',attrs={\"class\": \"sonspic\"}) for item in items: urlDiv = item.find( name= 'div',attrs={\"class\": \"divimg\"}) if not urlDiv is None: imgUrl= urlDiv.find(name= 'img') name= imgUrl['alt'] pic= imgUrl['src'] descP = item.find( name= 'p',attrs={\"style\": \" margin:0px;\"}) desc= descP.text pos = desc.index(\"►\") # 去掉无用的内容 desc = desc[0:pos] author = Author(name, \"\", desc, pic, mTime, \"\") author.printInfo() sqlTool.addAuthor(author) print(\"--------------------------------------\") dict = { # \"先秦\": 4, # \"两汉\": 10, \"魏晋\": 13, \"南北朝\": 20, \"隋代\": 3, \"唐代\": 232, \"五代\": 4, \"宋代\": 583, \"金朝\": 10, \"元代\": 64, \"明代\": 279, \"清代\": 598 } for mkey in dict: index = 0 sum = dict[mkey] while index 喜马拉雅 json解析 + 文件下载 import requests import urllib.request import demjson user_agent = 'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_11_5)' headers = {'User-Agent': user_agent} session = requests.session() def getAsleep(): sleepTime = random.uniform(0, 2) print(\"休眠：\", sleepTime) time.sleep(sleepTime) def downAFile(fileName ,fileUrl ,downCallBack): downPath = 'F:\\\\小伊\\\\%s.m4a'%(fileName) print(\"正在下载：\" ,fileName) urllib.request.urlretrieve(fileUrl, downPath ,downCallBack) def downCallBack(downedCount, countSize, allSize): per = 100.0 * downedCount * countSize / allSize if per > 100: per = 100 print('下载进度： %.2f%%' % per) def getUrlData( url ): page = session.get(url, headers=headers) jsonData = page.text bean1 = demjson.decode(jsonData) bean2 = bean1['data'] bean3 = bean2['tracksAudioPlay'] for data in bean3: name = data['trackName'] # print(\"名字：\" ,name) arrays= name.split(\"-\") if len(arrays)蜻蜓Fm 爬虫 爬取网易轻松一刻 xml 无版权 可以无限制使用！ all right reserved，powered by Gitbook该文件更新时间： 2018-12-14 08:56:15 "},"chinese/其他语言/kotlin.html":{"url":"chinese/其他语言/kotlin.html","title":"kotlin","keywords":"","body":"kotlin Kotlin 是 JetBrains 开发的基于JVM的语言。 数据类型 Byte、Short、Int、Long、Float、Double 、Boolean 、String 变量 、常量 // 变量 var value : Int = 10 // 常量 val name :String =\"aivin\" 函数 // fun ,有参数 ，有返回值 fun sum(a: Int, b: Int): String { return (a + b).toString() } // 无返回值 fun showInfo(a: Int, b: Int){ } // vararg 可变长参数 fun vars(vararg v:Int){ for(vt in v){ //... } } 字符串模板 val age :Int = 20 var info :String =\"年龄是$age\" //复杂格式 var info2 = \"$info 字符串长度是${info.length}\" 空指针 kotlin只是在编译的时候加强了空指针的检查，最后还是要判断是否为空才能最终使用。卵用。 //?表示可为null var ageString : String ? // ?. student 为空就返回null ，不是空 就返回 对应的值 // 只能赋值给 可以为空的变量 ageString =student ?. name // ?: ageString 为空就用默认值 ，否则用取得的值 var info :String? info = ageString ?: \"21\" // !! 非空断言 ageString不为空时获取对应的值 ，否则直接报错 。 // 不建议使用 这种方式 val length : Int = ageString!!.length // 判断是否为空 var flag : Boolean = ageString.isNullOrBlank() 类型转换 var info : String = \"100\" var info2 :Int = info.toInt() var info3 :String = info2.toString() 对象 所有的类都继承自 Any 。 默认所有的类都是final类型 。 // (info: String) 是主构方法 open class Person (info: String){ // 可以被重写 open var info : String =\"人类\" var age1 : Int = 25 // 次构造函数 constructor(info: String ,age: Int) : this(info) { this. info = info this.age1 = age } // 普通函数 open ,可以被重新 open fun showInfo(){ } // 普通函数 open ,不可以被重新 fun showInfo2(){ } } public class Student(info: String) : Person(info) { override var info : String =info // 次构造函数 constructor(info: String ,age: Int) : this(info) { this. info = info this.age1 = age } // override 重写函数 override fun showInfo() { super.showInfo() } } // 测试 var student1 : Student = Student(\"新人类\" ,19) var student2 : Student = Student(\"新人类\" ) 接口 interface Language { fun chinease(msg :String ) fun english(msg :String ) } // Person 是父类 ， Language是接口 public class Student(info: String) : Person(info),Language{ override fun english(msg: String) { } override fun chinease(msg: String) { } .... } 安卓使用 kotlin 类初始化 kotlin增加了一个新的关键字init用来处理类的初始化问题， init模块中的内容可以直接使用构造函数的参数。 apply 调用对象的apply函数，在函数范围内，可以任意调用该对象的任意方法，并返回该对象。 with 将对象作为函数的参数，在函数内可以通过 this指代该对象。 返回值为函数的最后一行或return表达式 when 表达式类似 java 中的 switch intArrayOf 创建一个int数组 位运算符 shl —— 类似Java的> ushr —— 类似Java的>>> and —— 类似Java的& or —— 类似Java的| xor —— 同Java中的按位异或 ^ inv —— Java中的按位取反 - companion object Kotlin语言中使用\"object\"修饰静态类 Kotlin语言中使用\"companion object\"修饰静态方法 let 常与非空判断符一起使用 compoundDrawables?.let { //compoundDrawables不为空就执行... } 双冒号 :: // 调用d对象的方法getResult d::getResult 无版权 可以无限制使用！ all right reserved，powered by Gitbook该文件更新时间： 2018-12-07 17:21:03 "},"chinese/爬虫/python爬虫.html":{"url":"chinese/爬虫/python爬虫.html","title":"爬虫","keywords":"","body":"爬虫 Java是强类型，编译型语言。 Python是若类型，解释型语言。 python -V //查看当前版本 python版本 import sys print (sys.version) 推荐IDE PyCharm pip pip 是Python的软件包管理系统，Python语言自带的命令行工具，它可以安装和管理第三方软件包。 pip 安装库 pip install requests http://www.lfd.uci.edu/~gohlke/pythonlibs/ urllib、urllib2 在Python3已拆分更名为urllib.request和urllib.error urllib GET f=urllib.urlopen(\"http://m.cnblogs.com/\") s=f.read() print s 带参数 GET params = urllib.urlencode({'id': 8, 'name': 'jack', 'age': 25}) f = urllib.urlopen(\"http://localhost:18797/MailClient/test.aspx?%s\" % params) print f.read() POST params = urllib.urlencode({'id': 8, 'name': 'jack', 'age': 25}) f = urllib.urlopen(\"http://localhost:18797/MailClient/test.aspx\",params) print f.read() import urllib URL='http://192.168.0.102:8081/findYou/pointsApi/queryAllPointsTaskFy/{offset}/{limit}' URL= URL.replace('{offset}','0') URL = URL.replace('{limit}','1') f=urllib.urlopen(URL) s=f.read() print s //下载 import urllib import urllib.request import os def downCallBack(a, b, c): ''''' a:已经下载的数据块 b:数据块的大小 c:远程文件的大小 ''' per = 100.0 * a * b / c if per > 100: per = 100 print('下载进度： %.2f%%' % per) url = 'http://www.python.org/ftp/python/2.7.5/Python-2.7.5.tar.bz2' local = os.path.join('F:\\\\pythonDown\\\\', 'downDemo.zip') urllib.request.urlretrieve(url, local, downCallBack) BeautifulSoup pip install beautifulsoup4 中文乱码 1、先用chardet检测读取到的内容的编码 chardet.detect(content) 2、转换成合适的编码格式 html = unicode(content, \"gb2312\").encode(\"utf8\") 简单demo 权谋网 权谋网 资料来源 权谋网 爬虫程序很简单，并没有优化。 获取文章列表 import requests from bs4 import BeautifulSoup user_agent = 'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_11_5)' headers = {'User-Agent': user_agent} session = requests.session() def getAndSaveUrl( url): print(url) page = session.get(url, headers=headers) soup = BeautifulSoup(page.text, 'lxml') contents = soup.findAll('div', id='contentleft') for child in contents: item = child.findAll('h2') for hValue in item: aValue = hValue.find('a') title = aValue.string url = aValue['href'] print(title) f = open('D:/网址.txt', 'a') f.write('\\n' + url) # sum大小 请根据网站最新页数调整 sum = 181 index =1 while index 获取保存文章内容 import random import requests import time from bs4 import BeautifulSoup import re user_agent = 'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_11_5)' headers = {'User-Agent': user_agent} session = requests.session() localDir =\"C:\\\\test\\\\files\\\\\" def getAndSaveUrl( url): # print(\"抓取 \"+url) page = session.get(url, headers=headers) soup = BeautifulSoup(page.text, 'lxml') contents = soup.findAll('div', id='contentleft') for child in contents: item = child.findAll('h2') title= item[0].string # 去除标题中的特殊字符 title = re.sub(\"[\\s+\\.\\!\\/_,$%^*(+\\\"\\']+|[+——！，。?|？、~@#￥%……&*（）]+\", \"\", title) filePath = localDir +title+ \".md\" f = open(filePath, 'w') print(filePath+\"创建成功\") # 以下保存正文 f = open(filePath, 'a', encoding='utf-8') f.write('# ') f.write(title+ ' \\n ') f.write('```xml \\n ') pvalues = child.findAll(\"span\" ,attrs={'style': 'font-size:18px;'}) for pvalue in pvalues: content = pvalue.string if not content is None: # print(content) f = open(filePath, 'a' ,encoding='utf-8') f.write( content+'\\n' ) f.write('``` \\n ') f.close() print(\"完成 \"+url) # 开始运行 抓取 保存 fileDest =localDir+\"网址.txt\" f=open(fileDest,'r') lines=f.readlines() sum = len(lines) index = 0; for line in lines: index= index+1 sleepTime = random.uniform(0, 2) time.sleep(sleepTime) # 休眠 1秒 print(\"进度%d/%d , 休眠%f秒\" % (index, sum, sleepTime)) # 去掉末尾的换行符 url = line.strip('\\n') try: getAndSaveUrl(url) except: filePath = localDir + \"errorLog.txt\" f = open(filePath, 'a', encoding='utf-8') print(\"!!! 抓取失败 \" + url) f.write(url+'\\n') 生成 SUMMARY 文件 import os.path filePath = \"C:\\\\test\\\\SUMMARY.md\" f = open(filePath, 'a', encoding='utf-8') f.write( '# Summary\\n') f.write( '\\n') f.write( '\\n') f.write( '* [项目介绍](README.md)') f.write( '\\n') f.write( '* [权谋网](chinese/权谋网/权谋网.md)') f.write( '\\n') rootdir =\"C:\\\\test\\\\files\\\\\" list = os.listdir(rootdir) for file in list: fileBaseName = os.path.basename( file) array = fileBaseName.split(\".\") f.write( ' * [') f.write( array[0]) f.write('](chinese/权谋网/') f.write(fileBaseName) f.write( '\\n') 无版权 可以无限制使用！ all right reserved，powered by Gitbook该文件更新时间： 2018-12-11 16:46:13 "},"chinese/人工智能/人工智能相关概念.html":{"url":"chinese/人工智能/人工智能相关概念.html","title":"人工智能","keywords":"","body":"人工智能相关概念 熵 就是对信息的不确定性，如果我们对一个信息掌握得好，对应的熵就会低，反之就高。信息熵是表示随机变不确定性的度量。熵越大，信息量越大，也就是越不确定。 拟合 形象的说，拟合就是把平面上一系列的点，用一条光滑的曲线连接起来。因为这条曲线有无数种可能，从而有各种拟合方法。拟合的曲线一般可以用函数表示. 它是对我们数据点的一个近似表达. 在开始阶段, 红线的表达能力不强, 误差很大. 不过通过不断的学习, 预测误差将会被降低. 所以学习到后来. 红线也能近似表达出数据的样子. 张量（Tensor) 零阶张量为 纯量或标量 (scalar) 也就是一个数值. 比如 [1] 一阶张量为 向量 (vector), 比如 一维的 [1, 2, 3] 二阶张量为 矩阵 (matrix), 比如 二维的 [[1, 2, 3],[4, 5, 6],[7, 8, 9]] 以此类推, 还有 三阶 三维的 … 无版权 可以无限制使用！ all right reserved，powered by Gitbook该文件更新时间： 2018-12-07 17:21:03 "},"chinese/人工智能/机器学习.html":{"url":"chinese/人工智能/机器学习.html","title":"机器学习","keywords":"","body":"机器学习 无版权 可以无限制使用！ all right reserved，powered by Gitbook该文件更新时间： 2018-12-07 17:21:03 "},"chinese/人工智能/TensorFlow.html":{"url":"chinese/人工智能/TensorFlow.html","title":"TensorFlow","keywords":"","body":"TensorFlow 通过 Anaconda 来安装 tensorFlow 和其他依赖的库。 然后用 pycharm 来进行编写代码。 pycharm里面的 python.exe 要指定为 Anaconda 里面的那个 python.exe 。（否则 无法 import tensorflow） 无版权 可以无限制使用！ all right reserved，powered by Gitbook该文件更新时间： 2018-12-07 17:21:03 "},"chinese/区块链/区块链原理.html":{"url":"chinese/区块链/区块链原理.html","title":"区块链","keywords":"","body":"区块链 智能合约 智能合约可以理解为在区块链上可以自动执行的（由事件驱动的）、以代码形式编写的合同。 将合约用代码写成一段程序，这段代码一旦写好就公之于众，且无法修改无法篡改， 当外界条件发生变化如违约或合同到期，智能合约会自动触发。 图灵完备 所谓图灵完备的编程语言，即是能够实现所有计算机可以实现的功能的编程语言。 比如C，GO，Java都是图灵完备的 拜占庭将军问题 // EVM Ethereum Virtual Machine ， 以太坊虚拟机 。 Solidity 和EVM，就像java跟JVM的关系一样 gas 每个网络中的全节点都会储存相同的值。 合约执行会在所有节点中被多次重复，而且任何人都可以发布执行合约， 这使得合约执行的消耗非常昂贵，所以为防止以太坊网络发生蓄意攻击或滥用的现象， 以太坊协议规定交易或合约调用的每个运算步骤都需要收费。 这笔费用以gas作为单位计数，也就是俗称的燃料。 区块链拥堵问题 缓慢和高成本(手续费)是互联网上的主流交易往区块链平台上迁移的巨大障碍。 区块链信息越来越大，导致的存储问题 区块链的一个很大问题在于其中会包含所有的历史交易，这样下去整个链的信息会越来越大，如果不能解决的话会成为区块链协议的最大问题。 目前来说，没有办法。 信息量越来越大无可避免，因为中心化存储也一样数据也会越来越大。 可以考虑不同的机制，比如全节点和轻节点、数据压缩等。 DApp Decentralized Application ，分散式的应用程序 ICO Initial Coin Offering ，首次币发行 是一种区块链行业术语，是一种为区块链项目筹措资金的常用方式， 早期参与者可以从中获得初始产生的加密数字货币作为回报。 区块链1.0时代 这个时候的应用主要以电子货币和去中心化交易为主 RPC Remote Procedure Call 远程过程调用 智能合约 ABI Application Binary Interface 智能合约ABI 可以简单理解为 “是以太坊的一种合约间调用时的一个消息格式”。 区块链2.0时代 在1.0的基础上实现了图灵完备等，并进行了细节优化， 形成了以智能合约为特色的区块链2.0。 谁在维护区块链 // 法币 以国家主权信用抵押强制使用的货币 账本验证 // 共识机制 // 区块链 广播机制 // 区块链 数据更新机制 // 部署合约 、部署区块链 xml 无版权 可以无限制使用！ all right reserved，powered by Gitbook该文件更新时间： 2018-12-07 17:21:03 "},"chinese/区块链/以太坊.html":{"url":"chinese/区块链/以太坊.html","title":"以太坊","keywords":"","body":"以太坊 Ethereum 可以理解为以太坊是区块链里的Android，它是一个开发平台， 让我们就可以像基于Android Framework一样基于区块链技术写应用。 以太坊平台对底层区块链技术进行了封装，让区块链应用开发者可以直接基于以太坊平台进行开发， 开发者只要专注于应用本身的开发，从而大大降低了难度。 Ether币的单位 Ether币最小的单位是wei, 然后每1000个进一个单位 kwei (1000 Wei) mwei (1000 KWei) gwei (1000 mwei) szabo (1000 gwei) finney (1000 szabo) ether (1000 finney) 合约的永固性 当你把合约传上以太坊之后，它就变得不可更改。 如果你的智能协议有漏洞，即使你发现了也无法补救。 你只能让你的用户们放弃这个智能协议，然后转移到一个新的修复后的合约上。 1 // 1 // 1 // 1 // 1 // 1 // 1 // 无版权 可以无限制使用！ all right reserved，powered by Gitbook该文件更新时间： 2018-12-07 17:21:03 "},"chinese/区块链/Solidity.html":{"url":"chinese/区块链/Solidity.html","title":"Solidity","keywords":"","body":"Solidity Solidity https://github.com/ethereum/solidity Solidity 是以太坊智能合约编程语言 ，是一种静态类型语言 。 在以太坊平台上，Solidity编写的智能合约可以被编译成字节码在以太坊虚拟机上运行。 Solidity IDE remix IDE开源 https://github.com/ethereum/remix-ide //windows下安装步骤 1、安装 node 、nvm 2、通过npm 安装 npm install remix-ide -g 3、启动 remix-ide 4、使用（建议使用Chrome，不要用猎豹、360等） http://127.0.0.1:8080 Solidity类型分为两类：值类型 、 引用类型 值类型 说明 举例 布尔类型 bool bool reslut = false 整型 uint8，uint16，uint24......uint256(uint默认的是uint256) 步长8 int8 , uint16 定长浮点型 fixed/ufixed: 代表是否有符号 M 代表整数有效位数（M必须能够被8整数且范围 [8,256] ） N 代表小数有效位数（N的范围 [0 ,80] ufixed 和fixed 分别是 ufixed128x19 和fixed128x19的别名. 目前只能申明变量，还不能赋值 ufixed256x80 value fixed8x2 valueFix 定长字节数组 bytes1, bytes2, …, bytes32 byte的别名就是 byte1 bytes1 public b = 0x6c; 有理数和整型常量 整数常量和有理数常量从属于数字常量。 可以参考对应的数学概念 字符串常量 string STR_KEY =\"TOM\" string STR_KEY2 ='TOM2' 十六进制常量 hex\"001122ff\" 可以转为bytes类型 ， bytes mByts = hex\"001122ff\" 枚举 enum 函数 function 地址 地址的长度为20字节 地址常量 0xca35b7d915458ef540ade6068dfe2f44e8fa733c 引用类型 说明 举例 不定长字节数组 bytes 动态大小字节数据 字符串 string 动态大小utf-8编码的字符串 不提供长度查询和按序号的访问 数组 分为固定长度数组 和动态数组 uint [] array uint [5] arrayFixed 结构体 struct 变量、函数的 可见性 函数声明 默认是public ， 变量声明 默认是internal // public 外部可以调用被public修饰的函数和变量。 不用给变量手动写get函数。 // internal 内部能够正常访问，子类能够正常继承，但是不能供外部访问 // private 跟java的private一样 // external 只能修饰函数，说明这个函数只能被外部合约调用。 假设函数f()是external，还想在合约内调用，可以用this.f()。 变量存储 变量的存储位置属性有三种类型 1、memory 越过作用域即不可被访问的临时变量 。 函数参数、返回的参数 默认是memory 。 2、storage 数据将永远存在于区块链上 。 函数内局部变量默认是storage, 合约内的全局变量 是 storage . 3、calldata 不会被永久存储 ，只读 。 数组 // 固定长度数组 string [5] arrayFixed ; // 动态数组 ： 长度不定（可以动态修改） string [] array ; array.push(100); array[0] = 110 ; array.length = 20; // 重新设置数组的长度 array[15] = 90 ; return array[15] ; 定长字节数组 // 可以存放八个字节 bytes8 b8 = 0x6c69797565636875 ; // 定长字节数组的长度 b8.length ; 不定长数组 和 字符串 string string str =\"abcdefg\" ; // 初始化 bytes的长度为2 bytes nameBytes = new bytes(2); function test() returns (uint len) { // 将 string 转为 bytes bytes myBytes =bytes(str) ; // bytes的长度 myBytes.length ; // 获取bytes某个值 myBytes[1] ; bytes1 b1 ; //修改bytes某个值 myBytes[2] = b1; // 重新设置bytes的长度 nameBytes.length = 100 ; // 往bytes中添加byte nameBytes.push('Z') ; return nameBytes.length ; } 支持 乘方 操作 //5 的 2次方 5 ** 2 = 25 结构体 struct Person { uint age ; string name ; } Person p1 = Person(172, \"name1\"); 枚举 enum Fruit { Apple , Banana , Orange } Fruit fruit = Fruit.Apple ; if(fruit == Fruit.Apple){...} 构造函数 、析构函数 /* 构造函数不是必须的 。 构造函数就是方法名和合约名字相同的函数 。 合约初始化时会调用 。 只能有一个构造函数 */ function Demo(uint number, uint p) { ...} // 销毁合约 function killMyDemo() { if (owner == msg.sender) { // 检查谁在调用 selfdestruct(owner); // address owner; } } 函数 我们约定（不是硬性规定） 函数里的变量都是以()开头以区别全局变量， 私有函数的名字用()开头 // 修饰符 view ，指明函数只能读取数据不能更改数据 function getInfo() public view returns(string str){ return \"hello world\" ; } // 修饰符 pure ,表明这个函数甚至都不访问应用里的数据 function getInfo() public pure returns(uint value){ return value **2; } // 函数可以有多个返回值 function getPeopleInfo() public returns (uint _age , string _name){ return (20 , \"tom\" ) ; } uint pAge ; string pName ; function test(){ // 接收全部返回值 (pAge ,pName ) = getPeopleInfo(); //接收部分返回值 ( ,pName) = getPeopleInfo(); } 散列函数 、 类型强制转换 散列函数 keccak256 把一个字符串转换为一个256位的16进制数字 bytes32 result = keccak256(_name); uint rand = uint(result); 地址 // msg.sender 系统自带的全局变量 ，代表当前调用者（合约）的地址 。 // msg.value 系统全局变量 ，代表当前合约的余额 address myAddress = msg.sender ; // myAddress.balance 地址的余额 if (msg.value > 100 && myAddress.balance 映射 类似java中的map 。通过键值对的方式管理数据 申明键映射， 键的类型为 address ，值的类型为uint mapping(address => string) public peopleoInfo; // 保存键值对 peopleoInfo[msg.sender] = \"tom\"; // 根据键取值 string name= peopleoInfo[msg.sender] ; require 验证前置条件 // 如果满足条件，就会往下执行 ， // 如果不满足就会抛出错误，并终止程序 require(keccak256(_name) == keccak256(\"tom\")); if 判断 跟java一样 判断字符串相等 Solidity不支持原生的字符串比较, 我们只能通过比较 两字符串的 keccak256 哈希值来进行判断 if (keccak256(_name) == keccak256(\"tom\")){...} Import 导入 合约 一个 .sol 文件可以写多个合约。 但是为了方便管理 ，我们通常将不同的合约写到不同的文件中。 然后用 import 导入使用 。 import \"./Animal.sol\" ; 继承 // 用 is 表示合约的继承关系 contract Dog is Animal { ... } 接口 // 定义接口 注意没有{ } 。 contract InfoInterface { function getInfo( address _address) public view returns ( string _name ) ; } // 使用接口 ？？ // 调用接口 ？？ 事件 // 与其他合约的交互 // modifier 修饰符 ``` #### 1 ```xml 1 ``` #### 1 ```xml 1 ``` #### 1 ```xml 无版权 可以无限制使用！ all right reserved，powered by Gitbook该文件更新时间： 2018-12-07 17:21:03 "},"chinese/区块链/truffle.html":{"url":"chinese/区块链/truffle.html","title":"truffle","keywords":"","body":"truffle https://github.com/trufflesuite/truffle Truffle基于Javascript, 针对Solidity语言的一套开发框架。 为以太坊提供了开发环境、测试框架和资产管道， 旨在使以太坊开发更容易。 安装 基于Windows 1、 需要先安装 nodejs 2、 安装 npm install -g truffle 3、测试是否安装成功 truffle version 搭建工程 1、truffle init 初始化 truffle 项目。 contracts //智能合约目录 migrations //发布脚本目录 test //测试文件 truffle.js // ? truffle.js //Truffle的配置文件 2、配置需要编译的.sol文件 编辑 migrations/1_initial_migration.js // 获得指定的文件 var Migrations = artifacts.require(\"./Migrations.sol\"); module.exports = function(deployer) { // 部署到区块链上 deployer.deploy(Migrations); }; 3、编译合约 truffle.cmd complile // 所有的.sol都被编译了 4、配置部署地址信息 编辑 truffle.js module.exports={ networks:{ development:{ host:\"localhost\", port:8545, network_id:\"*\"//匹配任何netword id } } } 5、合约部署 truffle.cmd migrate 6、执行 Migrations .deployed().then(instance => contract = instance) truffle.cmd test 无版权 可以无限制使用！ all right reserved，powered by Gitbook该文件更新时间： 2018-12-07 17:21:03 "},"chinese/区块链/testrpc.html":{"url":"chinese/区块链/testrpc.html","title":"testrpc","keywords":"","body":"testrpc testrpc 是在本地使用内存模拟的一个以太坊环境，用来开发调试。 当合约在testrpc中测试通过后，再部署到真实的以太坊环境中去。 安装 基于Windows 1、 需要先安装 nodejs 2、 安装 npm install -g ethereumjs-testrpc 3、 testrpc 启动并获得账号和key 无版权 可以无限制使用！ all right reserved，powered by Gitbook该文件更新时间： 2018-12-07 17:21:03 "},"chinese/区块链/MetaMask.html":{"url":"chinese/区块链/MetaMask.html","title":"MetaMask","keywords":"","body":"MetaMask MetaMask是一个开源的简易以太坊钱包。 目前只能作为插件在Chrome浏览器中使用 。 在能科学上网的前提下，在Chrome上搜索插件 MetaMask 既可在线安装小狐狸。 安装完成后浏览器右上角将出现一个新图标（MetaMask 狐狸插件图标） 测试密码dfad#$Q@#DFGSFG45245 无版权 可以无限制使用！ all right reserved，powered by Gitbook该文件更新时间： 2018-12-07 17:21:03 "},"chinese/区块链/web3_js.html":{"url":"chinese/区块链/web3_js.html","title":"web3.js","keywords":"","body":"web3.js Web3.js 是以太坊提供的一个JavaScript库， 它提供了一系列与区块链交互方法， 使JavaScript与以太坊交互变得简单。 以太坊节点只能识别一种叫做 JSON-RPC 的语言。 这种语言直接读起来并不好懂。 Web3.js 让开发者使用 JavaScript 即可与以太坊进行交互 。 无版权 可以无限制使用！ all right reserved，powered by Gitbook该文件更新时间： 2018-12-07 17:21:03 "},"chinese/产品经理/常用概念.html":{"url":"chinese/产品经理/常用概念.html","title":"产品经理","keywords":"","body":"Axure 软件安装 Axure 原型制作工具 1、安装包 测试版本为8.1.0.3377 安装包在我百度盘有备份 2、汉化 汉化包也在百度盘 将汉化包解压，将其中的 lang文件夹, 复制到Axure 安装目录下即可。 3、破解 于20180907测试可用，以后可能会失效。 zdfans.com gP5uuK2gH+iIVO3YFZwoKyxAdHpXRGNnZWN8Obntqv7++FF3pAz7dTu8B61ySxli 类型 保真度 用途 特点 费用 线框图 低 文档、快速交流、表达设计思路和大纲 手绘草图，不能交互 低 原型 中 模拟成品的交互流程 可以交互 高 视觉稿 高 给非专业人看的，视觉感受 静态视觉设计，不能交互 中 类图(Class Diagram) 对象图(Object Diagram) 包图(Package Diagram) 组件图(Component Diagram) 部署图(Deployment Diagram) 用例图(User Case Diagram) 顺序图/序列图/时序图(Sequence Diagram) ---> 交互图 状态机图、状态图(State Machine Diagram) 协作图、通信图(Communlcation Diagram) 活动图(Activity Diagram) PERT图 项目评估与评审技术 Project Evaluation and Review Technique 可以使用亿图图示绘制 pert图示例 UML流程图 绘制软件 推荐使用 Visio 、processon 流程图符号 类型 作用 图形 开始 / 结束 代表“开始”、“结束” 过程 一个步骤或操作 判断 if else 数据 输入/ 输出 输入、输出的数据 箭头、连接线 工作流方向 文档 输入、输出的文件 多文档 外部数据 表示数据来自外部 数据库 表示从数据库中获取数据信息 内部存储 指数据提交之后，需要写入数据库 队列数据 表示数据处理的一种方式 直接数据 人工输入 用户通过键盘等手动输入的数据 人工操作 表示需要用户手动操作调整的内容 比如修改、搜索、删除、提交等 手动操作 卡片 穿孔卡是早期计算机的信息输入设备 纸带、条带 参考卡片 展示内容 在设备上展示信息 循环限值 是指循环开始或结束的条件 子流程 并行模式 表示同时进行 （在并行模式的框内可以添加其它的部件） 预定义流程 人员 注释 批注 页面内引用 相当于一个页面内的跳转 跨页引用 相当于一个跨页的连接器 预备 进入流程前的准备状态 推迟、延期 UML状态图 State Machine Diagram 用于描述一个特定的对象的所有可能状态以及由于各种事件的发生而引起的状态之间的转换。 概念 意义 图示 状态 开始 、其他状态、结束 转移 两个状态之间的一种关系 表示对象将在第一个状态中执行一定的动作， 并在某个特定事件发生而某个特定的条件满足时进入第二个状态 UML用例图 User Case Diagram 用例图从用户角度描述系统的静态使用情况 类型 作用 图示 角色、参与者 在系统外部与系统直接交互的人或事物 用例 系统外部可见的一个系统功能单元 系统边界、容器 用来展示系统的一部分功能，这部分功能联系紧密 关系 有4种：关联、泛化、包含、扩展 关系 意义 图示 备注 关联 箭头指向消息接收方 泛化 继承关系 箭头指向父类 包含 用来体现一个用例功能的多个子功能 拓展 是指用例功能的延伸，相当于为基础用例提供一个附加功能 UML类图 Unified Modeling Language 统一建模语言 绘制UML类图的软件推荐 Enterprise Architect 或 processon 作用域类型 符号 public + private - protected # 元素类型 图示 包 类 接口 元素之间的关系 定义 举例 备注 泛化（Generalization） 继承 箭头指向父类 实现（Realization） 类实现接口 箭头指向接口 关联（Association) 拥有关系 箭头指向被拥有者 聚合（Aggregation） 整体与部分的关系。部分可以单独存在。 菱形指向整体 组合(Composition) 整体与部分的关系 部分不能单独存在。 图标有2种菱形指向整体 依赖(Dependency) A需要B的协助才能完成某项功能 箭头指向被使用者 甘特图 甘特图最早由Henry L.Gantt在1917年提出。 甘特图是一个二维平面图， 横纬度 显示了每项工作的开始时间和结束时间，横道线的长度表示了该项工作的持续时间。 纵维表示工作内容 绘制工具可以使用 雁阵 无版权 可以无限制使用！ all right reserved，powered by Gitbook该文件更新时间： 2019-04-12 16:09:25 "}}