# 回调机制
回调的简单理解：

A需要做一件事情(不需要立刻知道结果)，给B设置一个回调对象，然后B在条件合适的时候执行得到一个结果， 然后通过A传过来的回调对象告诉A。



---

- 1、回调普通使用

```
1、定义回调接口：
public interface IH264StoreFinishCallBack
{
    public void onStoreAndParseFinished( boolean result, String msgStr) ;
}
```

```
2、设置接口：
private IH264StoreFinishCallBack ih264StoreFinishCallBack = new IH264StoreFinishCallBack()
{
    @Override
    public void onStoreAndParseFinished(boolean result, String msgStr)
    {
        if(result)
        {
            disMissIosLoading();
        }
    }
} ;
H264FileSotrPresenter h264FileSotrPresenter = new H264FileSotrPresenter(ih264StoreFinishCallBack);
```

```
3、触发回调：
if(ih264StoreFinishCallBack!=null)
{
 ih264StoreFinishCallBack.onStoreAndParseFinished(true ,"切换到照片时自动触发结束录像命令");
}


```

----

- 2、全局回调的使用方法(结合单例模式)

这种模式可以实现在不同的activity之间传递参数。

```
1、定义回调函数管理类：
/**
 * Created by Aivin on 2017/5/8.
 * 单例模式 管理一个回调对象，
 * 实现两个不同的activity实时通讯
 *用户手动改变计量单位后，通知另外一个activity做出相应的改变
 */

public class UnitsChangeCallBackManager
{

  private IUnitsModeChangeCallBack iUnitsModeChangeCallBack ;

    /**
    *接受传入的回调实例
    */
    public void setiUnitsModeChangeCallBack(IUnitsModeChangeCallBack iUnitsModeChangeCallBack) {
        this.iUnitsModeChangeCallBack = iUnitsModeChangeCallBack;
    }

    /**
     * 用户手动改变电池的警报值
     * @param type  标记是 哪一个电池被修改
     * @param value  具体的修改值
     * @param msgStr 拓展字段，备用。
     */
    public void sendUnitsChangedByUser(int type , int value , String msgStr)
    {
       if(iUnitsModeChangeCallBack !=null)
       {
           iUnitsModeChangeCallBack.onUnitsModeChange(type , value , msgStr);
       }
    }//

    /**私有化构造函数，防止被其他类实例化*/
    private UnitsChangeCallBackManager()
    {
        //初始化操作
    }//

    /**使用一个内部类来维护单例
     *单例模式使用内部类来维护单例的实现。
     *利用jvm提供的机制，加载类的线程互斥的，用来解决多线程访问的时候可能会遇到null的问题。
     **/
    private static class SingletonFactory
    {
        private static UnitsChangeCallBackManager instance = new UnitsChangeCallBackManager();
    }

    /**获取实例,对外提供的接口 */
    public static UnitsChangeCallBackManager getInstance()
    {
        return SingletonFactory.instance;
    }

    /**为了能在序列化过程仍能保持单例的特性，需要添加一个readResolve()方法 */
    private Object readResolve()
    {
        return getInstance();
    }

}
```

```
2、设置回调：
UnitsChangeCallBackManager.getInstance().setiUnitsModeChangeCallBack(this);
public void onUnitsModeChange(int type, int value, String msgStr)
{
    switch (type) {
        case 1:  
          break;
        case 2:
            break;       
    }
}
```


```
3、触发回调：
UnitsChangeCallBackManager.getInstance().sendUnitsChangedByUser(1,1 ,"英尺");
```

---
