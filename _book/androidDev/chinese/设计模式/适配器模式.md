# 适配器模式  Adapter Pattern   
解决接口不兼容的问题。
```xml
A 需要 C接口， 但是系统只提供了B接口。
同时, A 和B 都不想改或者不能改。
如果，我们将B封装一下，改成C接口的规范。就解决了问题。
```

被适配者 ：即源接口


#### 一、类适配器 （不推荐）
采用继承方案。
```java
// 旧接口 提供220V电压
public class Voltage220 {
    public int output220V() {
        return 220;
    }
}

// 用户需要 5V的电压
public interface Voltage5
{
    int output5V();
}

//新建适配器
public class VoltageAdapter extends Voltage220 implements Voltage5 {
    @Override
    public int output5V() {
      //获得旧接口的数据， 转换成用户需要的数据
        int src = output220V();
        return src / 44;
    }
}
```

#### 二、对象适配器 （推荐）
采用持有方案。
```java
// 新建适配器
public class VoltageAdapter2 implements Voltage5 {
    private Voltage220 mVoltage220;
    public VoltageAdapter2(Voltage220 voltage220) {...}

    @Override
    public int output5V() {
        int src = mVoltage220.output220V();
        return src / 44;
    }
}
```

#### 三、缺省适配器 、接口适配器模式（推荐）
原接口是 interface 。
```java
// 原接口
public  interface AnimatorPauseListener
{
  void onAnimationStart(Animator animation);
  void onAnimationEnd(Animator animation);  
   ...
  void onAnimationResume(Animator animation) ;
}

// 新建适配器
public abstract class AnimatorListenerAdapter implements  
AnimatorListener  {
    @Override
    public void onAnimationEnd(Animator animation){...}
    @Override
    public void onAnimationStart(Animator animation){...}
    @Override
    public void onAnimationResume(Animator animation) {...}
}
// 使用
XXX.addListener(new AnimatorListenerAdapter() {
           @Override
           public void onAnimationStart(Animator animation) {
               // 重新 需要的那个方法就行。
               // 而不必 要实现 interface 中所有的方法，从而简化代码
           }
       });

```


#### 四、双向适配器 （不推荐）
同时持有原接口和旧接口的对象。
```java  
class Adapter implements DesInterface,SrcInterface {  
    private Des des;  
    private Src src;  
    public Adapter(Des des) {... }  
    public Adapter(Src src) {...}  

    public void() func1(){
      src.xxx();
    };
    public void() func2(){
      des.xxx();
    };
}
```
