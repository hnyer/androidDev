##### 策略模式  Strategy Pattern

```
/**抽象接口，定义共同操作*/
public interface Strategy
{
	public double getValue(double paramA, double paramB);
}
```

```
/***
 * 加法策略
 */
public class AddStrategy implements Strategy
{
	@Override
	public double getValue(double paramA, double paramB)
	{
		return paramA + paramB;
	}
}//
```

```
/***
 * 减法策略
 */
public class SubStrategy implements Strategy
{
	@Override
	public double getValue(double paramA, double paramB)
	{
		return paramA - paramB;
	}
}//
```

```
/**
 * 根据传入的策略类型返回计算结果。
   辅助类。
 */
public class CalcClient
{
	private Strategy strategy;
	public void setStrategy(Strategy strategy)
	{
		this.strategy = strategy;
	}

	public double calc(double paramA, double paramB)
	{
		return this.strategy.getValue(paramA, paramB);
	}
}
```

```
/////////////// 演示 /////////////////////
 public static void main(String[] args)
 {
        double paramA = 5;
        double paramB = 21;
        //用if-else实现 （ 普通形式）   
        System.out.println("普通方法-加法结果是：" + calc("+", paramA, paramB));
        System.out.println("普通方法-减法结果是：" + calc("-", paramA, paramB));
        //System.out.println("乘法结果是：" + calc("*", paramA, paramB));
        //System.out.println("除法结果是：" + calc("/", paramA, paramB));

        //策略模式
        System.out.println("策略模式-加法结果是：" + calc(new AddStrategy(), paramA, paramB));
        System.out.println("策略模式-减法结果是：" + calc(new SubStrategy(), paramA, paramB));
        //System.out.println("乘法结果是：" + calc(new MultiStrategy(), paramA, paramB));
        //System.out.println("除法结果是：" + calc(new DivStrategy(), paramA, paramB));
    }


 /***
  * 用if-else实现 （ 普通形式）   
  */
 public static double calc(String op, double paramA, double paramB)
 {
    if ("+".equals(op)) {
      return paramA + paramB;

    } else if ("-".equals(op)) {

      return paramA - paramB;
    } else if ("*".equals(op)) {
      return paramA * paramB;

    } else if ("/".equals(op)) {
      return paramA / paramB;

    } else {
      throw new IllegalArgumentException("未找到计算方法!");
    }
  }



 /***
  * 策略模式  实现
  */
  public static double calc(Strategy strategy, double paramA, double paramB)
  {
    CalcClient calc = new CalcClient();
    calc.setStrategy(strategy);
    return calc.calc(paramA, paramB);
  }
```
<br>
前者通过简单的if-else来解决问题，在解决简单问题事会更简单、方便;
后者则是通过给予不同的具体策略来获取不同的结果，对于较为复杂的业务逻辑显得更为直观，扩展也更为方便。
<br>
#####   策略模式的优缺点：
######   优点：
1、结构清晰明了、使用简单直观。<br>
2、耦合度相对而言较低，扩展方便。<br>
3、操作封装也更为彻底，数据更为安全。<br>

###### 缺点：
1、随着策略的增加，子类也会变得繁多。
