# 动画详解

Android动画类型 |  特点|   大类
-| -
帧动画 Frame Animation|容易OOM|   视图动画
补间动画 TweenedAnimation |只能平移、缩放、旋转、透明度。不能拓展效果。 |视图动画
属性动画 Property Animation |可以拓展动画效果。可以作用于View和非View对象|属性动画、值动画





#### 一、帧动画  
将一个完整的动画拆分成一张张单独的图片，然后再将它们连贯起来进行播放，类似于动画片的工作原理。


#### 二、补间动画  
##### 特点
1、XML声明文件存放在res/anim目录；

2、基于Animation和AnimationSet的类结构；

3、效果由四个因素决定：1）初始状态；2）结束状态；3）持续时间；4）Interpolator

##### 劣势：
1、只能够作用在View上 。

2、补间动画机制是使用硬编码的方式来完成的，功能限定死 淡入淡出(透明度)、缩放(大小)、平移(位置)、旋转四种，基本上没有任何扩展性可言。例如不能实现对View的背景色进行动态地改变。

3、它只是改变了View的显示效果而已，而不会真正去改变View的属性。例如 现在屏幕的左上角有一个按钮，补间动画将它移动到了屏幕的右下角，你点击这个按钮，点击事件不会触发，因为实际上这个按钮还是停留在屏幕的左上角，只不过补间动画将这个按钮绘制到了屏幕的右下角而已。（想真正移动某组件，需要在动画结束后添加代码实现。）


#### 三、属性动画（Property Animation）

##### 特点
1、需要Android API level 11 （android3.0）以上使用。

2、XML文件存放在res/animator目录下；

3、基于Animator和AnimatorSet的类结构；

##### 优点：
1、可以对所有的Object对象（View和非View对象）的任意属性进行操作。

2、动画效果不局限于淡入淡出(透明度)、缩放(大小)、平移(位置)、旋转四种效果

3、因为是一种不断地对值进行操作的机制，并将值赋值到指定对象的指定属性上，所以不仅仅是一种视觉上的动画效果了。例如我们通过属性动画来移动一个按钮，那么这个按钮就是真正的移动了，而不再是仅仅在另外一个位置绘制了而已。


####  Activity 转场动画
overridePendingTransition(...)


#### Fragment 转场动画
fragmentCloseEnterAnimation(...)

&nbsp;&nbsp;
&nbsp;&nbsp;

#### 帧动画实现原理

顺序播放事先做好的图像，跟电影类似。

#### Android 补间动画的实现原理 / View 动画 Animation 运行原理解析
[参考](https://www.jianshu.com/p/48317612c164)

1、当调用了 View.startAnimation() 时动画并没有马上就执行，而是通过 invalidate() 层层通知到 ViewRootImpl 发起一次遍历 View 树的请求，而这次请求会等到接收到最近一帧到了的信号时才去发起遍历 View 树绘制操作。（底层 每 16.6ms 发送一个 VSync 信号。详情请参考 屏幕刷新机制 ）

2 、从 DecorView 开始遍历，遍历时会调用到 View 的 draw() 方法，如果有绑定动画，会去调用applyLegacyAnimation()，然后调用 getTransformation() 来根据当前时间计算动画进度，紧接着调用 applyTransformation() 并传入动画进度来应用动画。

3、 applyLegacyAnimation() 会根据 getTransformation() 的返回值来决定是否通知 ViewRootImpl 再发起一次遍历请求，返回值是 true 表示动画没结束，那么就去通知 ViewRootImpl 再次发起一次遍历请求。然后当下一帧到来时，再从 DecorView 开始遍历 View 树绘制，重复上面的步骤，这样直到动画结束。
```java  
private void testAnimation(View view)
   {
       Animation anim= new RotateAnimation(0.0f,+360.0f);
       anim.setInterpolator(new AccelerateDecelerateInterpolator());
       anim.setDuration(3000);
       view.startAnimation(anim);
   }

 public void startAnimation(Animation animation)
 {
     ...
     invalidate(true);
 }

 public void invalidate(boolean invalidateCache)
 {
       invalidateInternal(0, 0, mRight - mLeft, mBottom - mTop, invalidateCache, true);
 }


 void invalidateInternal(int l, int t, int r, int b,
                        boolean invalidateCache, boolean fullInvalidate)
{
      ...
      final ViewParent p = mParent;
       if (p != null && ai != null && l < r && t < b) {
           final Rect damage = ai.mTmpInvalRect;
           damage.set(l, t, r, b);
           // 调用 父容器的 invalidateChild
           p.invalidateChild(this, damage);
       }
       ...


 }


public final void invalidateChild(View child, final Rect dirty)
{
   final AttachInfo attachInfo = mAttachInfo;
   ViewParent parent = this;
   if (attachInfo != null) {
       do {
           ...
           //循环走到 ViewRootImpl 的 invalidateChildInParent(...)
           parent = parent.invalidateChildInParent(location, dirty);
           ...
       } while (parent != null);
   }
}


@Override
public ViewParent invalidateChildInParent(int[] location, Rect dirty)
{


   if (dirty == null) {
       invalidate();
       return null;
   } else if (dirty.isEmpty() && !mIsAnimating) {
       return null;
   }
   ...
   // 这是 ViewRootImpl 的函数
   //调用 invalidateRectOnScreen
   invalidateRectOnScreen(dirty);
   return null;
}


 private void invalidateRectOnScreen(Rect dirty)
 {
      ...
     if (!mWillDrawSoon && (intersected || mIsAnimating))
     {
         //调用 scheduleTraversals
         scheduleTraversals();
     }
     ...
 }


 void scheduleTraversals()
 {
     ...
     Choreographer.CALLBACK_TRAVERSAL, mTraversalRunnable, null);
     //会在 mTraversalRunnable 中执行 performTraversals(...)
     // ViewRootImpl 的performTraversals(...) 发起整个 View树的重绘制
    ...
 }


//    父容器drawChild(...)中调用 child.draw(...)
 boolean draw(Canvas canvas, ViewGroup parent, long drawingTime)
 {
   ...
     final Animation a = getAnimation();
     if (a != null) {
         //拿到 与view绑定的动画对象
         more = applyLegacyAnimation(parent, drawingTime, a, scalingRequired);
         ...
     }
    ...
     return more;
 }


 private boolean applyLegacyAnimation(ViewGroup parent, long drawingTime,
                                      Animation a, boolean scalingRequired)

  {
     Transformation invalidationTransform;
     ...
     if (!initialized) {
         ...
         onAnimationStart();
     }

     ...
     if (scalingRequired && mAttachInfo.mApplicationScale != 1f) {
         //调用  getTransformation(...)
         a.getTransformation(drawingTime, invalidationTransform, 1f);
     } else {
         invalidationTransform = t;
     }

     ...
     return more;
 }


 public boolean getTransformation(long currentTime, Transformation outTransformation)
 {
     if (mStartTime == -1) {
         //第一帧时间
         mStartTime = currentTime;
     }

     ...
     float normalizedTime;
     if (duration != 0) {
         //动画进度
         normalizedTime = ((float) (currentTime - (mStartTime + startOffset))) /
                 (float) duration;
     }
     ....


         final float interpolatedTime = mInterpolator.getInterpolation(normalizedTime);
         //应用动画
         applyTransformation(interpolatedTime, outTransformation);
     }

     return mMore;
 }


 protected void applyTransformation(float interpolatedTime, Transformation t)
 {
      ...
     //通过矩阵来具体实现动画效果 。 具体原理细节此篇不再深究
     t.getMatrix().setRotate(degrees, mPivotX * scale, mPivotY * scale);
     ...
 }

```

<br>
#### 矢量动画 svg
```xml
SVG（Scalable Vector Graphics）是Android 5.0中新加入的一个新特性 。
svg文件 使用xml格式定义 。
svg图片可以无限拉伸并不会变形和锯齿。

// svg在安卓上使用稍显复杂 ，
使用 Lottie 库 + AE 导出的json文件 可以更方便快捷地实现同样的效果 。
同时 Lottie 兼容 android 、ios、React Native 、web 。
https://github.com/airbnb/lottie-android
```
