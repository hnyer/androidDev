# 自定义控件
##  自定义View的意义
```text
1、实现基础控件无法做到的特效。
2、代码封装后方便给其他成员共用，无需重复造轮子。
3、将控件的内部逻辑封装在自定义View中，便于应用内解耦
```

## Android自定义View类型
### 1、组合控件
将基础控件(TextView、ProgressBar等)组合而成，比如下拉刷新控件等。 

###  2、完全自定义控件
```text
继承 View(UI在主线程中绘制)、ViewGroup 等顶级控件或 SurfaceView 特定控件。
难点在于程序的设计、事件传递处理、效率优化。

SurfaceView extends View ，但是是一个比较特殊的系统控件。UI在一个子线程中进行绘制。
```

## view自定义属性
```text
通过定义属性，使得开发者可以在xml中对控件进行一些参数配置。
不过，我不喜欢这种方式，我习惯在代码中配置。
```
 
## LayoutInflater
它的作用类似于 findViewById(),不同点是LayoutInflater是用来找 layout 下xml布局文件，并且实例化。
而findViewById() 是找具体xml下的具体控件。
```text
LayoutInflater inflater1 = activity.getLayoutInflater();
LayoutInflater inflater2 = LayoutInflater.from(this);
LayoutInflater inflater3 = (LayoutInflater)activity.getSystemService(LAYOUT_INFLATER_SERVICE);

// XmlPullParser parser, ViewGroup root, boolean attachToRoot
// 参数意义：parser :R.layout.abc , root :root布局   attachToRoot :是否加到root布局中
View itemView=inflater1.inflate(R.layout.abc, null);

注意：
通过 inflate 获得的view 是获取到的长宽都是为0 。
// itemView.getWidth() 、itemView.getHeight() 都会为0

为了能获得长宽，我目前采用的是如下方式 ：
将这个布局放到启动页下 ，通过 findViewById 的方式获取到后 保存起来给其他用 。
```

## MeasureSpec
```text
MeasureSpec 通过一个int数值(widthMeasureSpec 、heightMeasureSpec)计算“模式”和“大小”，
前2位表示“大小的模式” ，后30bit表示 “尺寸大小”

int mode=MeasureSpec.getMode(widthMeasureSpec);
int size=MeasureSpec.getSize(widthMeasureSpec);
    
//MeasureSpec.EXACTLY
用的较多。父容器已经检测出子View所需要的精确大小。
在该模式下，View的测量大小即为 SpecSize 。

//MeasureSpec.UNSPECIFIED
父容器未能检测出子View所需要的精确大小，但是指定了一个可用大小即specSize
在该模式下，View的测量大小不能超过SpecSize。用得少。

//MeasureSpec.AT_MOST
父容器不对子View的大小做限制 。用得少。
```

## 如何获取 自定义控件的宽高 
```text
1、addOnGlobalLayoutListener
private void test(){
    final View thisView = this;
    this.getViewTreeObserver().addOnGlobalLayoutListener(new ViewTreeObserver.OnGlobalLayoutListener() {
        @Override
        public void onGlobalLayout() {
            thisView.getViewTreeObserver().removeOnGlobalLayoutListener(this);
            int height = thisView.getMeasuredHeight();
            int width = thisView.getMeasuredHeight() ;
        }
    });
}

2、view.post() 、 view.postDelayed() 
view.post() 方法在整个view树的 performMeasure 、 performLayout 、performDraw执行完后，
才被主线程轮询到，才得到执行。
因此整个View树都完成了测量，布局，绘制。
所以可以拿到宽高信息。
```

## 如何触发重新绘制
```text
invalidate() 、postInvalidate()
```

## 首次 View 的绘制流程是在什么时候触发的
```text

```

## UI 绘制相关函数
### onMeasure()
```text
测量 View 的大小。决定了 view 本身的大小。
protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {
    int widthMode=MeasureSpec.getMode(widthMeasureSpec);
    int widthSize=MeasureSpec.getSize(widthMeasureSpec);

    int heighMode=MeasureSpec.getMode(heightMeasureSpec);
    int heighSize=MeasureSpec.getSize(heightMeasureSpec);

    int mesW= widthMode==MeasureSpec.EXACTLY ? widthSize: dip2px(getContext(),100);
    int mesH =heighMode==MeasureSpec.EXACTLY ? heighSize :  (int) (mesW*ratio) ;
    setMeasuredDimension(mesW,mesH); // 使得测量结果生效
}
```

### onLayout()
```text
用来决定 View 在 ViewGroup中的位置如何。
在 ViewGroup 中是 abstract,所以必须重写。 
在View中是空函数，一般不用重写。 

protected void onLayout(boolean boo, int l, int t, int r, int b) {
    for (int j=0;j<getChildCount();j++){
        View view = getChildAt(j);
        //  重新布局子View
        view.layout(l + padding,t  + padding,l + width, t + width);
    }
}
```

### layout()
确定View自己的位置。
```text
ViewGroup中的 是 final void layout ，不能重写。
View中 public void layout ，可以重写。但是一般不重写。
在 父容器中直接让子View直接调用即可。 

for (int j=0;j<getChildCount();j++){
    View view = getChildAt(j);
    view.layout(...); // 注意此处的 xx.layout() 
｝
```

### onDraw()
```text
决定如何绘制这个 View 。
 
```


### onSizeChanged()
该方法在当前View尺寸变化时被调用 。
可以在这里重新获取view的长宽等参数。
```text
protected void onSizeChanged(int w, int h, int oldw, int oldh)  {
    super.onSizeChanged(w, h, oldw, oldh);
    if (w != oldw || h != oldh) {
        mHeight = h;
        mMaxOverScrollDistance = w / 2.f;
    }
}
```

### measure() 
```text
// 测量入口，一般不用重写。
public final void measure(int widthMeasureSpec, int heightMeasureSpec){ }
```



### dispatchDraw()
绘制子View。
```text
View 没有重写 dispatchDraw的必要。

ViewGroup 貌似一般也不用重写 dispatchDraw ，只是在合适的地方调用一下自己的这个方法，使得自己的子View都去重新绘制。
```

### invalidate() 、postInvalidate()
```text
都是用于刷新界面。
invalidate  在UI线程调用。
postInvalidate  在非UI线程调用，将非UI线程切换到UI线程，最后也是调用invalidate 。

在 View 已被附加在 当前窗口的前提下，invalidate 一定会引起 onDraw 。
如果是 ViewGroup ，默认是认为不需要重新绘制的 ，
如果没有设置过背景 ，调用 invalidate ，viewGroup 的 onDraw 不会被调用。

invalidate 不会导致 onMeasure 和 onLayout 被调用，而 OnDraw 会被调用。
```

### requestLayout()
```text
常用于更新 。
requestLayout 会导致调用 measure()过程 和 layout()过程， 
将会根据标志位判断是否需要 onDraw。

invalidate 会导致调用 onDraw 。
所以一般而言，如果是绘制内容变了就调用 invalidate ， 
如果是位置变了就调用 requestLayout 。

requestLayout 会导致 onMeasure 和 onLayout 被调用。不一定会触发 OnDraw 。
```

### setWillNotDraw( )
```text
setWillNotDraw(true) // 设置后 就不会调用 onDraw() 。一般用来优化GroupView
View中默认设置为false ,ViewGroup默认设置为true 。
``` 

 


# 自定义控件示例
## 分贝波形图
```text
https://gitee.com/Aivin_CodeShare/android_tool_code/raw/master/AudioWaveView.java
```
![AudioWaveView](https://gitee.com/hnyer/filesOfGitbook/raw/master/files/201808161609_osChina_分贝波形图.gif)


## 瀑布流
现在的 RecyclerView 已经直接支出 瀑布流布局了。
```text
// 实现思路
将手机屏幕分成N块 ，
每当需要添加一张图片时，会将这张图片的宽度压缩成和列一样宽，再按照同样的压缩比例对图片的高度进行压缩，
然后在这三列中找出当前高度最小的一列，将图片添加到这一列中。
之后每当需要添加一张新图片时，都去重复上面的操作，就会形成瀑布流格局的照片墙。

然后解决下内存溢出问题。
```

##  手势控件
GestureDetector ，ScaleGestureDetector 。
支持识别 向左 、向右、 向上 、向下 、手势放大 、手势缩小 、停止缩放、 双击、 单击 、 长按 。
```text
https://gitee.com/Aivin_CodeShare/android_tool_code/raw/master/GestureView.java
```

# MPAndroidChart 图表绘制 
```text
https://github.com/PhilJay/MPAndroidChart
是 Android 中一个较流行的第三方开源库 。
适用于 Android 2.2 ( API 8 ) 及以上。
本次讲解基于 v3.0.3 版本。
MPAndroidChart 的动画机制只在Android API 11  及以上有效 。
```
