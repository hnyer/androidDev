# 类加载机制

## 类的生命周期
![](https://gitee.com/hnyer/filesOfGitbook/raw/master/files/201802051138_osChina_类生命周期.png)

## java类加载器分类
### 从虚拟机层面角度分类
```text
从虚拟机层面角度讲,分为两大类型的类加载器。
一是Bootstrap Classloader ，即启动类加载器（C++实现），它是虚拟机的一部分，
二是其他类型类加载器（JAVA实现），在虚拟机外部，并全部继承ClassLoader类。
```

![](https://gitee.com/hnyer/filesOfGitbook/raw/master/files/201802051139_osChina_类加载器分类.png)


### 从加载顺序角度来分类
![](https://gitee.com/hnyer/filesOfGitbook/raw/master/files/201802051139_osChina_parent委托机制.png)



1、Bootstrap ClassLoader
```text
主要负责加载JVM自身工作所需要的类。
是由C/C++编写的，它本身是虚拟机的一部分，所以它并不是一个JAVA类，无法在java代码中获取它的引用。
所以getClass().getName()返回null。

 System.out.println(System.getProperty("sun.boot.class.path"));
 xxx\jre\lib\resources.jar;
 xxx\jre\lib\rt.jar;
 xxx\jre\lib\sunrsasign.jar;
 xxx\jre\lib\jsse.jar;
 xxx\jre\lib\jce.jar;
 xxx\jre\lib\charsets.jar;
 xxx\jre\lib\jfr.jar;
 xxx\jre\classes
```


2、ExtClassLoader
```text
负责装载JRE扩展目录ext下的jar类包。一般为JVM平台扩展工具。

System.out.println(System.getProperty("java.ext.dirs"));
xxx\jre\lib\ext;
C:\Windows\Sun\Java\lib\ext
```


3、AppClassLoader(SystemAppClass)
```text
如果应用程序中没有自定义过自己的类加载器，一般情况下这个就是程序中默认的类加载器。
System.out.println(System.getProperty("java.class.path"));

//这个路径其实就是当前java工程目录bin，里面存放的是编译生成的class文件。
 F:\aivin_space\myEclipseSpace\MySample\bin
```




##  类加载之间的父子关系是怎样的
子类加载器和父类加载器的关系，是委派关系并不是继承关系。



## 双亲委派（parent delegation）模型
在加载类别时，每个类别加载器会先将加载类别的任务交由其parent，如果parent找不到，才由自己负责加载，如果自己也找不到，就会丢出 NoClassDefFoundError。

## 为什么要用“双亲委派模型”
防止内存中出现多份同样的字节码 。比如两个类A和类B都要加载System类：如果不用委托而是自己加载自己的，那么类A就会加载一份System字节码，然后类B又会加载一份System字节码，这样内存中就出现了两份System字节码。


## 自定义类加载器的意义和使用场景
```text
1、为了实现jdk的类加载器没有的某些功能。
例如Tomcat使用自定义的类加载器实现了热部署功能。

2、将java写的核心代码编译成.clas文件，然后将lass文件就加密。只有使用在自己的类加载器才能正确使用这些核心代码。
(因为只要获得了这个加载器，核心代码就可以轻易被获取。 所以要保护好自己的加载器。)
```
 