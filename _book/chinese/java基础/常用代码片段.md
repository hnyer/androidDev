# java常用代码片段
## list去重
将重复值去掉，同时不能破坏现有的顺序。
```java
private  List<String> removeDuplicate(List<String> list)
{
  Set<String> set = new HashSet<String>();
  List<String> newList = new ArrayList<String>();
  for (String str : list) {
    // 借助set的特性
    if (set.add(str)) {
      newList.add(str);
    }
  }
  return newList;
}
```


## String 操作
### 字符串切割
```java
String [] array= myString.split("[.]");
```

分割字符| 表达
-|-
.|"[.]"
&#124;|"\\\\&#124;"
*|"\\\\*"
\|"\\\\\\\\"
[|"\\\\["
]|"\\\\]"

### String 简单格式化
```java
return String.format("bookId= %s, bookName=%s]", bookId, bookName);
```


## 代码超时
函数超时、 执行超时、等待超时、连接超时

```java
final ExecutorService exec = Executors.newFixedThreadPool(1);
Callable<String> call = new Callable<String>() {
	public String call() throws Exception {
		// 耗时操作...
		Thread.sleep(1000 * 3);
		return "执行结果(成功或失败)";
	}
};

try {
	Future<String> future = exec.submit(call);
	// 超时时间 设置
	String result = future.get(1000 * 5, TimeUnit.MILLISECONDS);  
	System.out.println("执行未超时:" + result);
} catch (TimeoutException ex) {
	System.out.println("处理超时");
	ex.printStackTrace();
} catch (Exception e) {
	System.out.println("处理失败.");
	e.printStackTrace();
}
	exec.shutdown();
}
```


## 对象排序
```java
Collections.sort(mBeanList, new Comparator<MyBean>() {
        @Override
        public int compare(MyBean bean1, MyBean bean2) {
            // 按照对象属性排序
          return = bean1.xx - bean2.xx;
        }
    });
```


## 数组操作
### 数组相等
```java
Arrays.equals(myArray, NSS_MSG_TYPE_GET_MAIN_STREAM);
```

### 数组打印
```java
System.out.println(Arrays.toString(myArray));
```

### 数组扩容
```java
public  String [] getNewArrayWithMoreSpaceString(
String [] oldArray ,String [] increceData){
   String [] lastArray=new String[oldArray.length+increceData.length];
   //数组复制
   System.arraycopy(oldArray, 0, lastArray, 0, oldArray.length);
   System.arraycopy(increceData, 0, lastArray, oldArray.length+1, increceData.length);
   return   lastArray ;
}
```


## 文件操作
### 获得指定文件的byte数组
```java
public  byte[] getBytesFromFile(File file){  
      byte[] buffer = null;  
      try {  
        if(!file.exists()){
          file.createNewFile();
        }
          FileInputStream fis = new FileInputStream(file);  
          ByteArrayOutputStream bos = new ByteArrayOutputStream(1000);  
          byte[] b = new byte[1000];  
          int n;  
          while ((n = fis.read(b)) != -1) {  
              bos.write(b, 0, n);  
          }  
          fis.close();  
          bos.close();  
          buffer = bos.toByteArray();  
      } catch ( Exception e) {  
          e.printStackTrace();  
      }  
      return buffer;  
  }
```

### 根据byte数组，生成文件
```java
public void getFileFromBytes(byte[] bfile, File file ,boolean isAppend){  
    BufferedOutputStream bos = null;  
    FileOutputStream fos = null;  
    try {  
        fos = new FileOutputStream(file ,isAppend);  
        bos = new BufferedOutputStream(fos );  
        bos.write(bfile);  
    } catch (Exception e) {  
        e.printStackTrace();  
    } finally {  
        if (bos != null) {  
            try {  
                bos.close();  
            } catch (IOException e1) {  
                e1.printStackTrace();  
            }  
        }  
        if (fos != null) {  
            try {  
                fos.close();  
            } catch (IOException e1) {  
                e1.printStackTrace();  
            }  
        }  
    }  
}
```

### 保存String到本地
```java
public  boolean saveTxtToSdWithAppend(String messgeStr,  String filePath, boolean isAppend){
     File file = new File(filePath);
     try {
         file.createNewFile();
     } catch (IOException e) {
         e.printStackTrace();
     }

     boolean resultFlage = true;
     try {
         // 打开一个写文件器，是否追加形式
         FileWriter writer = new FileWriter(filePath, isAppend);
         writer.write(messgeStr + "\r\n");
         writer.close();
     } catch (IOException e) {
         resultFlage = false;
         e.printStackTrace();
     }
     return resultFlage;
 }
```

### 从txt(小文件) 获取String
```java
public  String getStringFromTxt(File file) {
    StringBuffer sb = new StringBuffer();
    try {
        BufferedReader rd = new BufferedReader(new FileReader(file));
        String s = rd.readLine();
        while (null != s) {
            sb.append(s);
            s = rd.readLine();
        }

    } catch (FileNotFoundException e) {
        e.printStackTrace();   
    } catch (IOException e) {
        e.printStackTrace();
    }
    return sb.toString();
}
```


### 按行读取(较大文件) 、解决乱码问题
```java
public void read(String filePath, String logPath) throws  Exception {
  RandomAccessFile raf = new RandomAccessFile(filePath, "r");
  // 设置指针的位置为文件的开始部分
  raf.seek(currentInex);
  long totalLenth = raf.length();
  while (currentInex <= totalLenth) {
    String stringValue = new String(raf.readLine().getBytes("ISO-8859-1"), "utf-8");
    currentInex = raf.getFilePointer();
    raf.close();
  }
}
```


### 递归 遍历文件夹
```java
public void  getFileList(String strPath) {
      File dir = new File(strPath);
      File[] files = dir.listFiles();  
      if (files != null) {
          for (File file : files) {
              if (file.isDirectory()) {  
                  getFileList(file.getAbsolutePath());  
              } else {
                  // 文件
              }
          }
      }
  }
```


## 时间间隔
```java
public static String getConversationDateString(String result) throws  Exception{
  if(!result.equals("")){
    SimpleDateFormat sdf = new SimpleDateFormat("MM-dd HH:mm");
    SimpleDateFormat sdfDay = new SimpleDateFormat("MM-dd");
    String now = sdf.format(new Date());
    Date oldTime = null;
    Date newTime = null;
    oldTime = sdf.parse(result);
    newTime = sdf.parse(now);

    long time = newTime.getTime() - oldTime.getTime();
    int day;
    String[] olds = sdfDay.format(oldTime).split("-");
    String[] news = sdfDay.format(newTime).split("-");

    if(news[0].equals(olds[0])){
      day = Integer.valueOf(news[1]) - Integer.valueOf(olds[1]);
    }else{
      Calendar cal = Calendar.getInstance();  
      //月份设置要减1，所以设置1月就是1-1，设置2月就是2-1，如此类推  
      cal.set(Calendar.MONTH, 1-1);  
      cal.add(Calendar.MONTH, -(Integer.valueOf(news[0]) - Integer.valueOf(olds[0])));  
      //得到上一个月最最后一天日期(31/30/29/28)  
      int oldDay=cal.getActualMaximum(Calendar.DAY_OF_MONTH) - Integer.valueOf(olds[1]);  
      day = oldDay + Integer.valueOf(news[1]);
    }

    if(time <= 24 * 60 * 60 * 1000){
      if(time <= 60 * 1000){
        return "刚刚";
      }else if (time <= 60 * 60 * 1000) {
        result = (time/60/1000) + "分钟前";
      } else {
        result = (time/60/60/1000) + "小时前";
      }
    }else if(day == 1){
      result = "昨天";
    }else if(day == 2){
      result = "前天";
    }else if(day < 7){
      result = day + "天前";
    }else {
      result = sdfDay.format(oldTime);
    }
  }
  return result;
}
```

## 求夹角
### 根据正切公式
```java
/**根据两个点获取 斜率*/
public static double getXl(MyPointBean bean1, MyPointBean bean2) {
    double xlValue = 0;
    xlValue = (bean2.getY() - bean1.getY()) / (bean2.getX() - bean1.getX());
    return xlValue;
}

/**根据2条线的斜率 获得之间的夹角*/
public static double getAngle(double xl_1, double xl_2) {
    double angleValue = 0;
    // 反正切
    angleValue = Math.atan((xl_2 - xl_1) / (1 + xl_1 * xl_2));
    // 将弧度转为度数
    return Math.toDegrees(angleValue);
}
```

## 遍历map 遍历set
```java
Map<String ,Integer>  map=new HashMap();
//方法一 ，需要遍历 两次     
for (Object object : map.keySet()) {
 String key = (String) object;
 Integer value = (Integer) map.get(key);
}

// 方法二， 只需遍历一次 （推荐）
Set<Entry<String, Integer>>  entrySet = map.entrySet();
for (Entry<String, Integer> object : entrySet){
 Object key = object.getKey();
 Object value = object.getValue();
}

//遍历set
Set<String> set=new HashSet();
Iterator<String> iterator=set.iterator();
while (iterator.hasNext()) {
  String obj = iterator.next();
}
```

## 随机数 Random
Math.Random() 范围是 [0,1)

###  生成 [startNum,endNum)
```java
public int getRadomInt(int startNum, int endNum){
  return new Random().nextInt(endNum - startNum) + startNum;
}
```

### 生成 [startNum,endNum]
```java
public int getRadomInt2(int startNum, int endNum){
  return new  Random().nextInt(endNum - startNum + 1) + startNum;
}
```

## 文件解压缩
zip解压缩是基于 pache的 ant.jar 实现 。

```java
/**
 * 解压耗时操作应该在子线程中进行。
 */
public class ZipUtil{
		private byte[] buf;
	  public ZipUtil(){
	      this.buf = new byte[ 1024*4];
	  }

    /**
     * @param zipFileAbsulutPaht 压缩文件的绝对路径  xxx/xxx.zip
     * @param destFileDir　　　解压到的目录　
     */
    public void unZip(String zipFileAbsulutPaht, String destFileDir)  {
        FileOutputStream fileOut;
        File file;
        InputStream inputStream;

        try {
            //生成一个zip的文件
            ZipFile  zipFile = new ZipFile(zipFileAbsulutPaht);
            //遍历zipFile中所有的实体，并把他们解压出来
            for (@SuppressWarnings("unchecked") Enumeration<ZipEntry> entries = zipFile.getEntries(); entries.hasMoreElements();)  {
                ZipEntry entry =  entries.nextElement();
                //生成他们解压后的一个文件
                String tempNameFile=entry.getName() ;
                file = new File(destFileDir+File.separator+tempNameFile.replace("\\", "/"));

                if (entry.isDirectory())  {
                    file.mkdirs();
                } else {
                    File parent = file.getParentFile();
                    if (!parent.exists())  {
                        parent.mkdirs();
                    }
                    //获取出该压缩实体的输入流
                    inputStream = zipFile.getInputStream(entry);
                    fileOut = new FileOutputStream(file);
                    int length = 0;
                    //将实体写到本地文件中去
                    while ((length = inputStream.read(this.buf)) > 0)  {
                        fileOut.write(this.buf, 0, length);
                    }
                    fileOut.close();
                    inputStream.close();
                }
            }
            zipFile.close();
        } catch (IOException ioe) {
            ioe.printStackTrace();
        }
    }
}

// 使用
new ZipUtil().unZip(mnt/xxx/xxx.zip , mnt/xx/xx/);
```
