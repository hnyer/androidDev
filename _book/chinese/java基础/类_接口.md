# 类、接口
## 抽象类接口区别
以下是常用的几点区别。另外的小细节可以在编码的时候体会得到。
```text
1、抽象类可以有构造器 ，接口不能有构造器

问：抽象类不能new，但抽象类里为什么还要有构造方法？
答：抽象类可以有成员变量，他们的初始化怎么做呢？这么一样你就明白为什么抽象类可以有构造函数了。

2、接口和抽象类可以被new吗 ？
Java语言规范规定了抽象类不能实例化 。接口也不能被new出来 。

但是我们平时有时会见到一些迷惑性的代码，其实那是创建了匿名内部类 。具体请参考匿名内部类的定义。
```
 
## 匿名内部类 造成 new 出一个 抽象函数或接口实例 的假象 
```text
// java编译器特有的写法？？
AbstractClassA test1= new AbstractClassA() {
  @Override
  public void func1() {
     System.out.println("func1...");
  }
};

//错误写法，无法通过编译
AbstractClassA test2= new AbstractClassA();
```

## 内部类
```text
可以将一个类的定义放在另一个类的定义内部，这就是内部类。

使用内部类最大的优点就在于它能够非常好的解决多重继承的问题，
如果我们不需要解决多重继承问题，那么我们自然可以使用其他的编码方式 。

内部类是个编译时的概念，一旦编译成功后，它就与外围类属于两个完全不同的类（当然他们之间还是有联系的）。
内部类它可以无限制地访问外围类的元素。

Java中内部类主要分为成员内部类、局部内部类、匿名内部类、静态内部类。
```

### 内部类类名规则 , 带 $ 的函数
```text
public class TestClass {
    // 内部类
   private MyTestCallback myTestCallback = new MyTestCallback() {
       @Override
       public void showMsg(String msg) {   }
   };
}
// 编译成功后，发现有生成 TestClass$1.class 
class TestClass$1 implements MyTestCallback {
    TestClass$1(TestClass this$0) {
        this.this$0 = this$0;
    }
    public void showMsg(String msg) {   }
}
```

### 实现多重继承的方案
```text
1、接口, 无需多说。

2、内部类。
// 这种方式实现多重继承，我认为不太优雅。
public class Father {
    public void strong(){  }
}
public class Mother {
    public void kind(){  }
}
public class Son {
// 通过 2个内部类，获得两个父类的能力。
    class Father_1 extends Father{   }
    class Mother_1 extends  Mother{   }
}
```
 

### 匿名内部类
匿名内部类没有名字 ，创建格式如下 。
 ```text
 new 父类构造器（参数列表）|实现接口（）      {    
      //匿名内部类的类体部分    
}  

// 匿名内部类参数为何要为final
1、首先在内部类编译成功后，它会产生一个class文件，该class文件与外部类并不是同一class文件，仅仅只保留对外部类的引用。

2、内部类并不是直接调用方法传递的参数，而是利用自身的构造器对传入的参数进行备份，
自己内部方法调用的实际上时自己的属性而不是外部方法传递进来的参数。

3、在内部类中的属性和外部方法的参数两者从外表上看是同一个东西，但实际上却不是，也就是说在内部类中我对属性的改变并不会影响到外部的形参，
而然这从程序员的角度来看这是不可行的，毕竟站在程序的角度来看这两个根本就是同一个，
如果内部类该变了，而外部方法的形参却没有改变这是难以理解和不可接受的，所以为了保持参数的一致性，就规定使用final来避免形参的不改变。 （规定的！！）
```

## 父类的静态方法能否被子类重写
Java静态方法形式上可以重写，但从本质上来说不是Java的重写。
```text
静态方法：
java中 static修饰符修饰的方法就是静态方法。
所谓静态就是指：在编译之后所分配的内存会一直存在，不会被回收，直到程序退出内存才会释放这个空间。
static方法不是后期绑定的，它在编译期就绑定了。

静态方法是不需要对象的。自然无法根据对象的类去覆盖方法。

如果父类中定义的静态方法在子类中被重新定义，那么定义在父类中的静态方法将被隐藏。
public class Father {
    public static void test(){ 
    }
}
public class Son extends Father{
    public static void test(){
    }
}
// Son 中有test这方法， Son.test() 执行的就是 son的test ，如果没有这个方法，调用的就是father的test .
Son.test();
```
 

  