# Java内存模型
```text
其他语言，例如c/c++直接使用了物理硬件或操作系统的内存模型 ，
由于不同平台上内存模型的差异性，需要开发者针对不同的平台做相应的兼容处理。
Java内存模型是为了屏蔽各种硬件和系统的访问差异，达到一致的并发效果。
进一步解决多线程编程中的线程安全等问题。
```

![](https://gitee.com/hnyer/filesOfGitbook/raw/master/files/201801170848_osChina_p8.png)
![](https://gitee.com/hnyer/filesOfGitbook/raw/master/files/201801241435_osChina_线程内存和主内存.jpg)



# 运行时数据区域
![aivin](https://gitee.com/hnyer/filesOfGitbook/raw/master/files/201801170848_osChina_p7.png) <br>
(绿色部分是每个线程私有的，白色部分是线程共享的)
```text
分为5块内存空间。
附：栈是运行的单位，而堆是存储的单元。

// 1、程序计数器
当前线程所执行的字节码的行号指示器。用来记录程序运行到哪里了，下一步又该执行哪一步操作。

// 2、本地方法栈
存储本地方法执行过程中的栈数据。

// 3、JVM栈（Java栈）
存放一个Java线程的运行状态。

//  4、堆
存放运行时产生的对象的。Java只能在堆中存放对象

//  5、方法区
方法区主要是用来存类型数据的，与类型相关的东西，比如常量，静态变量。
注：运行时常量池是方法区的一部分，用来存放编译器生成的各种字面量和符号引用。
```


#  基本概念
## 主内存
```text
进程内存。
所有线程共享主内存。
```

## 工作内存
```text
线程内存。
每个线程都有自己的执行空间(即工作内存)，线程执行的时候用到某变量，
首先要将变量从主内存拷贝的自己的工作内存空间，
然后对变量进行操作：读取，修改，赋值等，这些均在工作内存完成，
操作完成后再将变量写回主内存；
```

## 可见性
```text
指当一个线程修改了共享变量的值，其他线程能够立即得知这个修改。

各个线程都从主内存中获取数据，线程之间数据是不可见的；
例如，主内存 变量A 原始值为1，线程1从主内存取出 变量A，修改A的值为2，
在线程1未将变量A写回主内存的时候，线程2拿到变量A的值仍然为1；

我们可以使用 volatile 或 synchronized 等机制 保证可见性。
```

## 有序性
```text
如果在本线程内观察，所有的操作都是有序的；
指"线程内表现为串行的语义"

如果在一个线程中观察另一个线程，所有的操作都是无序的。
指"指令重排序"现象和"工作内存与主内存同步延迟"现象。
 
Java提供了 volatile 和 synchronized 来保证有序性 ，
volatile 本身包含禁止指令重排序的语义，
synchronized 则是由"一个变量在同一个时刻只允许一条线程对其进行lock操作"的规则来获得。
```

## 原子操作 、原子性
```text
是指不会被线程调度机制打断的操作机制。
这种操作一旦开始，就一直运行到结束，中间不会有任何 context switch （切换到另一个线程）。
根据java 定义，原子操作是不会被打断地的操作，因此被认为是线程安全的。
java中可以通过锁和循环CAS的方式来实现原子操作。
```


## 指令重排序  
```text
即生成的机器指令与字节码指令顺序不一致。

为什么会有重排序?
为了提高执行效率，目前大多数现代微处理器都会采用将指令乱序执行。
在条件允许的情况下，直接运行当前有能力立即执行的后续指令，避开获取下一条指令所需数据时造成的等待。

int a = 1;
int b = 2;
int c = a + b;

将上面的代码编译成Java字节码或生成机器指令，大致可视为展开成了以下几步动作：
对a赋值1                 --1
对b赋值2                 --2
取a的值                  --3
取b的值                  --4
将取到两个值相加后存入c  --5
在上面5个动作中，动作1可能会和动作2、4重排序，
动作2可能会和动作1、3重排序，动作3可能会和动作2、4重排序，
动作4可能会和1、3重排序。但动作1和动作3、5不能重排序。
动作2和动作4、5不能重排序。因为它们之间存在数据依赖关系，
一旦重排，as-if-serial语义便无法保证。
```


## as-if-serial 语义
```text
所有的动作都可以为了优化而被重排序，
但是必须保证它们重排序后的结果和程序代码本身的应有结果是一致。
所以，重排序不会发生在有数据依赖的操作之中。
```

 

# 8大原子操作
```text
为了解决主内存和工作线程的一致性问题，Java定义了如下原子操作.
1、 lock 锁定
作用于主内存，把变量标记为一条线程独占状态。

2、unlock 解锁。
作用于主内存，释放后的变量才能被其他线程锁定。

3、 read 读取
作用于主内存。 将变量的值从主内存传输到工作内存中。

4、load 载入
作用于工作内存。将从主内存中得到的变量值放入工作内存的变量副本中。

5、 use 使用。
作用于工作内存。 将工作内存中的变量的值传递给执行引擎。

6、assign 赋值
作用于工作内存。将执行引擎传递过来的值赋值给工作内存中的变量副本。

7、store 存储
作用于工作内存。 将工作内存中的变量值传递到主内存。

8、write 写入
作用于主内存。将从工作内存中传递过来的值 赋值给主内存的变量。
```
 



 

 
  
 





 
 

 
 
 
 
 