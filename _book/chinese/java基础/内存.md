
##### 运行时数据区域：
分为5块内存空间。
附：栈是运行的单位，而堆是存储的单元。

1、程序计数器
当前线程所执行的字节码的行号指示器。用来记录程序运行到哪里了，下一步又该执行哪一步操作。

2、本地方法栈
存储本地方法执行过程中的栈数据。

3、JVM栈（Java栈）
存放一个Java线程的运行状态
4、堆
存放运行时产生的对象的。Java只能在堆中存放对象
5、方法区
方法区主要是用来存类型数据的，与类型相关的东西，比如常量，静态变量。
注：运行时常量池是方法区的一部分，用来存放编译器生成的各种字面量和符号引用。
![aivin](https://gitee.com/hnyer/filesOfGitbook/raw/master/files/201801170848_osChina_p7.png)
(绿色部分是每个线程私有的，白色部分是线程共享的)

----------------------------------------


##### Java内存模型
其他语言，例如c/c++直接使用了物理硬件或操作系统的内存模型，由于不同平台上内存模型的差异性，需要开发者针对不同的平台做相应的兼容处理。
Java内存模型是为了屏蔽各种硬件和系统的访问差异，达到一致的并发效果。进一步解决多线程编程中的线程安全等问题。

###### 基本概念
1、主内存：
进程内存？
所有线程共享主内存。

2、工作内存：
线程内存?
每个线程都有自己的执行空间(即工作内存)，线程执行的时候用到某变量，首先要将变量从主内存拷贝的自己的工作内存空间，然后对变量进行操作：读取，修改，赋值等，这些均在工作内存完成，操作完成后再将变量写回主内存；

3、可见性
各个线程都从主内存中获取数据，线程之间数据是不可见的；打个比方：主内存变量A原始值为1，线程1从主内存取出变量A，修改A的值为2，在线程1未将变量A写回主内存的时候，线程2拿到变量A的值仍然为1；

4、指令重排序  
[参考资料](http://tech.meituan.com/java-memory-reordering.html)
(即生成的机器指令与字节码指令顺序不一致。)
为什么会有重排序?
为了提高执行效率，目前大多数现代微处理器都会采用将指令乱序执行。在条件允许的情况下，直接运行当前有能力立即执行的后续指令，避开获取下一条指令所需数据时造成的等待。
```
int a = 1;
int b = 2;
int c = a + b;

将上面的代码编译成Java字节码或生成机器指令，大致可视为展开成了以下几步动作：
对a赋值1
对b赋值2
取a的值
取b的值
将取到两个值相加后存入c
在上面5个动作中，动作1可能会和动作2、4重排序，
动作2可能会和动作1、3重排序，动作3可能会和动作2、4重排序，
动作4可能会和1、3重排序。但动作1和动作3、5不能重排序。
动作2和动作4、5不能重排序。因为它们之间存在数据依赖关系，
一旦重排，as-if-serial语义便无法保证。
```

5、as-if-serial语义
所有的动作都可以为了优化而被重排序，但是必须保证它们重排序后的结果和程序代码本身的应有结果是一致。所以，重排序不会发生在有数据依赖的操作之中。

------


![aivin](https://gitee.com/hnyer/filesOfGitbook/raw/master/files/201801170848_osChina_p8.png)
(java内存模型)

###### 8大原子操作：
为了解决主内存和工作线程的一致性问题，Java定义了如下原子操作.
1、 lock 锁定
作用于主内存，把变量标记为一条线程独占状态。

2、unlock 解锁。
作用于主内存，释放后的变量才能被其他线程锁定。

3、 read读取
作用于主内存。 将变量的值从主内存传输到工作内存中。

4、load 载入
作用于工作内存。将从主内存中得到的变量值放入工作内存的变量副本中。

5、 use 使用。
作用于工作内存。 将工作内存中的变量的值传递给执行引擎。

6、assign 赋值
作用于工作内存。将执行引擎传递过来的值赋值给工作内存中的变量副本。

7、store 存储
作用于工作内存。 将工作内存中的变量值传递到主内存。

8、write 写入
作用于主内存。将从工作内存中传递过来的值 赋值给主内存的变量。

-----

##### 线程同步机制
1、同步方法
```
//锁住整个方法
 public synchronized void save(){}
```

2、同步代码块
```
synchronized(object)
{
  //同步是一种高开销的操作，通常没有必要同步整个方法，
  //使用synchronized代码块同步关键代码即可。
}
```

3、使用volatile轻量级同步机制
```
//一个变量使用volatile后，它将具有以下两种特性：
①、此变量对所有线程可见。
当一条线程修改了这个变量的值，新的值对于其他线程来说是立即得知的。普通变量不能实现这一点。
(注：因为Java里的运算并非原子操作，所以volatile只能保证了可见性，仍然需要通过加锁来保证数据的一致性)
②、 volatile 禁止CPU进行指令重排序优化。
普通的变量可能会进行指令重排序，所以不能保证变量赋值操作的顺序与程序代码中的执行顺序一致。
```

4、重入锁 ReentrantLock
// ??

5、使用ThreadLocal
// ??

6、使用阻塞队列实现同步
// ??

7、使用AtomicInteger 实现原子变量

原子操作就是指将读取变量值、修改变量值、保存变量值看成一个整体来操作
即-这几种行为要么同时完成，要么都不完成。
// ???

---




-----

##### 问题：
1、内存分为哪几部分，这些部分分别都存储哪些数据？
~~答案：略。~~

2、一个对象从创建到销毁都是怎么在这些部分里存活和转移的？

3、内存的哪些部分会参与GC的回收？
 ///??

4、Java的内存模型是怎么设计的？
~~答案：略。~~

5、为什么要这么设计？
~~答案：略。~~

6、结合内存模型的设计谈谈volatile关键字的作用？
~~答案：略。~~

7、接着可见性这三个字，还可以继续问你并发的内容。
