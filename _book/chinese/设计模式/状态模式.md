# 状态模式 State Pattern

某种业务情况下，确实可以用 if  else 来完成 ，但是由于 不同状态下的处理方法不一样。会导致大量的 if  else 代码。 会造成代码复杂，不易维护等问题。 此时可以考虑用 状态模式 解决。

### [示例](https://www.jianshu.com/p/2229fd27b35e)
一个订单的状态： 未支付、正在支付、已支付、申请退款，退款中，退款完成

```java
//直接采用简单的 if else 方式

public void 支付（）
{
  if(未支付)
  {
    //处理 支付操作
  }else if(正在支付){
    //提示 不符合操作条件。
  }
  else if(退款完成){
  //提示 不符合操作条件。
  }
}

public void 退款（）
{
  if(未支付)
  {
   //提示 不符合操作条件。
  }else if(正在支付){
   //提示 不符合操作条件。
  } else if(退款完成){
   //提示 不符合操作条件。
  }else if(已支付){
    // 处理退款操作..
  }
}

//如果要新增 一个 "退款审核"状态 。
//此时需要去修改以上所有的 if else ,严重破坏 开闭原则 。
```


```java
//采用状态模式

/**未支付状态*/
public class NoPayStatus  
{
    public NoPayStatus(Order order,String name)
    {
        //初始化订单信息
    }

    public OrderStatus processOrder(Order order)
    {
        //处理当前状态下的订单，
        ...
        //根据处理结果，设置订单新的状态
        OrderStatus state=new PayStatus(order,"已支付");
        order.setStatus(state);
        return state;
    }
}

/**申请退款*/
public class ApplyDrawbackStatus  
 {
  private Order order;
  private String name;
    public ApplyDrawbackStatus(Order order, String name)
     {
       //初始化订单信息
    }

    @Override
    public OrderStatus processOrder(Order order)
    {
        //处理当前状态下的订单，
        ...
       //根据处理结果，设置订单新的状态
        return new DrawbackStatus(order, "订单回款中");
    }

}

//使用场景
//某个时刻根据情况根据具体情况给订单设置状态
Order order=new Order();
order.setStatus( 某个状态);
....
//在另一个时刻，处理订单。
OrderStatus status=order.getStatus();
status.processOrder(order);

```

#### 缺点
并没有完全符合 开闭原则 。

```java
@Override
public OrderStatus processOrder(Order order)
{
  //如果要新增 一个 "退款审核"状态 。
  //也需要修改相关代码
  //return new DrawbackStatus(order, "订单回款中");
  return new CheckDrawbackStatus(order, "退款审核中");
}
```

&nbsp;&nbsp;
&nbsp;&nbsp;

#### 策略模式 和 状态模式 的区别

1、策略模式只是一个解决方案的封装 。重在外部对策略的选择或动态的切换。策略模式每个算法是相对独立的。<br>

2、状态模式是初始化一个状态，之后的每个状态的变化都会指定下一个状态。状态模式中每个状态是存在相互转化的，
