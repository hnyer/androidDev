# 享元模式  Flyweight Pattern

当系统中存在大量相似或相同的对象时，将会导致运行代价过高、OOM 等问题，享元模式正为解决之一类问题而诞生。

#### 注意
1、享元模式在使用时存在线程安全问题，需要考虑线程安全。<br>
2、通常用一个 工厂类 类维护享元对象。


&nbsp;&nbsp;
&nbsp;&nbsp;

#### 内部状态 Internal State
存储在享元对象内部并且不会随环境改变而改变的状态，内部状态可以共享。

#### 外部状态 External State
随环境改变而改变的、不可以共享的状态。外部状态由客户端保存。<br>
外部状态不可以影响享元对象的内部状态，它们是相互独立的。

&nbsp;&nbsp;
&nbsp;&nbsp;
#### 缺点
1、对象 需要分离出 内部状态 和 外部状态，这使得程序的逻辑复杂化。<br>
2、读取外部状态使得运行时间变长。

&nbsp;&nbsp;
&nbsp;&nbsp;

### [示例](https://blog.csdn.net/lovelion/article/details/7667860)
![](https://gitee.com/hnyer/filesOfGitbook/raw/master/files/201803271357_osChina_享元模式.png)
<br>
围棋棋盘中包含大量的黑子和白子，它们的形状、大小都一模一样，只是出现的位置不同而已。如果将每一个棋子都作为一个独立的对象存储在内存中，将导致该围棋软件在运行时所需内存空间较大。


```java
class Chessman   
{
  /**内部状态*/
  private String color;
  /**外部状态*/
  private Point location;

  public Chessman(String color)
  { ...}

  public String getColor()
  { ... }

  public String getLocation()
  { ...}

  /**更新外部状态 需要主要线程安全*/
  public synchronized void updateLocation( Point loation)
  { ...  }

}
```


```java
public class ChessmanFactory
{
    /**享元池*/
    private static Map<String,Chessman> map=new HashMap<>();

    public static ChessFlyWeight getChess(String color)
    {
        if(map.get(color)!=null){
            return map.get(color);
        }else{
            Chessman chessman=new Chessman(color);
            map.put(color, chessman);
            return chessman;
        }
    }
}
```


```java
//多次调用 也只创建了一个 Chessman 对象
Chessman chessman=ChessmanFactory.getChess("黑色");
```
