
##### 单例模式（Singleton Pattern）

在Java应用中，单例对象能保证在一个JVM中，该对象只有一个实例存在。

###### 使用场景：

1、某些大型的类创建频繁时会导致很大的系统开销。

2、软件系统中有些地方只能有一个实例，否则会出现各种问题。例如打印机为了避免状态不一致而采用单例模式。


###### 缺点：

1、单例实例的生命周期和软件的生命周期一样长。如果它持有某些对象的引用 ，会导致该对象无法释放。


特点：
 1、单例类只能有一个实例。

2、单例类必须自己自己创建自己的唯一实例。

3、单例类必须给所有其他对象提供这一实例。

4、构造方法限定为private，避免了类在外部被实例化，只能通过getInstance()方法访问。（此处不考虑反射机制）


单例模式分二种：饿汉式单例、懒汉式单例。  


```
public class SingleTonBean
{
	/**持有私有静态实例，防止被引用，此处赋值为null，目的是实现延迟加载*/
	private static SingleTonBean  instance = null ;

	/**私有化构造函数，防止被其他类实例化*/
	private SingleTonBean()
	{
		//初始化操作
	}//

	/**使用一个内部类来维护单例
	 *单例模式使用内部类来维护单例的实现。
	 *利用jvm提供的机制，加载类的线程互斥的，用来解决多线程访问的时候可能会遇到null的问题。
	 **/
	 private static class SingletonFactory
	 {
	     private static SingleTonBean instance = new SingleTonBean();
	 }

	 /**获取实例,对外提供的唯一接口 */
	public static SingleTonBean getInstance()
	{
		return SingletonFactory.instance;
	}

	 /**为了能在序列化过程仍能保持单例的特性，需要添加一个readResolve()方法 */
	private Object readResolve()
    {
	    return getInstance();
	}
}
```




饿汉式单例 ：
```
public class SingletonDemo1 {
    private  SingletonDemo1(){
    //构造方法是私有
    }

    //饿汉式：被调用之前就自己创建好实例
    private static final SingletonDemo1 singleton=new SingletonDemo1();

    public SingletonDemo1 getIncetance(){
        return singleton;
    }
}
```


懒汉式单例 ：
```
public class SingletonDemo2 {
    private static SingletonDemo2 singleton = null;

    private SingletonDemo2() {
    // 私有化构造方法
    }

    public synchronized static SingletonDemo2 getIncetance() {
        if (singleton == null) {
            // 懒汉式：在调用的时候才实例化对象
            singleton = new SingletonDemo2();
        }
        return singleton;
    }

}
```


##### 使用类的静态方法也可以实现单例模式的效果，分析这两种方案的不同。
1、单例模式可以延迟初始化，有助于优化性能 。

2、待补充。


##### 要点解析
- 1、单例模式和反序列化的问题
一般来说，一个类实现了Serializable接口，我们就可以将它写入内存然后再从内存中读取组装成一个跟原来一样的对象。此时，内存中存在N（N>=2）个相同的对象。 而单例模式要求JVM中只能有一个类的对象。如果不做特殊处理反序列就会违反单例模式的规则。

```
/**
 * 实现readResolve方法，一个class可以直接控制反序化返回的类型和对象引用。
 * ObjectInputStream 会检查对象的class是否定义了readResolve方法。
 * Method readResolveMethod = getInheritableMethod( cl, "readResolve", null, Object.class);
 */
 private Object readResolve() throws ObjectStreamException {  
			return INSTANCE; //直接返回已经存在单例对象，不再组装新的对象。确保唯一性。
	 }

```
