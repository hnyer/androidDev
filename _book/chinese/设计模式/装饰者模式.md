# 装饰者模式 、Decorator Pattern 、包装模式  、Wrapper Pattern

在不改变一个对象原有结构和功能的前提下，给它新加一些额外的功能。 装饰模式是一种用于替代继承的技术。

<br>

```java
/**被装饰的原始对象*/
public class ConcreteComponent extends MyComponent
{
    /**原有功能*/
    @Override
    public void operation() { ...  }
}
```
#### 透明装饰模式 (尽量使用这种方式)
要求完全针对抽象编程。可以透明地使用装饰之前的对象和装饰之后的对象。<br>
为了达到这种效果， 必须在构件对象的方法中调用 增强方法。<br>
但是缺点是用户不能单独地调用那些增强的方法 。<br>
```java
/**具体装饰器*/
public class ConcreteDecoratorA  extends MyComponent
{
    MyComponent component ;
    /**持有被装饰的对象*/
    public ConcreteDecoratorA(MyComponent component) { ...  }
    public int operationA(){ ... 增强方法 ...  }

    @Override
    public void operation()
    {
        // 区别点！！里面调用了 operationA（）
        operationA();
        component.operation();
    }
}

```

```java
MyComponent myComponet1= new ConcreteComponent(...);
// 针对MyComponent抽象编程
MyComponent myComponet2 = new ConcreteDecoratorA(myComponet1);
myComponet1.operation();
//不能在外面调用额外功能 。- 编译 出错
myComponet2.operationA();
myComponet2.operation();

```

#### 半透明装饰模式

```java

/**具体装饰器*/
public class ConcreteDecoratorA  extends MyComponent
{
    MyComponent component ;
    /**持有被装饰的对象*/
    public ConcreteDecoratorA(MyComponent component) { ...  }
    public int operationA(){ ... 增强方法 ...  }

    @Override
    public void operation()
    {
        // 区别点！！ 在里面并没有调用 operationA()
        component.operation();
    }
}

```

```java
MyComponent myComponet1= new ConcreteComponent(...);
ConcreteDecoratorA myComponet2 = new ConcreteDecoratorA(myComponet1);
//透明装饰者模式
myComponet1.operation();
// 可以在外 调用增强方法 - 编译ok
myComponet2.operationA();
myComponet2.operation();

```

<br>
####  如何理解 “半透明装饰模式不能实现对同一个对象的多次装饰”
首先明确一点：半透明装饰模式 是将 增强方法 和原有方法 独立开来的。在装饰器中 原有方法并没有调用过增强方法。 <br>   
因为装饰类持有的是 MyComponent 类型的引用，而 MyComponent 并不能调用增强方法。所以导致如下结果： 多次装饰的情况下，无法使用那些增强方法。


<br>
#### 代理模式 与 装饰者模式 区别
代理模式的目标是控制对被代理对象的访问（强调控制） ，而装饰模式是给原对象增加额外功能 （强调增加功能）。
